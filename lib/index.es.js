import './index.css';
var aw = Object.defineProperty;
var iw = (e, t, n) => t in e ? aw(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var _i = (e, t, n) => (iw(e, typeof t != "symbol" ? t + "" : t, n), n);
import { Fragment as We, isVNode as Wo, Comment as lw, Text as sb, defineComponent as J, reactive as Et, getCurrentInstance as On, onMounted as ze, onUpdated as Co, onUnmounted as Xo, watch as le, computed as T, inject as nt, provide as ot, ref as G, unref as Ye, shallowRef as K, watchEffect as Ve, onBeforeUnmount as at, triggerRef as ub, createVNode as m, h as rc, Transition as Yn, withDirectives as An, resolveDirective as sw, cloneVNode as Ko, render as hr, nextTick as mt, toRef as Je, withModifiers as Vp, vShow as wo, onBeforeMount as gd, Teleport as hd, createTextVNode as Se, isRef as cb, toRefs as bd, toRaw as Ft, useAttrs as uw, onBeforeUpdate as yd, getCurrentScope as cw, onScopeDispose as dw, TransitionGroup as ns, onActivated as fw, openBlock as ke, createBlock as Ut, mergeProps as cn, createElementBlock as ct, normalizeProps as Sd, guardReactiveProps as $d, withCtx as ce, toDisplayString as $e, createElementVNode as Ot, renderList as qt, toHandlers as Ol, createCommentVNode as Vn, pushScopeId as pw, popScopeId as vw, markRaw as Dt, defineAsyncComponent as mw, resolveDynamicComponent as gw, normalizeStyle as qr, createApp as hw } from "vue";
function ri(e) {
  "@babel/helpers - typeof";
  return ri = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ri(e);
}
function bw(e, t) {
  if (ri(e) != "object" || !e)
    return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(e, t || "default");
    if (ri(o) != "object")
      return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function yw(e) {
  var t = bw(e, "string");
  return ri(t) == "symbol" ? t : t + "";
}
function Sw(e, t, n) {
  return t = yw(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Wp(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    t && (o = o.filter(function(r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function L(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Wp(Object(n), !0).forEach(function(o) {
      Sw(e, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Wp(Object(n)).forEach(function(o) {
      Object.defineProperty(e, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return e;
}
function h() {
  return h = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, h.apply(this, arguments);
}
const $w = (e) => typeof e == "function", Cw = Array.isArray, ww = (e) => typeof e == "string", xw = (e) => e !== null && typeof e == "object", Ow = /^on[^a-z]/, Pw = (e) => Ow.test(e), Cd = (e) => {
  const t = /* @__PURE__ */ Object.create(null);
  return (n) => t[n] || (t[n] = e(n));
}, Iw = /-(\w)/g, yi = Cd((e) => e.replace(Iw, (t, n) => n ? n.toUpperCase() : "")), Tw = /\B([A-Z])/g, Ew = Cd((e) => e.replace(Tw, "-$1").toLowerCase()), Mw = Cd((e) => e.charAt(0).toUpperCase() + e.slice(1)), _w = Object.prototype.hasOwnProperty, Kp = (e, t) => _w.call(e, t);
function Dw(e, t, n, o) {
  const r = e[n];
  if (r != null) {
    const a = Kp(r, "default");
    if (a && o === void 0) {
      const i = r.default;
      o = r.type !== Function && $w(i) ? i() : i;
    }
    r.type === Boolean && (!Kp(t, n) && !a ? o = !1 : o === "" && (o = !0));
  }
  return o;
}
function Da(e) {
  return typeof e == "number" ? `${e}px` : e;
}
function Gr(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0;
  return typeof e == "function" ? e(t) : e ?? n;
}
function Aw(e) {
  let t;
  const n = new Promise((r) => {
    t = e(() => {
      r(!0);
    });
  }), o = () => {
    t == null || t();
  };
  return o.then = (r, a) => n.then(r, a), o.promise = n, o;
}
function ae() {
  const e = [];
  for (let t = 0; t < arguments.length; t++) {
    const n = t < 0 || arguments.length <= t ? void 0 : arguments[t];
    if (n) {
      if (ww(n))
        e.push(n);
      else if (Cw(n))
        for (let o = 0; o < n.length; o++) {
          const r = ae(n[o]);
          r && e.push(r);
        }
      else if (xw(n))
        for (const o in n)
          n[o] && e.push(o);
    }
  }
  return e.join(" ");
}
var db = function() {
  if (typeof Map < "u")
    return Map;
  function e(t, n) {
    var o = -1;
    return t.some(function(r, a) {
      return r[0] === n ? (o = a, !0) : !1;
    }), o;
  }
  return (
    /** @class */
    function() {
      function t() {
        this.__entries__ = [];
      }
      return Object.defineProperty(t.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: !0,
        configurable: !0
      }), t.prototype.get = function(n) {
        var o = e(this.__entries__, n), r = this.__entries__[o];
        return r && r[1];
      }, t.prototype.set = function(n, o) {
        var r = e(this.__entries__, n);
        ~r ? this.__entries__[r][1] = o : this.__entries__.push([n, o]);
      }, t.prototype.delete = function(n) {
        var o = this.__entries__, r = e(o, n);
        ~r && o.splice(r, 1);
      }, t.prototype.has = function(n) {
        return !!~e(this.__entries__, n);
      }, t.prototype.clear = function() {
        this.__entries__.splice(0);
      }, t.prototype.forEach = function(n, o) {
        o === void 0 && (o = null);
        for (var r = 0, a = this.__entries__; r < a.length; r++) {
          var i = a[r];
          n.call(o, i[1], i[0]);
        }
      }, t;
    }()
  );
}(), ac = typeof window < "u" && typeof document < "u" && window.document === document, Pl = function() {
  return typeof global < "u" && global.Math === Math ? global : typeof self < "u" && self.Math === Math ? self : typeof window < "u" && window.Math === Math ? window : Function("return this")();
}(), Nw = function() {
  return typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(Pl) : function(e) {
    return setTimeout(function() {
      return e(Date.now());
    }, 1e3 / 60);
  };
}(), Rw = 2;
function Fw(e, t) {
  var n = !1, o = !1, r = 0;
  function a() {
    n && (n = !1, e()), o && l();
  }
  function i() {
    Nw(a);
  }
  function l() {
    var u = Date.now();
    if (n) {
      if (u - r < Rw)
        return;
      o = !0;
    } else
      n = !0, o = !1, setTimeout(i, t);
    r = u;
  }
  return l;
}
var Bw = 20, kw = ["top", "right", "bottom", "left", "width", "height", "size", "weight"], Lw = typeof MutationObserver < "u", Hw = (
  /** @class */
  function() {
    function e() {
      this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = Fw(this.refresh.bind(this), Bw);
    }
    return e.prototype.addObserver = function(t) {
      ~this.observers_.indexOf(t) || this.observers_.push(t), this.connected_ || this.connect_();
    }, e.prototype.removeObserver = function(t) {
      var n = this.observers_, o = n.indexOf(t);
      ~o && n.splice(o, 1), !n.length && this.connected_ && this.disconnect_();
    }, e.prototype.refresh = function() {
      var t = this.updateObservers_();
      t && this.refresh();
    }, e.prototype.updateObservers_ = function() {
      var t = this.observers_.filter(function(n) {
        return n.gatherActive(), n.hasActive();
      });
      return t.forEach(function(n) {
        return n.broadcastActive();
      }), t.length > 0;
    }, e.prototype.connect_ = function() {
      !ac || this.connected_ || (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), Lw ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, {
        attributes: !0,
        childList: !0,
        characterData: !0,
        subtree: !0
      })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), this.connected_ = !0);
    }, e.prototype.disconnect_ = function() {
      !ac || !this.connected_ || (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1);
    }, e.prototype.onTransitionEnd_ = function(t) {
      var n = t.propertyName, o = n === void 0 ? "" : n, r = kw.some(function(a) {
        return !!~o.indexOf(a);
      });
      r && this.refresh();
    }, e.getInstance = function() {
      return this.instance_ || (this.instance_ = new e()), this.instance_;
    }, e.instance_ = null, e;
  }()
), fb = function(e, t) {
  for (var n = 0, o = Object.keys(t); n < o.length; n++) {
    var r = o[n];
    Object.defineProperty(e, r, {
      value: t[r],
      enumerable: !1,
      writable: !1,
      configurable: !0
    });
  }
  return e;
}, la = function(e) {
  var t = e && e.ownerDocument && e.ownerDocument.defaultView;
  return t || Pl;
}, pb = os(0, 0, 0, 0);
function Il(e) {
  return parseFloat(e) || 0;
}
function Up(e) {
  for (var t = [], n = 1; n < arguments.length; n++)
    t[n - 1] = arguments[n];
  return t.reduce(function(o, r) {
    var a = e["border-" + r + "-width"];
    return o + Il(a);
  }, 0);
}
function zw(e) {
  for (var t = ["top", "right", "bottom", "left"], n = {}, o = 0, r = t; o < r.length; o++) {
    var a = r[o], i = e["padding-" + a];
    n[a] = Il(i);
  }
  return n;
}
function jw(e) {
  var t = e.getBBox();
  return os(0, 0, t.width, t.height);
}
function Vw(e) {
  var t = e.clientWidth, n = e.clientHeight;
  if (!t && !n)
    return pb;
  var o = la(e).getComputedStyle(e), r = zw(o), a = r.left + r.right, i = r.top + r.bottom, l = Il(o.width), u = Il(o.height);
  if (o.boxSizing === "border-box" && (Math.round(l + a) !== t && (l -= Up(o, "left", "right") + a), Math.round(u + i) !== n && (u -= Up(o, "top", "bottom") + i)), !Kw(e)) {
    var s = Math.round(l + a) - t, c = Math.round(u + i) - n;
    Math.abs(s) !== 1 && (l -= s), Math.abs(c) !== 1 && (u -= c);
  }
  return os(r.left, r.top, l, u);
}
var Ww = /* @__PURE__ */ function() {
  return typeof SVGGraphicsElement < "u" ? function(e) {
    return e instanceof la(e).SVGGraphicsElement;
  } : function(e) {
    return e instanceof la(e).SVGElement && typeof e.getBBox == "function";
  };
}();
function Kw(e) {
  return e === la(e).document.documentElement;
}
function Uw(e) {
  return ac ? Ww(e) ? jw(e) : Vw(e) : pb;
}
function Gw(e) {
  var t = e.x, n = e.y, o = e.width, r = e.height, a = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object, i = Object.create(a.prototype);
  return fb(i, {
    x: t,
    y: n,
    width: o,
    height: r,
    top: n,
    right: t + o,
    bottom: r + n,
    left: t
  }), i;
}
function os(e, t, n, o) {
  return { x: e, y: t, width: n, height: o };
}
var Yw = (
  /** @class */
  function() {
    function e(t) {
      this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = os(0, 0, 0, 0), this.target = t;
    }
    return e.prototype.isActive = function() {
      var t = Uw(this.target);
      return this.contentRect_ = t, t.width !== this.broadcastWidth || t.height !== this.broadcastHeight;
    }, e.prototype.broadcastRect = function() {
      var t = this.contentRect_;
      return this.broadcastWidth = t.width, this.broadcastHeight = t.height, t;
    }, e;
  }()
), Xw = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t, n) {
      var o = Gw(n);
      fb(this, { target: t, contentRect: o });
    }
    return e;
  }()
), qw = (
  /** @class */
  function() {
    function e(t, n, o) {
      if (this.activeObservations_ = [], this.observations_ = new db(), typeof t != "function")
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      this.callback_ = t, this.controller_ = n, this.callbackCtx_ = o;
    }
    return e.prototype.observe = function(t) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(t instanceof la(t).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var n = this.observations_;
        n.has(t) || (n.set(t, new Yw(t)), this.controller_.addObserver(this), this.controller_.refresh());
      }
    }, e.prototype.unobserve = function(t) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(t instanceof la(t).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var n = this.observations_;
        n.has(t) && (n.delete(t), n.size || this.controller_.removeObserver(this));
      }
    }, e.prototype.disconnect = function() {
      this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
    }, e.prototype.gatherActive = function() {
      var t = this;
      this.clearActive(), this.observations_.forEach(function(n) {
        n.isActive() && t.activeObservations_.push(n);
      });
    }, e.prototype.broadcastActive = function() {
      if (this.hasActive()) {
        var t = this.callbackCtx_, n = this.activeObservations_.map(function(o) {
          return new Xw(o.target, o.broadcastRect());
        });
        this.callback_.call(t, n, t), this.clearActive();
      }
    }, e.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    }, e.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    }, e;
  }()
), vb = typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : new db(), mb = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t) {
      if (!(this instanceof e))
        throw new TypeError("Cannot call a class as a function.");
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      var n = Hw.getInstance(), o = new qw(t, n, this);
      vb.set(this, o);
    }
    return e;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(e) {
  mb.prototype[e] = function() {
    var t;
    return (t = vb.get(this))[e].apply(t, arguments);
  };
});
var gb = function() {
  return typeof Pl.ResizeObserver < "u" ? Pl.ResizeObserver : mb;
}();
const ic = (e) => e != null && e !== "", bt = (e, t) => {
  const n = h({}, e);
  return Object.keys(t).forEach((o) => {
    const r = n[o];
    if (r)
      r.type || r.default ? r.default = t[o] : r.def ? r.def(t[o]) : n[o] = {
        type: r,
        default: t[o]
      };
    else
      throw new Error(`not have ${o} prop`);
  }), n;
}, Qw = (e) => {
  const t = Object.keys(e), n = {}, o = {}, r = {};
  for (let a = 0, i = t.length; a < i; a++) {
    const l = t[a];
    Pw(l) ? (n[l[2].toLowerCase() + l.slice(3)] = e[l], o[l] = e[l]) : r[l] = e[l];
  }
  return {
    onEvents: o,
    events: n,
    extraAttrs: r
  };
}, Zw = function() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  const n = {}, o = /;(?![^(]*\))/g, r = /:(.+)/;
  return typeof e == "object" ? e : (e.split(o).forEach(function(a) {
    if (a) {
      const i = a.split(r);
      if (i.length > 1) {
        const l = t ? yi(i[0].trim()) : i[0].trim();
        n[l] = i[1].trim();
      }
    }
  }), n);
}, Tl = (e, t) => e[t] !== void 0, hb = Symbol("skipFlatten"), xt = function() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  const n = Array.isArray(e) ? e : [e], o = [];
  return n.forEach((r) => {
    Array.isArray(r) ? o.push(...xt(r, t)) : r && r.type === We ? r.key === hb ? o.push(r) : o.push(...xt(r.children, t)) : r && Wo(r) ? t && !Sb(r) ? o.push(r) : t || o.push(r) : ic(r) && o.push(r);
  }), o;
}, bb = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default", n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (Wo(e))
    return e.type === We ? t === "default" ? xt(e.children) : [] : e.children && e.children[t] ? xt(e.children[t](n)) : [];
  {
    const o = e.$slots[t] && e.$slots[t](n);
    return xt(o);
  }
}, to = (e) => {
  var t;
  let n = ((t = e == null ? void 0 : e.vnode) === null || t === void 0 ? void 0 : t.el) || e && (e.$el || e);
  for (; n && !n.tagName; )
    n = n.nextSibling;
  return n;
}, yb = (e) => {
  const t = {};
  if (e.$ && e.$.vnode) {
    const n = e.$.vnode.props || {};
    Object.keys(e.$props).forEach((o) => {
      const r = e.$props[o], a = Ew(o);
      (r !== void 0 || a in n) && (t[o] = r);
    });
  } else if (Wo(e) && typeof e.type == "object") {
    const n = e.props || {}, o = {};
    Object.keys(n).forEach((a) => {
      o[yi(a)] = n[a];
    });
    const r = e.type.props || {};
    Object.keys(r).forEach((a) => {
      const i = Dw(r, o, a, o[a]);
      (i !== void 0 || a in o) && (t[a] = i);
    });
  }
  return t;
}, Jw = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default", n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : e, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0, r;
  if (e.$) {
    const a = e[t];
    if (a !== void 0)
      return typeof a == "function" && o ? a(n) : a;
    r = e.$slots[t], r = o && r ? r(n) : r;
  } else if (Wo(e)) {
    const a = e.props && e.props[t];
    if (a !== void 0 && e.props !== null)
      return typeof a == "function" && o ? a(n) : a;
    e.type === We ? r = e.children : e.children && e.children[t] && (r = e.children[t], r = o && r ? r(n) : r);
  }
  return Array.isArray(r) && (r = xt(r), r = r.length === 1 ? r[0] : r, r = r.length === 0 ? void 0 : r), r;
};
function Gp() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, n = {};
  return e.$ ? n = h(h({}, n), e.$attrs) : n = h(h({}, n), e.props), Qw(n)[t ? "onEvents" : "events"];
}
function ex(e, t) {
  let o = ((Wo(e) ? e.props : e.$attrs) || {}).style || {};
  return typeof o == "string" && (o = Zw(o, t)), o;
}
function tx(e) {
  return e.length === 1 && e[0].type === We;
}
function Sb(e) {
  return e && (e.type === lw || e.type === We && e.children.length === 0 || e.type === sb && e.children.trim() === "");
}
function nn() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  const t = [];
  return e.forEach((n) => {
    Array.isArray(n) ? t.push(...n) : (n == null ? void 0 : n.type) === We ? t.push(...nn(n.children)) : t.push(n);
  }), t.filter((n) => !Sb(n));
}
function on(e) {
  return Array.isArray(e) && e.length === 1 && (e = e[0]), e && e.__v_isVNode && typeof e.type != "symbol";
}
function Uo(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "default";
  var o, r;
  return (o = t[n]) !== null && o !== void 0 ? o : (r = e[n]) === null || r === void 0 ? void 0 : r.call(e);
}
const br = J({
  compatConfig: {
    MODE: 3
  },
  name: "ResizeObserver",
  props: {
    disabled: Boolean,
    onResize: Function
  },
  emits: ["resize"],
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = Et({
      width: 0,
      height: 0,
      offsetHeight: 0,
      offsetWidth: 0
    });
    let r = null, a = null;
    const i = () => {
      a && (a.disconnect(), a = null);
    }, l = (c) => {
      const {
        onResize: d
      } = e, f = c[0].target, {
        width: p,
        height: v
      } = f.getBoundingClientRect(), {
        offsetWidth: g,
        offsetHeight: b
      } = f, y = Math.floor(p), S = Math.floor(v);
      if (o.width !== y || o.height !== S || o.offsetWidth !== g || o.offsetHeight !== b) {
        const w = {
          width: y,
          height: S,
          offsetWidth: g,
          offsetHeight: b
        };
        h(o, w), d && Promise.resolve().then(() => {
          d(h(h({}, w), {
            offsetWidth: g,
            offsetHeight: b
          }), f);
        });
      }
    }, u = On(), s = () => {
      const {
        disabled: c
      } = e;
      if (c) {
        i();
        return;
      }
      const d = to(u);
      d !== r && (i(), r = d), !a && d && (a = new gb(l), a.observe(d));
    };
    return ze(() => {
      s();
    }), Co(() => {
      s();
    }), Xo(() => {
      i();
    }), le(() => e.disabled, () => {
      s();
    }, {
      flush: "post"
    }), () => {
      var c;
      return (c = n.default) === null || c === void 0 ? void 0 : c.call(n)[0];
    };
  }
});
let $b = (e) => setTimeout(e, 16), Cb = (e) => clearTimeout(e);
typeof window < "u" && "requestAnimationFrame" in window && ($b = (e) => window.requestAnimationFrame(e), Cb = (e) => window.cancelAnimationFrame(e));
let Yp = 0;
const wd = /* @__PURE__ */ new Map();
function wb(e) {
  wd.delete(e);
}
function Ue(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  Yp += 1;
  const n = Yp;
  function o(r) {
    if (r === 0)
      wb(n), e();
    else {
      const a = $b(() => {
        o(r - 1);
      });
      wd.set(n, a);
    }
  }
  return o(t), n;
}
Ue.cancel = (e) => {
  const t = wd.get(e);
  return wb(t), Cb(t);
};
const ro = function() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return t;
}, Xn = (e) => {
  const t = e;
  return t.install = function(n) {
    n.component(t.displayName || t.name, e);
  }, e;
};
function ai() {
  return {
    type: [Function, Array]
  };
}
function He(e) {
  return {
    type: Object,
    default: e
  };
}
function Me(e) {
  return {
    type: Boolean,
    default: e
  };
}
function de(e) {
  return {
    type: Function,
    default: e
  };
}
function Wt(e, t) {
  const n = {
    validator: () => !0,
    default: e
  };
  return n;
}
function Nt(e) {
  return {
    type: Array,
    default: e
  };
}
function Ze(e) {
  return {
    type: String,
    default: e
  };
}
function dt(e, t) {
  return e ? {
    type: e,
    default: t
  } : Wt(t);
}
let Kt = !1;
try {
  const e = Object.defineProperty({}, "passive", {
    get() {
      Kt = !0;
    }
  });
  window.addEventListener("testPassive", null, e), window.removeEventListener("testPassive", null, e);
} catch {
}
function Kn(e, t, n, o) {
  if (e && e.addEventListener) {
    let r = o;
    r === void 0 && Kt && (t === "touchstart" || t === "touchmove" || t === "wheel") && (r = {
      passive: !1
    }), e.addEventListener(t, n, r);
  }
  return {
    remove: () => {
      e && e.removeEventListener && e.removeEventListener(t, n);
    }
  };
}
const xd = "anticon", xb = Symbol("GlobalFormContextKey"), nx = (e) => {
  ot(xb, e);
}, ox = () => nt(xb, {
  validateMessages: T(() => {
  })
}), rx = () => ({
  iconPrefixCls: String,
  getTargetContainer: {
    type: Function
  },
  getPopupContainer: {
    type: Function
  },
  prefixCls: String,
  getPrefixCls: {
    type: Function
  },
  renderEmpty: {
    type: Function
  },
  transformCellText: {
    type: Function
  },
  csp: He(),
  input: He(),
  autoInsertSpaceInButton: {
    type: Boolean,
    default: void 0
  },
  locale: He(),
  pageHeader: He(),
  componentSize: {
    type: String
  },
  componentDisabled: {
    type: Boolean,
    default: void 0
  },
  direction: {
    type: String,
    default: "ltr"
  },
  space: He(),
  virtual: {
    type: Boolean,
    default: void 0
  },
  dropdownMatchSelectWidth: {
    type: [Number, Boolean],
    default: !0
  },
  form: He(),
  pagination: He(),
  theme: He(),
  select: He(),
  wave: He()
}), Od = Symbol("configProvider"), Ob = {
  getPrefixCls: (e, t) => t || (e ? `ant-${e}` : "ant"),
  iconPrefixCls: T(() => xd),
  getPopupContainer: T(() => () => document.body),
  direction: T(() => "ltr")
}, rs = () => nt(Od, Ob), ax = (e) => ot(Od, e), Pb = Symbol("DisabledContextKey"), Cn = () => nt(Pb, G(void 0)), Ib = (e) => {
  const t = Cn();
  return ot(Pb, T(() => {
    var n;
    return (n = e.value) !== null && n !== void 0 ? n : t.value;
  })), e;
}, ix = {
  // Options.jsx
  items_per_page: "/ page",
  jump_to: "Go to",
  jump_to_confirm: "confirm",
  page: "",
  // Pagination.jsx
  prev_page: "Previous Page",
  next_page: "Next Page",
  prev_5: "Previous 5 Pages",
  next_5: "Next 5 Pages",
  prev_3: "Previous 3 Pages",
  next_3: "Next 3 Pages"
}, lx = {
  locale: "en_US",
  today: "Today",
  now: "Now",
  backToToday: "Back to today",
  ok: "Ok",
  clear: "Clear",
  month: "Month",
  year: "Year",
  timeSelect: "select time",
  dateSelect: "select date",
  weekSelect: "Choose a week",
  monthSelect: "Choose a month",
  yearSelect: "Choose a year",
  decadeSelect: "Choose a decade",
  yearFormat: "YYYY",
  dateFormat: "M/D/YYYY",
  dayFormat: "D",
  dateTimeFormat: "M/D/YYYY HH:mm:ss",
  monthBeforeYear: !0,
  previousMonth: "Previous month (PageUp)",
  nextMonth: "Next month (PageDown)",
  previousYear: "Last year (Control + left)",
  nextYear: "Next year (Control + right)",
  previousDecade: "Last decade",
  nextDecade: "Next decade",
  previousCentury: "Last century",
  nextCentury: "Next century"
}, Tb = {
  placeholder: "Select time",
  rangePlaceholder: ["Start time", "End time"]
}, El = {
  lang: h({
    placeholder: "Select date",
    yearPlaceholder: "Select year",
    quarterPlaceholder: "Select quarter",
    monthPlaceholder: "Select month",
    weekPlaceholder: "Select week",
    rangePlaceholder: ["Start date", "End date"],
    rangeYearPlaceholder: ["Start year", "End year"],
    rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
    rangeMonthPlaceholder: ["Start month", "End month"],
    rangeWeekPlaceholder: ["Start week", "End week"]
  }, lx),
  timePickerLocale: h({}, Tb)
}, gn = "${label} is not a valid ${type}", yo = {
  locale: "en",
  Pagination: ix,
  DatePicker: El,
  TimePicker: Tb,
  Calendar: El,
  global: {
    placeholder: "Please select"
  },
  Table: {
    filterTitle: "Filter menu",
    filterConfirm: "OK",
    filterReset: "Reset",
    filterEmptyText: "No filters",
    filterCheckall: "Select all items",
    filterSearchPlaceholder: "Search in filters",
    emptyText: "No data",
    selectAll: "Select current page",
    selectInvert: "Invert current page",
    selectNone: "Clear all data",
    selectionAll: "Select all data",
    sortTitle: "Sort",
    expand: "Expand row",
    collapse: "Collapse row",
    triggerDesc: "Click to sort descending",
    triggerAsc: "Click to sort ascending",
    cancelSort: "Click to cancel sorting"
  },
  Tour: {
    Next: "Next",
    Previous: "Previous",
    Finish: "Finish"
  },
  Modal: {
    okText: "OK",
    cancelText: "Cancel",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Cancel"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Search here",
    itemUnit: "item",
    itemsUnit: "items",
    remove: "Remove",
    selectCurrent: "Select current page",
    removeCurrent: "Remove current page",
    selectAll: "Select all data",
    removeAll: "Remove all data",
    selectInvert: "Invert current page"
  },
  Upload: {
    uploading: "Uploading...",
    removeFile: "Remove file",
    uploadError: "Upload error",
    previewFile: "Preview file",
    downloadFile: "Download file"
  },
  Empty: {
    description: "No data"
  },
  Icon: {
    icon: "icon"
  },
  Text: {
    edit: "Edit",
    copy: "Copy",
    copied: "Copied",
    expand: "Expand"
  },
  PageHeader: {
    back: "Back"
  },
  Form: {
    optional: "(optional)",
    defaultValidateMessages: {
      default: "Field validation error for ${label}",
      required: "Please enter ${label}",
      enum: "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: gn,
        method: gn,
        array: gn,
        object: gn,
        number: gn,
        date: gn,
        boolean: gn,
        integer: gn,
        float: gn,
        regexp: gn,
        email: gn,
        url: gn,
        hex: gn
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  },
  Image: {
    preview: "Preview"
  },
  QRCode: {
    expired: "QR code expired",
    refresh: "Refresh",
    scanned: "Scanned"
  }
}, Eb = J({
  compatConfig: {
    MODE: 3
  },
  name: "LocaleReceiver",
  props: {
    componentName: String,
    defaultLocale: {
      type: [Object, Function]
    },
    children: {
      type: Function
    }
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = nt("localeData", {}), r = T(() => {
      const {
        componentName: i = "global",
        defaultLocale: l
      } = e, u = l || yo[i || "global"], {
        antLocale: s
      } = o, c = i && s ? s[i] : {};
      return h(h({}, typeof u == "function" ? u() : u), c || {});
    }), a = T(() => {
      const {
        antLocale: i
      } = o, l = i && i.locale;
      return i && i.exist && !l ? yo.locale : l;
    });
    return () => {
      const i = e.children || n.default, {
        antLocale: l
      } = o;
      return i == null ? void 0 : i(r.value, a.value, l);
    };
  }
});
function Pr(e, t, n) {
  const o = nt("localeData", {});
  return [T(() => {
    const {
      antLocale: a
    } = o, i = Ye(t) || yo[e || "global"], l = e && a ? a[e] : {};
    return h(h(h({}, typeof i == "function" ? i() : i), l || {}), Ye(n) || {});
  })];
}
function Pd(e) {
  for (var t = 0, n, o = 0, r = e.length; r >= 4; ++o, r -= 4)
    n = e.charCodeAt(o) & 255 | (e.charCodeAt(++o) & 255) << 8 | (e.charCodeAt(++o) & 255) << 16 | (e.charCodeAt(++o) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (r) {
    case 3:
      t ^= (e.charCodeAt(o + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(o + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(o) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
const Xp = "%";
class sx {
  constructor(t) {
    this.cache = /* @__PURE__ */ new Map(), this.instanceId = t;
  }
  get(t) {
    return this.cache.get(Array.isArray(t) ? t.join(Xp) : t) || null;
  }
  update(t, n) {
    const o = Array.isArray(t) ? t.join(Xp) : t, r = this.cache.get(o), a = n(r);
    a === null ? this.cache.delete(o) : this.cache.set(o, a);
  }
}
const Mb = "data-token-hash", fr = "data-css-hash", ux = "data-cache-path", Yr = "__cssinjs_instance__";
function ii() {
  const e = Math.random().toString(12).slice(2);
  if (typeof document < "u" && document.head && document.body) {
    const t = document.body.querySelectorAll(`style[${fr}]`) || [], {
      firstChild: n
    } = document.head;
    Array.from(t).forEach((r) => {
      r[Yr] = r[Yr] || e, r[Yr] === e && document.head.insertBefore(r, n);
    });
    const o = {};
    Array.from(document.querySelectorAll(`style[${fr}]`)).forEach((r) => {
      var a;
      const i = r.getAttribute(fr);
      o[i] ? r[Yr] === e && ((a = r.parentNode) === null || a === void 0 || a.removeChild(r)) : o[i] = !0;
    });
  }
  return new sx(e);
}
const _b = Symbol("StyleContextKey"), cx = () => {
  var e, t, n;
  const o = On();
  let r;
  if (o && o.appContext) {
    const a = (n = (t = (e = o.appContext) === null || e === void 0 ? void 0 : e.config) === null || t === void 0 ? void 0 : t.globalProperties) === null || n === void 0 ? void 0 : n.__ANTDV_CSSINJS_CACHE__;
    a ? r = a : (r = ii(), o.appContext.config.globalProperties && (o.appContext.config.globalProperties.__ANTDV_CSSINJS_CACHE__ = r));
  } else
    r = ii();
  return r;
}, Db = {
  cache: ii(),
  defaultCache: !0,
  hashPriority: "low"
}, as = () => {
  const e = cx();
  return nt(_b, K(h(h({}, Db), {
    cache: e
  })));
}, dx = (e) => {
  const t = as(), n = K(h(h({}, Db), {
    cache: ii()
  }));
  return le([() => Ye(e), t], () => {
    const o = h({}, t.value), r = Ye(e);
    Object.keys(r).forEach((i) => {
      const l = r[i];
      r[i] !== void 0 && (o[i] = l);
    });
    const {
      cache: a
    } = r;
    o.cache = o.cache || ii(), o.defaultCache = !a && t.value.defaultCache, n.value = o;
  }, {
    immediate: !0
  }), ot(_b, n), n;
}, fx = () => ({
  autoClear: Me(),
  /** @private Test only. Not work in production. */
  mock: Ze(),
  /**
   * Only set when you need ssr to extract style on you own.
   * If not provided, it will auto create <style /> on the end of Provider in server side.
   */
  cache: He(),
  /** Tell children that this context is default generated context */
  defaultCache: Me(),
  /** Use `:where` selector to reduce hashId css selector priority */
  hashPriority: Ze(),
  /** Tell cssinjs where to inject style in */
  container: dt(),
  /** Component wil render inline  `<style />` for fallback in SSR. Not recommend. */
  ssrInline: Me(),
  /** Transform css before inject in document. Please note that `transformers` do not support dynamic update */
  transformers: Nt(),
  /**
   * Linters to lint css before inject in document.
   * Styles will be linted after transforming.
   * Please note that `linters` do not support dynamic update.
   */
  linters: Nt()
});
Xn(J({
  name: "AStyleProvider",
  inheritAttrs: !1,
  props: fx(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return dx(e), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
}));
function px() {
  return !1;
}
let lc = !1;
function vx() {
  return lc;
}
const mx = process.env.NODE_ENV === "production" ? px : vx;
if (process.env.NODE_ENV !== "production" && typeof module < "u" && module && module.hot && typeof window < "u") {
  const e = window;
  if (typeof e.webpackHotUpdate == "function") {
    const t = e.webpackHotUpdate;
    e.webpackHotUpdate = function() {
      return lc = !0, setTimeout(() => {
        lc = !1;
      }, 0), t(...arguments);
    };
  }
}
function Ab(e, t, n, o) {
  const r = as(), a = K(""), i = K();
  Ve(() => {
    a.value = [e, ...t.value].join("%");
  });
  const l = mx(), u = (s) => {
    r.value.cache.update(s, (c) => {
      const [d = 0, f] = c || [];
      return d - 1 === 0 ? (o == null || o(f, !1), null) : [d - 1, f];
    });
  };
  return le(a, (s, c) => {
    c && u(c), r.value.cache.update(s, (d) => {
      const [f = 0, p] = d || [];
      let v = p;
      process.env.NODE_ENV !== "production" && p && l && (o == null || o(v, l), v = null);
      const g = v || n();
      return [f + 1, g];
    }), i.value = r.value.cache.get(a.value)[1];
  }, {
    immediate: !0
  }), at(() => {
    u(a.value);
  }), i;
}
function Nn() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function ko(e, t) {
  return e && e.contains ? e.contains(t) : !1;
}
const qp = "data-vc-order", gx = "vc-util-key", sc = /* @__PURE__ */ new Map();
function Nb() {
  let {
    mark: e
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return e ? e.startsWith("data-") ? e : `data-${e}` : gx;
}
function is(e) {
  return e.attachTo ? e.attachTo : document.querySelector("head") || document.body;
}
function hx(e) {
  return e === "queue" ? "prependQueue" : e ? "prepend" : "append";
}
function Rb(e) {
  return Array.from((sc.get(e) || e).children).filter((t) => t.tagName === "STYLE");
}
function Fb(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!Nn())
    return null;
  const {
    csp: n,
    prepend: o
  } = t, r = document.createElement("style");
  r.setAttribute(qp, hx(o)), n != null && n.nonce && (r.nonce = n == null ? void 0 : n.nonce), r.innerHTML = e;
  const a = is(t), {
    firstChild: i
  } = a;
  if (o) {
    if (o === "queue") {
      const l = Rb(a).filter((u) => ["prepend", "prependQueue"].includes(u.getAttribute(qp)));
      if (l.length)
        return a.insertBefore(r, l[l.length - 1].nextSibling), r;
    }
    a.insertBefore(r, i);
  } else
    a.appendChild(r);
  return r;
}
function Bb(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const n = is(t);
  return Rb(n).find((o) => o.getAttribute(Nb(t)) === e);
}
function Ml(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const n = Bb(e, t);
  n && is(t).removeChild(n);
}
function bx(e, t) {
  const n = sc.get(e);
  if (!n || !ko(document, n)) {
    const o = Fb("", t), {
      parentNode: r
    } = o;
    sc.set(e, r), e.removeChild(o);
  }
}
function li(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var o, r, a;
  const i = is(n);
  bx(i, n);
  const l = Bb(t, n);
  if (l)
    return !((o = n.csp) === null || o === void 0) && o.nonce && l.nonce !== ((r = n.csp) === null || r === void 0 ? void 0 : r.nonce) && (l.nonce = (a = n.csp) === null || a === void 0 ? void 0 : a.nonce), l.innerHTML !== e && (l.innerHTML = e), l;
  const u = Fb(e, n);
  return u.setAttribute(Nb(n), t), u;
}
function yx(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
class sa {
  constructor() {
    this.cache = /* @__PURE__ */ new Map(), this.keys = [], this.cacheCallTimes = 0;
  }
  size() {
    return this.keys.length;
  }
  internalGet(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, o = {
      map: this.cache
    };
    return t.forEach((r) => {
      var a;
      o ? o = (a = o == null ? void 0 : o.map) === null || a === void 0 ? void 0 : a.get(r) : o = void 0;
    }), o != null && o.value && n && (o.value[1] = this.cacheCallTimes++), o == null ? void 0 : o.value;
  }
  get(t) {
    var n;
    return (n = this.internalGet(t, !0)) === null || n === void 0 ? void 0 : n[0];
  }
  has(t) {
    return !!this.internalGet(t);
  }
  set(t, n) {
    if (!this.has(t)) {
      if (this.size() + 1 > sa.MAX_CACHE_SIZE + sa.MAX_CACHE_OFFSET) {
        const [r] = this.keys.reduce((a, i) => {
          const [, l] = a;
          return this.internalGet(i)[1] < l ? [i, this.internalGet(i)[1]] : a;
        }, [this.keys[0], this.cacheCallTimes]);
        this.delete(r);
      }
      this.keys.push(t);
    }
    let o = this.cache;
    t.forEach((r, a) => {
      if (a === t.length - 1)
        o.set(r, {
          value: [n, this.cacheCallTimes++]
        });
      else {
        const i = o.get(r);
        i ? i.map || (i.map = /* @__PURE__ */ new Map()) : o.set(r, {
          map: /* @__PURE__ */ new Map()
        }), o = o.get(r).map;
      }
    });
  }
  deleteByPath(t, n) {
    var o;
    const r = t.get(n[0]);
    if (n.length === 1)
      return r.map ? t.set(n[0], {
        map: r.map
      }) : t.delete(n[0]), (o = r.value) === null || o === void 0 ? void 0 : o[0];
    const a = this.deleteByPath(r.map, n.slice(1));
    return (!r.map || r.map.size === 0) && !r.value && t.delete(n[0]), a;
  }
  delete(t) {
    if (this.has(t))
      return this.keys = this.keys.filter((n) => !yx(n, t)), this.deleteByPath(this.cache, t);
  }
}
sa.MAX_CACHE_SIZE = 20;
sa.MAX_CACHE_OFFSET = 5;
let uc = {};
function lt(e, t) {
  process.env.NODE_ENV !== "production" && !e && console !== void 0 && console.error(`Warning: ${t}`);
}
function kb(e, t) {
  process.env.NODE_ENV !== "production" && !e && console !== void 0 && console.warn(`Note: ${t}`);
}
function Sx() {
  uc = {};
}
function Lb(e, t, n) {
  !t && !uc[n] && (e(!1, n), uc[n] = !0);
}
function yn(e, t) {
  Lb(lt, e, t);
}
function cc(e, t) {
  Lb(kb, e, t);
}
function $x() {
}
let Pt = $x;
process.env.NODE_ENV !== "production" && (Pt = (e, t, n) => {
  yn(e, `[ant-design-vue: ${t}] ${n}`), process.env.NODE_ENV === "test" && Sx();
});
let Qp = 0;
class Hb {
  constructor(t) {
    this.derivatives = Array.isArray(t) ? t : [t], this.id = Qp, t.length === 0 && Pt(t.length > 0, "[Ant Design Vue CSS-in-JS] Theme should have at least one derivative function."), Qp += 1;
  }
  getDerivativeToken(t) {
    return this.derivatives.reduce((n, o) => o(t, n), void 0);
  }
}
const tu = new sa();
function zb(e) {
  const t = Array.isArray(e) ? e : [e];
  return tu.has(t) || tu.set(t, new Hb(t)), tu.get(t);
}
const Zp = /* @__PURE__ */ new WeakMap();
function _l(e) {
  let t = Zp.get(e) || "";
  return t || (Object.keys(e).forEach((n) => {
    const o = e[n];
    t += n, o instanceof Hb ? t += o.id : o && typeof o == "object" ? t += _l(o) : t += o;
  }), Zp.set(e, t)), t;
}
function Cx(e, t) {
  return Pd(`${t}_${_l(e)}`);
}
const Ka = `random-${Date.now()}-${Math.random()}`.replace(/\./g, ""), jb = "_bAmBoO_";
function wx(e, t, n) {
  var o, r;
  if (Nn()) {
    li(e, Ka);
    const a = document.createElement("div");
    a.style.position = "fixed", a.style.left = "0", a.style.top = "0", t == null || t(a), document.body.appendChild(a), process.env.NODE_ENV !== "production" && (a.innerHTML = "Test", a.style.zIndex = "9999999");
    const i = n ? n(a) : (o = getComputedStyle(a).content) === null || o === void 0 ? void 0 : o.includes(jb);
    return (r = a.parentNode) === null || r === void 0 || r.removeChild(a), Ml(Ka), i;
  }
  return !1;
}
let nu;
function xx() {
  return nu === void 0 && (nu = wx(`@layer ${Ka} { .${Ka} { content: "${jb}"!important; } }`, (e) => {
    e.className = Ka;
  })), nu;
}
const Jp = {}, Ox = process.env.NODE_ENV === "production", Px = process.env.NODE_ENV === "prerender", Ix = !Ox && !Px ? "css-dev-only-do-not-override" : "css", ir = /* @__PURE__ */ new Map();
function Tx(e) {
  ir.set(e, (ir.get(e) || 0) + 1);
}
function Ex(e, t) {
  typeof document < "u" && document.querySelectorAll(`style[${Mb}="${e}"]`).forEach((o) => {
    var r;
    o[Yr] === t && ((r = o.parentNode) === null || r === void 0 || r.removeChild(o));
  });
}
const Mx = 0;
function _x(e, t) {
  ir.set(e, (ir.get(e) || 0) - 1);
  const n = Array.from(ir.keys()), o = n.filter((r) => (ir.get(r) || 0) <= 0);
  n.length - o.length > Mx && o.forEach((r) => {
    Ex(r, t), ir.delete(r);
  });
}
const Dx = (e, t, n, o) => {
  const r = n.getDerivativeToken(e);
  let a = h(h({}, r), t);
  return o && (a = o(a)), a;
};
function Ax(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : G({});
  const o = as(), r = T(() => h({}, ...t.value)), a = T(() => _l(r.value)), i = T(() => _l(n.value.override || Jp));
  return Ab("token", T(() => [n.value.salt || "", e.value.id, a.value, i.value]), () => {
    const {
      salt: u = "",
      override: s = Jp,
      formatToken: c,
      getComputedToken: d
    } = n.value, f = d ? d(r.value, s, e.value) : Dx(r.value, s, e.value, c), p = Cx(f, u);
    f._tokenKey = p, Tx(p);
    const v = `${Ix}-${Pd(p)}`;
    return f._hashId = v, [f, v];
  }, (u) => {
    var s;
    _x(u[0]._tokenKey, (s = o.value) === null || s === void 0 ? void 0 : s.cache.instanceId);
  });
}
var Nx = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, Vb = "comm", Wb = "rule", Kb = "decl", Rx = "@import", Fx = "@keyframes", Bx = "@layer", Ub = Math.abs, Id = String.fromCharCode;
function Gb(e) {
  return e.trim();
}
function rl(e, t, n) {
  return e.replace(t, n);
}
function kx(e, t, n) {
  return e.indexOf(t, n);
}
function si(e, t) {
  return e.charCodeAt(t) | 0;
}
function ui(e, t, n) {
  return e.slice(t, n);
}
function fo(e) {
  return e.length;
}
function Lx(e) {
  return e.length;
}
function Di(e, t) {
  return t.push(e), e;
}
var ls = 1, ua = 1, Yb = 0, Rn = 0, Rt = 0, ba = "";
function Td(e, t, n, o, r, a, i, l) {
  return { value: e, root: t, parent: n, type: o, props: r, children: a, line: ls, column: ua, length: i, return: "", siblings: l };
}
function Hx() {
  return Rt;
}
function zx() {
  return Rt = Rn > 0 ? si(ba, --Rn) : 0, ua--, Rt === 10 && (ua = 1, ls--), Rt;
}
function Un() {
  return Rt = Rn < Yb ? si(ba, Rn++) : 0, ua++, Rt === 10 && (ua = 1, ls++), Rt;
}
function pr() {
  return si(ba, Rn);
}
function al() {
  return Rn;
}
function ss(e, t) {
  return ui(ba, e, t);
}
function dc(e) {
  switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function jx(e) {
  return ls = ua = 1, Yb = fo(ba = e), Rn = 0, [];
}
function Vx(e) {
  return ba = "", e;
}
function ou(e) {
  return Gb(ss(Rn - 1, fc(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function Wx(e) {
  for (; (Rt = pr()) && Rt < 33; )
    Un();
  return dc(e) > 2 || dc(Rt) > 3 ? "" : " ";
}
function Kx(e, t) {
  for (; --t && Un() && !(Rt < 48 || Rt > 102 || Rt > 57 && Rt < 65 || Rt > 70 && Rt < 97); )
    ;
  return ss(e, al() + (t < 6 && pr() == 32 && Un() == 32));
}
function fc(e) {
  for (; Un(); )
    switch (Rt) {
      case e:
        return Rn;
      case 34:
      case 39:
        e !== 34 && e !== 39 && fc(Rt);
        break;
      case 40:
        e === 41 && fc(e);
        break;
      case 92:
        Un();
        break;
    }
  return Rn;
}
function Ux(e, t) {
  for (; Un() && e + Rt !== 57; )
    if (e + Rt === 84 && pr() === 47)
      break;
  return "/*" + ss(t, Rn - 1) + "*" + Id(e === 47 ? e : Un());
}
function Gx(e) {
  for (; !dc(pr()); )
    Un();
  return ss(e, Rn);
}
function Yx(e) {
  return Vx(il("", null, null, null, [""], e = jx(e), 0, [0], e));
}
function il(e, t, n, o, r, a, i, l, u) {
  for (var s = 0, c = 0, d = i, f = 0, p = 0, v = 0, g = 1, b = 1, y = 1, S = 0, w = "", C = r, $ = a, O = o, x = w; b; )
    switch (v = S, S = Un()) {
      case 40:
        if (v != 108 && si(x, d - 1) == 58) {
          kx(x += rl(ou(S), "&", "&\f"), "&\f", Ub(s ? l[s - 1] : 0)) != -1 && (y = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        x += ou(S);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        x += Wx(v);
        break;
      case 92:
        x += Kx(al() - 1, 7);
        continue;
      case 47:
        switch (pr()) {
          case 42:
          case 47:
            Di(Xx(Ux(Un(), al()), t, n, u), u);
            break;
          default:
            x += "/";
        }
        break;
      case 123 * g:
        l[s++] = fo(x) * y;
      case 125 * g:
      case 59:
      case 0:
        switch (S) {
          case 0:
          case 125:
            b = 0;
          case 59 + c:
            y == -1 && (x = rl(x, /\f/g, "")), p > 0 && fo(x) - d && Di(p > 32 ? tv(x + ";", o, n, d - 1, u) : tv(rl(x, " ", "") + ";", o, n, d - 2, u), u);
            break;
          case 59:
            x += ";";
          default:
            if (Di(O = ev(x, t, n, s, c, r, l, w, C = [], $ = [], d, a), a), S === 123)
              if (c === 0)
                il(x, t, O, O, C, a, d, l, $);
              else
                switch (f === 99 && si(x, 3) === 110 ? 100 : f) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    il(e, O, O, o && Di(ev(e, O, O, 0, 0, r, l, w, r, C = [], d, $), $), r, $, d, l, o ? C : $);
                    break;
                  default:
                    il(x, O, O, O, [""], $, 0, l, $);
                }
        }
        s = c = p = 0, g = y = 1, w = x = "", d = i;
        break;
      case 58:
        d = 1 + fo(x), p = v;
      default:
        if (g < 1) {
          if (S == 123)
            --g;
          else if (S == 125 && g++ == 0 && zx() == 125)
            continue;
        }
        switch (x += Id(S), S * g) {
          case 38:
            y = c > 0 ? 1 : (x += "\f", -1);
            break;
          case 44:
            l[s++] = (fo(x) - 1) * y, y = 1;
            break;
          case 64:
            pr() === 45 && (x += ou(Un())), f = pr(), c = d = fo(w = x += Gx(al())), S++;
            break;
          case 45:
            v === 45 && fo(x) == 2 && (g = 0);
        }
    }
  return a;
}
function ev(e, t, n, o, r, a, i, l, u, s, c, d) {
  for (var f = r - 1, p = r === 0 ? a : [""], v = Lx(p), g = 0, b = 0, y = 0; g < o; ++g)
    for (var S = 0, w = ui(e, f + 1, f = Ub(b = i[g])), C = e; S < v; ++S)
      (C = Gb(b > 0 ? p[S] + " " + w : rl(w, /&\f/g, p[S]))) && (u[y++] = C);
  return Td(e, t, n, r === 0 ? Wb : l, u, s, c, d);
}
function Xx(e, t, n, o) {
  return Td(e, t, n, Vb, Id(Hx()), ui(e, 2, -2), 0, o);
}
function tv(e, t, n, o, r) {
  return Td(e, t, n, Kb, ui(e, 0, o), ui(e, o + 1, -1), o, r);
}
function pc(e, t) {
  for (var n = "", o = 0; o < e.length; o++)
    n += t(e[o], o, e, t) || "";
  return n;
}
function qx(e, t, n, o) {
  switch (e.type) {
    case Bx:
      if (e.children.length)
        break;
    case Rx:
    case Kb:
      return e.return = e.return || e.value;
    case Vb:
      return "";
    case Fx:
      return e.return = e.value + "{" + pc(e.children, o) + "}";
    case Wb:
      if (!fo(e.value = e.props.join(",")))
        return "";
  }
  return fo(n = pc(e.children, o)) ? e.return = e.value + "{" + n + "}" : "";
}
function Xb(e, t) {
  const {
    path: n,
    parentSelectors: o
  } = t;
  yn(!1, `[Ant Design Vue CSS-in-JS] ${n ? `Error in '${n}': ` : ""}${e}${o.length ? ` Selector info: ${o.join(" -> ")}` : ""}`);
}
const Qx = (e, t, n) => {
  if (e === "content") {
    const o = /(attr|counters?|url|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
    (typeof t != "string" || ["normal", "none", "initial", "inherit", "unset"].indexOf(t) === -1 && !o.test(t) && (t.charAt(0) !== t.charAt(t.length - 1) || t.charAt(0) !== '"' && t.charAt(0) !== "'")) && Xb(`You seem to be using a value for 'content' without quotes, try replacing it with \`content: '"${t}"'\`.`, n);
  }
}, Zx = (e, t, n) => {
  e === "animation" && n.hashId && t !== "none" && Xb(`You seem to be using hashed animation '${t}', in which case 'animationName' with Keyframe as value is recommended.`, n);
}, nv = "data-ant-cssinjs-cache-path", Jx = "_FILE_STYLE__";
let vr, qb = !0;
function e1() {
  var e;
  if (!vr && (vr = {}, Nn())) {
    const t = document.createElement("div");
    t.className = nv, t.style.position = "fixed", t.style.visibility = "hidden", t.style.top = "-9999px", document.body.appendChild(t);
    let n = getComputedStyle(t).content || "";
    n = n.replace(/^"/, "").replace(/"$/, ""), n.split(";").forEach((r) => {
      const [a, i] = r.split(":");
      vr[a] = i;
    });
    const o = document.querySelector(`style[${nv}]`);
    o && (qb = !1, (e = o.parentNode) === null || e === void 0 || e.removeChild(o)), document.body.removeChild(t);
  }
}
function t1(e) {
  return e1(), !!vr[e];
}
function n1(e) {
  const t = vr[e];
  let n = null;
  if (t && Nn())
    if (qb)
      n = Jx;
    else {
      const o = document.querySelector(`style[${fr}="${vr[e]}"]`);
      o ? n = o.innerHTML : delete vr[e];
    }
  return [n, t];
}
const ov = Nn(), Qb = "_skip_check_", Zb = "_multi_value_";
function rv(e) {
  return pc(Yx(e), qx).replace(/\{%%%\:[^;];}/g, ";");
}
function o1(e) {
  return typeof e == "object" && e && (Qb in e || Zb in e);
}
function r1(e, t, n) {
  if (!t)
    return e;
  const o = `.${t}`, r = n === "low" ? `:where(${o})` : o;
  return e.split(",").map((i) => {
    var l;
    const u = i.trim().split(/\s+/);
    let s = u[0] || "";
    const c = ((l = s.match(/^\w+/)) === null || l === void 0 ? void 0 : l[0]) || "";
    return s = `${c}${r}${s.slice(c.length)}`, [s, ...u.slice(1)].join(" ");
  }).join(",");
}
const vc = /* @__PURE__ */ new Set();
process.env.NODE_ENV;
const mc = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    root: n,
    injectHash: o,
    parentSelectors: r
  } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    root: !0,
    parentSelectors: []
  };
  const {
    hashId: a,
    layer: i,
    path: l,
    hashPriority: u,
    transformers: s = [],
    linters: c = []
  } = t;
  let d = "", f = {};
  function p(b) {
    const y = b.getName(a);
    if (!f[y]) {
      const [S] = mc(b.style, t, {
        root: !1,
        parentSelectors: r
      });
      f[y] = `@keyframes ${b.getName(a)}${S}`;
    }
  }
  function v(b) {
    let y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return b.forEach((S) => {
      Array.isArray(S) ? v(S, y) : S && y.push(S);
    }), y;
  }
  if (v(Array.isArray(e) ? e : [e]).forEach((b) => {
    const y = typeof b == "string" && !n ? {} : b;
    if (typeof y == "string")
      d += `${y}
`;
    else if (y._keyframe)
      p(y);
    else {
      const S = s.reduce((w, C) => {
        var $;
        return (($ = C == null ? void 0 : C.visit) === null || $ === void 0 ? void 0 : $.call(C, w)) || w;
      }, y);
      Object.keys(S).forEach((w) => {
        var C;
        const $ = S[w];
        if (typeof $ == "object" && $ && (w !== "animationName" || !$._keyframe) && !o1($)) {
          let O = !1, x = w.trim(), M = !1;
          (n || o) && a ? x.startsWith("@") ? O = !0 : x = r1(w, a, u) : n && !a && (x === "&" || x === "") && (x = "", M = !0);
          const [_, N] = mc($, t, {
            root: M,
            injectHash: O,
            parentSelectors: [...r, x]
          });
          f = h(h({}, f), N), d += `${x}${_}`;
        } else {
          let O = function(M, _) {
            process.env.NODE_ENV !== "production" && (typeof $ != "object" || !($ != null && $[Qb])) && [Qx, Zx, ...c].forEach((E) => E(M, _, {
              path: l,
              hashId: a,
              parentSelectors: r
            }));
            const N = M.replace(/[A-Z]/g, (E) => `-${E.toLowerCase()}`);
            let I = _;
            !Nx[M] && typeof I == "number" && I !== 0 && (I = `${I}px`), M === "animationName" && (_ != null && _._keyframe) && (p(_), I = _.getName(a)), d += `${N}:${I};`;
          };
          const x = (C = $ == null ? void 0 : $.value) !== null && C !== void 0 ? C : $;
          typeof $ == "object" && ($ != null && $[Zb]) && Array.isArray(x) ? x.forEach((M) => {
            O(w, M);
          }) : O(w, x);
        }
      });
    }
  }), !n)
    d = `{${d}}`;
  else if (i && xx()) {
    const b = i.split(",");
    d = `@layer ${b[b.length - 1].trim()} {${d}}`, b.length > 1 && (d = `@layer ${i}{%%%:%}${d}`);
  }
  return [d, f];
};
function a1(e, t) {
  return Pd(`${e.join("%")}${t}`);
}
function gc(e, t) {
  const n = as(), o = T(() => e.value.token._tokenKey), r = T(() => [o.value, ...e.value.path]);
  let a = ov;
  return process.env.NODE_ENV !== "production" && n.value.mock !== void 0 && (a = n.value.mock === "client"), Ab(
    "style",
    r,
    // Create cache if needed
    () => {
      const {
        path: i,
        hashId: l,
        layer: u,
        nonce: s,
        clientOnly: c,
        order: d = 0
      } = e.value, f = r.value.join("|");
      if (t1(f)) {
        const [x, M] = n1(f);
        if (x)
          return [x, o.value, M, {}, c, d];
      }
      const p = t(), {
        hashPriority: v,
        container: g,
        transformers: b,
        linters: y,
        cache: S
      } = n.value, [w, C] = mc(p, {
        hashId: l,
        hashPriority: v,
        layer: u,
        path: i.join("-"),
        transformers: b,
        linters: y
      }), $ = rv(w), O = a1(r.value, $);
      if (a) {
        const x = {
          mark: fr,
          prepend: "queue",
          attachTo: g,
          priority: d
        }, M = typeof s == "function" ? s() : s;
        M && (x.csp = {
          nonce: M
        });
        const _ = li($, O, x);
        _[Yr] = S.instanceId, _.setAttribute(Mb, o.value), process.env.NODE_ENV !== "production" && _.setAttribute(ux, r.value.join("|")), Object.keys(C).forEach((N) => {
          vc.has(N) || (vc.add(N), li(rv(C[N]), `_effect-${N}`, {
            mark: fr,
            prepend: "queue",
            attachTo: g
          }));
        });
      }
      return [$, o.value, O, C, c, d];
    },
    // Remove cache if no need
    (i, l) => {
      let [, , u] = i;
      (l || n.value.autoClear) && ov && Ml(u, {
        mark: fr
      });
    }
  ), (i) => i;
}
class Xe {
  constructor(t, n) {
    this._keyframe = !0, this.name = t, this.style = n;
  }
  getName() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return t ? `${t}-${this.name}` : this.name;
  }
}
const i1 = "4.2.1", ci = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"];
function Xt(e, t) {
  l1(e) && (e = "100%");
  var n = s1(e);
  return e = t === 360 ? e : Math.min(t, Math.max(0, parseFloat(e))), n && (e = parseInt(String(e * t), 10) / 100), Math.abs(e - t) < 1e-6 ? 1 : (t === 360 ? e = (e < 0 ? e % t + t : e % t) / parseFloat(String(t)) : e = e % t / parseFloat(String(t)), e);
}
function Ai(e) {
  return Math.min(1, Math.max(0, e));
}
function l1(e) {
  return typeof e == "string" && e.indexOf(".") !== -1 && parseFloat(e) === 1;
}
function s1(e) {
  return typeof e == "string" && e.indexOf("%") !== -1;
}
function Jb(e) {
  return e = parseFloat(e), (isNaN(e) || e < 0 || e > 1) && (e = 1), e;
}
function Ni(e) {
  return e <= 1 ? "".concat(Number(e) * 100, "%") : e;
}
function ur(e) {
  return e.length === 1 ? "0" + e : String(e);
}
function u1(e, t, n) {
  return {
    r: Xt(e, 255) * 255,
    g: Xt(t, 255) * 255,
    b: Xt(n, 255) * 255
  };
}
function av(e, t, n) {
  e = Xt(e, 255), t = Xt(t, 255), n = Xt(n, 255);
  var o = Math.max(e, t, n), r = Math.min(e, t, n), a = 0, i = 0, l = (o + r) / 2;
  if (o === r)
    i = 0, a = 0;
  else {
    var u = o - r;
    switch (i = l > 0.5 ? u / (2 - o - r) : u / (o + r), o) {
      case e:
        a = (t - n) / u + (t < n ? 6 : 0);
        break;
      case t:
        a = (n - e) / u + 2;
        break;
      case n:
        a = (e - t) / u + 4;
        break;
    }
    a /= 6;
  }
  return { h: a, s: i, l };
}
function ru(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * (6 * n) : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function c1(e, t, n) {
  var o, r, a;
  if (e = Xt(e, 360), t = Xt(t, 100), n = Xt(n, 100), t === 0)
    r = n, a = n, o = n;
  else {
    var i = n < 0.5 ? n * (1 + t) : n + t - n * t, l = 2 * n - i;
    o = ru(l, i, e + 1 / 3), r = ru(l, i, e), a = ru(l, i, e - 1 / 3);
  }
  return { r: o * 255, g: r * 255, b: a * 255 };
}
function hc(e, t, n) {
  e = Xt(e, 255), t = Xt(t, 255), n = Xt(n, 255);
  var o = Math.max(e, t, n), r = Math.min(e, t, n), a = 0, i = o, l = o - r, u = o === 0 ? 0 : l / o;
  if (o === r)
    a = 0;
  else {
    switch (o) {
      case e:
        a = (t - n) / l + (t < n ? 6 : 0);
        break;
      case t:
        a = (n - e) / l + 2;
        break;
      case n:
        a = (e - t) / l + 4;
        break;
    }
    a /= 6;
  }
  return { h: a, s: u, v: i };
}
function d1(e, t, n) {
  e = Xt(e, 360) * 6, t = Xt(t, 100), n = Xt(n, 100);
  var o = Math.floor(e), r = e - o, a = n * (1 - t), i = n * (1 - r * t), l = n * (1 - (1 - r) * t), u = o % 6, s = [n, i, a, a, l, n][u], c = [l, n, n, i, a, a][u], d = [a, a, l, n, n, i][u];
  return { r: s * 255, g: c * 255, b: d * 255 };
}
function bc(e, t, n, o) {
  var r = [
    ur(Math.round(e).toString(16)),
    ur(Math.round(t).toString(16)),
    ur(Math.round(n).toString(16))
  ];
  return o && r[0].startsWith(r[0].charAt(1)) && r[1].startsWith(r[1].charAt(1)) && r[2].startsWith(r[2].charAt(1)) ? r[0].charAt(0) + r[1].charAt(0) + r[2].charAt(0) : r.join("");
}
function f1(e, t, n, o, r) {
  var a = [
    ur(Math.round(e).toString(16)),
    ur(Math.round(t).toString(16)),
    ur(Math.round(n).toString(16)),
    ur(p1(o))
  ];
  return r && a[0].startsWith(a[0].charAt(1)) && a[1].startsWith(a[1].charAt(1)) && a[2].startsWith(a[2].charAt(1)) && a[3].startsWith(a[3].charAt(1)) ? a[0].charAt(0) + a[1].charAt(0) + a[2].charAt(0) + a[3].charAt(0) : a.join("");
}
function p1(e) {
  return Math.round(parseFloat(e) * 255).toString(16);
}
function iv(e) {
  return bn(e) / 255;
}
function bn(e) {
  return parseInt(e, 16);
}
function v1(e) {
  return {
    r: e >> 16,
    g: (e & 65280) >> 8,
    b: e & 255
  };
}
var yc = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function Wr(e) {
  var t = { r: 0, g: 0, b: 0 }, n = 1, o = null, r = null, a = null, i = !1, l = !1;
  return typeof e == "string" && (e = h1(e)), typeof e == "object" && (so(e.r) && so(e.g) && so(e.b) ? (t = u1(e.r, e.g, e.b), i = !0, l = String(e.r).substr(-1) === "%" ? "prgb" : "rgb") : so(e.h) && so(e.s) && so(e.v) ? (o = Ni(e.s), r = Ni(e.v), t = d1(e.h, o, r), i = !0, l = "hsv") : so(e.h) && so(e.s) && so(e.l) && (o = Ni(e.s), a = Ni(e.l), t = c1(e.h, o, a), i = !0, l = "hsl"), Object.prototype.hasOwnProperty.call(e, "a") && (n = e.a)), n = Jb(n), {
    ok: i,
    format: e.format || l,
    r: Math.min(255, Math.max(t.r, 0)),
    g: Math.min(255, Math.max(t.g, 0)),
    b: Math.min(255, Math.max(t.b, 0)),
    a: n
  };
}
var m1 = "[-\\+]?\\d+%?", g1 = "[-\\+]?\\d*\\.\\d+%?", Ho = "(?:".concat(g1, ")|(?:").concat(m1, ")"), au = "[\\s|\\(]+(".concat(Ho, ")[,|\\s]+(").concat(Ho, ")[,|\\s]+(").concat(Ho, ")\\s*\\)?"), iu = "[\\s|\\(]+(".concat(Ho, ")[,|\\s]+(").concat(Ho, ")[,|\\s]+(").concat(Ho, ")[,|\\s]+(").concat(Ho, ")\\s*\\)?"), zn = {
  CSS_UNIT: new RegExp(Ho),
  rgb: new RegExp("rgb" + au),
  rgba: new RegExp("rgba" + iu),
  hsl: new RegExp("hsl" + au),
  hsla: new RegExp("hsla" + iu),
  hsv: new RegExp("hsv" + au),
  hsva: new RegExp("hsva" + iu),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function h1(e) {
  if (e = e.trim().toLowerCase(), e.length === 0)
    return !1;
  var t = !1;
  if (yc[e])
    e = yc[e], t = !0;
  else if (e === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  var n = zn.rgb.exec(e);
  return n ? { r: n[1], g: n[2], b: n[3] } : (n = zn.rgba.exec(e), n ? { r: n[1], g: n[2], b: n[3], a: n[4] } : (n = zn.hsl.exec(e), n ? { h: n[1], s: n[2], l: n[3] } : (n = zn.hsla.exec(e), n ? { h: n[1], s: n[2], l: n[3], a: n[4] } : (n = zn.hsv.exec(e), n ? { h: n[1], s: n[2], v: n[3] } : (n = zn.hsva.exec(e), n ? { h: n[1], s: n[2], v: n[3], a: n[4] } : (n = zn.hex8.exec(e), n ? {
    r: bn(n[1]),
    g: bn(n[2]),
    b: bn(n[3]),
    a: iv(n[4]),
    format: t ? "name" : "hex8"
  } : (n = zn.hex6.exec(e), n ? {
    r: bn(n[1]),
    g: bn(n[2]),
    b: bn(n[3]),
    format: t ? "name" : "hex"
  } : (n = zn.hex4.exec(e), n ? {
    r: bn(n[1] + n[1]),
    g: bn(n[2] + n[2]),
    b: bn(n[3] + n[3]),
    a: iv(n[4] + n[4]),
    format: t ? "name" : "hex8"
  } : (n = zn.hex3.exec(e), n ? {
    r: bn(n[1] + n[1]),
    g: bn(n[2] + n[2]),
    b: bn(n[3] + n[3]),
    format: t ? "name" : "hex"
  } : !1)))))))));
}
function so(e) {
  return !!zn.CSS_UNIT.exec(String(e));
}
var Ct = (
  /** @class */
  function() {
    function e(t, n) {
      t === void 0 && (t = ""), n === void 0 && (n = {});
      var o;
      if (t instanceof e)
        return t;
      typeof t == "number" && (t = v1(t)), this.originalInput = t;
      var r = Wr(t);
      this.originalInput = t, this.r = r.r, this.g = r.g, this.b = r.b, this.a = r.a, this.roundA = Math.round(100 * this.a) / 100, this.format = (o = n.format) !== null && o !== void 0 ? o : r.format, this.gradientType = n.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = r.ok;
    }
    return e.prototype.isDark = function() {
      return this.getBrightness() < 128;
    }, e.prototype.isLight = function() {
      return !this.isDark();
    }, e.prototype.getBrightness = function() {
      var t = this.toRgb();
      return (t.r * 299 + t.g * 587 + t.b * 114) / 1e3;
    }, e.prototype.getLuminance = function() {
      var t = this.toRgb(), n, o, r, a = t.r / 255, i = t.g / 255, l = t.b / 255;
      return a <= 0.03928 ? n = a / 12.92 : n = Math.pow((a + 0.055) / 1.055, 2.4), i <= 0.03928 ? o = i / 12.92 : o = Math.pow((i + 0.055) / 1.055, 2.4), l <= 0.03928 ? r = l / 12.92 : r = Math.pow((l + 0.055) / 1.055, 2.4), 0.2126 * n + 0.7152 * o + 0.0722 * r;
    }, e.prototype.getAlpha = function() {
      return this.a;
    }, e.prototype.setAlpha = function(t) {
      return this.a = Jb(t), this.roundA = Math.round(100 * this.a) / 100, this;
    }, e.prototype.isMonochrome = function() {
      var t = this.toHsl().s;
      return t === 0;
    }, e.prototype.toHsv = function() {
      var t = hc(this.r, this.g, this.b);
      return { h: t.h * 360, s: t.s, v: t.v, a: this.a };
    }, e.prototype.toHsvString = function() {
      var t = hc(this.r, this.g, this.b), n = Math.round(t.h * 360), o = Math.round(t.s * 100), r = Math.round(t.v * 100);
      return this.a === 1 ? "hsv(".concat(n, ", ").concat(o, "%, ").concat(r, "%)") : "hsva(".concat(n, ", ").concat(o, "%, ").concat(r, "%, ").concat(this.roundA, ")");
    }, e.prototype.toHsl = function() {
      var t = av(this.r, this.g, this.b);
      return { h: t.h * 360, s: t.s, l: t.l, a: this.a };
    }, e.prototype.toHslString = function() {
      var t = av(this.r, this.g, this.b), n = Math.round(t.h * 360), o = Math.round(t.s * 100), r = Math.round(t.l * 100);
      return this.a === 1 ? "hsl(".concat(n, ", ").concat(o, "%, ").concat(r, "%)") : "hsla(".concat(n, ", ").concat(o, "%, ").concat(r, "%, ").concat(this.roundA, ")");
    }, e.prototype.toHex = function(t) {
      return t === void 0 && (t = !1), bc(this.r, this.g, this.b, t);
    }, e.prototype.toHexString = function(t) {
      return t === void 0 && (t = !1), "#" + this.toHex(t);
    }, e.prototype.toHex8 = function(t) {
      return t === void 0 && (t = !1), f1(this.r, this.g, this.b, this.a, t);
    }, e.prototype.toHex8String = function(t) {
      return t === void 0 && (t = !1), "#" + this.toHex8(t);
    }, e.prototype.toHexShortString = function(t) {
      return t === void 0 && (t = !1), this.a === 1 ? this.toHexString(t) : this.toHex8String(t);
    }, e.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    }, e.prototype.toRgbString = function() {
      var t = Math.round(this.r), n = Math.round(this.g), o = Math.round(this.b);
      return this.a === 1 ? "rgb(".concat(t, ", ").concat(n, ", ").concat(o, ")") : "rgba(".concat(t, ", ").concat(n, ", ").concat(o, ", ").concat(this.roundA, ")");
    }, e.prototype.toPercentageRgb = function() {
      var t = function(n) {
        return "".concat(Math.round(Xt(n, 255) * 100), "%");
      };
      return {
        r: t(this.r),
        g: t(this.g),
        b: t(this.b),
        a: this.a
      };
    }, e.prototype.toPercentageRgbString = function() {
      var t = function(n) {
        return Math.round(Xt(n, 255) * 100);
      };
      return this.a === 1 ? "rgb(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%)") : "rgba(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%, ").concat(this.roundA, ")");
    }, e.prototype.toName = function() {
      if (this.a === 0)
        return "transparent";
      if (this.a < 1)
        return !1;
      for (var t = "#" + bc(this.r, this.g, this.b, !1), n = 0, o = Object.entries(yc); n < o.length; n++) {
        var r = o[n], a = r[0], i = r[1];
        if (t === i)
          return a;
      }
      return !1;
    }, e.prototype.toString = function(t) {
      var n = !!t;
      t = t ?? this.format;
      var o = !1, r = this.a < 1 && this.a >= 0, a = !n && r && (t.startsWith("hex") || t === "name");
      return a ? t === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (t === "rgb" && (o = this.toRgbString()), t === "prgb" && (o = this.toPercentageRgbString()), (t === "hex" || t === "hex6") && (o = this.toHexString()), t === "hex3" && (o = this.toHexString(!0)), t === "hex4" && (o = this.toHex8String(!0)), t === "hex8" && (o = this.toHex8String()), t === "name" && (o = this.toName()), t === "hsl" && (o = this.toHslString()), t === "hsv" && (o = this.toHsvString()), o || this.toHexString());
    }, e.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    }, e.prototype.clone = function() {
      return new e(this.toString());
    }, e.prototype.lighten = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.l += t / 100, n.l = Ai(n.l), new e(n);
    }, e.prototype.brighten = function(t) {
      t === void 0 && (t = 10);
      var n = this.toRgb();
      return n.r = Math.max(0, Math.min(255, n.r - Math.round(255 * -(t / 100)))), n.g = Math.max(0, Math.min(255, n.g - Math.round(255 * -(t / 100)))), n.b = Math.max(0, Math.min(255, n.b - Math.round(255 * -(t / 100)))), new e(n);
    }, e.prototype.darken = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.l -= t / 100, n.l = Ai(n.l), new e(n);
    }, e.prototype.tint = function(t) {
      return t === void 0 && (t = 10), this.mix("white", t);
    }, e.prototype.shade = function(t) {
      return t === void 0 && (t = 10), this.mix("black", t);
    }, e.prototype.desaturate = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.s -= t / 100, n.s = Ai(n.s), new e(n);
    }, e.prototype.saturate = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.s += t / 100, n.s = Ai(n.s), new e(n);
    }, e.prototype.greyscale = function() {
      return this.desaturate(100);
    }, e.prototype.spin = function(t) {
      var n = this.toHsl(), o = (n.h + t) % 360;
      return n.h = o < 0 ? 360 + o : o, new e(n);
    }, e.prototype.mix = function(t, n) {
      n === void 0 && (n = 50);
      var o = this.toRgb(), r = new e(t).toRgb(), a = n / 100, i = {
        r: (r.r - o.r) * a + o.r,
        g: (r.g - o.g) * a + o.g,
        b: (r.b - o.b) * a + o.b,
        a: (r.a - o.a) * a + o.a
      };
      return new e(i);
    }, e.prototype.analogous = function(t, n) {
      t === void 0 && (t = 6), n === void 0 && (n = 30);
      var o = this.toHsl(), r = 360 / n, a = [this];
      for (o.h = (o.h - (r * t >> 1) + 720) % 360; --t; )
        o.h = (o.h + r) % 360, a.push(new e(o));
      return a;
    }, e.prototype.complement = function() {
      var t = this.toHsl();
      return t.h = (t.h + 180) % 360, new e(t);
    }, e.prototype.monochromatic = function(t) {
      t === void 0 && (t = 6);
      for (var n = this.toHsv(), o = n.h, r = n.s, a = n.v, i = [], l = 1 / t; t--; )
        i.push(new e({ h: o, s: r, v: a })), a = (a + l) % 1;
      return i;
    }, e.prototype.splitcomplement = function() {
      var t = this.toHsl(), n = t.h;
      return [
        this,
        new e({ h: (n + 72) % 360, s: t.s, l: t.l }),
        new e({ h: (n + 216) % 360, s: t.s, l: t.l })
      ];
    }, e.prototype.onBackground = function(t) {
      var n = this.toRgb(), o = new e(t).toRgb(), r = n.a + o.a * (1 - n.a);
      return new e({
        r: (n.r * n.a + o.r * o.a * (1 - n.a)) / r,
        g: (n.g * n.a + o.g * o.a * (1 - n.a)) / r,
        b: (n.b * n.a + o.b * o.a * (1 - n.a)) / r,
        a: r
      });
    }, e.prototype.triad = function() {
      return this.polyad(3);
    }, e.prototype.tetrad = function() {
      return this.polyad(4);
    }, e.prototype.polyad = function(t) {
      for (var n = this.toHsl(), o = n.h, r = [this], a = 360 / t, i = 1; i < t; i++)
        r.push(new e({ h: (o + i * a) % 360, s: n.s, l: n.l }));
      return r;
    }, e.prototype.equals = function(t) {
      return this.toRgbString() === new e(t).toRgbString();
    }, e;
  }()
), Ri = 2, lv = 0.16, b1 = 0.05, y1 = 0.05, S1 = 0.15, ey = 5, ty = 4, $1 = [{
  index: 7,
  opacity: 0.15
}, {
  index: 6,
  opacity: 0.25
}, {
  index: 5,
  opacity: 0.3
}, {
  index: 5,
  opacity: 0.45
}, {
  index: 5,
  opacity: 0.65
}, {
  index: 5,
  opacity: 0.85
}, {
  index: 4,
  opacity: 0.9
}, {
  index: 3,
  opacity: 0.95
}, {
  index: 2,
  opacity: 0.97
}, {
  index: 1,
  opacity: 0.98
}];
function sv(e) {
  var t = e.r, n = e.g, o = e.b, r = hc(t, n, o);
  return {
    h: r.h * 360,
    s: r.s,
    v: r.v
  };
}
function Fi(e) {
  var t = e.r, n = e.g, o = e.b;
  return "#".concat(bc(t, n, o, !1));
}
function C1(e, t, n) {
  var o = n / 100, r = {
    r: (t.r - e.r) * o + e.r,
    g: (t.g - e.g) * o + e.g,
    b: (t.b - e.b) * o + e.b
  };
  return r;
}
function uv(e, t, n) {
  var o;
  return Math.round(e.h) >= 60 && Math.round(e.h) <= 240 ? o = n ? Math.round(e.h) - Ri * t : Math.round(e.h) + Ri * t : o = n ? Math.round(e.h) + Ri * t : Math.round(e.h) - Ri * t, o < 0 ? o += 360 : o >= 360 && (o -= 360), o;
}
function cv(e, t, n) {
  if (e.h === 0 && e.s === 0)
    return e.s;
  var o;
  return n ? o = e.s - lv * t : t === ty ? o = e.s + lv : o = e.s + b1 * t, o > 1 && (o = 1), n && t === ey && o > 0.1 && (o = 0.1), o < 0.06 && (o = 0.06), Number(o.toFixed(2));
}
function dv(e, t, n) {
  var o;
  return n ? o = e.v + y1 * t : o = e.v - S1 * t, o > 1 && (o = 1), Number(o.toFixed(2));
}
function yr(e) {
  for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = [], o = Wr(e), r = ey; r > 0; r -= 1) {
    var a = sv(o), i = Fi(Wr({
      h: uv(a, r, !0),
      s: cv(a, r, !0),
      v: dv(a, r, !0)
    }));
    n.push(i);
  }
  n.push(Fi(o));
  for (var l = 1; l <= ty; l += 1) {
    var u = sv(o), s = Fi(Wr({
      h: uv(u, l),
      s: cv(u, l),
      v: dv(u, l)
    }));
    n.push(s);
  }
  return t.theme === "dark" ? $1.map(function(c) {
    var d = c.index, f = c.opacity, p = Fi(C1(Wr(t.backgroundColor || "#141414"), Wr(n[d]), f * 100));
    return p;
  }) : n;
}
var Qr = {
  red: "#F5222D",
  volcano: "#FA541C",
  orange: "#FA8C16",
  gold: "#FAAD14",
  yellow: "#FADB14",
  lime: "#A0D911",
  green: "#52C41A",
  cyan: "#13C2C2",
  blue: "#1890FF",
  geekblue: "#2F54EB",
  purple: "#722ED1",
  magenta: "#EB2F96",
  grey: "#666666"
}, ll = {}, lu = {};
Object.keys(Qr).forEach(function(e) {
  ll[e] = yr(Qr[e]), ll[e].primary = ll[e][5], lu[e] = yr(Qr[e], {
    theme: "dark",
    backgroundColor: "#141414"
  }), lu[e].primary = lu[e][5];
});
var w1 = ll.blue;
const x1 = (e) => {
  const {
    controlHeight: t
  } = e;
  return {
    controlHeightSM: t * 0.75,
    controlHeightXS: t * 0.5,
    controlHeightLG: t * 1.25
  };
};
function O1(e) {
  const {
    sizeUnit: t,
    sizeStep: n
  } = e;
  return {
    sizeXXL: t * (n + 8),
    sizeXL: t * (n + 4),
    sizeLG: t * (n + 2),
    sizeMD: t * (n + 1),
    sizeMS: t * n,
    size: t * n,
    sizeSM: t * (n - 1),
    sizeXS: t * (n - 2),
    sizeXXS: t * (n - 3)
    // 4
  };
}
const ny = {
  blue: "#1677ff",
  purple: "#722ED1",
  cyan: "#13C2C2",
  green: "#52C41A",
  magenta: "#EB2F96",
  pink: "#eb2f96",
  red: "#F5222D",
  orange: "#FA8C16",
  yellow: "#FADB14",
  volcano: "#FA541C",
  geekblue: "#2F54EB",
  gold: "#FAAD14",
  lime: "#A0D911"
}, us = h(h({}, ny), {
  // Color
  colorPrimary: "#1677ff",
  colorSuccess: "#52c41a",
  colorWarning: "#faad14",
  colorError: "#ff4d4f",
  colorInfo: "#1677ff",
  colorTextBase: "",
  colorBgBase: "",
  // Font
  fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
  fontSize: 14,
  // Line
  lineWidth: 1,
  lineType: "solid",
  // Motion
  motionUnit: 0.1,
  motionBase: 0,
  motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
  motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
  motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
  motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
  motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
  motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
  motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
  motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
  // Radius
  borderRadius: 6,
  // Size
  sizeUnit: 4,
  sizeStep: 4,
  sizePopupArrow: 16,
  // Control Base
  controlHeight: 32,
  // zIndex
  zIndexBase: 0,
  zIndexPopupBase: 1e3,
  // Image
  opacityImage: 1,
  // Wireframe
  wireframe: !1
});
function P1(e, t) {
  let {
    generateColorPalettes: n,
    generateNeutralColorPalettes: o
  } = t;
  const {
    colorSuccess: r,
    colorWarning: a,
    colorError: i,
    colorInfo: l,
    colorPrimary: u,
    colorBgBase: s,
    colorTextBase: c
  } = e, d = n(u), f = n(r), p = n(a), v = n(i), g = n(l), b = o(s, c);
  return h(h({}, b), {
    colorPrimaryBg: d[1],
    colorPrimaryBgHover: d[2],
    colorPrimaryBorder: d[3],
    colorPrimaryBorderHover: d[4],
    colorPrimaryHover: d[5],
    colorPrimary: d[6],
    colorPrimaryActive: d[7],
    colorPrimaryTextHover: d[8],
    colorPrimaryText: d[9],
    colorPrimaryTextActive: d[10],
    colorSuccessBg: f[1],
    colorSuccessBgHover: f[2],
    colorSuccessBorder: f[3],
    colorSuccessBorderHover: f[4],
    colorSuccessHover: f[4],
    colorSuccess: f[6],
    colorSuccessActive: f[7],
    colorSuccessTextHover: f[8],
    colorSuccessText: f[9],
    colorSuccessTextActive: f[10],
    colorErrorBg: v[1],
    colorErrorBgHover: v[2],
    colorErrorBorder: v[3],
    colorErrorBorderHover: v[4],
    colorErrorHover: v[5],
    colorError: v[6],
    colorErrorActive: v[7],
    colorErrorTextHover: v[8],
    colorErrorText: v[9],
    colorErrorTextActive: v[10],
    colorWarningBg: p[1],
    colorWarningBgHover: p[2],
    colorWarningBorder: p[3],
    colorWarningBorderHover: p[4],
    colorWarningHover: p[4],
    colorWarning: p[6],
    colorWarningActive: p[7],
    colorWarningTextHover: p[8],
    colorWarningText: p[9],
    colorWarningTextActive: p[10],
    colorInfoBg: g[1],
    colorInfoBgHover: g[2],
    colorInfoBorder: g[3],
    colorInfoBorderHover: g[4],
    colorInfoHover: g[4],
    colorInfo: g[6],
    colorInfoActive: g[7],
    colorInfoTextHover: g[8],
    colorInfoText: g[9],
    colorInfoTextActive: g[10],
    colorBgMask: new Ct("#000").setAlpha(0.45).toRgbString(),
    colorWhite: "#fff"
  });
}
const I1 = (e) => {
  let t = e, n = e, o = e, r = e;
  return e < 6 && e >= 5 ? t = e + 1 : e < 16 && e >= 6 ? t = e + 2 : e >= 16 && (t = 16), e < 7 && e >= 5 ? n = 4 : e < 8 && e >= 7 ? n = 5 : e < 14 && e >= 8 ? n = 6 : e < 16 && e >= 14 ? n = 7 : e >= 16 && (n = 8), e < 6 && e >= 2 ? o = 1 : e >= 6 && (o = 2), e > 4 && e < 8 ? r = 4 : e >= 8 && (r = 6), {
    borderRadius: e > 16 ? 16 : e,
    borderRadiusXS: o,
    borderRadiusSM: n,
    borderRadiusLG: t,
    borderRadiusOuter: r
  };
};
function T1(e) {
  const {
    motionUnit: t,
    motionBase: n,
    borderRadius: o,
    lineWidth: r
  } = e;
  return h({
    // motion
    motionDurationFast: `${(n + t).toFixed(1)}s`,
    motionDurationMid: `${(n + t * 2).toFixed(1)}s`,
    motionDurationSlow: `${(n + t * 3).toFixed(1)}s`,
    // line
    lineWidthBold: r + 1
  }, I1(o));
}
const uo = (e, t) => new Ct(e).setAlpha(t).toRgbString(), Aa = (e, t) => new Ct(e).darken(t).toHexString(), E1 = (e) => {
  const t = yr(e);
  return {
    1: t[0],
    2: t[1],
    3: t[2],
    4: t[3],
    5: t[4],
    6: t[5],
    7: t[6],
    8: t[4],
    9: t[5],
    10: t[6]
    // 8: colors[7],
    // 9: colors[8],
    // 10: colors[9],
  };
}, M1 = (e, t) => {
  const n = e || "#fff", o = t || "#000";
  return {
    colorBgBase: n,
    colorTextBase: o,
    colorText: uo(o, 0.88),
    colorTextSecondary: uo(o, 0.65),
    colorTextTertiary: uo(o, 0.45),
    colorTextQuaternary: uo(o, 0.25),
    colorFill: uo(o, 0.15),
    colorFillSecondary: uo(o, 0.06),
    colorFillTertiary: uo(o, 0.04),
    colorFillQuaternary: uo(o, 0.02),
    colorBgLayout: Aa(n, 4),
    colorBgContainer: Aa(n, 0),
    colorBgElevated: Aa(n, 0),
    colorBgSpotlight: uo(o, 0.85),
    colorBorder: Aa(n, 15),
    colorBorderSecondary: Aa(n, 6)
  };
};
function _1(e) {
  const t = new Array(10).fill(null).map((n, o) => {
    const r = o - 1, a = e * Math.pow(2.71828, r / 5), i = o > 1 ? Math.floor(a) : Math.ceil(a);
    return Math.floor(i / 2) * 2;
  });
  return t[1] = e, t.map((n) => {
    const o = n + 8;
    return {
      size: n,
      lineHeight: o / n
    };
  });
}
const D1 = (e) => {
  const t = _1(e), n = t.map((r) => r.size), o = t.map((r) => r.lineHeight);
  return {
    fontSizeSM: n[0],
    fontSize: n[1],
    fontSizeLG: n[2],
    fontSizeXL: n[3],
    fontSizeHeading1: n[6],
    fontSizeHeading2: n[5],
    fontSizeHeading3: n[4],
    fontSizeHeading4: n[3],
    fontSizeHeading5: n[2],
    lineHeight: o[1],
    lineHeightLG: o[2],
    lineHeightSM: o[0],
    lineHeightHeading1: o[6],
    lineHeightHeading2: o[5],
    lineHeightHeading3: o[4],
    lineHeightHeading4: o[3],
    lineHeightHeading5: o[2]
  };
};
function A1(e) {
  const t = Object.keys(ny).map((n) => {
    const o = yr(e[n]);
    return new Array(10).fill(1).reduce((r, a, i) => (r[`${n}-${i + 1}`] = o[i], r), {});
  }).reduce((n, o) => (n = h(h({}, n), o), n), {});
  return h(h(h(h(h(h(h({}, e), t), P1(e, {
    generateColorPalettes: E1,
    generateNeutralColorPalettes: M1
  })), D1(e.fontSize)), O1(e)), x1(e)), T1(e));
}
function su(e) {
  return e >= 0 && e <= 255;
}
function Bi(e, t) {
  const {
    r: n,
    g: o,
    b: r,
    a
  } = new Ct(e).toRgb();
  if (a < 1)
    return e;
  const {
    r: i,
    g: l,
    b: u
  } = new Ct(t).toRgb();
  for (let s = 0.01; s <= 1; s += 0.01) {
    const c = Math.round((n - i * (1 - s)) / s), d = Math.round((o - l * (1 - s)) / s), f = Math.round((r - u * (1 - s)) / s);
    if (su(c) && su(d) && su(f))
      return new Ct({
        r: c,
        g: d,
        b: f,
        a: Math.round(s * 100) / 100
      }).toRgbString();
  }
  return new Ct({
    r: n,
    g: o,
    b: r,
    a: 1
  }).toRgbString();
}
var N1 = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function R1(e) {
  const {
    override: t
  } = e, n = N1(e, ["override"]), o = h({}, t);
  Object.keys(us).forEach((p) => {
    delete o[p];
  });
  const r = h(h({}, n), o), a = 480, i = 576, l = 768, u = 992, s = 1200, c = 1600, d = 2e3;
  return h(h(h({}, r), {
    colorLink: r.colorInfoText,
    colorLinkHover: r.colorInfoHover,
    colorLinkActive: r.colorInfoActive,
    // ============== Background ============== //
    colorFillContent: r.colorFillSecondary,
    colorFillContentHover: r.colorFill,
    colorFillAlter: r.colorFillQuaternary,
    colorBgContainerDisabled: r.colorFillTertiary,
    // ============== Split ============== //
    colorBorderBg: r.colorBgContainer,
    colorSplit: Bi(r.colorBorderSecondary, r.colorBgContainer),
    // ============== Text ============== //
    colorTextPlaceholder: r.colorTextQuaternary,
    colorTextDisabled: r.colorTextQuaternary,
    colorTextHeading: r.colorText,
    colorTextLabel: r.colorTextSecondary,
    colorTextDescription: r.colorTextTertiary,
    colorTextLightSolid: r.colorWhite,
    colorHighlight: r.colorError,
    colorBgTextHover: r.colorFillSecondary,
    colorBgTextActive: r.colorFill,
    colorIcon: r.colorTextTertiary,
    colorIconHover: r.colorText,
    colorErrorOutline: Bi(r.colorErrorBg, r.colorBgContainer),
    colorWarningOutline: Bi(r.colorWarningBg, r.colorBgContainer),
    // Font
    fontSizeIcon: r.fontSizeSM,
    // Control
    lineWidth: r.lineWidth,
    controlOutlineWidth: r.lineWidth * 2,
    // Checkbox size and expand icon size
    controlInteractiveSize: r.controlHeight / 2,
    controlItemBgHover: r.colorFillTertiary,
    controlItemBgActive: r.colorPrimaryBg,
    controlItemBgActiveHover: r.colorPrimaryBgHover,
    controlItemBgActiveDisabled: r.colorFill,
    controlTmpOutline: r.colorFillQuaternary,
    controlOutline: Bi(r.colorPrimaryBg, r.colorBgContainer),
    lineType: r.lineType,
    borderRadius: r.borderRadius,
    borderRadiusXS: r.borderRadiusXS,
    borderRadiusSM: r.borderRadiusSM,
    borderRadiusLG: r.borderRadiusLG,
    fontWeightStrong: 600,
    opacityLoading: 0.65,
    linkDecoration: "none",
    linkHoverDecoration: "none",
    linkFocusDecoration: "none",
    controlPaddingHorizontal: 12,
    controlPaddingHorizontalSM: 8,
    paddingXXS: r.sizeXXS,
    paddingXS: r.sizeXS,
    paddingSM: r.sizeSM,
    padding: r.size,
    paddingMD: r.sizeMD,
    paddingLG: r.sizeLG,
    paddingXL: r.sizeXL,
    paddingContentHorizontalLG: r.sizeLG,
    paddingContentVerticalLG: r.sizeMS,
    paddingContentHorizontal: r.sizeMS,
    paddingContentVertical: r.sizeSM,
    paddingContentHorizontalSM: r.size,
    paddingContentVerticalSM: r.sizeXS,
    marginXXS: r.sizeXXS,
    marginXS: r.sizeXS,
    marginSM: r.sizeSM,
    margin: r.size,
    marginMD: r.sizeMD,
    marginLG: r.sizeLG,
    marginXL: r.sizeXL,
    marginXXL: r.sizeXXL,
    boxShadow: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
    boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
    screenXS: a,
    screenXSMin: a,
    screenXSMax: i - 1,
    screenSM: i,
    screenSMMin: i,
    screenSMMax: l - 1,
    screenMD: l,
    screenMDMin: l,
    screenMDMax: u - 1,
    screenLG: u,
    screenLGMin: u,
    screenLGMax: s - 1,
    screenXL: s,
    screenXLMin: s,
    screenXLMax: c - 1,
    screenXXL: c,
    screenXXLMin: c,
    screenXXLMax: d - 1,
    screenXXXL: d,
    screenXXXLMin: d,
    // FIXME: component box-shadow, should be removed
    boxShadowPopoverArrow: "3px 3px 7px rgba(0, 0, 0, 0.1)",
    boxShadowCard: `
      0 1px 2px -2px ${new Ct("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new Ct("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new Ct("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
    boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
  }), o);
}
const oy = (e, t, n, o, r) => {
  const a = e / 2, i = 0, l = a, u = n * 1 / Math.sqrt(2), s = a - n * (1 - 1 / Math.sqrt(2)), c = a - t * (1 / Math.sqrt(2)), d = n * (Math.sqrt(2) - 1) + t * (1 / Math.sqrt(2)), f = 2 * a - c, p = d, v = 2 * a - u, g = s, b = 2 * a - i, y = l, S = a * Math.sqrt(2) + n * (Math.sqrt(2) - 2), w = n * (Math.sqrt(2) - 1);
  return {
    pointerEvents: "none",
    width: e,
    height: e,
    overflow: "hidden",
    "&::after": {
      content: '""',
      position: "absolute",
      width: S,
      height: S,
      bottom: 0,
      insetInline: 0,
      margin: "auto",
      borderRadius: {
        _skip_check_: !0,
        value: `0 0 ${t}px 0`
      },
      transform: "translateY(50%) rotate(-135deg)",
      boxShadow: r,
      zIndex: 0,
      background: "transparent"
    },
    "&::before": {
      position: "absolute",
      bottom: 0,
      insetInlineStart: 0,
      width: e,
      height: e / 2,
      background: o,
      clipPath: {
        _multi_value_: !0,
        value: [`polygon(${w}px 100%, 50% ${w}px, ${2 * a - w}px 100%, ${w}px 100%)`, `path('M ${i} ${l} A ${n} ${n} 0 0 0 ${u} ${s} L ${c} ${d} A ${t} ${t} 0 0 1 ${f} ${p} L ${v} ${g} A ${n} ${n} 0 0 0 ${b} ${y} Z')`]
      },
      content: '""'
    }
  };
};
function ry(e, t) {
  return ci.reduce((n, o) => {
    const r = e[`${o}-1`], a = e[`${o}-3`], i = e[`${o}-6`], l = e[`${o}-7`];
    return h(h({}, n), t(o, {
      lightColor: r,
      lightBorderColor: a,
      darkColor: i,
      textColor: l
    }));
  }, {});
}
const So = {
  overflow: "hidden",
  whiteSpace: "nowrap",
  textOverflow: "ellipsis"
}, st = (e) => ({
  boxSizing: "border-box",
  margin: 0,
  padding: 0,
  color: e.colorText,
  fontSize: e.fontSize,
  // font-variant: @font-variant-base;
  lineHeight: e.lineHeight,
  listStyle: "none",
  // font-feature-settings: @font-feature-settings-base;
  fontFamily: e.fontFamily
}), Si = () => ({
  display: "inline-flex",
  alignItems: "center",
  color: "inherit",
  fontStyle: "normal",
  lineHeight: 0,
  textAlign: "center",
  textTransform: "none",
  // for SVG icon, see https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4
  verticalAlign: "-0.125em",
  textRendering: "optimizeLegibility",
  "-webkit-font-smoothing": "antialiased",
  "-moz-osx-font-smoothing": "grayscale",
  "> *": {
    lineHeight: 1
  },
  svg: {
    display: "inline-block"
  }
}), ca = () => ({
  // https://github.com/ant-design/ant-design/issues/21301#issuecomment-583955229
  "&::before": {
    display: "table",
    content: '""'
  },
  "&::after": {
    // https://github.com/ant-design/ant-design/issues/21864
    display: "table",
    clear: "both",
    content: '""'
  }
}), F1 = (e) => ({
  a: {
    color: e.colorLink,
    textDecoration: e.linkDecoration,
    backgroundColor: "transparent",
    outline: "none",
    cursor: "pointer",
    transition: `color ${e.motionDurationSlow}`,
    "-webkit-text-decoration-skip": "objects",
    "&:hover": {
      color: e.colorLinkHover
    },
    "&:active": {
      color: e.colorLinkActive
    },
    "&:active,\n  &:hover": {
      textDecoration: e.linkHoverDecoration,
      outline: 0
    },
    // https://github.com/ant-design/ant-design/issues/22503
    "&:focus": {
      textDecoration: e.linkFocusDecoration,
      outline: 0
    },
    "&[disabled]": {
      color: e.colorTextDisabled,
      cursor: "not-allowed"
    }
  }
}), B1 = (e, t) => {
  const {
    fontFamily: n,
    fontSize: o
  } = e, r = `[class^="${t}"], [class*=" ${t}"]`;
  return {
    [r]: {
      fontFamily: n,
      fontSize: o,
      boxSizing: "border-box",
      "&::before, &::after": {
        boxSizing: "border-box"
      },
      [r]: {
        boxSizing: "border-box",
        "&::before, &::after": {
          boxSizing: "border-box"
        }
      }
    }
  };
}, Sr = (e) => ({
  outline: `${e.lineWidthBold}px solid ${e.colorPrimaryBorder}`,
  outlineOffset: 1,
  transition: "outline-offset 0s, outline 0s"
}), $i = (e) => ({
  "&:focus-visible": h({}, Sr(e))
});
function ht(e, t, n) {
  return (o) => {
    const r = T(() => o == null ? void 0 : o.value), [a, i, l] = ya(), {
      getPrefixCls: u,
      iconPrefixCls: s
    } = rs(), c = T(() => u()), d = T(() => ({
      theme: a.value,
      token: i.value,
      hashId: l.value,
      path: ["Shared", c.value]
    }));
    gc(d, () => [{
      // Link
      "&": F1(i.value)
    }]);
    const f = T(() => ({
      theme: a.value,
      token: i.value,
      hashId: l.value,
      path: [e, r.value, s.value]
    }));
    return [gc(f, () => {
      const {
        token: p,
        flush: v
      } = L1(i.value), g = typeof n == "function" ? n(p) : n, b = h(h({}, g), i.value[e]), y = `.${r.value}`, S = qe(p, {
        componentCls: y,
        prefixCls: r.value,
        iconCls: `.${s.value}`,
        antCls: `.${c.value}`
      }, b), w = t(S, {
        hashId: l.value,
        prefixCls: r.value,
        rootPrefixCls: c.value,
        iconPrefixCls: s.value,
        overrideComponentToken: i.value[e]
      });
      return v(e, b), [B1(i.value, r.value), w];
    }), l];
  };
}
const ay = process.env.NODE_ENV !== "production" || typeof CSSINJS_STATISTIC < "u";
let Sc = !0;
function qe() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  if (!ay)
    return h({}, ...t);
  Sc = !1;
  const o = {};
  return t.forEach((r) => {
    Object.keys(r).forEach((i) => {
      Object.defineProperty(o, i, {
        configurable: !0,
        enumerable: !0,
        get: () => r[i]
      });
    });
  }), Sc = !0, o;
}
function k1() {
}
function L1(e) {
  let t, n = e, o = k1;
  return ay && (t = /* @__PURE__ */ new Set(), n = new Proxy(e, {
    get(r, a) {
      return Sc && t.add(a), r[a];
    }
  }), o = (r, a) => {
    Array.from(t);
  }), {
    token: n,
    keys: t,
    flush: o
  };
}
const H1 = zb(A1), iy = {
  token: us,
  hashed: !0
}, ly = Symbol("DesignTokenContext"), $c = K(), z1 = (e) => {
  ot(ly, e), le(e, () => {
    $c.value = Ye(e), ub($c);
  }, {
    immediate: !0,
    deep: !0
  });
}, j1 = J({
  props: {
    value: He()
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    return z1(T(() => e.value)), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
});
function ya() {
  const e = nt(ly, T(() => $c.value || iy)), t = T(() => `${i1}-${e.value.hashed || ""}`), n = T(() => e.value.theme || H1), o = Ax(n, T(() => [us, e.value.token]), T(() => ({
    salt: t.value,
    override: h({
      override: e.value.token
    }, e.value.components),
    formatToken: R1
  })));
  return [n, T(() => o.value[0]), T(() => e.value.hashed ? o.value[1] : "")];
}
const sy = J({
  compatConfig: {
    MODE: 3
  },
  setup() {
    const [, e] = ya(), t = T(() => new Ct(e.value.colorBgBase).toHsl().l < 0.5 ? {
      opacity: 0.65
    } : {});
    return () => m("svg", {
      style: t.value,
      width: "184",
      height: "152",
      viewBox: "0 0 184 152",
      xmlns: "http://www.w3.org/2000/svg"
    }, [m("g", {
      fill: "none",
      "fill-rule": "evenodd"
    }, [m("g", {
      transform: "translate(24 31.67)"
    }, [m("ellipse", {
      "fill-opacity": ".8",
      fill: "#F5F5F7",
      cx: "67.797",
      cy: "106.89",
      rx: "67.797",
      ry: "12.668"
    }, null), m("path", {
      d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
      fill: "#AEB8C2"
    }, null), m("path", {
      d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
      fill: "url(#linearGradient-1)",
      transform: "translate(13.56)"
    }, null), m("path", {
      d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
      fill: "#F5F5F7"
    }, null), m("path", {
      d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
      fill: "#DCE0E6"
    }, null)]), m("path", {
      d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
      fill: "#DCE0E6"
    }, null), m("g", {
      transform: "translate(149.65 15.383)",
      fill: "#FFF"
    }, [m("ellipse", {
      cx: "20.654",
      cy: "3.167",
      rx: "2.849",
      ry: "2.815"
    }, null), m("path", {
      d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
    }, null)])])]);
  }
});
sy.PRESENTED_IMAGE_DEFAULT = !0;
const uy = J({
  compatConfig: {
    MODE: 3
  },
  setup() {
    const [, e] = ya(), t = T(() => {
      const {
        colorFill: n,
        colorFillTertiary: o,
        colorFillQuaternary: r,
        colorBgContainer: a
      } = e.value;
      return {
        borderColor: new Ct(n).onBackground(a).toHexString(),
        shadowColor: new Ct(o).onBackground(a).toHexString(),
        contentColor: new Ct(r).onBackground(a).toHexString()
      };
    });
    return () => m("svg", {
      width: "64",
      height: "41",
      viewBox: "0 0 64 41",
      xmlns: "http://www.w3.org/2000/svg"
    }, [m("g", {
      transform: "translate(0 1)",
      fill: "none",
      "fill-rule": "evenodd"
    }, [m("ellipse", {
      fill: t.value.shadowColor,
      cx: "32",
      cy: "33",
      rx: "32",
      ry: "7"
    }, null), m("g", {
      "fill-rule": "nonzero",
      stroke: t.value.borderColor
    }, [m("path", {
      d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
    }, null), m("path", {
      d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
      fill: t.value.contentColor
    }, null)])])]);
  }
});
uy.PRESENTED_IMAGE_SIMPLE = !0;
const V1 = (e) => {
  const {
    componentCls: t,
    margin: n,
    marginXS: o,
    marginXL: r,
    fontSize: a,
    lineHeight: i
  } = e;
  return {
    [t]: {
      marginInline: o,
      fontSize: a,
      lineHeight: i,
      textAlign: "center",
      // 原来 &-image 没有父子结构，现在为了外层承担我们的hashId，改成父子结果
      [`${t}-image`]: {
        height: e.emptyImgHeight,
        marginBottom: o,
        opacity: e.opacityImage,
        img: {
          height: "100%"
        },
        svg: {
          height: "100%",
          margin: "auto"
        }
      },
      // 原来 &-footer 没有父子结构，现在为了外层承担我们的hashId，改成父子结果
      [`${t}-footer`]: {
        marginTop: n
      },
      "&-normal": {
        marginBlock: r,
        color: e.colorTextDisabled,
        [`${t}-image`]: {
          height: e.emptyImgHeightMD
        }
      },
      "&-small": {
        marginBlock: o,
        color: e.colorTextDisabled,
        [`${t}-image`]: {
          height: e.emptyImgHeightSM
        }
      }
    }
  };
}, W1 = ht("Empty", (e) => {
  const {
    componentCls: t,
    controlHeightLG: n
  } = e, o = qe(e, {
    emptyImgCls: `${t}-img`,
    emptyImgHeight: n * 2.5,
    emptyImgHeightMD: n,
    emptyImgHeightSM: n * 0.875
  });
  return [V1(o)];
});
var K1 = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const cy = m(sy, null, null), dy = m(uy, null, null), U1 = () => ({
  prefixCls: String,
  imageStyle: He(),
  image: Wt(),
  description: Wt()
}), Ed = J({
  name: "AEmpty",
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: !1,
  props: U1(),
  setup(e, t) {
    let {
      slots: n = {},
      attrs: o
    } = t;
    const {
      direction: r,
      prefixCls: a
    } = Ke("empty", e), [i, l] = W1(a);
    return () => {
      var u, s;
      const c = a.value, d = h(h({}, e), o), {
        image: f = ((u = n.image) === null || u === void 0 ? void 0 : u.call(n)) || cy,
        description: p = ((s = n.description) === null || s === void 0 ? void 0 : s.call(n)) || void 0,
        imageStyle: v,
        class: g = ""
      } = d, b = K1(d, ["image", "description", "imageStyle", "class"]);
      return i(m(Eb, {
        componentName: "Empty",
        children: (y) => {
          const S = typeof p < "u" ? p : y.description, w = typeof S == "string" ? S : "empty";
          let C = null;
          return typeof f == "string" ? C = m("img", {
            alt: w,
            src: f
          }, null) : C = f, m("div", L({
            class: ae(c, g, l.value, {
              [`${c}-normal`]: f === dy,
              [`${c}-rtl`]: r.value === "rtl"
            })
          }, b), [m("div", {
            class: `${c}-image`,
            style: v
          }, [C]), S && m("p", {
            class: `${c}-description`
          }, [S]), n.default && m("div", {
            class: `${c}-footer`
          }, [nn(n.default())])]);
        }
      }, null));
    };
  }
});
Ed.PRESENTED_IMAGE_DEFAULT = cy;
Ed.PRESENTED_IMAGE_SIMPLE = dy;
const Na = Xn(Ed), Md = (e) => {
  const {
    prefixCls: t
  } = Ke("empty", e);
  return ((o) => {
    switch (o) {
      case "Table":
      case "List":
        return m(Na, {
          image: Na.PRESENTED_IMAGE_SIMPLE
        }, null);
      case "Select":
      case "TreeSelect":
      case "Cascader":
      case "Transfer":
      case "Mentions":
        return m(Na, {
          image: Na.PRESENTED_IMAGE_SIMPLE,
          class: `${t.value}-small`
        }, null);
      default:
        return m(Na, null, null);
    }
  })(e.componentName);
};
function G1(e) {
  return m(Md, {
    componentName: e
  }, null);
}
const fy = Symbol("SizeContextKey"), py = () => nt(fy, G(void 0)), vy = (e) => {
  const t = py();
  return ot(fy, T(() => e.value || t.value)), e;
}, Ke = (e, t) => {
  const n = py(), o = Cn(), r = nt(Od, h(h({}, Ob), {
    renderEmpty: (x) => rc(Md, {
      componentName: x
    })
  })), a = T(() => r.getPrefixCls(e, t.prefixCls)), i = T(() => {
    var x, M;
    return (x = t.direction) !== null && x !== void 0 ? x : (M = r.direction) === null || M === void 0 ? void 0 : M.value;
  }), l = T(() => {
    var x;
    return (x = t.iconPrefixCls) !== null && x !== void 0 ? x : r.iconPrefixCls.value;
  }), u = T(() => r.getPrefixCls()), s = T(() => {
    var x;
    return (x = r.autoInsertSpaceInButton) === null || x === void 0 ? void 0 : x.value;
  }), c = r.renderEmpty, d = r.space, f = r.pageHeader, p = r.form, v = T(() => {
    var x, M;
    return (x = t.getTargetContainer) !== null && x !== void 0 ? x : (M = r.getTargetContainer) === null || M === void 0 ? void 0 : M.value;
  }), g = T(() => {
    var x, M, _;
    return (M = (x = t.getContainer) !== null && x !== void 0 ? x : t.getPopupContainer) !== null && M !== void 0 ? M : (_ = r.getPopupContainer) === null || _ === void 0 ? void 0 : _.value;
  }), b = T(() => {
    var x, M;
    return (x = t.dropdownMatchSelectWidth) !== null && x !== void 0 ? x : (M = r.dropdownMatchSelectWidth) === null || M === void 0 ? void 0 : M.value;
  }), y = T(() => {
    var x;
    return (t.virtual === void 0 ? ((x = r.virtual) === null || x === void 0 ? void 0 : x.value) !== !1 : t.virtual !== !1) && b.value !== !1;
  }), S = T(() => t.size || n.value), w = T(() => {
    var x, M, _;
    return (x = t.autocomplete) !== null && x !== void 0 ? x : (_ = (M = r.input) === null || M === void 0 ? void 0 : M.value) === null || _ === void 0 ? void 0 : _.autocomplete;
  }), C = T(() => {
    var x;
    return (x = t.disabled) !== null && x !== void 0 ? x : o.value;
  }), $ = T(() => {
    var x;
    return (x = t.csp) !== null && x !== void 0 ? x : r.csp;
  }), O = T(() => {
    var x, M;
    return (x = t.wave) !== null && x !== void 0 ? x : (M = r.wave) === null || M === void 0 ? void 0 : M.value;
  });
  return {
    configProvider: r,
    prefixCls: a,
    direction: i,
    size: S,
    getTargetContainer: v,
    getPopupContainer: g,
    space: d,
    pageHeader: f,
    form: p,
    autoInsertSpaceInButton: s,
    renderEmpty: c,
    virtual: y,
    dropdownMatchSelectWidth: b,
    rootPrefixCls: u,
    getPrefixCls: r.getPrefixCls,
    autocomplete: w,
    csp: $,
    iconPrefixCls: l,
    disabled: C,
    select: r.select,
    wave: O
  };
};
function pt(e, t) {
  const n = h({}, e);
  for (let o = 0; o < t.length; o += 1) {
    const r = t[o];
    delete n[r];
  }
  return n;
}
function fv(e) {
  return typeof e == "object" && e != null && e.nodeType === 1;
}
function pv(e, t) {
  return (!t || e !== "hidden") && e !== "visible" && e !== "clip";
}
function uu(e, t) {
  if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) {
    var n = getComputedStyle(e, null);
    return pv(n.overflowY, t) || pv(n.overflowX, t) || function(o) {
      var r = function(a) {
        if (!a.ownerDocument || !a.ownerDocument.defaultView)
          return null;
        try {
          return a.ownerDocument.defaultView.frameElement;
        } catch {
          return null;
        }
      }(o);
      return !!r && (r.clientHeight < o.scrollHeight || r.clientWidth < o.scrollWidth);
    }(e);
  }
  return !1;
}
function ki(e, t, n, o, r, a, i, l) {
  return a < e && i > t || a > e && i < t ? 0 : a <= e && l <= n || i >= t && l >= n ? a - e - o : i > t && l < n || a < e && l > n ? i - t + r : 0;
}
var vv = function(e, t) {
  var n = window, o = t.scrollMode, r = t.block, a = t.inline, i = t.boundary, l = t.skipOverflowHiddenElements, u = typeof i == "function" ? i : function(he) {
    return he !== i;
  };
  if (!fv(e))
    throw new TypeError("Invalid target");
  for (var s, c, d = document.scrollingElement || document.documentElement, f = [], p = e; fv(p) && u(p); ) {
    if ((p = (c = (s = p).parentElement) == null ? s.getRootNode().host || null : c) === d) {
      f.push(p);
      break;
    }
    p != null && p === document.body && uu(p) && !uu(document.documentElement) || p != null && uu(p, l) && f.push(p);
  }
  for (var v = n.visualViewport ? n.visualViewport.width : innerWidth, g = n.visualViewport ? n.visualViewport.height : innerHeight, b = window.scrollX || pageXOffset, y = window.scrollY || pageYOffset, S = e.getBoundingClientRect(), w = S.height, C = S.width, $ = S.top, O = S.right, x = S.bottom, M = S.left, _ = r === "start" || r === "nearest" ? $ : r === "end" ? x : $ + w / 2, N = a === "center" ? M + C / 2 : a === "end" ? O : M, I = [], E = 0; E < f.length; E++) {
    var B = f[E], k = B.getBoundingClientRect(), P = k.height, R = k.width, D = k.top, A = k.right, H = k.bottom, j = k.left;
    if (o === "if-needed" && $ >= 0 && M >= 0 && x <= g && O <= v && $ >= D && x <= H && M >= j && O <= A)
      return I;
    var z = getComputedStyle(B), F = parseInt(z.borderLeftWidth, 10), U = parseInt(z.borderTopWidth, 10), Q = parseInt(z.borderRightWidth, 10), q = parseInt(z.borderBottomWidth, 10), oe = 0, Z = 0, ne = "offsetWidth" in B ? B.offsetWidth - B.clientWidth - F - Q : 0, Y = "offsetHeight" in B ? B.offsetHeight - B.clientHeight - U - q : 0, V = "offsetWidth" in B ? B.offsetWidth === 0 ? 0 : R / B.offsetWidth : 0, X = "offsetHeight" in B ? B.offsetHeight === 0 ? 0 : P / B.offsetHeight : 0;
    if (d === B)
      oe = r === "start" ? _ : r === "end" ? _ - g : r === "nearest" ? ki(y, y + g, g, U, q, y + _, y + _ + w, w) : _ - g / 2, Z = a === "start" ? N : a === "center" ? N - v / 2 : a === "end" ? N - v : ki(b, b + v, v, F, Q, b + N, b + N + C, C), oe = Math.max(0, oe + y), Z = Math.max(0, Z + b);
    else {
      oe = r === "start" ? _ - D - U : r === "end" ? _ - H + q + Y : r === "nearest" ? ki(D, H, P, U, q + Y, _, _ + w, w) : _ - (D + P / 2) + Y / 2, Z = a === "start" ? N - j - F : a === "center" ? N - (j + R / 2) + ne / 2 : a === "end" ? N - A + Q + ne : ki(j, A, R, F, Q + ne, N, N + C, C);
      var re = B.scrollLeft, ie = B.scrollTop;
      _ += ie - (oe = Math.max(0, Math.min(ie + oe / X, B.scrollHeight - P / X + Y))), N += re - (Z = Math.max(0, Math.min(re + Z / V, B.scrollWidth - R / V + ne)));
    }
    I.push({ el: B, top: oe, left: Z });
  }
  return I;
};
function my(e) {
  return e === Object(e) && Object.keys(e).length !== 0;
}
function Y1(e, t) {
  t === void 0 && (t = "auto");
  var n = "scrollBehavior" in document.body.style;
  e.forEach(function(o) {
    var r = o.el, a = o.top, i = o.left;
    r.scroll && n ? r.scroll({
      top: a,
      left: i,
      behavior: t
    }) : (r.scrollTop = a, r.scrollLeft = i);
  });
}
function X1(e) {
  return e === !1 ? {
    block: "end",
    inline: "nearest"
  } : my(e) ? e : {
    block: "start",
    inline: "nearest"
  };
}
function q1(e, t) {
  var n = e.isConnected || e.ownerDocument.documentElement.contains(e);
  if (my(t) && typeof t.behavior == "function")
    return t.behavior(n ? vv(e, t) : []);
  if (n) {
    var o = X1(t);
    return Y1(vv(e, o), o.behavior);
  }
}
function Q1(e, t) {
  for (var n = 0; n < t.length; n++) {
    var o = t[n];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);
  }
}
function gy(e, t, n) {
  return n && Q1(e, n), e;
}
function sl() {
  return (sl = Object.assign || function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }).apply(this, arguments);
}
function hy(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
}
function by(e, t) {
  if (e == null)
    return {};
  var n, o, r = {}, a = Object.keys(e);
  for (o = 0; o < a.length; o++)
    t.indexOf(n = a[o]) >= 0 || (r[n] = e[n]);
  return r;
}
function mv(e) {
  return ((t = e) != null && typeof t == "object" && Array.isArray(t) === !1) == 1 && Object.prototype.toString.call(e) === "[object Object]";
  var t;
}
var yy = Object.prototype, Sy = yy.toString, Z1 = yy.hasOwnProperty, $y = /^\s*function (\w+)/;
function gv(e) {
  var t, n = (t = e == null ? void 0 : e.type) !== null && t !== void 0 ? t : e;
  if (n) {
    var o = n.toString().match($y);
    return o ? o[1] : "";
  }
  return "";
}
var $r = function(e) {
  var t, n;
  return mv(e) !== !1 && typeof (t = e.constructor) == "function" && mv(n = t.prototype) !== !1 && n.hasOwnProperty("isPrototypeOf") !== !1;
}, Cy = function(e) {
  return e;
}, Qt = Cy;
if (process.env.NODE_ENV !== "production") {
  var J1 = typeof console < "u";
  Qt = J1 ? function(e) {
    console.warn("[VueTypes warn]: " + e);
  } : Cy;
}
var di = function(e, t) {
  return Z1.call(e, t);
}, eO = Number.isInteger || function(e) {
  return typeof e == "number" && isFinite(e) && Math.floor(e) === e;
}, da = Array.isArray || function(e) {
  return Sy.call(e) === "[object Array]";
}, fa = function(e) {
  return Sy.call(e) === "[object Function]";
}, Dl = function(e) {
  return $r(e) && di(e, "_vueTypes_name");
}, wy = function(e) {
  return $r(e) && (di(e, "type") || ["_vueTypes_name", "validator", "default", "required"].some(function(t) {
    return di(e, t);
  }));
};
function _d(e, t) {
  return Object.defineProperty(e.bind(t), "__original", { value: e });
}
function Ir(e, t, n) {
  var o;
  n === void 0 && (n = !1);
  var r = !0, a = "";
  o = $r(e) ? e : { type: e };
  var i = Dl(o) ? o._vueTypes_name + " - " : "";
  if (wy(o) && o.type !== null) {
    if (o.type === void 0 || o.type === !0 || !o.required && t === void 0)
      return r;
    da(o.type) ? (r = o.type.some(function(d) {
      return Ir(d, t, !0) === !0;
    }), a = o.type.map(function(d) {
      return gv(d);
    }).join(" or ")) : r = (a = gv(o)) === "Array" ? da(t) : a === "Object" ? $r(t) : a === "String" || a === "Number" || a === "Boolean" || a === "Function" ? function(d) {
      if (d == null)
        return "";
      var f = d.constructor.toString().match($y);
      return f ? f[1] : "";
    }(t) === a : t instanceof o.type;
  }
  if (!r) {
    var l = i + 'value "' + t + '" should be of type "' + a + '"';
    return n === !1 ? (Qt(l), !1) : l;
  }
  if (di(o, "validator") && fa(o.validator)) {
    var u = Qt, s = [];
    if (Qt = function(d) {
      s.push(d);
    }, r = o.validator(t), Qt = u, !r) {
      var c = (s.length > 1 ? "* " : "") + s.join(`
* `);
      return s.length = 0, n === !1 ? (Qt(c), r) : c;
    }
  }
  return r;
}
function wn(e, t) {
  var n = Object.defineProperties(t, { _vueTypes_name: { value: e, writable: !0 }, isRequired: { get: function() {
    return this.required = !0, this;
  } }, def: { value: function(r) {
    return r !== void 0 || this.default ? fa(r) || Ir(this, r, !0) === !0 ? (this.default = da(r) ? function() {
      return [].concat(r);
    } : $r(r) ? function() {
      return Object.assign({}, r);
    } : r, this) : (Qt(this._vueTypes_name + ' - invalid default value: "' + r + '"'), this) : this;
  } } }), o = n.validator;
  return fa(o) && (n.validator = _d(o, n)), n;
}
function ao(e, t) {
  var n = wn(e, t);
  return Object.defineProperty(n, "validate", { value: function(o) {
    return fa(this.validator) && Qt(this._vueTypes_name + ` - calling .validate() will overwrite the current custom validator function. Validator info:
` + JSON.stringify(this)), this.validator = _d(o, this), this;
  } });
}
function hv(e, t, n) {
  var o, r, a = (o = t, r = {}, Object.getOwnPropertyNames(o).forEach(function(d) {
    r[d] = Object.getOwnPropertyDescriptor(o, d);
  }), Object.defineProperties({}, r));
  if (a._vueTypes_name = e, !$r(n))
    return a;
  var i, l, u = n.validator, s = by(n, ["validator"]);
  if (fa(u)) {
    var c = a.validator;
    c && (c = (l = (i = c).__original) !== null && l !== void 0 ? l : i), a.validator = _d(c ? function(d) {
      return c.call(this, d) && u.call(this, d);
    } : u, a);
  }
  return Object.assign(a, s);
}
function cs(e) {
  return e.replace(/^(?!\s*$)/gm, "  ");
}
var tO = function() {
  return ao("any", {});
}, nO = function() {
  return ao("function", { type: Function });
}, oO = function() {
  return ao("boolean", { type: Boolean });
}, rO = function() {
  return ao("string", { type: String });
}, aO = function() {
  return ao("number", { type: Number });
}, iO = function() {
  return ao("array", { type: Array });
}, lO = function() {
  return ao("object", { type: Object });
}, sO = function() {
  return wn("integer", { type: Number, validator: function(e) {
    return eO(e);
  } });
}, uO = function() {
  return wn("symbol", { validator: function(e) {
    return typeof e == "symbol";
  } });
};
function cO(e, t) {
  if (t === void 0 && (t = "custom validation failed"), typeof e != "function")
    throw new TypeError("[VueTypes error]: You must provide a function as argument");
  return wn(e.name || "<<anonymous function>>", { validator: function(n) {
    var o = e(n);
    return o || Qt(this._vueTypes_name + " - " + t), o;
  } });
}
function dO(e) {
  if (!da(e))
    throw new TypeError("[VueTypes error]: You must provide an array as argument.");
  var t = 'oneOf - value should be one of "' + e.join('", "') + '".', n = e.reduce(function(o, r) {
    if (r != null) {
      var a = r.constructor;
      o.indexOf(a) === -1 && o.push(a);
    }
    return o;
  }, []);
  return wn("oneOf", { type: n.length > 0 ? n : void 0, validator: function(o) {
    var r = e.indexOf(o) !== -1;
    return r || Qt(t), r;
  } });
}
function fO(e) {
  if (!da(e))
    throw new TypeError("[VueTypes error]: You must provide an array as argument");
  for (var t = !1, n = [], o = 0; o < e.length; o += 1) {
    var r = e[o];
    if (wy(r)) {
      if (Dl(r) && r._vueTypes_name === "oneOf") {
        n = n.concat(r.type);
        continue;
      }
      if (fa(r.validator) && (t = !0), r.type !== !0 && r.type) {
        n = n.concat(r.type);
        continue;
      }
    }
    n.push(r);
  }
  return n = n.filter(function(a, i) {
    return n.indexOf(a) === i;
  }), wn("oneOfType", t ? { type: n, validator: function(a) {
    var i = [], l = e.some(function(u) {
      var s = Ir(Dl(u) && u._vueTypes_name === "oneOf" ? u.type || null : u, a, !0);
      return typeof s == "string" && i.push(s), s === !0;
    });
    return l || Qt("oneOfType - provided value does not match any of the " + i.length + ` passed-in validators:
` + cs(i.join(`
`))), l;
  } } : { type: n });
}
function pO(e) {
  return wn("arrayOf", { type: Array, validator: function(t) {
    var n, o = t.every(function(r) {
      return (n = Ir(e, r, !0)) === !0;
    });
    return o || Qt(`arrayOf - value validation error:
` + cs(n)), o;
  } });
}
function vO(e) {
  return wn("instanceOf", { type: e });
}
function mO(e) {
  return wn("objectOf", { type: Object, validator: function(t) {
    var n, o = Object.keys(t).every(function(r) {
      return (n = Ir(e, t[r], !0)) === !0;
    });
    return o || Qt(`objectOf - value validation error:
` + cs(n)), o;
  } });
}
function gO(e) {
  var t = Object.keys(e), n = t.filter(function(r) {
    var a;
    return !!(!((a = e[r]) === null || a === void 0) && a.required);
  }), o = wn("shape", { type: Object, validator: function(r) {
    var a = this;
    if (!$r(r))
      return !1;
    var i = Object.keys(r);
    if (n.length > 0 && n.some(function(u) {
      return i.indexOf(u) === -1;
    })) {
      var l = n.filter(function(u) {
        return i.indexOf(u) === -1;
      });
      return Qt(l.length === 1 ? 'shape - required property "' + l[0] + '" is not defined.' : 'shape - required properties "' + l.join('", "') + '" are not defined.'), !1;
    }
    return i.every(function(u) {
      if (t.indexOf(u) === -1)
        return a._vueTypes_isLoose === !0 || (Qt('shape - shape definition does not include a "' + u + '" property. Allowed keys: "' + t.join('", "') + '".'), !1);
      var s = Ir(e[u], r[u], !0);
      return typeof s == "string" && Qt('shape - "' + u + `" property validation error:
 ` + cs(s)), s === !0;
    });
  } });
  return Object.defineProperty(o, "_vueTypes_isLoose", { writable: !0, value: !1 }), Object.defineProperty(o, "loose", { get: function() {
    return this._vueTypes_isLoose = !0, this;
  } }), o;
}
var Jn = function() {
  function e() {
  }
  return e.extend = function(t) {
    var n = this;
    if (da(t))
      return t.forEach(function(d) {
        return n.extend(d);
      }), this;
    var o = t.name, r = t.validate, a = r !== void 0 && r, i = t.getter, l = i !== void 0 && i, u = by(t, ["name", "validate", "getter"]);
    if (di(this, o))
      throw new TypeError('[VueTypes error]: Type "' + o + '" already defined');
    var s, c = u.type;
    return Dl(c) ? (delete u.type, Object.defineProperty(this, o, l ? { get: function() {
      return hv(o, c, u);
    } } : { value: function() {
      var d, f = hv(o, c, u);
      return f.validator && (f.validator = (d = f.validator).bind.apply(d, [f].concat([].slice.call(arguments)))), f;
    } })) : (s = l ? { get: function() {
      var d = Object.assign({}, u);
      return a ? ao(o, d) : wn(o, d);
    }, enumerable: !0 } : { value: function() {
      var d, f, p = Object.assign({}, u);
      return d = a ? ao(o, p) : wn(o, p), p.validator && (d.validator = (f = p.validator).bind.apply(f, [d].concat([].slice.call(arguments)))), d;
    }, enumerable: !0 }, Object.defineProperty(this, o, s));
  }, gy(e, null, [{ key: "any", get: function() {
    return tO();
  } }, { key: "func", get: function() {
    return nO().def(this.defaults.func);
  } }, { key: "bool", get: function() {
    return oO().def(this.defaults.bool);
  } }, { key: "string", get: function() {
    return rO().def(this.defaults.string);
  } }, { key: "number", get: function() {
    return aO().def(this.defaults.number);
  } }, { key: "array", get: function() {
    return iO().def(this.defaults.array);
  } }, { key: "object", get: function() {
    return lO().def(this.defaults.object);
  } }, { key: "integer", get: function() {
    return sO().def(this.defaults.integer);
  } }, { key: "symbol", get: function() {
    return uO();
  } }]), e;
}();
function xy(e) {
  var t;
  return e === void 0 && (e = { func: function() {
  }, bool: !0, string: "", number: 0, array: function() {
    return [];
  }, object: function() {
    return {};
  }, integer: 0 }), (t = function(n) {
    function o() {
      return n.apply(this, arguments) || this;
    }
    return hy(o, n), gy(o, null, [{ key: "sensibleDefaults", get: function() {
      return sl({}, this.defaults);
    }, set: function(r) {
      this.defaults = r !== !1 ? sl({}, r !== !0 ? r : e) : {};
    } }]), o;
  }(Jn)).defaults = sl({}, e), t;
}
Jn.defaults = {}, Jn.custom = cO, Jn.oneOf = dO, Jn.instanceOf = vO, Jn.oneOfType = fO, Jn.arrayOf = pO, Jn.objectOf = mO, Jn.shape = gO, Jn.utils = { validate: function(e, t) {
  return Ir(t, e, !0) === !0;
}, toType: function(e, t, n) {
  return n === void 0 && (n = !1), n ? ao(e, t) : wn(e, t);
} };
(function(e) {
  function t() {
    return e.apply(this, arguments) || this;
  }
  return hy(t, e), t;
})(xy());
const W = xy({
  func: void 0,
  bool: void 0,
  string: void 0,
  number: void 0,
  array: void 0,
  object: void 0,
  integer: void 0
});
W.extend([{
  name: "looseBool",
  getter: !0,
  type: Boolean,
  default: void 0
}, {
  name: "style",
  getter: !0,
  type: [String, Object],
  default: void 0
}, {
  name: "VueNode",
  getter: !0,
  type: null
}]);
function hO(e) {
  return e.default = void 0, e;
}
const gt = (e, t, n) => {
  yn(e, `[ant-design-vue: ${t}] ${n}`);
};
function bv(e, t) {
  const {
    key: n
  } = e;
  let o;
  return "value" in e && ({
    value: o
  } = e), n ?? (o !== void 0 ? o : `rc-index-key-${t}`);
}
function Oy(e, t) {
  const {
    label: n,
    value: o,
    options: r
  } = e || {};
  return {
    label: n || (t ? "children" : "label"),
    value: o || "value",
    options: r || "options"
  };
}
function bO(e) {
  let {
    fieldNames: t,
    childrenAsData: n
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const o = [], {
    label: r,
    value: a,
    options: i
  } = Oy(t, !1);
  function l(u, s) {
    u.forEach((c) => {
      const d = c[r];
      if (s || !(i in c)) {
        const f = c[a];
        o.push({
          key: bv(c, o.length),
          groupOption: s,
          data: c,
          label: d,
          value: f
        });
      } else {
        let f = d;
        f === void 0 && n && (f = c.label), o.push({
          key: bv(c, o.length),
          group: !0,
          data: c,
          label: f
        }), l(c[i], !0);
      }
    });
  }
  return l(e, !1), o;
}
function Cc(e) {
  const t = h({}, e);
  return "props" in t || Object.defineProperty(t, "props", {
    get() {
      return lt(!1, "Return type is option instead of Option instance. Please read value directly instead of reading from `props`."), t;
    }
  }), t;
}
function yO(e, t) {
  if (!t || !t.length)
    return null;
  let n = !1;
  function o(a, i) {
    let [l, ...u] = i;
    if (!l)
      return [a];
    const s = a.split(l);
    return n = n || s.length > 1, s.reduce((c, d) => [...c, ...o(d, u)], []).filter((c) => c);
  }
  const r = o(e, t);
  return n ? r : null;
}
function SO() {
  return "";
}
function $O(e) {
  return e ? e.ownerDocument : window.document;
}
function Py() {
}
const CO = () => ({
  action: W.oneOfType([W.string, W.arrayOf(W.string)]).def([]),
  showAction: W.any.def([]),
  hideAction: W.any.def([]),
  getPopupClassNameFromAlign: W.any.def(SO),
  onPopupVisibleChange: Function,
  afterPopupVisibleChange: W.func.def(Py),
  popup: W.any,
  arrow: W.bool.def(!0),
  popupStyle: {
    type: Object,
    default: void 0
  },
  prefixCls: W.string.def("rc-trigger-popup"),
  popupClassName: W.string.def(""),
  popupPlacement: String,
  builtinPlacements: W.object,
  popupTransitionName: String,
  popupAnimation: W.any,
  mouseEnterDelay: W.number.def(0),
  mouseLeaveDelay: W.number.def(0.1),
  zIndex: Number,
  focusDelay: W.number.def(0),
  blurDelay: W.number.def(0.15),
  getPopupContainer: Function,
  getDocument: W.func.def($O),
  forceRender: {
    type: Boolean,
    default: void 0
  },
  destroyPopupOnHide: {
    type: Boolean,
    default: !1
  },
  mask: {
    type: Boolean,
    default: !1
  },
  maskClosable: {
    type: Boolean,
    default: !0
  },
  // onPopupAlign: PropTypes.func.def(noop),
  popupAlign: W.object.def(() => ({})),
  popupVisible: {
    type: Boolean,
    default: void 0
  },
  defaultPopupVisible: {
    type: Boolean,
    default: !1
  },
  maskTransitionName: String,
  maskAnimation: String,
  stretch: String,
  alignPoint: {
    type: Boolean,
    default: void 0
  },
  autoDestroy: {
    type: Boolean,
    default: !1
  },
  mobile: Object,
  getTriggerDOMNode: Function
}), Dd = {
  visible: Boolean,
  prefixCls: String,
  zIndex: Number,
  destroyPopupOnHide: Boolean,
  forceRender: Boolean,
  arrow: {
    type: Boolean,
    default: !0
  },
  // Legacy Motion
  animation: [String, Object],
  transitionName: String,
  // Measure
  stretch: {
    type: String
  },
  // Align
  align: {
    type: Object
  },
  point: {
    type: Object
  },
  getRootDomNode: {
    type: Function
  },
  getClassNameFromAlign: {
    type: Function
  },
  onAlign: {
    type: Function
  },
  onMouseenter: {
    type: Function
  },
  onMouseleave: {
    type: Function
  },
  onMousedown: {
    type: Function
  },
  onTouchstart: {
    type: Function
  }
}, wO = h(h({}, Dd), {
  mobile: {
    type: Object
  }
}), xO = h(h({}, Dd), {
  mask: Boolean,
  mobile: {
    type: Object
  },
  maskAnimation: String,
  maskTransitionName: String
});
function Ad(e) {
  let {
    prefixCls: t,
    animation: n,
    transitionName: o
  } = e;
  return n ? {
    name: `${t}-${n}`
  } : o ? {
    name: o
  } : {};
}
function Iy(e) {
  const {
    prefixCls: t,
    visible: n,
    zIndex: o,
    mask: r,
    maskAnimation: a,
    maskTransitionName: i
  } = e;
  if (!r)
    return null;
  let l = {};
  return (i || a) && (l = Ad({
    prefixCls: t,
    transitionName: i,
    animation: a
  })), m(Yn, L({
    appear: !0
  }, l), {
    default: () => [An(m("div", {
      style: {
        zIndex: o
      },
      class: `${t}-mask`
    }, null), [[sw("if"), n]])]
  });
}
Iy.displayName = "Mask";
const OO = J({
  compatConfig: {
    MODE: 3
  },
  name: "MobilePopupInner",
  inheritAttrs: !1,
  props: wO,
  emits: ["mouseenter", "mouseleave", "mousedown", "touchstart", "align"],
  setup(e, t) {
    let {
      expose: n,
      slots: o
    } = t;
    const r = G();
    return n({
      forceAlign: () => {
      },
      getElement: () => r.value
    }), () => {
      var a;
      const {
        zIndex: i,
        visible: l,
        prefixCls: u,
        mobile: {
          popupClassName: s,
          popupStyle: c,
          popupMotion: d = {},
          popupRender: f
        } = {}
      } = e, p = h({
        zIndex: i
      }, c);
      let v = xt((a = o.default) === null || a === void 0 ? void 0 : a.call(o));
      v.length > 1 && (v = m("div", {
        class: `${u}-content`
      }, [v])), f && (v = f(v));
      const g = ae(u, s);
      return m(Yn, L({
        ref: r
      }, d), {
        default: () => [l ? m("div", {
          class: g,
          style: p
        }, [v]) : null]
      });
    };
  }
});
var PO = function(e, t, n, o) {
  function r(a) {
    return a instanceof n ? a : new n(function(i) {
      i(a);
    });
  }
  return new (n || (n = Promise))(function(a, i) {
    function l(c) {
      try {
        s(o.next(c));
      } catch (d) {
        i(d);
      }
    }
    function u(c) {
      try {
        s(o.throw(c));
      } catch (d) {
        i(d);
      }
    }
    function s(c) {
      c.done ? a(c.value) : r(c.value).then(l, u);
    }
    s((o = o.apply(e, t || [])).next());
  });
};
const yv = ["measure", "align", null, "motion"], IO = (e, t) => {
  const n = K(null), o = K(), r = K(!1);
  function a(u) {
    r.value || (n.value = u);
  }
  function i() {
    Ue.cancel(o.value);
  }
  function l(u) {
    i(), o.value = Ue(() => {
      let s = n.value;
      switch (n.value) {
        case "align":
          s = "motion";
          break;
        case "motion":
          s = "stable";
          break;
      }
      a(s), u == null || u();
    });
  }
  return le(e, () => {
    a("measure");
  }, {
    immediate: !0,
    flush: "post"
  }), ze(() => {
    le(n, () => {
      switch (n.value) {
        case "measure":
          t();
          break;
      }
      n.value && (o.value = Ue(() => PO(void 0, void 0, void 0, function* () {
        const u = yv.indexOf(n.value), s = yv[u + 1];
        s && u !== -1 && a(s);
      })));
    }, {
      immediate: !0,
      flush: "post"
    });
  }), at(() => {
    r.value = !0, i();
  }), [n, l];
}, TO = (e) => {
  const t = K({
    width: 0,
    height: 0
  });
  function n(r) {
    t.value = {
      width: r.offsetWidth,
      height: r.offsetHeight
    };
  }
  return [T(() => {
    const r = {};
    if (e.value) {
      const {
        width: a,
        height: i
      } = t.value;
      e.value.indexOf("height") !== -1 && i ? r.height = `${i}px` : e.value.indexOf("minHeight") !== -1 && i && (r.minHeight = `${i}px`), e.value.indexOf("width") !== -1 && a ? r.width = `${a}px` : e.value.indexOf("minWidth") !== -1 && a && (r.minWidth = `${a}px`);
    }
    return r;
  }), n];
};
function Sv(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    t && (o = o.filter(function(r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function $v(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Sv(Object(n), !0).forEach(function(o) {
      EO(e, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Sv(Object(n)).forEach(function(o) {
      Object.defineProperty(e, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return e;
}
function wc(e) {
  "@babel/helpers - typeof";
  return wc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, wc(e);
}
function EO(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var Ra, MO = {
  Webkit: "-webkit-",
  Moz: "-moz-",
  // IE did it wrong again ...
  ms: "-ms-",
  O: "-o-"
};
function Al() {
  if (Ra !== void 0)
    return Ra;
  Ra = "";
  var e = document.createElement("p").style, t = "Transform";
  for (var n in MO)
    n + t in e && (Ra = n);
  return Ra;
}
function Ty() {
  return Al() ? "".concat(Al(), "TransitionProperty") : "transitionProperty";
}
function ds() {
  return Al() ? "".concat(Al(), "Transform") : "transform";
}
function Cv(e, t) {
  var n = Ty();
  n && (e.style[n] = t, n !== "transitionProperty" && (e.style.transitionProperty = t));
}
function cu(e, t) {
  var n = ds();
  n && (e.style[n] = t, n !== "transform" && (e.style.transform = t));
}
function _O(e) {
  return e.style.transitionProperty || e.style[Ty()];
}
function DO(e) {
  var t = window.getComputedStyle(e, null), n = t.getPropertyValue("transform") || t.getPropertyValue(ds());
  if (n && n !== "none") {
    var o = n.replace(/[^0-9\-.,]/g, "").split(",");
    return {
      x: parseFloat(o[12] || o[4], 0),
      y: parseFloat(o[13] || o[5], 0)
    };
  }
  return {
    x: 0,
    y: 0
  };
}
var AO = /matrix\((.*)\)/, NO = /matrix3d\((.*)\)/;
function RO(e, t) {
  var n = window.getComputedStyle(e, null), o = n.getPropertyValue("transform") || n.getPropertyValue(ds());
  if (o && o !== "none") {
    var r, a = o.match(AO);
    if (a)
      a = a[1], r = a.split(",").map(function(l) {
        return parseFloat(l, 10);
      }), r[4] = t.x, r[5] = t.y, cu(e, "matrix(".concat(r.join(","), ")"));
    else {
      var i = o.match(NO)[1];
      r = i.split(",").map(function(l) {
        return parseFloat(l, 10);
      }), r[12] = t.x, r[13] = t.y, cu(e, "matrix3d(".concat(r.join(","), ")"));
    }
  } else
    cu(e, "translateX(".concat(t.x, "px) translateY(").concat(t.y, "px) translateZ(0)"));
}
var FO = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source, Ci;
function wv(e) {
  var t = e.style.display;
  e.style.display = "none", e.offsetHeight, e.style.display = t;
}
function Zr(e, t, n) {
  var o = n;
  if (wc(t) === "object") {
    for (var r in t)
      t.hasOwnProperty(r) && Zr(e, r, t[r]);
    return;
  }
  if (typeof o < "u") {
    typeof o == "number" && (o = "".concat(o, "px")), e.style[t] = o;
    return;
  }
  return Ci(e, t);
}
function BO(e) {
  var t, n, o, r = e.ownerDocument, a = r.body, i = r && r.documentElement;
  return t = e.getBoundingClientRect(), n = Math.floor(t.left), o = Math.floor(t.top), n -= i.clientLeft || a.clientLeft || 0, o -= i.clientTop || a.clientTop || 0, {
    left: n,
    top: o
  };
}
function Ey(e, t) {
  var n = e["page".concat(t ? "Y" : "X", "Offset")], o = "scroll".concat(t ? "Top" : "Left");
  if (typeof n != "number") {
    var r = e.document;
    n = r.documentElement[o], typeof n != "number" && (n = r.body[o]);
  }
  return n;
}
function My(e) {
  return Ey(e);
}
function _y(e) {
  return Ey(e, !0);
}
function fi(e) {
  var t = BO(e), n = e.ownerDocument, o = n.defaultView || n.parentWindow;
  return t.left += My(o), t.top += _y(o), t;
}
function Nd(e) {
  return e != null && e == e.window;
}
function Dy(e) {
  return Nd(e) ? e.document : e.nodeType === 9 ? e : e.ownerDocument;
}
function kO(e, t, n) {
  var o = n, r = "", a = Dy(e);
  return o = o || a.defaultView.getComputedStyle(e, null), o && (r = o.getPropertyValue(t) || o[t]), r;
}
var LO = new RegExp("^(".concat(FO, ")(?!px)[a-z%]+$"), "i"), HO = /^(top|right|bottom|left)$/, du = "currentStyle", fu = "runtimeStyle", nr = "left", zO = "px";
function jO(e, t) {
  var n = e[du] && e[du][t];
  if (LO.test(n) && !HO.test(t)) {
    var o = e.style, r = o[nr], a = e[fu][nr];
    e[fu][nr] = e[du][nr], o[nr] = t === "fontSize" ? "1em" : n || 0, n = o.pixelLeft + zO, o[nr] = r, e[fu][nr] = a;
  }
  return n === "" ? "auto" : n;
}
typeof window < "u" && (Ci = window.getComputedStyle ? kO : jO);
function Li(e, t) {
  return e === "left" ? t.useCssRight ? "right" : e : t.useCssBottom ? "bottom" : e;
}
function xv(e) {
  if (e === "left")
    return "right";
  if (e === "right")
    return "left";
  if (e === "top")
    return "bottom";
  if (e === "bottom")
    return "top";
}
function Ov(e, t, n) {
  Zr(e, "position") === "static" && (e.style.position = "relative");
  var o = -999, r = -999, a = Li("left", n), i = Li("top", n), l = xv(a), u = xv(i);
  a !== "left" && (o = 999), i !== "top" && (r = 999);
  var s = "", c = fi(e);
  ("left" in t || "top" in t) && (s = _O(e) || "", Cv(e, "none")), "left" in t && (e.style[l] = "", e.style[a] = "".concat(o, "px")), "top" in t && (e.style[u] = "", e.style[i] = "".concat(r, "px")), wv(e);
  var d = fi(e), f = {};
  for (var p in t)
    if (t.hasOwnProperty(p)) {
      var v = Li(p, n), g = p === "left" ? o : r, b = c[p] - d[p];
      v === p ? f[v] = g + b : f[v] = g - b;
    }
  Zr(e, f), wv(e), ("left" in t || "top" in t) && Cv(e, s);
  var y = {};
  for (var S in t)
    if (t.hasOwnProperty(S)) {
      var w = Li(S, n), C = t[S] - c[S];
      S === w ? y[w] = f[w] + C : y[w] = f[w] - C;
    }
  Zr(e, y);
}
function VO(e, t) {
  var n = fi(e), o = DO(e), r = {
    x: o.x,
    y: o.y
  };
  "left" in t && (r.x = o.x + t.left - n.left), "top" in t && (r.y = o.y + t.top - n.top), RO(e, r);
}
function WO(e, t, n) {
  if (n.ignoreShake) {
    var o = fi(e), r = o.left.toFixed(0), a = o.top.toFixed(0), i = t.left.toFixed(0), l = t.top.toFixed(0);
    if (r === i && a === l)
      return;
  }
  n.useCssRight || n.useCssBottom ? Ov(e, t, n) : n.useCssTransform && ds() in document.body.style ? VO(e, t) : Ov(e, t, n);
}
function Rd(e, t) {
  for (var n = 0; n < e.length; n++)
    t(e[n]);
}
function Ay(e) {
  return Ci(e, "boxSizing") === "border-box";
}
var KO = ["margin", "border", "padding"], xc = -1, UO = 2, Oc = 1, GO = 0;
function YO(e, t, n) {
  var o = {}, r = e.style, a;
  for (a in t)
    t.hasOwnProperty(a) && (o[a] = r[a], r[a] = t[a]);
  n.call(e);
  for (a in t)
    t.hasOwnProperty(a) && (r[a] = o[a]);
}
function Ha(e, t, n) {
  var o = 0, r, a, i;
  for (a = 0; a < t.length; a++)
    if (r = t[a], r)
      for (i = 0; i < n.length; i++) {
        var l = void 0;
        r === "border" ? l = "".concat(r).concat(n[i], "Width") : l = r + n[i], o += parseFloat(Ci(e, l)) || 0;
      }
  return o;
}
var no = {
  getParent: function(t) {
    var n = t;
    do
      n.nodeType === 11 && n.host ? n = n.host : n = n.parentNode;
    while (n && n.nodeType !== 1 && n.nodeType !== 9);
    return n;
  }
};
Rd(["Width", "Height"], function(e) {
  no["doc".concat(e)] = function(t) {
    var n = t.document;
    return Math.max(
      // firefox chrome documentElement.scrollHeight< body.scrollHeight
      // ie standard mode : documentElement.scrollHeight> body.scrollHeight
      n.documentElement["scroll".concat(e)],
      // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
      n.body["scroll".concat(e)],
      no["viewport".concat(e)](n)
    );
  }, no["viewport".concat(e)] = function(t) {
    var n = "client".concat(e), o = t.document, r = o.body, a = o.documentElement, i = a[n];
    return o.compatMode === "CSS1Compat" && i || r && r[n] || i;
  };
});
function Pv(e, t, n) {
  var o = n;
  if (Nd(e))
    return t === "width" ? no.viewportWidth(e) : no.viewportHeight(e);
  if (e.nodeType === 9)
    return t === "width" ? no.docWidth(e) : no.docHeight(e);
  var r = t === "width" ? ["Left", "Right"] : ["Top", "Bottom"], a = Math.floor(t === "width" ? e.getBoundingClientRect().width : e.getBoundingClientRect().height), i = Ay(e), l = 0;
  (a == null || a <= 0) && (a = void 0, l = Ci(e, t), (l == null || Number(l) < 0) && (l = e.style[t] || 0), l = Math.floor(parseFloat(l)) || 0), o === void 0 && (o = i ? Oc : xc);
  var u = a !== void 0 || i, s = a || l;
  return o === xc ? u ? s - Ha(e, ["border", "padding"], r) : l : u ? o === Oc ? s : s + (o === UO ? -Ha(e, ["border"], r) : Ha(e, ["margin"], r)) : l + Ha(e, KO.slice(o), r);
}
var XO = {
  position: "absolute",
  visibility: "hidden",
  display: "block"
};
function Iv() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  var o, r = t[0];
  return r.offsetWidth !== 0 ? o = Pv.apply(void 0, t) : YO(r, XO, function() {
    o = Pv.apply(void 0, t);
  }), o;
}
Rd(["width", "height"], function(e) {
  var t = e.charAt(0).toUpperCase() + e.slice(1);
  no["outer".concat(t)] = function(o, r) {
    return o && Iv(o, e, r ? GO : Oc);
  };
  var n = e === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
  no[e] = function(o, r) {
    var a = r;
    if (a !== void 0) {
      if (o) {
        var i = Ay(o);
        return i && (a += Ha(o, ["padding", "border"], n)), Zr(o, e, a);
      }
      return;
    }
    return o && Iv(o, e, xc);
  };
});
function Ny(e, t) {
  for (var n in t)
    t.hasOwnProperty(n) && (e[n] = t[n]);
  return e;
}
var Qe = {
  getWindow: function(t) {
    if (t && t.document && t.setTimeout)
      return t;
    var n = t.ownerDocument || t;
    return n.defaultView || n.parentWindow;
  },
  getDocument: Dy,
  offset: function(t, n, o) {
    if (typeof n < "u")
      WO(t, n, o || {});
    else
      return fi(t);
  },
  isWindow: Nd,
  each: Rd,
  css: Zr,
  clone: function(t) {
    var n, o = {};
    for (n in t)
      t.hasOwnProperty(n) && (o[n] = t[n]);
    var r = t.overflow;
    if (r)
      for (n in t)
        t.hasOwnProperty(n) && (o.overflow[n] = t.overflow[n]);
    return o;
  },
  mix: Ny,
  getWindowScrollLeft: function(t) {
    return My(t);
  },
  getWindowScrollTop: function(t) {
    return _y(t);
  },
  merge: function() {
    for (var t = {}, n = 0; n < arguments.length; n++)
      Qe.mix(t, n < 0 || arguments.length <= n ? void 0 : arguments[n]);
    return t;
  },
  viewportWidth: 0,
  viewportHeight: 0
};
Ny(Qe, no);
var pu = Qe.getParent;
function Pc(e) {
  if (Qe.isWindow(e) || e.nodeType === 9)
    return null;
  var t = Qe.getDocument(e), n = t.body, o, r = Qe.css(e, "position"), a = r === "fixed" || r === "absolute";
  if (!a)
    return e.nodeName.toLowerCase() === "html" ? null : pu(e);
  for (o = pu(e); o && o !== n && o.nodeType !== 9; o = pu(o))
    if (r = Qe.css(o, "position"), r !== "static")
      return o;
  return null;
}
var Tv = Qe.getParent;
function qO(e) {
  if (Qe.isWindow(e) || e.nodeType === 9)
    return !1;
  var t = Qe.getDocument(e), n = t.body, o = null;
  for (
    o = Tv(e);
    // 修复元素位于 document.documentElement 下导致崩溃问题
    o && o !== n && o !== t;
    o = Tv(o)
  ) {
    var r = Qe.css(o, "position");
    if (r === "fixed")
      return !0;
  }
  return !1;
}
function Fd(e, t) {
  for (var n = {
    left: 0,
    right: 1 / 0,
    top: 0,
    bottom: 1 / 0
  }, o = Pc(e), r = Qe.getDocument(e), a = r.defaultView || r.parentWindow, i = r.body, l = r.documentElement; o; ) {
    if ((navigator.userAgent.indexOf("MSIE") === -1 || o.clientWidth !== 0) && // body may have overflow set on it, yet we still get the entire
    // viewport. In some browsers, el.offsetParent may be
    // document.documentElement, so check for that too.
    o !== i && o !== l && Qe.css(o, "overflow") !== "visible") {
      var u = Qe.offset(o);
      u.left += o.clientLeft, u.top += o.clientTop, n.top = Math.max(n.top, u.top), n.right = Math.min(
        n.right,
        // consider area without scrollBar
        u.left + o.clientWidth
      ), n.bottom = Math.min(n.bottom, u.top + o.clientHeight), n.left = Math.max(n.left, u.left);
    } else if (o === i || o === l)
      break;
    o = Pc(o);
  }
  var s = null;
  if (!Qe.isWindow(e) && e.nodeType !== 9) {
    s = e.style.position;
    var c = Qe.css(e, "position");
    c === "absolute" && (e.style.position = "fixed");
  }
  var d = Qe.getWindowScrollLeft(a), f = Qe.getWindowScrollTop(a), p = Qe.viewportWidth(a), v = Qe.viewportHeight(a), g = l.scrollWidth, b = l.scrollHeight, y = window.getComputedStyle(i);
  if (y.overflowX === "hidden" && (g = a.innerWidth), y.overflowY === "hidden" && (b = a.innerHeight), e.style && (e.style.position = s), t || qO(e))
    n.left = Math.max(n.left, d), n.top = Math.max(n.top, f), n.right = Math.min(n.right, d + p), n.bottom = Math.min(n.bottom, f + v);
  else {
    var S = Math.max(g, d + p);
    n.right = Math.min(n.right, S);
    var w = Math.max(b, f + v);
    n.bottom = Math.min(n.bottom, w);
  }
  return n.top >= 0 && n.left >= 0 && n.bottom > n.top && n.right > n.left ? n : null;
}
function QO(e, t, n, o) {
  var r = Qe.clone(e), a = {
    width: t.width,
    height: t.height
  };
  return o.adjustX && r.left < n.left && (r.left = n.left), o.resizeWidth && r.left >= n.left && r.left + a.width > n.right && (a.width -= r.left + a.width - n.right), o.adjustX && r.left + a.width > n.right && (r.left = Math.max(n.right - a.width, n.left)), o.adjustY && r.top < n.top && (r.top = n.top), o.resizeHeight && r.top >= n.top && r.top + a.height > n.bottom && (a.height -= r.top + a.height - n.bottom), o.adjustY && r.top + a.height > n.bottom && (r.top = Math.max(n.bottom - a.height, n.top)), Qe.mix(r, a);
}
function Bd(e) {
  var t, n, o;
  if (!Qe.isWindow(e) && e.nodeType !== 9)
    t = Qe.offset(e), n = Qe.outerWidth(e), o = Qe.outerHeight(e);
  else {
    var r = Qe.getWindow(e);
    t = {
      left: Qe.getWindowScrollLeft(r),
      top: Qe.getWindowScrollTop(r)
    }, n = Qe.viewportWidth(r), o = Qe.viewportHeight(r);
  }
  return t.width = n, t.height = o, t;
}
function Ev(e, t) {
  var n = t.charAt(0), o = t.charAt(1), r = e.width, a = e.height, i = e.left, l = e.top;
  return n === "c" ? l += a / 2 : n === "b" && (l += a), o === "c" ? i += r / 2 : o === "r" && (i += r), {
    left: i,
    top: l
  };
}
function Hi(e, t, n, o, r) {
  var a = Ev(t, n[1]), i = Ev(e, n[0]), l = [i.left - a.left, i.top - a.top];
  return {
    left: Math.round(e.left - l[0] + o[0] - r[0]),
    top: Math.round(e.top - l[1] + o[1] - r[1])
  };
}
function Mv(e, t, n) {
  return e.left < n.left || e.left + t.width > n.right;
}
function _v(e, t, n) {
  return e.top < n.top || e.top + t.height > n.bottom;
}
function ZO(e, t, n) {
  return e.left > n.right || e.left + t.width < n.left;
}
function JO(e, t, n) {
  return e.top > n.bottom || e.top + t.height < n.top;
}
function zi(e, t, n) {
  var o = [];
  return Qe.each(e, function(r) {
    o.push(r.replace(t, function(a) {
      return n[a];
    }));
  }), o;
}
function ji(e, t) {
  return e[t] = -e[t], e;
}
function Dv(e, t) {
  var n;
  return /%$/.test(e) ? n = parseInt(e.substring(0, e.length - 1), 10) / 100 * t : n = parseInt(e, 10), n || 0;
}
function Av(e, t) {
  e[0] = Dv(e[0], t.width), e[1] = Dv(e[1], t.height);
}
function Ry(e, t, n, o) {
  var r = n.points, a = n.offset || [0, 0], i = n.targetOffset || [0, 0], l = n.overflow, u = n.source || e;
  a = [].concat(a), i = [].concat(i), l = l || {};
  var s = {}, c = 0, d = !!(l && l.alwaysByViewport), f = Fd(u, d), p = Bd(u);
  Av(a, p), Av(i, t);
  var v = Hi(p, t, r, a, i), g = Qe.merge(p, v);
  if (f && (l.adjustX || l.adjustY) && o) {
    if (l.adjustX && Mv(v, p, f)) {
      var b = zi(r, /[lr]/gi, {
        l: "r",
        r: "l"
      }), y = ji(a, 0), S = ji(i, 0), w = Hi(p, t, b, y, S);
      ZO(w, p, f) || (c = 1, r = b, a = y, i = S);
    }
    if (l.adjustY && _v(v, p, f)) {
      var C = zi(r, /[tb]/gi, {
        t: "b",
        b: "t"
      }), $ = ji(a, 1), O = ji(i, 1), x = Hi(p, t, C, $, O);
      JO(x, p, f) || (c = 1, r = C, a = $, i = O);
    }
    c && (v = Hi(p, t, r, a, i), Qe.mix(g, v));
    var M = Mv(v, p, f), _ = _v(v, p, f);
    if (M || _) {
      var N = r;
      M && (N = zi(r, /[lr]/gi, {
        l: "r",
        r: "l"
      })), _ && (N = zi(r, /[tb]/gi, {
        t: "b",
        b: "t"
      })), r = N, a = n.offset || [0, 0], i = n.targetOffset || [0, 0];
    }
    s.adjustX = l.adjustX && M, s.adjustY = l.adjustY && _, (s.adjustX || s.adjustY) && (g = QO(v, p, f, s));
  }
  return g.width !== p.width && Qe.css(u, "width", Qe.width(u) + g.width - p.width), g.height !== p.height && Qe.css(u, "height", Qe.height(u) + g.height - p.height), Qe.offset(u, {
    left: g.left,
    top: g.top
  }, {
    useCssRight: n.useCssRight,
    useCssBottom: n.useCssBottom,
    useCssTransform: n.useCssTransform,
    ignoreShake: n.ignoreShake
  }), {
    points: r,
    offset: a,
    targetOffset: i,
    overflow: s
  };
}
function eP(e, t) {
  var n = Fd(e, t), o = Bd(e);
  return !n || o.left + o.width <= n.left || o.top + o.height <= n.top || o.left >= n.right || o.top >= n.bottom;
}
function kd(e, t, n) {
  var o = n.target || t, r = Bd(o), a = !eP(o, n.overflow && n.overflow.alwaysByViewport);
  return Ry(e, r, n, a);
}
kd.__getOffsetParent = Pc;
kd.__getVisibleRectForElement = Fd;
function tP(e, t, n) {
  var o, r, a = Qe.getDocument(e), i = a.defaultView || a.parentWindow, l = Qe.getWindowScrollLeft(i), u = Qe.getWindowScrollTop(i), s = Qe.viewportWidth(i), c = Qe.viewportHeight(i);
  "pageX" in t ? o = t.pageX : o = l + t.clientX, "pageY" in t ? r = t.pageY : r = u + t.clientY;
  var d = {
    left: o,
    top: r,
    width: 0,
    height: 0
  }, f = o >= 0 && o <= l + s && r >= 0 && r <= u + c, p = [n.points[0], "cc"];
  return Ry(e, d, $v($v({}, n), {}, {
    points: p
  }), f);
}
function Tt(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, r = e;
  if (Array.isArray(e) && (r = nn(e)[0]), !r)
    return null;
  const a = Ko(r, t, o);
  return a.props = n ? h(h({}, a.props), t) : a.props, Pt(typeof a.props.class != "object", "class must be string"), a;
}
function nP(e, t, n) {
  hr(Ko(e, h({}, t)), n);
}
const Ld = (e) => {
  if (!e)
    return !1;
  if (e.offsetParent)
    return !0;
  if (e.getBBox) {
    const t = e.getBBox();
    if (t.width || t.height)
      return !0;
  }
  if (e.getBoundingClientRect) {
    const t = e.getBoundingClientRect();
    if (t.width || t.height)
      return !0;
  }
  return !1;
};
function oP(e, t) {
  return e === t ? !0 : !e || !t ? !1 : "pageX" in t && "pageY" in t ? e.pageX === t.pageX && e.pageY === t.pageY : "clientX" in t && "clientY" in t ? e.clientX === t.clientX && e.clientY === t.clientY : !1;
}
function rP(e, t) {
  e !== document.activeElement && ko(t, e) && typeof e.focus == "function" && e.focus();
}
function Nv(e, t) {
  let n = null, o = null;
  function r(i) {
    let [{
      target: l
    }] = i;
    if (!document.documentElement.contains(l))
      return;
    const {
      width: u,
      height: s
    } = l.getBoundingClientRect(), c = Math.floor(u), d = Math.floor(s);
    (n !== c || o !== d) && Promise.resolve().then(() => {
      t({
        width: c,
        height: d
      });
    }), n = c, o = d;
  }
  const a = new gb(r);
  return e && a.observe(e), () => {
    a.disconnect();
  };
}
const aP = (e, t) => {
  let n = !1, o = null;
  function r() {
    clearTimeout(o);
  }
  function a(i) {
    if (!n || i === !0) {
      if (e() === !1)
        return;
      n = !0, r(), o = setTimeout(() => {
        n = !1;
      }, t.value);
    } else
      r(), o = setTimeout(() => {
        n = !1, a();
      }, t.value);
  }
  return [a, () => {
    n = !1, r();
  }];
};
function iP() {
  this.__data__ = [], this.size = 0;
}
function Hd(e, t) {
  return e === t || e !== e && t !== t;
}
function fs(e, t) {
  for (var n = e.length; n--; )
    if (Hd(e[n][0], t))
      return n;
  return -1;
}
var lP = Array.prototype, sP = lP.splice;
function uP(e) {
  var t = this.__data__, n = fs(t, e);
  if (n < 0)
    return !1;
  var o = t.length - 1;
  return n == o ? t.pop() : sP.call(t, n, 1), --this.size, !0;
}
function cP(e) {
  var t = this.__data__, n = fs(t, e);
  return n < 0 ? void 0 : t[n][1];
}
function dP(e) {
  return fs(this.__data__, e) > -1;
}
function fP(e, t) {
  var n = this.__data__, o = fs(n, e);
  return o < 0 ? (++this.size, n.push([e, t])) : n[o][1] = t, this;
}
function xo(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var o = e[t];
    this.set(o[0], o[1]);
  }
}
xo.prototype.clear = iP;
xo.prototype.delete = uP;
xo.prototype.get = cP;
xo.prototype.has = dP;
xo.prototype.set = fP;
function pP() {
  this.__data__ = new xo(), this.size = 0;
}
function vP(e) {
  var t = this.__data__, n = t.delete(e);
  return this.size = t.size, n;
}
function mP(e) {
  return this.__data__.get(e);
}
function gP(e) {
  return this.__data__.has(e);
}
var Fy = typeof global == "object" && global && global.Object === Object && global, hP = typeof self == "object" && self && self.Object === Object && self, qn = Fy || hP || Function("return this")(), Fn = qn.Symbol, By = Object.prototype, bP = By.hasOwnProperty, yP = By.toString, Fa = Fn ? Fn.toStringTag : void 0;
function SP(e) {
  var t = bP.call(e, Fa), n = e[Fa];
  try {
    e[Fa] = void 0;
    var o = !0;
  } catch {
  }
  var r = yP.call(e);
  return o && (t ? e[Fa] = n : delete e[Fa]), r;
}
var $P = Object.prototype, CP = $P.toString;
function wP(e) {
  return CP.call(e);
}
var xP = "[object Null]", OP = "[object Undefined]", Rv = Fn ? Fn.toStringTag : void 0;
function Tr(e) {
  return e == null ? e === void 0 ? OP : xP : Rv && Rv in Object(e) ? SP(e) : wP(e);
}
function Gn(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var PP = "[object AsyncFunction]", IP = "[object Function]", TP = "[object GeneratorFunction]", EP = "[object Proxy]";
function ky(e) {
  if (!Gn(e))
    return !1;
  var t = Tr(e);
  return t == IP || t == TP || t == PP || t == EP;
}
var vu = qn["__core-js_shared__"], Fv = function() {
  var e = /[^.]+$/.exec(vu && vu.keys && vu.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function MP(e) {
  return !!Fv && Fv in e;
}
var _P = Function.prototype, DP = _P.toString;
function Er(e) {
  if (e != null) {
    try {
      return DP.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var AP = /[\\^$.*+?()[\]{}|]/g, NP = /^\[object .+?Constructor\]$/, RP = Function.prototype, FP = Object.prototype, BP = RP.toString, kP = FP.hasOwnProperty, LP = RegExp(
  "^" + BP.call(kP).replace(AP, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function HP(e) {
  if (!Gn(e) || MP(e))
    return !1;
  var t = ky(e) ? LP : NP;
  return t.test(Er(e));
}
function zP(e, t) {
  return e == null ? void 0 : e[t];
}
function Mr(e, t) {
  var n = zP(e, t);
  return HP(n) ? n : void 0;
}
var pi = Mr(qn, "Map"), vi = Mr(Object, "create");
function jP() {
  this.__data__ = vi ? vi(null) : {}, this.size = 0;
}
function VP(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var WP = "__lodash_hash_undefined__", KP = Object.prototype, UP = KP.hasOwnProperty;
function GP(e) {
  var t = this.__data__;
  if (vi) {
    var n = t[e];
    return n === WP ? void 0 : n;
  }
  return UP.call(t, e) ? t[e] : void 0;
}
var YP = Object.prototype, XP = YP.hasOwnProperty;
function qP(e) {
  var t = this.__data__;
  return vi ? t[e] !== void 0 : XP.call(t, e);
}
var QP = "__lodash_hash_undefined__";
function ZP(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = vi && t === void 0 ? QP : t, this;
}
function Cr(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var o = e[t];
    this.set(o[0], o[1]);
  }
}
Cr.prototype.clear = jP;
Cr.prototype.delete = VP;
Cr.prototype.get = GP;
Cr.prototype.has = qP;
Cr.prototype.set = ZP;
function JP() {
  this.size = 0, this.__data__ = {
    hash: new Cr(),
    map: new (pi || xo)(),
    string: new Cr()
  };
}
function eI(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function ps(e, t) {
  var n = e.__data__;
  return eI(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
function tI(e) {
  var t = ps(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function nI(e) {
  return ps(this, e).get(e);
}
function oI(e) {
  return ps(this, e).has(e);
}
function rI(e, t) {
  var n = ps(this, e), o = n.size;
  return n.set(e, t), this.size += n.size == o ? 0 : 1, this;
}
function Oo(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var o = e[t];
    this.set(o[0], o[1]);
  }
}
Oo.prototype.clear = JP;
Oo.prototype.delete = tI;
Oo.prototype.get = nI;
Oo.prototype.has = oI;
Oo.prototype.set = rI;
var aI = 200;
function iI(e, t) {
  var n = this.__data__;
  if (n instanceof xo) {
    var o = n.__data__;
    if (!pi || o.length < aI - 1)
      return o.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new Oo(o);
  }
  return n.set(e, t), this.size = n.size, this;
}
function oo(e) {
  var t = this.__data__ = new xo(e);
  this.size = t.size;
}
oo.prototype.clear = pP;
oo.prototype.delete = vP;
oo.prototype.get = mP;
oo.prototype.has = gP;
oo.prototype.set = iI;
var lI = "__lodash_hash_undefined__";
function sI(e) {
  return this.__data__.set(e, lI), this;
}
function uI(e) {
  return this.__data__.has(e);
}
function pa(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.__data__ = new Oo(); ++t < n; )
    this.add(e[t]);
}
pa.prototype.add = pa.prototype.push = sI;
pa.prototype.has = uI;
function cI(e, t) {
  for (var n = -1, o = e == null ? 0 : e.length; ++n < o; )
    if (t(e[n], n, e))
      return !0;
  return !1;
}
function Nl(e, t) {
  return e.has(t);
}
var dI = 1, fI = 2;
function Ly(e, t, n, o, r, a) {
  var i = n & dI, l = e.length, u = t.length;
  if (l != u && !(i && u > l))
    return !1;
  var s = a.get(e), c = a.get(t);
  if (s && c)
    return s == t && c == e;
  var d = -1, f = !0, p = n & fI ? new pa() : void 0;
  for (a.set(e, t), a.set(t, e); ++d < l; ) {
    var v = e[d], g = t[d];
    if (o)
      var b = i ? o(g, v, d, t, e, a) : o(v, g, d, e, t, a);
    if (b !== void 0) {
      if (b)
        continue;
      f = !1;
      break;
    }
    if (p) {
      if (!cI(t, function(y, S) {
        if (!Nl(p, S) && (v === y || r(v, y, n, o, a)))
          return p.push(S);
      })) {
        f = !1;
        break;
      }
    } else if (!(v === g || r(v, g, n, o, a))) {
      f = !1;
      break;
    }
  }
  return a.delete(e), a.delete(t), f;
}
var Rl = qn.Uint8Array;
function pI(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(o, r) {
    n[++t] = [r, o];
  }), n;
}
function zd(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(o) {
    n[++t] = o;
  }), n;
}
var vI = 1, mI = 2, gI = "[object Boolean]", hI = "[object Date]", bI = "[object Error]", yI = "[object Map]", SI = "[object Number]", $I = "[object RegExp]", CI = "[object Set]", wI = "[object String]", xI = "[object Symbol]", OI = "[object ArrayBuffer]", PI = "[object DataView]", Bv = Fn ? Fn.prototype : void 0, mu = Bv ? Bv.valueOf : void 0;
function II(e, t, n, o, r, a, i) {
  switch (n) {
    case PI:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
        return !1;
      e = e.buffer, t = t.buffer;
    case OI:
      return !(e.byteLength != t.byteLength || !a(new Rl(e), new Rl(t)));
    case gI:
    case hI:
    case SI:
      return Hd(+e, +t);
    case bI:
      return e.name == t.name && e.message == t.message;
    case $I:
    case wI:
      return e == t + "";
    case yI:
      var l = pI;
    case CI:
      var u = o & vI;
      if (l || (l = zd), e.size != t.size && !u)
        return !1;
      var s = i.get(e);
      if (s)
        return s == t;
      o |= mI, i.set(e, t);
      var c = Ly(l(e), l(t), o, r, a, i);
      return i.delete(e), c;
    case xI:
      if (mu)
        return mu.call(e) == mu.call(t);
  }
  return !1;
}
function jd(e, t) {
  for (var n = -1, o = t.length, r = e.length; ++n < o; )
    e[r + n] = t[n];
  return e;
}
var xn = Array.isArray;
function Hy(e, t, n) {
  var o = t(e);
  return xn(e) ? o : jd(o, n(e));
}
function TI(e, t) {
  for (var n = -1, o = e == null ? 0 : e.length, r = 0, a = []; ++n < o; ) {
    var i = e[n];
    t(i, n, e) && (a[r++] = i);
  }
  return a;
}
function zy() {
  return [];
}
var EI = Object.prototype, MI = EI.propertyIsEnumerable, kv = Object.getOwnPropertySymbols, Vd = kv ? function(e) {
  return e == null ? [] : (e = Object(e), TI(kv(e), function(t) {
    return MI.call(e, t);
  }));
} : zy;
function _I(e, t) {
  for (var n = -1, o = Array(e); ++n < e; )
    o[n] = t(n);
  return o;
}
function io(e) {
  return e != null && typeof e == "object";
}
var DI = "[object Arguments]";
function Lv(e) {
  return io(e) && Tr(e) == DI;
}
var jy = Object.prototype, AI = jy.hasOwnProperty, NI = jy.propertyIsEnumerable, vs = Lv(/* @__PURE__ */ function() {
  return arguments;
}()) ? Lv : function(e) {
  return io(e) && AI.call(e, "callee") && !NI.call(e, "callee");
};
function RI() {
  return !1;
}
var Vy = typeof exports == "object" && exports && !exports.nodeType && exports, Hv = Vy && typeof module == "object" && module && !module.nodeType && module, FI = Hv && Hv.exports === Vy, zv = FI ? qn.Buffer : void 0, BI = zv ? zv.isBuffer : void 0, mi = BI || RI, kI = 9007199254740991, LI = /^(?:0|[1-9]\d*)$/;
function Wd(e, t) {
  var n = typeof e;
  return t = t ?? kI, !!t && (n == "number" || n != "symbol" && LI.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
var HI = 9007199254740991;
function Kd(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= HI;
}
var zI = "[object Arguments]", jI = "[object Array]", VI = "[object Boolean]", WI = "[object Date]", KI = "[object Error]", UI = "[object Function]", GI = "[object Map]", YI = "[object Number]", XI = "[object Object]", qI = "[object RegExp]", QI = "[object Set]", ZI = "[object String]", JI = "[object WeakMap]", eT = "[object ArrayBuffer]", tT = "[object DataView]", nT = "[object Float32Array]", oT = "[object Float64Array]", rT = "[object Int8Array]", aT = "[object Int16Array]", iT = "[object Int32Array]", lT = "[object Uint8Array]", sT = "[object Uint8ClampedArray]", uT = "[object Uint16Array]", cT = "[object Uint32Array]", wt = {};
wt[nT] = wt[oT] = wt[rT] = wt[aT] = wt[iT] = wt[lT] = wt[sT] = wt[uT] = wt[cT] = !0;
wt[zI] = wt[jI] = wt[eT] = wt[VI] = wt[tT] = wt[WI] = wt[KI] = wt[UI] = wt[GI] = wt[YI] = wt[XI] = wt[qI] = wt[QI] = wt[ZI] = wt[JI] = !1;
function dT(e) {
  return io(e) && Kd(e.length) && !!wt[Tr(e)];
}
function ms(e) {
  return function(t) {
    return e(t);
  };
}
var Wy = typeof exports == "object" && exports && !exports.nodeType && exports, Ua = Wy && typeof module == "object" && module && !module.nodeType && module, fT = Ua && Ua.exports === Wy, gu = fT && Fy.process, va = function() {
  try {
    var e = Ua && Ua.require && Ua.require("util").types;
    return e || gu && gu.binding && gu.binding("util");
  } catch {
  }
}(), jv = va && va.isTypedArray, Ud = jv ? ms(jv) : dT, pT = Object.prototype, vT = pT.hasOwnProperty;
function Ky(e, t) {
  var n = xn(e), o = !n && vs(e), r = !n && !o && mi(e), a = !n && !o && !r && Ud(e), i = n || o || r || a, l = i ? _I(e.length, String) : [], u = l.length;
  for (var s in e)
    (t || vT.call(e, s)) && !(i && // Safari 9 has enumerable `arguments.length` in strict mode.
    (s == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    r && (s == "offset" || s == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    a && (s == "buffer" || s == "byteLength" || s == "byteOffset") || // Skip index properties.
    Wd(s, u))) && l.push(s);
  return l;
}
var mT = Object.prototype;
function gs(e) {
  var t = e && e.constructor, n = typeof t == "function" && t.prototype || mT;
  return e === n;
}
function Uy(e, t) {
  return function(n) {
    return e(t(n));
  };
}
var gT = Uy(Object.keys, Object), hT = Object.prototype, bT = hT.hasOwnProperty;
function Gy(e) {
  if (!gs(e))
    return gT(e);
  var t = [];
  for (var n in Object(e))
    bT.call(e, n) && n != "constructor" && t.push(n);
  return t;
}
function Sa(e) {
  return e != null && Kd(e.length) && !ky(e);
}
function $a(e) {
  return Sa(e) ? Ky(e) : Gy(e);
}
function Ic(e) {
  return Hy(e, $a, Vd);
}
var yT = 1, ST = Object.prototype, $T = ST.hasOwnProperty;
function CT(e, t, n, o, r, a) {
  var i = n & yT, l = Ic(e), u = l.length, s = Ic(t), c = s.length;
  if (u != c && !i)
    return !1;
  for (var d = u; d--; ) {
    var f = l[d];
    if (!(i ? f in t : $T.call(t, f)))
      return !1;
  }
  var p = a.get(e), v = a.get(t);
  if (p && v)
    return p == t && v == e;
  var g = !0;
  a.set(e, t), a.set(t, e);
  for (var b = i; ++d < u; ) {
    f = l[d];
    var y = e[f], S = t[f];
    if (o)
      var w = i ? o(S, y, f, t, e, a) : o(y, S, f, e, t, a);
    if (!(w === void 0 ? y === S || r(y, S, n, o, a) : w)) {
      g = !1;
      break;
    }
    b || (b = f == "constructor");
  }
  if (g && !b) {
    var C = e.constructor, $ = t.constructor;
    C != $ && "constructor" in e && "constructor" in t && !(typeof C == "function" && C instanceof C && typeof $ == "function" && $ instanceof $) && (g = !1);
  }
  return a.delete(e), a.delete(t), g;
}
var Tc = Mr(qn, "DataView"), Ec = Mr(qn, "Promise"), Jr = Mr(qn, "Set"), Mc = Mr(qn, "WeakMap"), Vv = "[object Map]", wT = "[object Object]", Wv = "[object Promise]", Kv = "[object Set]", Uv = "[object WeakMap]", Gv = "[object DataView]", xT = Er(Tc), OT = Er(pi), PT = Er(Ec), IT = Er(Jr), TT = Er(Mc), Dn = Tr;
(Tc && Dn(new Tc(new ArrayBuffer(1))) != Gv || pi && Dn(new pi()) != Vv || Ec && Dn(Ec.resolve()) != Wv || Jr && Dn(new Jr()) != Kv || Mc && Dn(new Mc()) != Uv) && (Dn = function(e) {
  var t = Tr(e), n = t == wT ? e.constructor : void 0, o = n ? Er(n) : "";
  if (o)
    switch (o) {
      case xT:
        return Gv;
      case OT:
        return Vv;
      case PT:
        return Wv;
      case IT:
        return Kv;
      case TT:
        return Uv;
    }
  return t;
});
var ET = 1, Yv = "[object Arguments]", Xv = "[object Array]", Vi = "[object Object]", MT = Object.prototype, qv = MT.hasOwnProperty;
function _T(e, t, n, o, r, a) {
  var i = xn(e), l = xn(t), u = i ? Xv : Dn(e), s = l ? Xv : Dn(t);
  u = u == Yv ? Vi : u, s = s == Yv ? Vi : s;
  var c = u == Vi, d = s == Vi, f = u == s;
  if (f && mi(e)) {
    if (!mi(t))
      return !1;
    i = !0, c = !1;
  }
  if (f && !c)
    return a || (a = new oo()), i || Ud(e) ? Ly(e, t, n, o, r, a) : II(e, t, u, n, o, r, a);
  if (!(n & ET)) {
    var p = c && qv.call(e, "__wrapped__"), v = d && qv.call(t, "__wrapped__");
    if (p || v) {
      var g = p ? e.value() : e, b = v ? t.value() : t;
      return a || (a = new oo()), r(g, b, n, o, a);
    }
  }
  return f ? (a || (a = new oo()), CT(e, t, n, o, r, a)) : !1;
}
function hs(e, t, n, o, r) {
  return e === t ? !0 : e == null || t == null || !io(e) && !io(t) ? e !== e && t !== t : _T(e, t, n, o, hs, r);
}
function Gd(e, t) {
  return hs(e, t);
}
const DT = {
  align: Object,
  target: [Object, Function],
  onAlign: Function,
  monitorBufferTime: Number,
  monitorWindowResize: Boolean,
  disabled: Boolean
};
function Qv(e) {
  return typeof e != "function" ? null : e();
}
function Zv(e) {
  return typeof e != "object" || !e ? null : e;
}
const AT = J({
  compatConfig: {
    MODE: 3
  },
  name: "Align",
  props: DT,
  emits: ["align"],
  setup(e, t) {
    let {
      expose: n,
      slots: o
    } = t;
    const r = G({}), a = G(), [i, l] = aP(() => {
      const {
        disabled: f,
        target: p,
        align: v,
        onAlign: g
      } = e;
      if (!f && p && a.value) {
        const b = a.value;
        let y;
        const S = Qv(p), w = Zv(p);
        r.value.element = S, r.value.point = w, r.value.align = v;
        const {
          activeElement: C
        } = document;
        return S && Ld(S) ? y = kd(b, S, v) : w && (y = tP(b, w, v)), rP(C, b), g && y && g(b, y), !0;
      }
      return !1;
    }, T(() => e.monitorBufferTime)), u = G({
      cancel: () => {
      }
    }), s = G({
      cancel: () => {
      }
    }), c = () => {
      const f = e.target, p = Qv(f), v = Zv(f);
      a.value !== s.value.element && (s.value.cancel(), s.value.element = a.value, s.value.cancel = Nv(a.value, i)), (r.value.element !== p || !oP(r.value.point, v) || !Gd(r.value.align, e.align)) && (i(), u.value.element !== p && (u.value.cancel(), u.value.element = p, u.value.cancel = Nv(p, i)));
    };
    ze(() => {
      mt(() => {
        c();
      });
    }), Co(() => {
      mt(() => {
        c();
      });
    }), le(() => e.disabled, (f) => {
      f ? l() : i();
    }, {
      immediate: !0,
      flush: "post"
    });
    const d = G(null);
    return le(() => e.monitorWindowResize, (f) => {
      f ? d.value || (d.value = Kn(window, "resize", i)) : d.value && (d.value.remove(), d.value = null);
    }, {
      flush: "post"
    }), Xo(() => {
      u.value.cancel(), s.value.cancel(), d.value && d.value.remove(), l();
    }), n({
      forceAlign: () => i(!0)
    }), () => {
      const f = o == null ? void 0 : o.default();
      return f ? Tt(f[0], {
        ref: a
      }, !0, !0) : null;
    };
  }
});
ro("bottomLeft", "bottomRight", "topLeft", "topRight");
const Yy = (e) => e !== void 0 && (e === "topLeft" || e === "topRight") ? "slide-down" : "slide-up", Ca = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return h(e ? {
    name: e,
    appear: !0,
    // type: 'animation',
    // appearFromClass: `${transitionName}-appear ${transitionName}-appear-prepare`,
    // appearActiveClass: `antdv-base-transtion`,
    // appearToClass: `${transitionName}-appear ${transitionName}-appear-active`,
    enterFromClass: `${e}-enter ${e}-enter-prepare ${e}-enter-start`,
    enterActiveClass: `${e}-enter ${e}-enter-prepare`,
    enterToClass: `${e}-enter ${e}-enter-active`,
    leaveFromClass: ` ${e}-leave`,
    leaveActiveClass: `${e}-leave ${e}-leave-active`,
    leaveToClass: `${e}-leave ${e}-leave-active`
  } : {
    css: !1
  }, t);
}, bs = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return h(e ? {
    name: e,
    appear: !0,
    // appearFromClass: `${transitionName}-appear ${transitionName}-appear-prepare`,
    appearActiveClass: `${e}`,
    appearToClass: `${e}-appear ${e}-appear-active`,
    enterFromClass: `${e}-appear ${e}-enter ${e}-appear-prepare ${e}-enter-prepare`,
    enterActiveClass: `${e}`,
    enterToClass: `${e}-enter ${e}-appear ${e}-appear-active ${e}-enter-active`,
    leaveActiveClass: `${e} ${e}-leave`,
    leaveToClass: `${e}-leave-active`
  } : {
    css: !1
  }, t);
}, wr = (e, t, n) => n !== void 0 ? n : `${e}-${t}`, NT = J({
  compatConfig: {
    MODE: 3
  },
  name: "PopupInner",
  inheritAttrs: !1,
  props: Dd,
  emits: ["mouseenter", "mouseleave", "mousedown", "touchstart", "align"],
  setup(e, t) {
    let {
      expose: n,
      attrs: o,
      slots: r
    } = t;
    const a = K(), i = K(), l = K(), [u, s] = TO(Je(e, "stretch")), c = () => {
      e.stretch && s(e.getRootDomNode());
    }, d = K(!1);
    let f;
    le(() => e.visible, (O) => {
      clearTimeout(f), O ? f = setTimeout(() => {
        d.value = e.visible;
      }) : d.value = !1;
    }, {
      immediate: !0
    });
    const [p, v] = IO(d, c), g = K(), b = () => e.point ? e.point : e.getRootDomNode, y = () => {
      var O;
      (O = a.value) === null || O === void 0 || O.forceAlign();
    }, S = (O, x) => {
      var M;
      const _ = e.getClassNameFromAlign(x), N = l.value;
      l.value !== _ && (l.value = _), p.value === "align" && (N !== _ ? Promise.resolve().then(() => {
        y();
      }) : v(() => {
        var I;
        (I = g.value) === null || I === void 0 || I.call(g);
      }), (M = e.onAlign) === null || M === void 0 || M.call(e, O, x));
    }, w = T(() => {
      const O = typeof e.animation == "object" ? e.animation : Ad(e);
      return ["onAfterEnter", "onAfterLeave"].forEach((x) => {
        const M = O[x];
        O[x] = (_) => {
          v(), p.value = "stable", M == null || M(_);
        };
      }), O;
    }), C = () => new Promise((O) => {
      g.value = O;
    });
    le([w, p], () => {
      !w.value && p.value === "motion" && v();
    }, {
      immediate: !0
    }), n({
      forceAlign: y,
      getElement: () => i.value.$el || i.value
    });
    const $ = T(() => {
      var O;
      return !(!((O = e.align) === null || O === void 0) && O.points && (p.value === "align" || p.value === "stable"));
    });
    return () => {
      var O;
      const {
        zIndex: x,
        align: M,
        prefixCls: _,
        destroyPopupOnHide: N,
        onMouseenter: I,
        onMouseleave: E,
        onTouchstart: B = () => {
        },
        onMousedown: k
      } = e, P = p.value, R = [h(h({}, u.value), {
        zIndex: x,
        opacity: P === "motion" || P === "stable" || !d.value ? null : 0,
        // pointerEvents: statusValue === 'stable' ? null : 'none',
        pointerEvents: !d.value && P !== "stable" ? "none" : null
      }), o.style];
      let D = xt((O = r.default) === null || O === void 0 ? void 0 : O.call(r, {
        visible: e.visible
      }));
      D.length > 1 && (D = m("div", {
        class: `${_}-content`
      }, [D]));
      const A = ae(_, o.class, l.value, !e.arrow && `${_}-arrow-hidden`), j = d.value || !e.visible ? Ca(w.value.name, w.value) : {};
      return m(Yn, L(L({
        ref: i
      }, j), {}, {
        onBeforeEnter: C
      }), {
        default: () => !N || e.visible ? An(m(AT, {
          target: b(),
          key: "popup",
          ref: a,
          monitorWindowResize: !0,
          disabled: $.value,
          align: M,
          onAlign: S
        }, {
          default: () => m("div", {
            class: A,
            onMouseenter: I,
            onMouseleave: E,
            onMousedown: Vp(k, ["capture"]),
            [Kt ? "onTouchstartPassive" : "onTouchstart"]: Vp(B, ["capture"]),
            style: R
          }, [D])
        }), [[wo, d.value]]) : null
      });
    };
  }
}), RT = J({
  compatConfig: {
    MODE: 3
  },
  name: "Popup",
  inheritAttrs: !1,
  props: xO,
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      expose: r
    } = t;
    const a = K(!1), i = K(!1), l = K(), u = K();
    return le([() => e.visible, () => e.mobile], () => {
      a.value = e.visible, e.visible && e.mobile && (i.value = !0);
    }, {
      immediate: !0,
      flush: "post"
    }), r({
      forceAlign: () => {
        var s;
        (s = l.value) === null || s === void 0 || s.forceAlign();
      },
      getElement: () => {
        var s;
        return (s = l.value) === null || s === void 0 ? void 0 : s.getElement();
      }
    }), () => {
      const s = h(h(h({}, e), n), {
        visible: a.value
      }), c = i.value ? m(OO, L(L({}, s), {}, {
        mobile: e.mobile,
        ref: l
      }), {
        default: o.default
      }) : m(NT, L(L({}, s), {}, {
        ref: l
      }), {
        default: o.default
      });
      return m("div", {
        ref: u
      }, [m(Iy, s, null), c]);
    };
  }
});
function FT(e, t, n) {
  return n ? e[0] === t[0] : e[0] === t[0] && e[1] === t[1];
}
function Jv(e, t, n) {
  const o = e[t] || {};
  return h(h({}, o), n);
}
function BT(e, t, n, o) {
  const {
    points: r
  } = n, a = Object.keys(e);
  for (let i = 0; i < a.length; i += 1) {
    const l = a[i];
    if (FT(e[l].points, r, o))
      return `${t}-placement-${l}`;
  }
  return "";
}
const ys = {
  methods: {
    setState() {
      let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0, n = typeof e == "function" ? e(this.$data, this.$props) : e;
      if (this.getDerivedStateFromProps) {
        const o = this.getDerivedStateFromProps(yb(this), h(h({}, this.$data), n));
        if (o === null)
          return;
        n = h(h({}, n), o || {});
      }
      h(this.$data, n), this._.isMounted && this.$forceUpdate(), mt(() => {
        t && t();
      });
    },
    __emit() {
      const e = [].slice.call(arguments, 0);
      let t = e[0];
      t = `on${t[0].toUpperCase()}${t.substring(1)}`;
      const n = this.$props[t] || this.$attrs[t];
      if (e.length && n)
        if (Array.isArray(n))
          for (let o = 0, r = n.length; o < r; o++)
            n[o](...e.slice(1));
        else
          n(...e.slice(1));
    }
  }
}, Xy = Symbol("PortalContextKey"), Yd = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    inTriggerContext: !0
  };
  ot(Xy, {
    inTriggerContext: t.inTriggerContext,
    shouldRender: T(() => {
      const {
        sPopupVisible: n,
        popupRef: o,
        forceRender: r,
        autoDestroy: a
      } = e || {};
      let i = !1;
      return (n || o || r) && (i = !0), !n && a && (i = !1), i;
    })
  });
}, kT = () => {
  Yd({}, {
    inTriggerContext: !1
  });
  const e = nt(Xy, {
    shouldRender: T(() => !1),
    inTriggerContext: !1
  });
  return {
    shouldRender: T(() => e.shouldRender.value || e.inTriggerContext === !1)
  };
}, qy = J({
  compatConfig: {
    MODE: 3
  },
  name: "Portal",
  inheritAttrs: !1,
  props: {
    getContainer: W.func.isRequired,
    didUpdate: Function
  },
  setup(e, t) {
    let {
      slots: n
    } = t, o = !0, r;
    const {
      shouldRender: a
    } = kT();
    function i() {
      a.value && (r = e.getContainer());
    }
    gd(() => {
      o = !1, i();
    }), ze(() => {
      r || i();
    });
    const l = le(a, () => {
      a.value && !r && (r = e.getContainer()), r && l();
    });
    return Co(() => {
      mt(() => {
        var u;
        a.value && ((u = e.didUpdate) === null || u === void 0 || u.call(e, e));
      });
    }), () => {
      var u;
      return a.value ? o ? (u = n.default) === null || u === void 0 ? void 0 : u.call(n) : r ? m(hd, {
        to: r
      }, n) : null : null;
    };
  }
});
let hu;
function LT(e) {
  if (typeof document > "u")
    return 0;
  if (hu === void 0) {
    const t = document.createElement("div");
    t.style.width = "100%", t.style.height = "200px";
    const n = document.createElement("div"), o = n.style;
    o.position = "absolute", o.top = "0", o.left = "0", o.pointerEvents = "none", o.visibility = "hidden", o.width = "200px", o.height = "150px", o.overflow = "hidden", n.appendChild(t), document.body.appendChild(n);
    const r = t.offsetWidth;
    n.style.overflow = "scroll";
    let a = t.offsetWidth;
    r === a && (a = n.clientWidth), document.body.removeChild(n), hu = r - a;
  }
  return hu;
}
const HT = `vc-util-locker-${Date.now()}`;
let em = 0;
function zT() {
  return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
}
function jT(e) {
  const t = T(() => !!e && !!e.value);
  em += 1;
  const n = `${HT}_${em}`;
  Ve((o) => {
    if (Nn()) {
      if (t.value) {
        const r = LT(), a = zT();
        li(`
html body {
  overflow-y: hidden;
  ${a ? `width: calc(100% - ${r}px);` : ""}
}`, n);
      } else
        Ml(n);
      o(() => {
        Ml(n);
      });
    }
  }, {
    flush: "post"
  });
}
let or = 0;
const ul = Nn(), tm = (e) => {
  if (!ul)
    return null;
  if (e) {
    if (typeof e == "string")
      return document.querySelectorAll(e)[0];
    if (typeof e == "function")
      return e();
    if (typeof e == "object" && e instanceof window.HTMLElement)
      return e;
  }
  return document.body;
}, Qy = J({
  compatConfig: {
    MODE: 3
  },
  name: "PortalWrapper",
  inheritAttrs: !1,
  props: {
    wrapperClassName: String,
    forceRender: {
      type: Boolean,
      default: void 0
    },
    getContainer: W.any,
    visible: {
      type: Boolean,
      default: void 0
    },
    autoLock: Me(),
    didUpdate: Function
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = K(), r = K(), a = K(), i = K(1), l = Nn() && document.createElement("div"), u = () => {
      var p, v;
      o.value === l && ((v = (p = o.value) === null || p === void 0 ? void 0 : p.parentNode) === null || v === void 0 || v.removeChild(o.value)), o.value = null;
    };
    let s = null;
    const c = function() {
      return (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1) || o.value && !o.value.parentNode ? (s = tm(e.getContainer), s ? (s.appendChild(o.value), !0) : !1) : !0;
    }, d = () => ul ? (o.value || (o.value = l, c(!0)), f(), o.value) : null, f = () => {
      const {
        wrapperClassName: p
      } = e;
      o.value && p && p !== o.value.className && (o.value.className = p);
    };
    return Co(() => {
      f(), c();
    }), jT(T(() => e.autoLock && e.visible && Nn() && (o.value === document.body || o.value === l))), ze(() => {
      let p = !1;
      le([() => e.visible, () => e.getContainer], (v, g) => {
        let [b, y] = v, [S, w] = g;
        ul && (s = tm(e.getContainer), s === document.body && (b && !S ? or += 1 : p && (or -= 1))), p && (typeof y == "function" && typeof w == "function" ? y.toString() !== w.toString() : y !== w) && u(), p = !0;
      }, {
        immediate: !0,
        flush: "post"
      }), mt(() => {
        c() || (a.value = Ue(() => {
          i.value += 1;
        }));
      });
    }), at(() => {
      const {
        visible: p
      } = e;
      ul && s === document.body && (or = p && or ? or - 1 : or), u(), Ue.cancel(a.value);
    }), () => {
      const {
        forceRender: p,
        visible: v
      } = e;
      let g = null;
      const b = {
        getOpenCount: () => or,
        getContainer: d
      };
      return i.value && (p || v || r.value) && (g = m(qy, {
        getContainer: d,
        ref: r,
        didUpdate: e.didUpdate
      }, {
        default: () => {
          var y;
          return (y = n.default) === null || y === void 0 ? void 0 : y.call(n, b);
        }
      })), g;
    };
  }
}), VT = ["onClick", "onMousedown", "onTouchstart", "onMouseenter", "onMouseleave", "onFocus", "onBlur", "onContextmenu"], wa = J({
  compatConfig: {
    MODE: 3
  },
  name: "Trigger",
  mixins: [ys],
  inheritAttrs: !1,
  props: CO(),
  setup(e) {
    const t = T(() => {
      const {
        popupPlacement: r,
        popupAlign: a,
        builtinPlacements: i
      } = e;
      return r && i ? Jv(i, r, a) : a;
    }), n = K(null), o = (r) => {
      n.value = r;
    };
    return {
      vcTriggerContext: nt("vcTriggerContext", {}),
      popupRef: n,
      setPopupRef: o,
      triggerRef: K(null),
      align: t,
      focusTime: null,
      clickOutsideHandler: null,
      contextmenuOutsideHandler1: null,
      contextmenuOutsideHandler2: null,
      touchOutsideHandler: null,
      attachId: null,
      delayTimer: null,
      hasPopupMouseDown: !1,
      preClickTime: null,
      preTouchTime: null,
      mouseDownTimeout: null,
      childOriginEvents: {}
    };
  },
  data() {
    const e = this.$props;
    let t;
    return this.popupVisible !== void 0 ? t = !!e.popupVisible : t = !!e.defaultPopupVisible, VT.forEach((n) => {
      this[`fire${n}`] = (o) => {
        this.fireEvents(n, o);
      };
    }), {
      prevPopupVisible: t,
      sPopupVisible: t,
      point: null
    };
  },
  watch: {
    popupVisible(e) {
      e !== void 0 && (this.prevPopupVisible = this.sPopupVisible, this.sPopupVisible = e);
    }
  },
  created() {
    ot("vcTriggerContext", {
      onPopupMouseDown: this.onPopupMouseDown,
      onPopupMouseenter: this.onPopupMouseenter,
      onPopupMouseleave: this.onPopupMouseleave
    }), Yd(this);
  },
  deactivated() {
    this.setPopupVisible(!1);
  },
  mounted() {
    this.$nextTick(() => {
      this.updatedCal();
    });
  },
  updated() {
    this.$nextTick(() => {
      this.updatedCal();
    });
  },
  beforeUnmount() {
    this.clearDelayTimer(), this.clearOutsideHandler(), clearTimeout(this.mouseDownTimeout), Ue.cancel(this.attachId);
  },
  methods: {
    updatedCal() {
      const e = this.$props;
      if (this.$data.sPopupVisible) {
        let n;
        !this.clickOutsideHandler && (this.isClickToHide() || this.isContextmenuToShow()) && (n = e.getDocument(this.getRootDomNode()), this.clickOutsideHandler = Kn(n, "mousedown", this.onDocumentClick)), this.touchOutsideHandler || (n = n || e.getDocument(this.getRootDomNode()), this.touchOutsideHandler = Kn(n, "touchstart", this.onDocumentClick, Kt ? {
          passive: !1
        } : !1)), !this.contextmenuOutsideHandler1 && this.isContextmenuToShow() && (n = n || e.getDocument(this.getRootDomNode()), this.contextmenuOutsideHandler1 = Kn(n, "scroll", this.onContextmenuClose)), !this.contextmenuOutsideHandler2 && this.isContextmenuToShow() && (this.contextmenuOutsideHandler2 = Kn(window, "blur", this.onContextmenuClose));
      } else
        this.clearOutsideHandler();
    },
    onMouseenter(e) {
      const {
        mouseEnterDelay: t
      } = this.$props;
      this.fireEvents("onMouseenter", e), this.delaySetPopupVisible(!0, t, t ? null : e);
    },
    onMouseMove(e) {
      this.fireEvents("onMousemove", e), this.setPoint(e);
    },
    onMouseleave(e) {
      this.fireEvents("onMouseleave", e), this.delaySetPopupVisible(!1, this.$props.mouseLeaveDelay);
    },
    onPopupMouseenter() {
      const {
        vcTriggerContext: e = {}
      } = this;
      e.onPopupMouseenter && e.onPopupMouseenter(), this.clearDelayTimer();
    },
    onPopupMouseleave(e) {
      var t;
      if (e && e.relatedTarget && !e.relatedTarget.setTimeout && ko((t = this.popupRef) === null || t === void 0 ? void 0 : t.getElement(), e.relatedTarget))
        return;
      this.isMouseLeaveToHide() && this.delaySetPopupVisible(!1, this.$props.mouseLeaveDelay);
      const {
        vcTriggerContext: n = {}
      } = this;
      n.onPopupMouseleave && n.onPopupMouseleave(e);
    },
    onFocus(e) {
      this.fireEvents("onFocus", e), this.clearDelayTimer(), this.isFocusToShow() && (this.focusTime = Date.now(), this.delaySetPopupVisible(!0, this.$props.focusDelay));
    },
    onMousedown(e) {
      this.fireEvents("onMousedown", e), this.preClickTime = Date.now();
    },
    onTouchstart(e) {
      this.fireEvents("onTouchstart", e), this.preTouchTime = Date.now();
    },
    onBlur(e) {
      ko(e.target, e.relatedTarget || document.activeElement) || (this.fireEvents("onBlur", e), this.clearDelayTimer(), this.isBlurToHide() && this.delaySetPopupVisible(!1, this.$props.blurDelay));
    },
    onContextmenu(e) {
      e.preventDefault(), this.fireEvents("onContextmenu", e), this.setPopupVisible(!0, e);
    },
    onContextmenuClose() {
      this.isContextmenuToShow() && this.close();
    },
    onClick(e) {
      if (this.fireEvents("onClick", e), this.focusTime) {
        let n;
        if (this.preClickTime && this.preTouchTime ? n = Math.min(this.preClickTime, this.preTouchTime) : this.preClickTime ? n = this.preClickTime : this.preTouchTime && (n = this.preTouchTime), Math.abs(n - this.focusTime) < 20)
          return;
        this.focusTime = 0;
      }
      this.preClickTime = 0, this.preTouchTime = 0, this.isClickToShow() && (this.isClickToHide() || this.isBlurToHide()) && e && e.preventDefault && e.preventDefault(), e && e.domEvent && e.domEvent.preventDefault();
      const t = !this.$data.sPopupVisible;
      (this.isClickToHide() && !t || t && this.isClickToShow()) && this.setPopupVisible(!this.$data.sPopupVisible, e);
    },
    onPopupMouseDown() {
      const {
        vcTriggerContext: e = {}
      } = this;
      this.hasPopupMouseDown = !0, clearTimeout(this.mouseDownTimeout), this.mouseDownTimeout = setTimeout(() => {
        this.hasPopupMouseDown = !1;
      }, 0), e.onPopupMouseDown && e.onPopupMouseDown(...arguments);
    },
    onDocumentClick(e) {
      if (this.$props.mask && !this.$props.maskClosable)
        return;
      const t = e.target, n = this.getRootDomNode(), o = this.getPopupDomNode();
      // mousedown on the target should also close popup when action is contextMenu.
      // https://github.com/ant-design/ant-design/issues/29853
      (!ko(n, t) || this.isContextMenuOnly()) && !ko(o, t) && !this.hasPopupMouseDown && this.delaySetPopupVisible(!1, 0.1);
    },
    getPopupDomNode() {
      var e;
      return ((e = this.popupRef) === null || e === void 0 ? void 0 : e.getElement()) || null;
    },
    getRootDomNode() {
      var e, t, n, o;
      const {
        getTriggerDOMNode: r
      } = this.$props;
      if (r) {
        const a = ((t = (e = this.triggerRef) === null || e === void 0 ? void 0 : e.$el) === null || t === void 0 ? void 0 : t.nodeName) === "#comment" ? null : to(this.triggerRef);
        return to(r(a));
      }
      try {
        const a = ((o = (n = this.triggerRef) === null || n === void 0 ? void 0 : n.$el) === null || o === void 0 ? void 0 : o.nodeName) === "#comment" ? null : to(this.triggerRef);
        if (a)
          return a;
      } catch {
      }
      return to(this);
    },
    handleGetPopupClassFromAlign(e) {
      const t = [], n = this.$props, {
        popupPlacement: o,
        builtinPlacements: r,
        prefixCls: a,
        alignPoint: i,
        getPopupClassNameFromAlign: l
      } = n;
      return o && r && t.push(BT(r, a, e, i)), l && t.push(l(e)), t.join(" ");
    },
    getPopupAlign() {
      const e = this.$props, {
        popupPlacement: t,
        popupAlign: n,
        builtinPlacements: o
      } = e;
      return t && o ? Jv(o, t, n) : n;
    },
    getComponent() {
      const e = {};
      this.isMouseEnterToShow() && (e.onMouseenter = this.onPopupMouseenter), this.isMouseLeaveToHide() && (e.onMouseleave = this.onPopupMouseleave), e.onMousedown = this.onPopupMouseDown, e[Kt ? "onTouchstartPassive" : "onTouchstart"] = this.onPopupMouseDown;
      const {
        handleGetPopupClassFromAlign: t,
        getRootDomNode: n,
        $attrs: o
      } = this, {
        prefixCls: r,
        destroyPopupOnHide: a,
        popupClassName: i,
        popupAnimation: l,
        popupTransitionName: u,
        popupStyle: s,
        mask: c,
        maskAnimation: d,
        maskTransitionName: f,
        zIndex: p,
        stretch: v,
        alignPoint: g,
        mobile: b,
        arrow: y,
        forceRender: S
      } = this.$props, {
        sPopupVisible: w,
        point: C
      } = this.$data, $ = h(h({
        prefixCls: r,
        arrow: y,
        destroyPopupOnHide: a,
        visible: w,
        point: g ? C : null,
        align: this.align,
        animation: l,
        getClassNameFromAlign: t,
        stretch: v,
        getRootDomNode: n,
        mask: c,
        zIndex: p,
        transitionName: u,
        maskAnimation: d,
        maskTransitionName: f,
        class: i,
        style: s,
        onAlign: o.onPopupAlign || Py
      }, e), {
        ref: this.setPopupRef,
        mobile: b,
        forceRender: S
      });
      return m(RT, $, {
        default: this.$slots.popup || (() => Jw(this, "popup"))
      });
    },
    attachParent(e) {
      Ue.cancel(this.attachId);
      const {
        getPopupContainer: t,
        getDocument: n
      } = this.$props, o = this.getRootDomNode();
      let r;
      t ? (o || t.length === 0) && (r = t(o)) : r = n(this.getRootDomNode()).body, r ? r.appendChild(e) : this.attachId = Ue(() => {
        this.attachParent(e);
      });
    },
    getContainer() {
      const {
        $props: e
      } = this, {
        getDocument: t
      } = e, n = t(this.getRootDomNode()).createElement("div");
      return n.style.position = "absolute", n.style.top = "0", n.style.left = "0", n.style.width = "100%", this.attachParent(n), n;
    },
    setPopupVisible(e, t) {
      const {
        alignPoint: n,
        sPopupVisible: o,
        onPopupVisibleChange: r
      } = this;
      this.clearDelayTimer(), o !== e && (Tl(this, "popupVisible") || this.setState({
        sPopupVisible: e,
        prevPopupVisible: o
      }), r && r(e)), n && t && e && this.setPoint(t);
    },
    setPoint(e) {
      const {
        alignPoint: t
      } = this.$props;
      !t || !e || this.setState({
        point: {
          pageX: e.pageX,
          pageY: e.pageY
        }
      });
    },
    handlePortalUpdate() {
      this.prevPopupVisible !== this.sPopupVisible && this.afterPopupVisibleChange(this.sPopupVisible);
    },
    delaySetPopupVisible(e, t, n) {
      const o = t * 1e3;
      if (this.clearDelayTimer(), o) {
        const r = n ? {
          pageX: n.pageX,
          pageY: n.pageY
        } : null;
        this.delayTimer = setTimeout(() => {
          this.setPopupVisible(e, r), this.clearDelayTimer();
        }, o);
      } else
        this.setPopupVisible(e, n);
    },
    clearDelayTimer() {
      this.delayTimer && (clearTimeout(this.delayTimer), this.delayTimer = null);
    },
    clearOutsideHandler() {
      this.clickOutsideHandler && (this.clickOutsideHandler.remove(), this.clickOutsideHandler = null), this.contextmenuOutsideHandler1 && (this.contextmenuOutsideHandler1.remove(), this.contextmenuOutsideHandler1 = null), this.contextmenuOutsideHandler2 && (this.contextmenuOutsideHandler2.remove(), this.contextmenuOutsideHandler2 = null), this.touchOutsideHandler && (this.touchOutsideHandler.remove(), this.touchOutsideHandler = null);
    },
    createTwoChains(e) {
      let t = () => {
      };
      const n = Gp(this);
      return this.childOriginEvents[e] && n[e] ? this[`fire${e}`] : (t = this.childOriginEvents[e] || n[e] || t, t);
    },
    isClickToShow() {
      const {
        action: e,
        showAction: t
      } = this.$props;
      return e.indexOf("click") !== -1 || t.indexOf("click") !== -1;
    },
    isContextMenuOnly() {
      const {
        action: e
      } = this.$props;
      return e === "contextmenu" || e.length === 1 && e[0] === "contextmenu";
    },
    isContextmenuToShow() {
      const {
        action: e,
        showAction: t
      } = this.$props;
      return e.indexOf("contextmenu") !== -1 || t.indexOf("contextmenu") !== -1;
    },
    isClickToHide() {
      const {
        action: e,
        hideAction: t
      } = this.$props;
      return e.indexOf("click") !== -1 || t.indexOf("click") !== -1;
    },
    isMouseEnterToShow() {
      const {
        action: e,
        showAction: t
      } = this.$props;
      return e.indexOf("hover") !== -1 || t.indexOf("mouseenter") !== -1;
    },
    isMouseLeaveToHide() {
      const {
        action: e,
        hideAction: t
      } = this.$props;
      return e.indexOf("hover") !== -1 || t.indexOf("mouseleave") !== -1;
    },
    isFocusToShow() {
      const {
        action: e,
        showAction: t
      } = this.$props;
      return e.indexOf("focus") !== -1 || t.indexOf("focus") !== -1;
    },
    isBlurToHide() {
      const {
        action: e,
        hideAction: t
      } = this.$props;
      return e.indexOf("focus") !== -1 || t.indexOf("blur") !== -1;
    },
    forcePopupAlign() {
      var e;
      this.$data.sPopupVisible && ((e = this.popupRef) === null || e === void 0 || e.forceAlign());
    },
    fireEvents(e, t) {
      this.childOriginEvents[e] && this.childOriginEvents[e](t);
      const n = this.$props[e] || this.$attrs[e];
      n && n(t);
    },
    close() {
      this.setPopupVisible(!1);
    }
  },
  render() {
    const {
      $attrs: e
    } = this, t = nn(bb(this)), {
      alignPoint: n,
      getPopupContainer: o
    } = this.$props, r = t[0];
    this.childOriginEvents = Gp(r);
    const a = {
      key: "trigger"
    };
    this.isContextmenuToShow() ? a.onContextmenu = this.onContextmenu : a.onContextmenu = this.createTwoChains("onContextmenu"), this.isClickToHide() || this.isClickToShow() ? (a.onClick = this.onClick, a.onMousedown = this.onMousedown, a[Kt ? "onTouchstartPassive" : "onTouchstart"] = this.onTouchstart) : (a.onClick = this.createTwoChains("onClick"), a.onMousedown = this.createTwoChains("onMousedown"), a[Kt ? "onTouchstartPassive" : "onTouchstart"] = this.createTwoChains("onTouchstart")), this.isMouseEnterToShow() ? (a.onMouseenter = this.onMouseenter, n && (a.onMousemove = this.onMouseMove)) : a.onMouseenter = this.createTwoChains("onMouseenter"), this.isMouseLeaveToHide() ? a.onMouseleave = this.onMouseleave : a.onMouseleave = this.createTwoChains("onMouseleave"), this.isFocusToShow() || this.isBlurToHide() ? (a.onFocus = this.onFocus, a.onBlur = this.onBlur) : (a.onFocus = this.createTwoChains("onFocus"), a.onBlur = (s) => {
      s && (!s.relatedTarget || !ko(s.target, s.relatedTarget)) && this.createTwoChains("onBlur")(s);
    });
    const i = ae(r && r.props && r.props.class, e.class);
    i && (a.class = i);
    const l = Tt(r, h(h({}, a), {
      ref: "triggerRef"
    }), !0, !0), u = m(Qy, {
      key: "portal",
      getContainer: o && (() => o(this.getRootDomNode())),
      didUpdate: this.handlePortalUpdate,
      visible: this.$data.sPopupVisible
    }, {
      default: this.getComponent
    });
    return m(We, null, [l, u]);
  }
});
var WT = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const KT = (e) => {
  const t = e === !0 ? 0 : 1;
  return {
    bottomLeft: {
      points: ["tl", "bl"],
      offset: [0, 4],
      overflow: {
        adjustX: t,
        adjustY: 1
      }
    },
    bottomRight: {
      points: ["tr", "br"],
      offset: [0, 4],
      overflow: {
        adjustX: t,
        adjustY: 1
      }
    },
    topLeft: {
      points: ["bl", "tl"],
      offset: [0, -4],
      overflow: {
        adjustX: t,
        adjustY: 1
      }
    },
    topRight: {
      points: ["br", "tr"],
      offset: [0, -4],
      overflow: {
        adjustX: t,
        adjustY: 1
      }
    }
  };
}, UT = J({
  name: "SelectTrigger",
  inheritAttrs: !1,
  props: {
    dropdownAlign: Object,
    visible: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    dropdownClassName: String,
    dropdownStyle: W.object,
    placement: String,
    empty: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    popupClassName: String,
    animation: String,
    transitionName: String,
    getPopupContainer: Function,
    dropdownRender: Function,
    containerWidth: Number,
    dropdownMatchSelectWidth: W.oneOfType([Number, Boolean]).def(!0),
    popupElement: W.any,
    direction: String,
    getTriggerDOMNode: Function,
    onPopupVisibleChange: Function,
    onPopupMouseEnter: Function,
    onPopupFocusin: Function,
    onPopupFocusout: Function
  },
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: r
    } = t;
    const a = T(() => {
      const {
        dropdownMatchSelectWidth: l
      } = e;
      return KT(l);
    }), i = G();
    return r({
      getPopupElement: () => i.value
    }), () => {
      const l = h(h({}, e), o), {
        empty: u = !1
      } = l, s = WT(l, ["empty"]), {
        visible: c,
        dropdownAlign: d,
        prefixCls: f,
        popupElement: p,
        dropdownClassName: v,
        dropdownStyle: g,
        direction: b = "ltr",
        placement: y,
        dropdownMatchSelectWidth: S,
        containerWidth: w,
        dropdownRender: C,
        animation: $,
        transitionName: O,
        getPopupContainer: x,
        getTriggerDOMNode: M,
        onPopupVisibleChange: _,
        onPopupMouseEnter: N,
        onPopupFocusin: I,
        onPopupFocusout: E
      } = s, B = `${f}-dropdown`;
      let k = p;
      C && (k = C({
        menuNode: p,
        props: e
      }));
      const P = $ ? `${B}-${$}` : O, R = h({
        minWidth: `${w}px`
      }, g);
      return typeof S == "number" ? R.width = `${S}px` : S && (R.width = `${w}px`), m(wa, L(L({}, e), {}, {
        showAction: _ ? ["click"] : [],
        hideAction: _ ? ["click"] : [],
        popupPlacement: y || (b === "rtl" ? "bottomRight" : "bottomLeft"),
        builtinPlacements: a.value,
        prefixCls: B,
        popupTransitionName: P,
        popupAlign: d,
        popupVisible: c,
        getPopupContainer: x,
        popupClassName: ae(v, {
          [`${B}-empty`]: u
        }),
        popupStyle: R,
        getTriggerDOMNode: M,
        onPopupVisibleChange: _
      }), {
        default: n.default,
        popup: () => m("div", {
          ref: i,
          onMouseenter: N,
          onFocusin: I,
          onFocusout: E
        }, [k])
      });
    };
  }
}), ee = {
  /**
   * MAC_ENTER
   */
  MAC_ENTER: 3,
  /**
   * BACKSPACE
   */
  BACKSPACE: 8,
  /**
   * TAB
   */
  TAB: 9,
  /**
   * NUMLOCK on FF/Safari Mac
   */
  NUM_CENTER: 12,
  /**
   * ENTER
   */
  ENTER: 13,
  /**
   * SHIFT
   */
  SHIFT: 16,
  /**
   * CTRL
   */
  CTRL: 17,
  /**
   * ALT
   */
  ALT: 18,
  /**
   * PAUSE
   */
  PAUSE: 19,
  /**
   * CAPS_LOCK
   */
  CAPS_LOCK: 20,
  /**
   * ESC
   */
  ESC: 27,
  /**
   * SPACE
   */
  SPACE: 32,
  /**
   * PAGE_UP
   */
  PAGE_UP: 33,
  /**
   * PAGE_DOWN
   */
  PAGE_DOWN: 34,
  /**
   * END
   */
  END: 35,
  /**
   * HOME
   */
  HOME: 36,
  /**
   * LEFT
   */
  LEFT: 37,
  /**
   * UP
   */
  UP: 38,
  /**
   * RIGHT
   */
  RIGHT: 39,
  /**
   * DOWN
   */
  DOWN: 40,
  /**
   * PRINT_SCREEN
   */
  PRINT_SCREEN: 44,
  /**
   * INSERT
   */
  INSERT: 45,
  /**
   * DELETE
   */
  DELETE: 46,
  /**
   * ZERO
   */
  ZERO: 48,
  /**
   * ONE
   */
  ONE: 49,
  /**
   * TWO
   */
  TWO: 50,
  /**
   * THREE
   */
  THREE: 51,
  /**
   * FOUR
   */
  FOUR: 52,
  /**
   * FIVE
   */
  FIVE: 53,
  /**
   * SIX
   */
  SIX: 54,
  /**
   * SEVEN
   */
  SEVEN: 55,
  /**
   * EIGHT
   */
  EIGHT: 56,
  /**
   * NINE
   */
  NINE: 57,
  /**
   * QUESTION_MARK
   */
  QUESTION_MARK: 63,
  /**
   * A
   */
  A: 65,
  /**
   * B
   */
  B: 66,
  /**
   * C
   */
  C: 67,
  /**
   * D
   */
  D: 68,
  /**
   * E
   */
  E: 69,
  /**
   * F
   */
  F: 70,
  /**
   * G
   */
  G: 71,
  /**
   * H
   */
  H: 72,
  /**
   * I
   */
  I: 73,
  /**
   * J
   */
  J: 74,
  /**
   * K
   */
  K: 75,
  /**
   * L
   */
  L: 76,
  /**
   * M
   */
  M: 77,
  /**
   * N
   */
  N: 78,
  /**
   * O
   */
  O: 79,
  /**
   * P
   */
  P: 80,
  /**
   * Q
   */
  Q: 81,
  /**
   * R
   */
  R: 82,
  /**
   * S
   */
  S: 83,
  /**
   * T
   */
  T: 84,
  /**
   * U
   */
  U: 85,
  /**
   * V
   */
  V: 86,
  /**
   * W
   */
  W: 87,
  /**
   * X
   */
  X: 88,
  /**
   * Y
   */
  Y: 89,
  /**
   * Z
   */
  Z: 90,
  /**
   * META
   */
  META: 91,
  /**
   * WIN_KEY_RIGHT
   */
  WIN_KEY_RIGHT: 92,
  /**
   * CONTEXT_MENU
   */
  CONTEXT_MENU: 93,
  /**
   * NUM_ZERO
   */
  NUM_ZERO: 96,
  /**
   * NUM_ONE
   */
  NUM_ONE: 97,
  /**
   * NUM_TWO
   */
  NUM_TWO: 98,
  /**
   * NUM_THREE
   */
  NUM_THREE: 99,
  /**
   * NUM_FOUR
   */
  NUM_FOUR: 100,
  /**
   * NUM_FIVE
   */
  NUM_FIVE: 101,
  /**
   * NUM_SIX
   */
  NUM_SIX: 102,
  /**
   * NUM_SEVEN
   */
  NUM_SEVEN: 103,
  /**
   * NUM_EIGHT
   */
  NUM_EIGHT: 104,
  /**
   * NUM_NINE
   */
  NUM_NINE: 105,
  /**
   * NUM_MULTIPLY
   */
  NUM_MULTIPLY: 106,
  /**
   * NUM_PLUS
   */
  NUM_PLUS: 107,
  /**
   * NUM_MINUS
   */
  NUM_MINUS: 109,
  /**
   * NUM_PERIOD
   */
  NUM_PERIOD: 110,
  /**
   * NUM_DIVISION
   */
  NUM_DIVISION: 111,
  /**
   * F1
   */
  F1: 112,
  /**
   * F2
   */
  F2: 113,
  /**
   * F3
   */
  F3: 114,
  /**
   * F4
   */
  F4: 115,
  /**
   * F5
   */
  F5: 116,
  /**
   * F6
   */
  F6: 117,
  /**
   * F7
   */
  F7: 118,
  /**
   * F8
   */
  F8: 119,
  /**
   * F9
   */
  F9: 120,
  /**
   * F10
   */
  F10: 121,
  /**
   * F11
   */
  F11: 122,
  /**
   * F12
   */
  F12: 123,
  /**
   * NUMLOCK
   */
  NUMLOCK: 144,
  /**
   * SEMICOLON
   */
  SEMICOLON: 186,
  /**
   * DASH
   */
  DASH: 189,
  /**
   * EQUALS
   */
  EQUALS: 187,
  /**
   * COMMA
   */
  COMMA: 188,
  /**
   * PERIOD
   */
  PERIOD: 190,
  /**
   * SLASH
   */
  SLASH: 191,
  /**
   * APOSTROPHE
   */
  APOSTROPHE: 192,
  /**
   * SINGLE_QUOTE
   */
  SINGLE_QUOTE: 222,
  /**
   * OPEN_SQUARE_BRACKET
   */
  OPEN_SQUARE_BRACKET: 219,
  /**
   * BACKSLASH
   */
  BACKSLASH: 220,
  /**
   * CLOSE_SQUARE_BRACKET
   */
  CLOSE_SQUARE_BRACKET: 221,
  /**
   * WIN_KEY
   */
  WIN_KEY: 224,
  /**
   * MAC_FF_META
   */
  MAC_FF_META: 224,
  /**
   * WIN_IME
   */
  WIN_IME: 229,
  // ======================== Function ========================
  /**
   * whether text and modified key is entered at the same time.
   */
  isTextModifyingKeyEvent: function(t) {
    const {
      keyCode: n
    } = t;
    if (t.altKey && !t.ctrlKey || t.metaKey || // Function keys don't generate text
    n >= ee.F1 && n <= ee.F12)
      return !1;
    switch (n) {
      case ee.ALT:
      case ee.CAPS_LOCK:
      case ee.CONTEXT_MENU:
      case ee.CTRL:
      case ee.DOWN:
      case ee.END:
      case ee.ESC:
      case ee.HOME:
      case ee.INSERT:
      case ee.LEFT:
      case ee.MAC_FF_META:
      case ee.META:
      case ee.NUMLOCK:
      case ee.NUM_CENTER:
      case ee.PAGE_DOWN:
      case ee.PAGE_UP:
      case ee.PAUSE:
      case ee.PRINT_SCREEN:
      case ee.RIGHT:
      case ee.SHIFT:
      case ee.UP:
      case ee.WIN_KEY:
      case ee.WIN_KEY_RIGHT:
        return !1;
      default:
        return !0;
    }
  },
  /**
   * whether character is entered.
   */
  isCharacterKey: function(t) {
    if (t >= ee.ZERO && t <= ee.NINE || t >= ee.NUM_ZERO && t <= ee.NUM_MULTIPLY || t >= ee.A && t <= ee.Z || window.navigator.userAgent.indexOf("WebKit") !== -1 && t === 0)
      return !0;
    switch (t) {
      case ee.SPACE:
      case ee.QUESTION_MARK:
      case ee.NUM_PLUS:
      case ee.NUM_MINUS:
      case ee.NUM_PERIOD:
      case ee.NUM_DIVISION:
      case ee.SEMICOLON:
      case ee.DASH:
      case ee.EQUALS:
      case ee.COMMA:
      case ee.PERIOD:
      case ee.SLASH:
      case ee.APOSTROPHE:
      case ee.SINGLE_QUOTE:
      case ee.OPEN_SQUARE_BRACKET:
      case ee.BACKSLASH:
      case ee.CLOSE_SQUARE_BRACKET:
        return !0;
      default:
        return !1;
    }
  }
}, xr = (e, t) => {
  let {
    slots: n
  } = t;
  var o;
  const {
    class: r,
    customizeIcon: a,
    customizeIconProps: i,
    onMousedown: l,
    onClick: u
  } = e;
  let s;
  return typeof a == "function" ? s = a(i) : s = Wo(a) ? Ko(a) : a, m("span", {
    class: r,
    onMousedown: (c) => {
      c.preventDefault(), l && l(c);
    },
    style: {
      userSelect: "none",
      WebkitUserSelect: "none"
    },
    unselectable: "on",
    onClick: u,
    "aria-hidden": !0
  }, [s !== void 0 ? s : m("span", {
    class: r.split(/\s+/).map((c) => `${c}-icon`)
  }, [(o = n.default) === null || o === void 0 ? void 0 : o.call(n)])]);
};
xr.inheritAttrs = !1;
xr.displayName = "TransBtn";
xr.props = {
  class: String,
  customizeIcon: W.any,
  customizeIconProps: W.any,
  onMousedown: Function,
  onClick: Function
};
var GT = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const Ss = J({
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: !1,
  props: {
    disabled: W.looseBool,
    type: W.string,
    value: W.any,
    lazy: W.bool.def(!0),
    tag: {
      type: String,
      default: "input"
    },
    size: W.string
  },
  emits: ["change", "input", "blur", "keydown", "focus", "compositionstart", "compositionend", "keyup"],
  setup(e, t) {
    let {
      emit: n,
      attrs: o,
      expose: r
    } = t;
    const a = K(null), i = G(), l = G(!1);
    le([() => e.value, l], () => {
      l.value || (i.value = e.value);
    }, {
      immediate: !0
    });
    const u = (C) => {
      n("change", C);
    }, s = (C) => {
      l.value = !0, C.target.composing = !0, n("compositionstart", C);
    }, c = (C) => {
      l.value = !1, C.target.composing = !1, n("compositionend", C);
      const $ = document.createEvent("HTMLEvents");
      $.initEvent("input", !0, !0), C.target.dispatchEvent($);
    }, d = (C) => {
      if (l.value && e.lazy) {
        i.value = C.target.value;
        return;
      }
      n("input", C);
    }, f = (C) => {
      n("blur", C);
    }, p = (C) => {
      n("focus", C);
    }, v = () => {
      a.value && a.value.focus();
    }, g = () => {
      a.value && a.value.blur();
    }, b = (C) => {
      n("keydown", C);
    }, y = (C) => {
      n("keyup", C);
    };
    return r({
      focus: v,
      blur: g,
      input: a,
      setSelectionRange: (C, $, O) => {
        var x;
        (x = a.value) === null || x === void 0 || x.setSelectionRange(C, $, O);
      },
      select: () => {
        var C;
        (C = a.value) === null || C === void 0 || C.select();
      },
      getSelectionStart: () => {
        var C;
        return (C = a.value) === null || C === void 0 ? void 0 : C.selectionStart;
      },
      getSelectionEnd: () => {
        var C;
        return (C = a.value) === null || C === void 0 ? void 0 : C.selectionEnd;
      },
      getScrollTop: () => {
        var C;
        return (C = a.value) === null || C === void 0 ? void 0 : C.scrollTop;
      }
    }), () => {
      const {
        tag: C
      } = e, $ = GT(e, ["tag"]);
      return m(C, L(L(L({}, $), o), {}, {
        onInput: d,
        onChange: u,
        onBlur: f,
        onFocus: p,
        ref: a,
        value: i.value,
        onCompositionstart: s,
        onCompositionend: c,
        onKeyup: y,
        onKeydown: b
      }), null);
    };
  }
}), YT = {
  inputRef: W.any,
  prefixCls: String,
  id: String,
  inputElement: W.VueNode,
  disabled: {
    type: Boolean,
    default: void 0
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  autocomplete: String,
  editable: {
    type: Boolean,
    default: void 0
  },
  activeDescendantId: String,
  value: String,
  open: {
    type: Boolean,
    default: void 0
  },
  tabindex: W.oneOfType([W.number, W.string]),
  /** Pass accessibility props to input */
  attrs: W.object,
  onKeydown: {
    type: Function
  },
  onMousedown: {
    type: Function
  },
  onChange: {
    type: Function
  },
  onPaste: {
    type: Function
  },
  onCompositionstart: {
    type: Function
  },
  onCompositionend: {
    type: Function
  },
  onFocus: {
    type: Function
  },
  onBlur: {
    type: Function
  }
}, Zy = J({
  compatConfig: {
    MODE: 3
  },
  name: "SelectInput",
  inheritAttrs: !1,
  props: YT,
  setup(e) {
    let t = null;
    const n = nt("VCSelectContainerEvent");
    return () => {
      var o;
      const {
        prefixCls: r,
        id: a,
        inputElement: i,
        disabled: l,
        tabindex: u,
        autofocus: s,
        autocomplete: c,
        editable: d,
        activeDescendantId: f,
        value: p,
        onKeydown: v,
        onMousedown: g,
        onChange: b,
        onPaste: y,
        onCompositionstart: S,
        onCompositionend: w,
        onFocus: C,
        onBlur: $,
        open: O,
        inputRef: x,
        attrs: M
      } = e;
      let _ = i || m(Ss, null, null);
      const N = _.props || {}, {
        onKeydown: I,
        onInput: E,
        onFocus: B,
        onBlur: k,
        onMousedown: P,
        onCompositionstart: R,
        onCompositionend: D,
        style: A
      } = N;
      return _ = Tt(_, h(h(h(h(h({
        type: "search"
      }, N), {
        id: a,
        ref: x,
        disabled: l,
        tabindex: u,
        autocomplete: c || "off",
        autofocus: s,
        class: ae(`${r}-selection-search-input`, (o = _ == null ? void 0 : _.props) === null || o === void 0 ? void 0 : o.class),
        role: "combobox",
        "aria-expanded": O,
        "aria-haspopup": "listbox",
        "aria-owns": `${a}_list`,
        "aria-autocomplete": "list",
        "aria-controls": `${a}_list`,
        "aria-activedescendant": f
      }), M), {
        value: d ? p : "",
        readonly: !d,
        unselectable: d ? null : "on",
        style: h(h({}, A), {
          opacity: d ? null : 0
        }),
        onKeydown: (H) => {
          v(H), I && I(H);
        },
        onMousedown: (H) => {
          g(H), P && P(H);
        },
        onInput: (H) => {
          b(H), E && E(H);
        },
        onCompositionstart(H) {
          S(H), R && R(H);
        },
        onCompositionend(H) {
          w(H), D && D(H);
        },
        onPaste: y,
        onFocus: function() {
          clearTimeout(t), B && B(arguments.length <= 0 ? void 0 : arguments[0]), C && C(arguments.length <= 0 ? void 0 : arguments[0]), n == null || n.focus(arguments.length <= 0 ? void 0 : arguments[0]);
        },
        onBlur: function() {
          for (var H = arguments.length, j = new Array(H), z = 0; z < H; z++)
            j[z] = arguments[z];
          t = setTimeout(() => {
            k && k(j[0]), $ && $(j[0]), n == null || n.blur(j[0]);
          }, 100);
        }
      }), _.type === "textarea" ? {} : {
        type: "search"
      }), !0, !0), _;
    };
  }
}), XT = `accept acceptcharset accesskey action allowfullscreen allowtransparency
alt async autocomplete autofocus autoplay capture cellpadding cellspacing challenge
charset checked classid classname colspan cols content contenteditable contextmenu
controls coords crossorigin data datetime default defer dir disabled download draggable
enctype form formaction formenctype formmethod formnovalidate formtarget frameborder
headers height hidden high href hreflang htmlfor for httpequiv icon id inputmode integrity
is keyparams keytype kind label lang list loop low manifest marginheight marginwidth max maxlength media
mediagroup method min minlength multiple muted name novalidate nonce open
optimum pattern placeholder poster preload radiogroup readonly rel required
reversed role rowspan rows sandbox scope scoped scrolling seamless selected
shape size sizes span spellcheck src srcdoc srclang srcset start step style
summary tabindex target title type usemap value width wmode wrap`, qT = `onCopy onCut onPaste onCompositionend onCompositionstart onCompositionupdate onKeydown
    onKeypress onKeyup onFocus onBlur onChange onInput onSubmit onClick onContextmenu onDoubleclick onDblclick
    onDrag onDragend onDragenter onDragexit onDragleave onDragover onDragstart onDrop onMousedown
    onMouseenter onMouseleave onMousemove onMouseout onMouseover onMouseup onSelect onTouchcancel
    onTouchend onTouchmove onTouchstart onTouchstartPassive onTouchmovePassive onScroll onWheel onAbort onCanplay onCanplaythrough
    onDurationchange onEmptied onEncrypted onEnded onError onLoadeddata onLoadedmetadata
    onLoadstart onPause onPlay onPlaying onProgress onRatechange onSeeked onSeeking onStalled onSuspend onTimeupdate onVolumechange onWaiting onLoad onError`, nm = `${XT} ${qT}`.split(/[\s\n]+/), QT = "aria-", ZT = "data-";
function om(e, t) {
  return e.indexOf(t) === 0;
}
function _r(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n;
  t === !1 ? n = {
    aria: !0,
    data: !0,
    attr: !0
  } : t === !0 ? n = {
    aria: !0
  } : n = h({}, t);
  const o = {};
  return Object.keys(e).forEach((r) => {
    // Aria
    (n.aria && (r === "role" || om(r, QT)) || // Data
    n.data && om(r, ZT) || // Attr
    n.attr && (nm.includes(r) || nm.includes(r.toLowerCase()))) && (o[r] = e[r]);
  }), o;
}
const Jy = Symbol("OverflowContextProviderKey"), _c = J({
  compatConfig: {
    MODE: 3
  },
  name: "OverflowContextProvider",
  inheritAttrs: !1,
  props: {
    value: {
      type: Object
    }
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ot(Jy, T(() => e.value)), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
}), JT = () => nt(Jy, T(() => null));
var eE = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const kr = void 0, cl = J({
  compatConfig: {
    MODE: 3
  },
  name: "Item",
  props: {
    prefixCls: String,
    item: W.any,
    renderItem: Function,
    responsive: Boolean,
    itemKey: {
      type: [String, Number]
    },
    registerSize: Function,
    display: Boolean,
    order: Number,
    component: W.any,
    invalidate: Boolean
  },
  setup(e, t) {
    let {
      slots: n,
      expose: o
    } = t;
    const r = T(() => e.responsive && !e.display), a = G();
    o({
      itemNodeRef: a
    });
    function i(l) {
      e.registerSize(e.itemKey, l);
    }
    return Xo(() => {
      i(null);
    }), () => {
      var l;
      const {
        prefixCls: u,
        invalidate: s,
        item: c,
        renderItem: d,
        responsive: f,
        registerSize: p,
        itemKey: v,
        display: g,
        order: b,
        component: y = "div"
      } = e, S = eE(e, ["prefixCls", "invalidate", "item", "renderItem", "responsive", "registerSize", "itemKey", "display", "order", "component"]), w = (l = n.default) === null || l === void 0 ? void 0 : l.call(n), C = d && c !== kr ? d(c) : w;
      let $;
      s || ($ = {
        opacity: r.value ? 0 : 1,
        height: r.value ? 0 : kr,
        overflowY: r.value ? "hidden" : kr,
        order: f ? b : kr,
        pointerEvents: r.value ? "none" : kr,
        position: r.value ? "absolute" : kr
      });
      const O = {};
      return r.value && (O["aria-hidden"] = !0), m(br, {
        disabled: !f,
        onResize: (x) => {
          let {
            offsetWidth: M
          } = x;
          i(M);
        }
      }, {
        default: () => m(y, L(L(L({
          class: ae(!s && u),
          style: $
        }, O), S), {}, {
          ref: a
        }), {
          default: () => [C]
        })
      });
    };
  }
});
var bu = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const tE = J({
  compatConfig: {
    MODE: 3
  },
  name: "RawItem",
  inheritAttrs: !1,
  props: {
    component: W.any,
    title: W.any,
    id: String,
    onMouseenter: {
      type: Function
    },
    onMouseleave: {
      type: Function
    },
    onClick: {
      type: Function
    },
    onKeydown: {
      type: Function
    },
    onFocus: {
      type: Function
    },
    role: String,
    tabindex: Number
  },
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const r = JT();
    return () => {
      var a;
      if (!r.value) {
        const {
          component: d = "div"
        } = e, f = bu(e, ["component"]);
        return m(d, L(L({}, f), o), {
          default: () => [(a = n.default) === null || a === void 0 ? void 0 : a.call(n)]
        });
      }
      const i = r.value, {
        className: l
      } = i, u = bu(i, ["className"]), {
        class: s
      } = o, c = bu(o, ["class"]);
      return m(_c, {
        value: null
      }, {
        default: () => [m(cl, L(L(L({
          class: ae(l, s)
        }, u), c), e), n)]
      });
    };
  }
});
var nE = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const e0 = "responsive", t0 = "invalidate";
function oE(e) {
  return `+ ${e.length} ...`;
}
const rE = () => ({
  id: String,
  prefixCls: String,
  data: Array,
  itemKey: [String, Number, Function],
  /** Used for `responsive`. It will limit render node to avoid perf issue */
  itemWidth: {
    type: Number,
    default: 10
  },
  renderItem: Function,
  /** @private Do not use in your production. Render raw node that need wrap Item by developer self */
  renderRawItem: Function,
  maxCount: [Number, String],
  renderRest: Function,
  /** @private Do not use in your production. Render raw node that need wrap Item by developer self */
  renderRawRest: Function,
  suffix: W.any,
  component: String,
  itemComponent: W.any,
  /** @private This API may be refactor since not well design */
  onVisibleChange: Function,
  /** When set to `full`, ssr will render full items by default and remove at client side */
  ssr: String,
  onMousedown: Function
}), mo = J({
  name: "Overflow",
  inheritAttrs: !1,
  props: rE(),
  emits: ["visibleChange"],
  setup(e, t) {
    let {
      attrs: n,
      emit: o,
      slots: r
    } = t;
    const a = T(() => e.ssr === "full"), i = K(null), l = T(() => i.value || 0), u = K(/* @__PURE__ */ new Map()), s = K(0), c = K(0), d = K(0), f = K(null), p = K(null), v = T(() => p.value === null && a.value ? Number.MAX_SAFE_INTEGER : p.value || 0), g = K(!1), b = T(() => `${e.prefixCls}-item`), y = T(() => Math.max(s.value, c.value)), S = T(() => !!(e.data.length && e.maxCount === e0)), w = T(() => e.maxCount === t0), C = T(() => S.value || typeof e.maxCount == "number" && e.data.length > e.maxCount), $ = T(() => {
      let P = e.data;
      return S.value ? i.value === null && a.value ? P = e.data : P = e.data.slice(0, Math.min(e.data.length, l.value / e.itemWidth)) : typeof e.maxCount == "number" && (P = e.data.slice(0, e.maxCount)), P;
    }), O = T(() => S.value ? e.data.slice(v.value + 1) : e.data.slice($.value.length)), x = (P, R) => {
      var D;
      return typeof e.itemKey == "function" ? e.itemKey(P) : (D = e.itemKey && (P == null ? void 0 : P[e.itemKey])) !== null && D !== void 0 ? D : R;
    }, M = T(() => e.renderItem || ((P) => P)), _ = (P, R) => {
      p.value = P, R || (g.value = P < e.data.length - 1, o("visibleChange", P));
    }, N = (P, R) => {
      i.value = R.clientWidth;
    }, I = (P, R) => {
      const D = new Map(u.value);
      R === null ? D.delete(P) : D.set(P, R), u.value = D;
    }, E = (P, R) => {
      s.value = c.value, c.value = R;
    }, B = (P, R) => {
      d.value = R;
    }, k = (P) => u.value.get(x($.value[P], P));
    return le([l, u, c, d, () => e.itemKey, $], () => {
      if (l.value && y.value && $.value) {
        let P = d.value;
        const R = $.value.length, D = R - 1;
        if (!R) {
          _(0), f.value = null;
          return;
        }
        for (let A = 0; A < R; A += 1) {
          const H = k(A);
          if (H === void 0) {
            _(A - 1, !0);
            break;
          }
          if (P += H, // Only one means `totalWidth` is the final width
          D === 0 && P <= l.value || // Last two width will be the final width
          A === D - 1 && P + k(D) <= l.value) {
            _(D), f.value = null;
            break;
          } else if (P + y.value > l.value) {
            _(A - 1), f.value = P - H - d.value + c.value;
            break;
          }
        }
        e.suffix && k(0) + d.value > l.value && (f.value = null);
      }
    }), () => {
      const P = g.value && !!O.value.length, {
        itemComponent: R,
        renderRawItem: D,
        renderRawRest: A,
        renderRest: H,
        prefixCls: j = "rc-overflow",
        suffix: z,
        component: F = "div",
        id: U,
        onMousedown: Q
      } = e, {
        class: q,
        style: oe
      } = n, Z = nE(n, ["class", "style"]);
      let ne = {};
      f.value !== null && S.value && (ne = {
        position: "absolute",
        left: `${f.value}px`,
        top: 0
      });
      const Y = {
        prefixCls: b.value,
        responsive: S.value,
        component: R,
        invalidate: w.value
      }, V = D ? (he, ge) => {
        const we = x(he, ge);
        return m(_c, {
          key: we,
          value: h(h({}, Y), {
            order: ge,
            item: he,
            itemKey: we,
            registerSize: I,
            display: ge <= v.value
          })
        }, {
          default: () => [D(he, ge)]
        });
      } : (he, ge) => {
        const we = x(he, ge);
        return m(cl, L(L({}, Y), {}, {
          order: ge,
          key: we,
          item: he,
          renderItem: M.value,
          itemKey: we,
          registerSize: I,
          display: ge <= v.value
        }), null);
      };
      let X = () => null;
      const re = {
        order: P ? v.value : Number.MAX_SAFE_INTEGER,
        className: `${b.value} ${b.value}-rest`,
        registerSize: E,
        display: P
      };
      if (A)
        A && (X = () => m(_c, {
          value: h(h({}, Y), re)
        }, {
          default: () => [A(O.value)]
        }));
      else {
        const he = H || oE;
        X = () => m(cl, L(L({}, Y), re), {
          default: () => typeof he == "function" ? he(O.value) : he
        });
      }
      const ie = () => {
        var he;
        return m(F, L({
          id: U,
          class: ae(!w.value && j, q),
          style: oe,
          onMousedown: Q
        }, Z), {
          default: () => [$.value.map(V), C.value ? X() : null, z && m(cl, L(L({}, Y), {}, {
            order: v.value,
            class: `${b.value}-suffix`,
            registerSize: B,
            display: !0,
            style: ne
          }), {
            default: () => z
          }), (he = r.default) === null || he === void 0 ? void 0 : he.call(r)]
        });
      };
      return m(br, {
        disabled: !S.value,
        onResize: N
      }, {
        default: ie
      });
    };
  }
});
mo.Item = tE;
mo.RESPONSIVE = e0;
mo.INVALIDATE = t0;
const n0 = Symbol("TreeSelectLegacyContextPropsKey");
function aE(e) {
  return ot(n0, e);
}
function $s() {
  return nt(n0, {});
}
const iE = {
  id: String,
  prefixCls: String,
  values: W.array,
  open: {
    type: Boolean,
    default: void 0
  },
  searchValue: String,
  inputRef: W.any,
  placeholder: W.any,
  disabled: {
    type: Boolean,
    default: void 0
  },
  mode: String,
  showSearch: {
    type: Boolean,
    default: void 0
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  autocomplete: String,
  activeDescendantId: String,
  tabindex: W.oneOfType([W.number, W.string]),
  removeIcon: W.any,
  choiceTransitionName: String,
  maxTagCount: W.oneOfType([W.number, W.string]),
  maxTagTextLength: Number,
  maxTagPlaceholder: W.any.def(() => (e) => `+ ${e.length} ...`),
  tagRender: Function,
  onToggleOpen: {
    type: Function
  },
  onRemove: Function,
  onInputChange: Function,
  onInputPaste: Function,
  onInputKeyDown: Function,
  onInputMouseDown: Function,
  onInputCompositionStart: Function,
  onInputCompositionEnd: Function
}, rm = (e) => {
  e.preventDefault(), e.stopPropagation();
}, lE = J({
  name: "MultipleSelectSelector",
  inheritAttrs: !1,
  props: iE,
  setup(e) {
    const t = K(), n = K(0), o = K(!1), r = $s(), a = T(() => `${e.prefixCls}-selection`), i = T(() => e.open || e.mode === "tags" ? e.searchValue : ""), l = T(() => e.mode === "tags" || e.showSearch && (e.open || o.value));
    ze(() => {
      le(i, () => {
        n.value = t.value.scrollWidth;
      }, {
        flush: "post",
        immediate: !0
      });
    });
    function u(f, p, v, g, b) {
      return m("span", {
        class: ae(`${a.value}-item`, {
          [`${a.value}-item-disabled`]: v
        }),
        title: typeof f == "string" || typeof f == "number" ? f.toString() : void 0
      }, [m("span", {
        class: `${a.value}-item-content`
      }, [p]), g && m(xr, {
        class: `${a.value}-item-remove`,
        onMousedown: rm,
        onClick: b,
        customizeIcon: e.removeIcon
      }, {
        default: () => [Se("×")]
      })]);
    }
    function s(f, p, v, g, b, y) {
      var S;
      const w = ($) => {
        rm($), e.onToggleOpen(!open);
      };
      let C = y;
      return r.keyEntities && (C = ((S = r.keyEntities[f]) === null || S === void 0 ? void 0 : S.node) || {}), m("span", {
        key: f,
        onMousedown: w
      }, [e.tagRender({
        label: p,
        value: f,
        disabled: v,
        closable: g,
        onClose: b,
        option: C
      })]);
    }
    function c(f) {
      const {
        disabled: p,
        label: v,
        value: g,
        option: b
      } = f, y = !e.disabled && !p;
      let S = v;
      if (typeof e.maxTagTextLength == "number" && (typeof v == "string" || typeof v == "number")) {
        const C = String(S);
        C.length > e.maxTagTextLength && (S = `${C.slice(0, e.maxTagTextLength)}...`);
      }
      const w = (C) => {
        var $;
        C && C.stopPropagation(), ($ = e.onRemove) === null || $ === void 0 || $.call(e, f);
      };
      return typeof e.tagRender == "function" ? s(g, S, p, y, w, b) : u(v, S, p, y, w);
    }
    function d(f) {
      const {
        maxTagPlaceholder: p = (g) => `+ ${g.length} ...`
      } = e, v = typeof p == "function" ? p(f) : p;
      return u(v, v, !1);
    }
    return () => {
      const {
        id: f,
        prefixCls: p,
        values: v,
        open: g,
        inputRef: b,
        placeholder: y,
        disabled: S,
        autofocus: w,
        autocomplete: C,
        activeDescendantId: $,
        tabindex: O,
        onInputChange: x,
        onInputPaste: M,
        onInputKeyDown: _,
        onInputMouseDown: N,
        onInputCompositionStart: I,
        onInputCompositionEnd: E
      } = e, B = m("div", {
        class: `${a.value}-search`,
        style: {
          width: n.value + "px"
        },
        key: "input"
      }, [m(Zy, {
        inputRef: b,
        open: g,
        prefixCls: p,
        id: f,
        inputElement: null,
        disabled: S,
        autofocus: w,
        autocomplete: C,
        editable: l.value,
        activeDescendantId: $,
        value: i.value,
        onKeydown: _,
        onMousedown: N,
        onChange: x,
        onPaste: M,
        onCompositionstart: I,
        onCompositionend: E,
        tabindex: O,
        attrs: _r(e, !0),
        onFocus: () => o.value = !0,
        onBlur: () => o.value = !1
      }, null), m("span", {
        ref: t,
        class: `${a.value}-search-mirror`,
        "aria-hidden": !0
      }, [i.value, Se(" ")])]), k = m(mo, {
        prefixCls: `${a.value}-overflow`,
        data: v,
        renderItem: c,
        renderRest: d,
        suffix: B,
        itemKey: "key",
        maxCount: e.maxTagCount,
        key: "overflow"
      }, null);
      return m(We, null, [k, !v.length && !i.value && m("span", {
        class: `${a.value}-placeholder`
      }, [y])]);
    };
  }
}), sE = {
  inputElement: W.any,
  id: String,
  prefixCls: String,
  values: W.array,
  open: {
    type: Boolean,
    default: void 0
  },
  searchValue: String,
  inputRef: W.any,
  placeholder: W.any,
  disabled: {
    type: Boolean,
    default: void 0
  },
  mode: String,
  showSearch: {
    type: Boolean,
    default: void 0
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  autocomplete: String,
  activeDescendantId: String,
  tabindex: W.oneOfType([W.number, W.string]),
  activeValue: String,
  backfill: {
    type: Boolean,
    default: void 0
  },
  optionLabelRender: Function,
  onInputChange: Function,
  onInputPaste: Function,
  onInputKeyDown: Function,
  onInputMouseDown: Function,
  onInputCompositionStart: Function,
  onInputCompositionEnd: Function
}, Xd = J({
  name: "SingleSelector",
  setup(e) {
    const t = K(!1), n = T(() => e.mode === "combobox"), o = T(() => n.value || e.showSearch), r = T(() => {
      let s = e.searchValue || "";
      return n.value && e.activeValue && !t.value && (s = e.activeValue), s;
    }), a = $s();
    le([n, () => e.activeValue], () => {
      n.value && (t.value = !1);
    }, {
      immediate: !0
    });
    const i = T(() => e.mode !== "combobox" && !e.open && !e.showSearch ? !1 : !!r.value), l = T(() => {
      const s = e.values[0];
      return s && (typeof s.label == "string" || typeof s.label == "number") ? s.label.toString() : void 0;
    }), u = () => {
      if (e.values[0])
        return null;
      const s = i.value ? {
        visibility: "hidden"
      } : void 0;
      return m("span", {
        class: `${e.prefixCls}-selection-placeholder`,
        style: s
      }, [e.placeholder]);
    };
    return () => {
      var s, c, d, f;
      const {
        inputElement: p,
        prefixCls: v,
        id: g,
        values: b,
        inputRef: y,
        disabled: S,
        autofocus: w,
        autocomplete: C,
        activeDescendantId: $,
        open: O,
        tabindex: x,
        optionLabelRender: M,
        onInputKeyDown: _,
        onInputMouseDown: N,
        onInputChange: I,
        onInputPaste: E,
        onInputCompositionStart: B,
        onInputCompositionEnd: k
      } = e, P = b[0];
      let R = null;
      if (P && a.customSlots) {
        const D = (s = P.key) !== null && s !== void 0 ? s : P.value, A = ((c = a.keyEntities[D]) === null || c === void 0 ? void 0 : c.node) || {};
        R = a.customSlots[(d = A.slots) === null || d === void 0 ? void 0 : d.title] || a.customSlots.title || P.label, typeof R == "function" && (R = R(A));
      } else
        R = M && P ? M(P.option) : P == null ? void 0 : P.label;
      return m(We, null, [m("span", {
        class: `${v}-selection-search`
      }, [m(Zy, {
        inputRef: y,
        prefixCls: v,
        id: g,
        open: O,
        inputElement: p,
        disabled: S,
        autofocus: w,
        autocomplete: C,
        editable: o.value,
        activeDescendantId: $,
        value: r.value,
        onKeydown: _,
        onMousedown: N,
        onChange: (D) => {
          t.value = !0, I(D);
        },
        onPaste: E,
        onCompositionstart: B,
        onCompositionend: k,
        tabindex: x,
        attrs: _r(e, !0)
      }, null)]), !n.value && P && !i.value && m("span", {
        class: `${v}-selection-item`,
        title: l.value
      }, [m(We, {
        key: (f = P.key) !== null && f !== void 0 ? f : P.value
      }, [R])]), u()]);
    };
  }
});
Xd.props = sE;
Xd.inheritAttrs = !1;
function uE(e) {
  return ![
    // System function button
    ee.ESC,
    ee.SHIFT,
    ee.BACKSPACE,
    ee.TAB,
    ee.WIN_KEY,
    ee.ALT,
    ee.META,
    ee.WIN_KEY_RIGHT,
    ee.CTRL,
    ee.SEMICOLON,
    ee.EQUALS,
    ee.CAPS_LOCK,
    ee.CONTEXT_MENU,
    // F1-F12
    ee.F1,
    ee.F2,
    ee.F3,
    ee.F4,
    ee.F5,
    ee.F6,
    ee.F7,
    ee.F8,
    ee.F9,
    ee.F10,
    ee.F11,
    ee.F12
  ].includes(e);
}
function o0() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 250, t = null, n;
  at(() => {
    clearTimeout(n);
  });
  function o(r) {
    (r || t === null) && (t = r), clearTimeout(n), n = setTimeout(() => {
      t = null;
    }, e);
  }
  return [() => t, o];
}
function gi() {
  const e = (t) => {
    e.current = t;
  };
  return e;
}
const cE = J({
  name: "Selector",
  inheritAttrs: !1,
  props: {
    id: String,
    prefixCls: String,
    showSearch: {
      type: Boolean,
      default: void 0
    },
    open: {
      type: Boolean,
      default: void 0
    },
    /** Display in the Selector value, it's not same as `value` prop */
    values: W.array,
    multiple: {
      type: Boolean,
      default: void 0
    },
    mode: String,
    searchValue: String,
    activeValue: String,
    inputElement: W.any,
    autofocus: {
      type: Boolean,
      default: void 0
    },
    activeDescendantId: String,
    tabindex: W.oneOfType([W.number, W.string]),
    disabled: {
      type: Boolean,
      default: void 0
    },
    placeholder: W.any,
    removeIcon: W.any,
    // Tags
    maxTagCount: W.oneOfType([W.number, W.string]),
    maxTagTextLength: Number,
    maxTagPlaceholder: W.any,
    tagRender: Function,
    optionLabelRender: Function,
    /** Check if `tokenSeparators` contains `\n` or `\r\n` */
    tokenWithEnter: {
      type: Boolean,
      default: void 0
    },
    // Motion
    choiceTransitionName: String,
    onToggleOpen: {
      type: Function
    },
    /** `onSearch` returns go next step boolean to check if need do toggle open */
    onSearch: Function,
    onSearchSubmit: Function,
    onRemove: Function,
    onInputKeyDown: {
      type: Function
    },
    /**
     * @private get real dom for trigger align.
     * This may be removed after React provides replacement of `findDOMNode`
     */
    domRef: Function
  },
  setup(e, t) {
    let {
      expose: n
    } = t;
    const o = gi();
    let r = !1;
    const [a, i] = o0(0), l = (y) => {
      const {
        which: S
      } = y;
      (S === ee.UP || S === ee.DOWN) && y.preventDefault(), e.onInputKeyDown && e.onInputKeyDown(y), S === ee.ENTER && e.mode === "tags" && !r && !e.open && e.onSearchSubmit(y.target.value), uE(S) && e.onToggleOpen(!0);
    }, u = () => {
      i(!0);
    };
    let s = null;
    const c = (y) => {
      e.onSearch(y, !0, r) !== !1 && e.onToggleOpen(!0);
    }, d = () => {
      r = !0;
    }, f = (y) => {
      r = !1, e.mode !== "combobox" && c(y.target.value);
    }, p = (y) => {
      let {
        target: {
          value: S
        }
      } = y;
      if (e.tokenWithEnter && s && /[\r\n]/.test(s)) {
        const w = s.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
        S = S.replace(w, s);
      }
      s = null, c(S);
    }, v = (y) => {
      const {
        clipboardData: S
      } = y;
      s = S.getData("text");
    }, g = (y) => {
      let {
        target: S
      } = y;
      S !== o.current && (document.body.style.msTouchAction !== void 0 ? setTimeout(() => {
        o.current.focus();
      }) : o.current.focus());
    }, b = (y) => {
      const S = a();
      y.target !== o.current && !S && y.preventDefault(), (e.mode !== "combobox" && (!e.showSearch || !S) || !e.open) && (e.open && e.onSearch("", !0, !1), e.onToggleOpen());
    };
    return n({
      focus: () => {
        o.current.focus();
      },
      blur: () => {
        o.current.blur();
      }
    }), () => {
      const {
        prefixCls: y,
        domRef: S,
        mode: w
      } = e, C = {
        inputRef: o,
        onInputKeyDown: l,
        onInputMouseDown: u,
        onInputChange: p,
        onInputPaste: v,
        onInputCompositionStart: d,
        onInputCompositionEnd: f
      }, $ = w === "multiple" || w === "tags" ? m(lE, L(L({}, e), C), null) : m(Xd, L(L({}, e), C), null);
      return m("div", {
        ref: S,
        class: `${y}-selector`,
        onClick: g,
        onMousedown: b
      }, [$]);
    };
  }
});
function dE(e, t, n) {
  function o(r) {
    var a, i, l;
    let u = r.target;
    u.shadowRoot && r.composed && (u = r.composedPath()[0] || u);
    const s = [(a = e[0]) === null || a === void 0 ? void 0 : a.value, (l = (i = e[1]) === null || i === void 0 ? void 0 : i.value) === null || l === void 0 ? void 0 : l.getPopupElement()];
    t.value && s.every((c) => c && !c.contains(u) && c !== u) && n(!1);
  }
  ze(() => {
    window.addEventListener("mousedown", o);
  }), at(() => {
    window.removeEventListener("mousedown", o);
  });
}
function fE() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
  const t = K(!1);
  let n;
  const o = () => {
    clearTimeout(n);
  };
  return ze(() => {
    o();
  }), [t, (a, i) => {
    o(), n = setTimeout(() => {
      t.value = a, i && i();
    }, e);
  }, o];
}
const r0 = Symbol("BaseSelectContextKey");
function pE(e) {
  return ot(r0, e);
}
function a0() {
  return nt(r0, {});
}
const qd = () => {
  if (typeof navigator > "u" || typeof window > "u")
    return !1;
  const e = navigator.userAgent || navigator.vendor || window.opera;
  return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(e) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(e == null ? void 0 : e.substring(0, 4));
};
function Fl(e) {
  if (!cb(e))
    return Et(e);
  const t = new Proxy({}, {
    get(n, o, r) {
      return Reflect.get(e.value, o, r);
    },
    set(n, o, r) {
      return e.value[o] = r, !0;
    },
    deleteProperty(n, o) {
      return Reflect.deleteProperty(e.value, o);
    },
    has(n, o) {
      return Reflect.has(e.value, o);
    },
    ownKeys() {
      return Object.keys(e.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: !0,
        configurable: !0
      };
    }
  });
  return Et(t);
}
var vE = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const mE = ["value", "onChange", "removeIcon", "placeholder", "autofocus", "maxTagCount", "maxTagTextLength", "maxTagPlaceholder", "choiceTransitionName", "onInputKeyDown", "onPopupScroll", "tabindex", "OptionList", "notFoundContent"], gE = () => ({
  prefixCls: String,
  id: String,
  omitDomProps: Array,
  // >>> Value
  displayValues: Array,
  onDisplayValuesChange: Function,
  // >>> Active
  /** Current dropdown list active item string value */
  activeValue: String,
  /** Link search input with target element */
  activeDescendantId: String,
  onActiveValueChange: Function,
  // >>> Search
  searchValue: String,
  /** Trigger onSearch, return false to prevent trigger open event */
  onSearch: Function,
  /** Trigger when search text match the `tokenSeparators`. Will provide split content */
  onSearchSplit: Function,
  maxLength: Number,
  OptionList: W.any,
  /** Tell if provided `options` is empty */
  emptyOptions: Boolean
}), Qd = () => ({
  showSearch: {
    type: Boolean,
    default: void 0
  },
  tagRender: {
    type: Function
  },
  optionLabelRender: {
    type: Function
  },
  direction: {
    type: String
  },
  // MISC
  tabindex: Number,
  autofocus: Boolean,
  notFoundContent: W.any,
  placeholder: W.any,
  onClear: Function,
  choiceTransitionName: String,
  // >>> Mode
  mode: String,
  // >>> Status
  disabled: {
    type: Boolean,
    default: void 0
  },
  loading: {
    type: Boolean,
    default: void 0
  },
  // >>> Open
  open: {
    type: Boolean,
    default: void 0
  },
  defaultOpen: {
    type: Boolean,
    default: void 0
  },
  onDropdownVisibleChange: {
    type: Function
  },
  // >>> Customize Input
  /** @private Internal usage. Do not use in your production. */
  getInputElement: {
    type: Function
  },
  /** @private Internal usage. Do not use in your production. */
  getRawInputElement: {
    type: Function
  },
  // >>> Selector
  maxTagTextLength: Number,
  maxTagCount: {
    type: [String, Number]
  },
  maxTagPlaceholder: W.any,
  // >>> Search
  tokenSeparators: {
    type: Array
  },
  // >>> Icons
  allowClear: {
    type: Boolean,
    default: void 0
  },
  showArrow: {
    type: Boolean,
    default: void 0
  },
  inputIcon: W.any,
  /** Clear all icon */
  clearIcon: W.any,
  /** Selector remove icon */
  removeIcon: W.any,
  // >>> Dropdown
  animation: String,
  transitionName: String,
  dropdownStyle: {
    type: Object
  },
  dropdownClassName: String,
  dropdownMatchSelectWidth: {
    type: [Boolean, Number],
    default: void 0
  },
  dropdownRender: {
    type: Function
  },
  dropdownAlign: Object,
  placement: {
    type: String
  },
  getPopupContainer: {
    type: Function
  },
  // >>> Focus
  showAction: {
    type: Array
  },
  onBlur: {
    type: Function
  },
  onFocus: {
    type: Function
  },
  // >>> Rest Events
  onKeyup: Function,
  onKeydown: Function,
  onMousedown: Function,
  onPopupScroll: Function,
  onInputKeyDown: Function,
  onMouseenter: Function,
  onMouseleave: Function,
  onClick: Function
}), hE = () => h(h({}, gE()), Qd());
function Zd(e) {
  return e === "tags" || e === "multiple";
}
const i0 = J({
  compatConfig: {
    MODE: 3
  },
  name: "BaseSelect",
  inheritAttrs: !1,
  props: bt(hE(), {
    showAction: [],
    notFoundContent: "Not Found"
  }),
  setup(e, t) {
    let {
      attrs: n,
      expose: o,
      slots: r
    } = t;
    const a = T(() => Zd(e.mode)), i = T(() => e.showSearch !== void 0 ? e.showSearch : a.value || e.mode === "combobox"), l = K(!1);
    ze(() => {
      l.value = qd();
    });
    const u = $s(), s = K(null), c = gi(), d = K(null), f = K(null), p = K(null), v = G(!1), [g, b, y] = fE();
    o({
      focus: () => {
        var V;
        (V = f.value) === null || V === void 0 || V.focus();
      },
      blur: () => {
        var V;
        (V = f.value) === null || V === void 0 || V.blur();
      },
      scrollTo: (V) => {
        var X;
        return (X = p.value) === null || X === void 0 ? void 0 : X.scrollTo(V);
      }
    });
    const C = T(() => {
      var V;
      if (e.mode !== "combobox")
        return e.searchValue;
      const X = (V = e.displayValues[0]) === null || V === void 0 ? void 0 : V.value;
      return typeof X == "string" || typeof X == "number" ? String(X) : "";
    }), $ = e.open !== void 0 ? e.open : e.defaultOpen, O = K($), x = K($), M = (V) => {
      O.value = e.open !== void 0 ? e.open : V, x.value = O.value;
    };
    le(() => e.open, () => {
      M(e.open);
    });
    const _ = T(() => !e.notFoundContent && e.emptyOptions);
    Ve(() => {
      x.value = O.value, (e.disabled || _.value && x.value && e.mode === "combobox") && (x.value = !1);
    });
    const N = T(() => _.value ? !1 : x.value), I = (V) => {
      const X = V !== void 0 ? V : !x.value;
      x.value !== X && !e.disabled && (M(X), e.onDropdownVisibleChange && e.onDropdownVisibleChange(X));
    }, E = T(() => (e.tokenSeparators || []).some((V) => [`
`, `\r
`].includes(V))), B = (V, X, re) => {
      var ie, he;
      let ge = !0, we = V;
      (ie = e.onActiveValueChange) === null || ie === void 0 || ie.call(e, null);
      const Le = re ? null : yO(V, e.tokenSeparators);
      return e.mode !== "combobox" && Le && (we = "", (he = e.onSearchSplit) === null || he === void 0 || he.call(e, Le), I(!1), ge = !1), e.onSearch && C.value !== we && e.onSearch(we, {
        source: X ? "typing" : "effect"
      }), ge;
    }, k = (V) => {
      var X;
      !V || !V.trim() || (X = e.onSearch) === null || X === void 0 || X.call(e, V, {
        source: "submit"
      });
    };
    le(x, () => {
      !x.value && !a.value && e.mode !== "combobox" && B("", !1, !1);
    }, {
      immediate: !0,
      flush: "post"
    }), le(() => e.disabled, () => {
      O.value && e.disabled && M(!1), e.disabled && !v.value && b(!1);
    }, {
      immediate: !0
    });
    const [P, R] = o0(), D = function(V) {
      var X;
      const re = P(), {
        which: ie
      } = V;
      if (ie === ee.ENTER && (e.mode !== "combobox" && V.preventDefault(), x.value || I(!0)), R(!!C.value), ie === ee.BACKSPACE && !re && a.value && !C.value && e.displayValues.length) {
        const Le = [...e.displayValues];
        let be = null;
        for (let pe = Le.length - 1; pe >= 0; pe -= 1) {
          const xe = Le[pe];
          if (!xe.disabled) {
            Le.splice(pe, 1), be = xe;
            break;
          }
        }
        be && e.onDisplayValuesChange(Le, {
          type: "remove",
          values: [be]
        });
      }
      for (var he = arguments.length, ge = new Array(he > 1 ? he - 1 : 0), we = 1; we < he; we++)
        ge[we - 1] = arguments[we];
      x.value && p.value && p.value.onKeydown(V, ...ge), (X = e.onKeydown) === null || X === void 0 || X.call(e, V, ...ge);
    }, A = function(V) {
      for (var X = arguments.length, re = new Array(X > 1 ? X - 1 : 0), ie = 1; ie < X; ie++)
        re[ie - 1] = arguments[ie];
      x.value && p.value && p.value.onKeyup(V, ...re), e.onKeyup && e.onKeyup(V, ...re);
    }, H = (V) => {
      const X = e.displayValues.filter((re) => re !== V);
      e.onDisplayValuesChange(X, {
        type: "remove",
        values: [V]
      });
    }, j = K(!1), z = function() {
      b(!0), e.disabled || (e.onFocus && !j.value && e.onFocus(...arguments), e.showAction && e.showAction.includes("focus") && I(!0)), j.value = !0;
    }, F = G(!1), U = function() {
      if (F.value || (v.value = !0, b(!1, () => {
        j.value = !1, v.value = !1, I(!1);
      }), e.disabled))
        return;
      const V = C.value;
      V && (e.mode === "tags" ? e.onSearch(V, {
        source: "submit"
      }) : e.mode === "multiple" && e.onSearch("", {
        source: "blur"
      })), e.onBlur && e.onBlur(...arguments);
    }, Q = () => {
      F.value = !0;
    }, q = () => {
      F.value = !1;
    };
    ot("VCSelectContainerEvent", {
      focus: z,
      blur: U
    });
    const oe = [];
    ze(() => {
      oe.forEach((V) => clearTimeout(V)), oe.splice(0, oe.length);
    }), at(() => {
      oe.forEach((V) => clearTimeout(V)), oe.splice(0, oe.length);
    });
    const Z = function(V) {
      var X, re;
      const {
        target: ie
      } = V, he = (X = d.value) === null || X === void 0 ? void 0 : X.getPopupElement();
      if (he && he.contains(ie)) {
        const be = setTimeout(() => {
          var pe;
          const xe = oe.indexOf(be);
          xe !== -1 && oe.splice(xe, 1), y(), !l.value && !he.contains(document.activeElement) && ((pe = f.value) === null || pe === void 0 || pe.focus());
        });
        oe.push(be);
      }
      for (var ge = arguments.length, we = new Array(ge > 1 ? ge - 1 : 0), Le = 1; Le < ge; Le++)
        we[Le - 1] = arguments[Le];
      (re = e.onMousedown) === null || re === void 0 || re.call(e, V, ...we);
    }, ne = K(null), Y = () => {
    };
    return ze(() => {
      le(N, () => {
        var V;
        if (N.value) {
          const X = Math.ceil((V = s.value) === null || V === void 0 ? void 0 : V.offsetWidth);
          ne.value !== X && !Number.isNaN(X) && (ne.value = X);
        }
      }, {
        immediate: !0,
        flush: "post"
      });
    }), dE([s, d], N, I), pE(Fl(h(h({}, bd(e)), {
      open: x,
      triggerOpen: N,
      showSearch: i,
      multiple: a,
      toggleOpen: I
    }))), () => {
      const V = h(h({}, e), n), {
        prefixCls: X,
        id: re,
        open: ie,
        defaultOpen: he,
        mode: ge,
        // Search related
        showSearch: we,
        searchValue: Le,
        onSearch: be,
        // Icons
        allowClear: pe,
        clearIcon: xe,
        showArrow: Ne,
        inputIcon: ye,
        // Others
        disabled: Ce,
        loading: Te,
        getInputElement: te,
        getPopupContainer: se,
        placement: Pe,
        // Dropdown
        animation: _e,
        transitionName: Ee,
        dropdownStyle: Be,
        dropdownClassName: ue,
        dropdownMatchSelectWidth: fe,
        dropdownRender: ve,
        dropdownAlign: Ie,
        showAction: Fe,
        direction: Oe,
        // Tags
        tokenSeparators: De,
        tagRender: je,
        optionLabelRender: et,
        // Events
        onPopupScroll: Ge,
        onDropdownVisibleChange: tt,
        onFocus: ut,
        onBlur: Bt,
        onKeyup: Jt,
        onKeydown: en,
        onMousedown: zt,
        onClear: an,
        omitDomProps: Bn,
        getRawInputElement: Eo,
        displayValues: Mo,
        onDisplayValuesChange: tr,
        emptyOptions: Ma,
        activeDescendantId: me,
        activeValue: Re,
        OptionList: Ae
      } = V, vt = vE(V, ["prefixCls", "id", "open", "defaultOpen", "mode", "showSearch", "searchValue", "onSearch", "allowClear", "clearIcon", "showArrow", "inputIcon", "disabled", "loading", "getInputElement", "getPopupContainer", "placement", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "showAction", "direction", "tokenSeparators", "tagRender", "optionLabelRender", "onPopupScroll", "onDropdownVisibleChange", "onFocus", "onBlur", "onKeyup", "onKeydown", "onMousedown", "onClear", "omitDomProps", "getRawInputElement", "displayValues", "onDisplayValuesChange", "emptyOptions", "activeDescendantId", "activeValue", "OptionList"]), _t = ge === "combobox" && te && te() || null, It = typeof Eo == "function" && Eo(), ln = h({}, vt);
      let jt;
      It && (jt = (Ln) => {
        I(Ln);
      }), mE.forEach((Ln) => {
        delete ln[Ln];
      }), Bn == null || Bn.forEach((Ln) => {
        delete ln[Ln];
      });
      const Zn = Ne !== void 0 ? Ne : Te || !a.value && ge !== "combobox";
      let mn;
      Zn && (mn = m(xr, {
        class: ae(`${X}-arrow`, {
          [`${X}-arrow-loading`]: Te
        }),
        customizeIcon: ye,
        customizeIconProps: {
          loading: Te,
          searchValue: C.value,
          open: x.value,
          focused: g.value,
          showSearch: i.value
        }
      }, null));
      let Pn;
      const St = () => {
        an == null || an(), tr([], {
          type: "clear",
          values: Mo
        }), B("", !1, !1);
      };
      !Ce && pe && (Mo.length || C.value) && (Pn = m(xr, {
        class: `${X}-clear`,
        onMousedown: St,
        customizeIcon: xe
      }, {
        default: () => [Se("×")]
      }));
      const kn = m(Ae, {
        ref: p
      }, h(h({}, u.customSlots), {
        option: r.option
      })), In = ae(X, n.class, {
        [`${X}-focused`]: g.value,
        [`${X}-multiple`]: a.value,
        [`${X}-single`]: !a.value,
        [`${X}-allow-clear`]: pe,
        [`${X}-show-arrow`]: Zn,
        [`${X}-disabled`]: Ce,
        [`${X}-loading`]: Te,
        [`${X}-open`]: x.value,
        [`${X}-customize-input`]: _t,
        [`${X}-show-search`]: i.value
      }), _o = m(UT, {
        ref: d,
        disabled: Ce,
        prefixCls: X,
        visible: N.value,
        popupElement: kn,
        containerWidth: ne.value,
        animation: _e,
        transitionName: Ee,
        dropdownStyle: Be,
        dropdownClassName: ue,
        direction: Oe,
        dropdownMatchSelectWidth: fe,
        dropdownRender: ve,
        dropdownAlign: Ie,
        placement: Pe,
        getPopupContainer: se,
        empty: Ma,
        getTriggerDOMNode: () => c.current,
        onPopupVisibleChange: jt,
        onPopupMouseEnter: Y,
        onPopupFocusin: Q,
        onPopupFocusout: q
      }, {
        default: () => It ? on(It) && Tt(It, {
          ref: c
        }, !1, !0) : m(cE, L(L({}, e), {}, {
          domRef: c,
          prefixCls: X,
          inputElement: _t,
          ref: f,
          id: re,
          showSearch: i.value,
          mode: ge,
          activeDescendantId: me,
          tagRender: je,
          optionLabelRender: et,
          values: Mo,
          open: x.value,
          onToggleOpen: I,
          activeValue: Re,
          searchValue: C.value,
          onSearch: B,
          onSearchSubmit: k,
          onRemove: H,
          tokenWithEnter: E.value
        }), null)
      });
      let Do;
      return It ? Do = _o : Do = m("div", L(L({}, ln), {}, {
        class: In,
        ref: s,
        onMousedown: Z,
        onKeydown: D,
        onKeyup: A
      }), [g.value && !x.value && m("span", {
        style: {
          width: 0,
          height: 0,
          position: "absolute",
          overflow: "hidden",
          opacity: 0
        },
        "aria-live": "polite"
      }, [`${Mo.map((Ln) => {
        let {
          label: Br,
          value: Hn
        } = Ln;
        return ["number", "string"].includes(typeof Br) ? Br : Hn;
      }).join(", ")}`]), _o, mn, Pn]), Do;
    };
  }
}), Cs = (e, t) => {
  let {
    height: n,
    offset: o,
    prefixCls: r,
    onInnerResize: a
  } = e, {
    slots: i
  } = t;
  var l;
  let u = {}, s = {
    display: "flex",
    flexDirection: "column"
  };
  return o !== void 0 && (u = {
    height: `${n}px`,
    position: "relative",
    overflow: "hidden"
  }, s = h(h({}, s), {
    transform: `translateY(${o}px)`,
    position: "absolute",
    left: 0,
    right: 0,
    top: 0
  })), m("div", {
    style: u
  }, [m(br, {
    onResize: (c) => {
      let {
        offsetHeight: d
      } = c;
      d && a && a();
    }
  }, {
    default: () => [m("div", {
      style: s,
      class: ae({
        [`${r}-holder-inner`]: r
      })
    }, [(l = i.default) === null || l === void 0 ? void 0 : l.call(i)])]
  })]);
};
Cs.displayName = "Filter";
Cs.inheritAttrs = !1;
Cs.props = {
  prefixCls: String,
  /** Virtual filler height. Should be `count * itemMinHeight` */
  height: Number,
  /** Set offset of visible items. Should be the top of start item position */
  offset: Number,
  onInnerResize: Function
};
const l0 = (e, t) => {
  let {
    setRef: n
  } = e, {
    slots: o
  } = t;
  var r;
  const a = xt((r = o.default) === null || r === void 0 ? void 0 : r.call(o));
  return a && a.length ? Ko(a[0], {
    ref: n
  }) : a;
};
l0.props = {
  setRef: {
    type: Function,
    default: () => {
    }
  }
};
const bE = 20;
function am(e) {
  return "touches" in e ? e.touches[0].pageY : e.pageY;
}
const yE = J({
  compatConfig: {
    MODE: 3
  },
  name: "ScrollBar",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    scrollTop: Number,
    scrollHeight: Number,
    height: Number,
    count: Number,
    onScroll: {
      type: Function
    },
    onStartMove: {
      type: Function
    },
    onStopMove: {
      type: Function
    }
  },
  setup() {
    return {
      moveRaf: null,
      scrollbarRef: gi(),
      thumbRef: gi(),
      visibleTimeout: null,
      state: Et({
        dragging: !1,
        pageY: null,
        startTop: null,
        visible: !1
      })
    };
  },
  watch: {
    scrollTop: {
      handler() {
        this.delayHidden();
      },
      flush: "post"
    }
  },
  mounted() {
    var e, t;
    (e = this.scrollbarRef.current) === null || e === void 0 || e.addEventListener("touchstart", this.onScrollbarTouchStart, Kt ? {
      passive: !1
    } : !1), (t = this.thumbRef.current) === null || t === void 0 || t.addEventListener("touchstart", this.onMouseDown, Kt ? {
      passive: !1
    } : !1);
  },
  beforeUnmount() {
    this.removeEvents(), clearTimeout(this.visibleTimeout);
  },
  methods: {
    delayHidden() {
      clearTimeout(this.visibleTimeout), this.state.visible = !0, this.visibleTimeout = setTimeout(() => {
        this.state.visible = !1;
      }, 2e3);
    },
    onScrollbarTouchStart(e) {
      e.preventDefault();
    },
    onContainerMouseDown(e) {
      e.stopPropagation(), e.preventDefault();
    },
    // ======================= Clean =======================
    patchEvents() {
      window.addEventListener("mousemove", this.onMouseMove), window.addEventListener("mouseup", this.onMouseUp), this.thumbRef.current.addEventListener("touchmove", this.onMouseMove, Kt ? {
        passive: !1
      } : !1), this.thumbRef.current.addEventListener("touchend", this.onMouseUp);
    },
    removeEvents() {
      window.removeEventListener("mousemove", this.onMouseMove), window.removeEventListener("mouseup", this.onMouseUp), this.scrollbarRef.current.removeEventListener("touchstart", this.onScrollbarTouchStart, Kt ? {
        passive: !1
      } : !1), this.thumbRef.current && (this.thumbRef.current.removeEventListener("touchstart", this.onMouseDown, Kt ? {
        passive: !1
      } : !1), this.thumbRef.current.removeEventListener("touchmove", this.onMouseMove, Kt ? {
        passive: !1
      } : !1), this.thumbRef.current.removeEventListener("touchend", this.onMouseUp)), Ue.cancel(this.moveRaf);
    },
    // ======================= Thumb =======================
    onMouseDown(e) {
      const {
        onStartMove: t
      } = this.$props;
      h(this.state, {
        dragging: !0,
        pageY: am(e),
        startTop: this.getTop()
      }), t(), this.patchEvents(), e.stopPropagation(), e.preventDefault();
    },
    onMouseMove(e) {
      const {
        dragging: t,
        pageY: n,
        startTop: o
      } = this.state, {
        onScroll: r
      } = this.$props;
      if (Ue.cancel(this.moveRaf), t) {
        const a = am(e) - n, i = o + a, l = this.getEnableScrollRange(), u = this.getEnableHeightRange(), s = u ? i / u : 0, c = Math.ceil(s * l);
        this.moveRaf = Ue(() => {
          r(c);
        });
      }
    },
    onMouseUp() {
      const {
        onStopMove: e
      } = this.$props;
      this.state.dragging = !1, e(), this.removeEvents();
    },
    // ===================== Calculate =====================
    getSpinHeight() {
      const {
        height: e,
        scrollHeight: t
      } = this.$props;
      let n = e / t * 100;
      return n = Math.max(n, bE), n = Math.min(n, e / 2), Math.floor(n);
    },
    getEnableScrollRange() {
      const {
        scrollHeight: e,
        height: t
      } = this.$props;
      return e - t || 0;
    },
    getEnableHeightRange() {
      const {
        height: e
      } = this.$props, t = this.getSpinHeight();
      return e - t || 0;
    },
    getTop() {
      const {
        scrollTop: e
      } = this.$props, t = this.getEnableScrollRange(), n = this.getEnableHeightRange();
      return e === 0 || t === 0 ? 0 : e / t * n;
    },
    // Not show scrollbar when height is large than scrollHeight
    showScroll() {
      const {
        height: e,
        scrollHeight: t
      } = this.$props;
      return t > e;
    }
  },
  render() {
    const {
      dragging: e,
      visible: t
    } = this.state, {
      prefixCls: n
    } = this.$props, o = this.getSpinHeight() + "px", r = this.getTop() + "px", a = this.showScroll(), i = a && t;
    return m("div", {
      ref: this.scrollbarRef,
      class: ae(`${n}-scrollbar`, {
        [`${n}-scrollbar-show`]: a
      }),
      style: {
        width: "8px",
        top: 0,
        bottom: 0,
        right: 0,
        position: "absolute",
        display: i ? void 0 : "none"
      },
      onMousedown: this.onContainerMouseDown,
      onMousemove: this.delayHidden
    }, [m("div", {
      ref: this.thumbRef,
      class: ae(`${n}-scrollbar-thumb`, {
        [`${n}-scrollbar-thumb-moving`]: e
      }),
      style: {
        width: "100%",
        height: o,
        top: r,
        left: 0,
        position: "absolute",
        background: "rgba(0, 0, 0, 0.5)",
        borderRadius: "99px",
        cursor: "pointer",
        userSelect: "none"
      },
      onMousedown: this.onMouseDown
    }, null)]);
  }
});
function SE(e, t, n, o) {
  const r = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), i = G(Symbol("update"));
  le(e, () => {
    i.value = Symbol("update");
  });
  let l;
  function u() {
    Ue.cancel(l);
  }
  function s() {
    u(), l = Ue(() => {
      r.forEach((d, f) => {
        if (d && d.offsetParent) {
          const {
            offsetHeight: p
          } = d;
          a.get(f) !== p && (i.value = Symbol("update"), a.set(f, d.offsetHeight));
        }
      });
    });
  }
  function c(d, f) {
    const p = t(d);
    r.get(p), f ? (r.set(p, f.$el || f), s()) : r.delete(p);
  }
  return Xo(() => {
    u();
  }), [c, s, a, i];
}
function $E(e, t, n, o, r, a, i, l) {
  let u;
  return (s) => {
    if (s == null) {
      l();
      return;
    }
    Ue.cancel(u);
    const c = t.value, d = o.itemHeight;
    if (typeof s == "number")
      i(s);
    else if (s && typeof s == "object") {
      let f;
      const {
        align: p
      } = s;
      "index" in s ? {
        index: f
      } = s : f = c.findIndex((b) => r(b) === s.key);
      const {
        offset: v = 0
      } = s, g = (b, y) => {
        if (b < 0 || !e.value)
          return;
        const S = e.value.clientHeight;
        let w = !1, C = y;
        if (S) {
          const $ = y || p;
          let O = 0, x = 0, M = 0;
          const _ = Math.min(c.length, f);
          for (let E = 0; E <= _; E += 1) {
            const B = r(c[E]);
            x = O;
            const k = n.get(B);
            M = x + (k === void 0 ? d : k), O = M, E === f && k === void 0 && (w = !0);
          }
          const N = e.value.scrollTop;
          let I = null;
          switch ($) {
            case "top":
              I = x - v;
              break;
            case "bottom":
              I = M - S + v;
              break;
            default: {
              const E = N + S;
              x < N ? C = "top" : M > E && (C = "bottom");
            }
          }
          I !== null && I !== N && i(I);
        }
        u = Ue(() => {
          w && a(), g(b - 1, C);
        }, 2);
      };
      g(5);
    }
  };
}
const CE = typeof navigator == "object" && /Firefox/i.test(navigator.userAgent), s0 = (e, t) => {
  let n = !1, o = null;
  function r() {
    clearTimeout(o), n = !0, o = setTimeout(() => {
      n = !1;
    }, 50);
  }
  return function(a) {
    let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    const l = (
      // Pass origin wheel when on the top
      a < 0 && e.value || // Pass origin wheel when on the bottom
      a > 0 && t.value
    );
    return i && l ? (clearTimeout(o), n = !1) : (!l || n) && r(), !n && l;
  };
};
function wE(e, t, n, o) {
  let r = 0, a = null, i = null, l = !1;
  const u = s0(t, n);
  function s(d) {
    if (!e.value)
      return;
    Ue.cancel(a);
    const {
      deltaY: f
    } = d;
    r += f, i = f, !u(f) && (CE || d.preventDefault(), a = Ue(() => {
      o(r * (l ? 10 : 1)), r = 0;
    }));
  }
  function c(d) {
    e.value && (l = d.detail === i);
  }
  return [s, c];
}
const xE = 14 / 15;
function OE(e, t, n) {
  let o = !1, r = 0, a = null, i = null;
  const l = () => {
    a && (a.removeEventListener("touchmove", u), a.removeEventListener("touchend", s));
  }, u = (f) => {
    if (o) {
      const p = Math.ceil(f.touches[0].pageY);
      let v = r - p;
      r = p, n(v) && f.preventDefault(), clearInterval(i), i = setInterval(() => {
        v *= xE, (!n(v, !0) || Math.abs(v) <= 0.1) && clearInterval(i);
      }, 16);
    }
  }, s = () => {
    o = !1, l();
  }, c = (f) => {
    l(), f.touches.length === 1 && !o && (o = !0, r = Math.ceil(f.touches[0].pageY), a = f.target, a.addEventListener("touchmove", u, {
      passive: !1
    }), a.addEventListener("touchend", s));
  }, d = () => {
  };
  ze(() => {
    document.addEventListener("touchmove", d, {
      passive: !1
    }), le(e, (f) => {
      t.value.removeEventListener("touchstart", c), l(), clearInterval(i), f && t.value.addEventListener("touchstart", c, {
        passive: !1
      });
    }, {
      immediate: !0
    });
  }), at(() => {
    document.removeEventListener("touchmove", d);
  });
}
var PE = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const IE = [], TE = {
  overflowY: "auto",
  overflowAnchor: "none"
};
function EE(e, t, n, o, r, a) {
  let {
    getKey: i
  } = a;
  return e.slice(t, n + 1).map((l, u) => {
    const s = t + u, c = r(l, s, {
      // style: status === 'MEASURE_START' ? { visibility: 'hidden' } : {},
    }), d = i(l);
    return m(l0, {
      key: d,
      setRef: (f) => o(l, f)
    }, {
      default: () => [c]
    });
  });
}
const u0 = J({
  compatConfig: {
    MODE: 3
  },
  name: "List",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    data: W.array,
    height: Number,
    itemHeight: Number,
    /** If not match virtual scroll condition, Set List still use height of container. */
    fullHeight: {
      type: Boolean,
      default: void 0
    },
    itemKey: {
      type: [String, Number, Function],
      required: !0
    },
    component: {
      type: [String, Object]
    },
    /** Set `false` will always use real scroll instead of virtual one */
    virtual: {
      type: Boolean,
      default: void 0
    },
    children: Function,
    onScroll: Function,
    onMousedown: Function,
    onMouseenter: Function,
    onVisibleChange: Function
  },
  setup(e, t) {
    let {
      expose: n
    } = t;
    const o = T(() => {
      const {
        height: H,
        itemHeight: j,
        virtual: z
      } = e;
      return !!(z !== !1 && H && j);
    }), r = T(() => {
      const {
        height: H,
        itemHeight: j,
        data: z
      } = e;
      return o.value && z && j * z.length > H;
    }), a = Et({
      scrollTop: 0,
      scrollMoving: !1
    }), i = T(() => e.data || IE), l = K([]);
    le(i, () => {
      l.value = Ft(i.value).slice();
    }, {
      immediate: !0
    });
    const u = K((H) => {
    });
    le(() => e.itemKey, (H) => {
      typeof H == "function" ? u.value = H : u.value = (j) => j == null ? void 0 : j[H];
    }, {
      immediate: !0
    });
    const s = K(), c = K(), d = K(), f = (H) => u.value(H), p = {
      getKey: f
    };
    function v(H) {
      let j;
      typeof H == "function" ? j = H(a.scrollTop) : j = H;
      const z = O(j);
      s.value && (s.value.scrollTop = z), a.scrollTop = z;
    }
    const [g, b, y, S] = SE(l, f), w = Et({
      scrollHeight: void 0,
      start: 0,
      end: 0,
      offset: void 0
    }), C = K(0);
    ze(() => {
      mt(() => {
        var H;
        C.value = ((H = c.value) === null || H === void 0 ? void 0 : H.offsetHeight) || 0;
      });
    }), Co(() => {
      mt(() => {
        var H;
        C.value = ((H = c.value) === null || H === void 0 ? void 0 : H.offsetHeight) || 0;
      });
    }), le([o, l], () => {
      o.value || h(w, {
        scrollHeight: void 0,
        start: 0,
        end: l.value.length - 1,
        offset: void 0
      });
    }, {
      immediate: !0
    }), le([o, l, C, r], () => {
      o.value && !r.value && h(w, {
        scrollHeight: C.value,
        start: 0,
        end: l.value.length - 1,
        offset: void 0
      }), s.value && (a.scrollTop = s.value.scrollTop);
    }, {
      immediate: !0
    }), le([r, o, () => a.scrollTop, l, S, () => e.height, C], () => {
      if (!o.value || !r.value)
        return;
      let H = 0, j, z, F;
      const U = l.value.length, Q = l.value, q = a.scrollTop, {
        itemHeight: oe,
        height: Z
      } = e, ne = q + Z;
      for (let Y = 0; Y < U; Y += 1) {
        const V = Q[Y], X = f(V);
        let re = y.get(X);
        re === void 0 && (re = oe);
        const ie = H + re;
        j === void 0 && ie >= q && (j = Y, z = H), F === void 0 && ie > ne && (F = Y), H = ie;
      }
      j === void 0 && (j = 0, z = 0, F = Math.ceil(Z / oe)), F === void 0 && (F = U - 1), F = Math.min(F + 1, U), h(w, {
        scrollHeight: H,
        start: j,
        end: F,
        offset: z
      });
    }, {
      immediate: !0
    });
    const $ = T(() => w.scrollHeight - e.height);
    function O(H) {
      let j = H;
      return Number.isNaN($.value) || (j = Math.min(j, $.value)), j = Math.max(j, 0), j;
    }
    const x = T(() => a.scrollTop <= 0), M = T(() => a.scrollTop >= $.value), _ = s0(x, M);
    function N(H) {
      v(H);
    }
    function I(H) {
      var j;
      const {
        scrollTop: z
      } = H.currentTarget;
      z !== a.scrollTop && v(z), (j = e.onScroll) === null || j === void 0 || j.call(e, H);
    }
    const [E, B] = wE(o, x, M, (H) => {
      v((j) => j + H);
    });
    OE(o, s, (H, j) => _(H, j) ? !1 : (E({
      preventDefault() {
      },
      deltaY: H
    }), !0));
    function k(H) {
      o.value && H.preventDefault();
    }
    const P = () => {
      s.value && (s.value.removeEventListener("wheel", E, Kt ? {
        passive: !1
      } : !1), s.value.removeEventListener("DOMMouseScroll", B), s.value.removeEventListener("MozMousePixelScroll", k));
    };
    Ve(() => {
      mt(() => {
        s.value && (P(), s.value.addEventListener("wheel", E, Kt ? {
          passive: !1
        } : !1), s.value.addEventListener("DOMMouseScroll", B), s.value.addEventListener("MozMousePixelScroll", k));
      });
    }), at(() => {
      P();
    });
    const R = $E(s, l, y, e, f, b, v, () => {
      var H;
      (H = d.value) === null || H === void 0 || H.delayHidden();
    });
    n({
      scrollTo: R
    });
    const D = T(() => {
      let H = null;
      return e.height && (H = h({
        [e.fullHeight ? "height" : "maxHeight"]: e.height + "px"
      }, TE), o.value && (H.overflowY = "hidden", a.scrollMoving && (H.pointerEvents = "none"))), H;
    });
    return le([() => w.start, () => w.end, l], () => {
      if (e.onVisibleChange) {
        const H = l.value.slice(w.start, w.end + 1);
        e.onVisibleChange(H, l.value);
      }
    }, {
      flush: "post"
    }), {
      state: a,
      mergedData: l,
      componentStyle: D,
      onFallbackScroll: I,
      onScrollBar: N,
      componentRef: s,
      useVirtual: o,
      calRes: w,
      collectHeight: b,
      setInstance: g,
      sharedConfig: p,
      scrollBarRef: d,
      fillerInnerRef: c,
      delayHideScrollBar: () => {
        var H;
        (H = d.value) === null || H === void 0 || H.delayHidden();
      }
    };
  },
  render() {
    const e = h(h({}, this.$props), this.$attrs), {
      prefixCls: t = "rc-virtual-list",
      height: n,
      itemHeight: o,
      // eslint-disable-next-line no-unused-vars
      fullHeight: r,
      data: a,
      itemKey: i,
      virtual: l,
      component: u = "div",
      onScroll: s,
      children: c = this.$slots.default,
      style: d,
      class: f
    } = e, p = PE(e, ["prefixCls", "height", "itemHeight", "fullHeight", "data", "itemKey", "virtual", "component", "onScroll", "children", "style", "class"]), v = ae(t, f), {
      scrollTop: g
    } = this.state, {
      scrollHeight: b,
      offset: y,
      start: S,
      end: w
    } = this.calRes, {
      componentStyle: C,
      onFallbackScroll: $,
      onScrollBar: O,
      useVirtual: x,
      collectHeight: M,
      sharedConfig: _,
      setInstance: N,
      mergedData: I,
      delayHideScrollBar: E
    } = this;
    return m("div", L({
      style: h(h({}, d), {
        position: "relative"
      }),
      class: v
    }, p), [m(u, {
      class: `${t}-holder`,
      style: C,
      ref: "componentRef",
      onScroll: $,
      onMouseenter: E
    }, {
      default: () => [m(Cs, {
        prefixCls: t,
        height: b,
        offset: y,
        onInnerResize: M,
        ref: "fillerInnerRef"
      }, {
        default: () => EE(I, S, w, N, c, _)
      })]
    }), x && m(yE, {
      ref: "scrollBarRef",
      prefixCls: t,
      scrollTop: g,
      height: n,
      scrollHeight: b,
      count: I.length,
      onScroll: O,
      onStartMove: () => {
        this.state.scrollMoving = !0;
      },
      onStopMove: () => {
        this.state.scrollMoving = !1;
      }
    }, null)]);
  }
});
function Jd(e, t, n) {
  const o = G(e());
  return le(t, (r, a) => {
    n ? n(r, a) && (o.value = e()) : o.value = e();
  }), o;
}
function ME() {
  return /(mac\sos|macintosh)/i.test(navigator.appVersion);
}
const c0 = Symbol("SelectContextKey");
function _E(e) {
  return ot(c0, e);
}
function DE() {
  return nt(c0, {});
}
var AE = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function im(e) {
  return typeof e == "string" || typeof e == "number";
}
const NE = J({
  compatConfig: {
    MODE: 3
  },
  name: "OptionList",
  inheritAttrs: !1,
  setup(e, t) {
    let {
      expose: n,
      slots: o
    } = t;
    const r = a0(), a = DE(), i = T(() => `${r.prefixCls}-item`), l = Jd(() => a.flattenOptions, [() => r.open, () => a.flattenOptions], ($) => $[0]), u = gi(), s = ($) => {
      $.preventDefault();
    }, c = ($) => {
      u.current && u.current.scrollTo(typeof $ == "number" ? {
        index: $
      } : $);
    }, d = function($) {
      let O = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      const x = l.value.length;
      for (let M = 0; M < x; M += 1) {
        const _ = ($ + M * O + x) % x, {
          group: N,
          data: I
        } = l.value[_];
        if (!N && !I.disabled)
          return _;
      }
      return -1;
    }, f = Et({
      activeIndex: d(0)
    }), p = function($) {
      let O = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      f.activeIndex = $;
      const x = {
        source: O ? "keyboard" : "mouse"
      }, M = l.value[$];
      if (!M) {
        a.onActiveValue(null, -1, x);
        return;
      }
      a.onActiveValue(M.value, $, x);
    };
    le([() => l.value.length, () => r.searchValue], () => {
      p(a.defaultActiveFirstOption !== !1 ? d(0) : -1);
    }, {
      immediate: !0
    });
    const v = ($) => a.rawValues.has($) && r.mode !== "combobox";
    le([() => r.open, () => r.searchValue], () => {
      if (!r.multiple && r.open && a.rawValues.size === 1) {
        const $ = Array.from(a.rawValues)[0], O = Ft(l.value).findIndex((x) => {
          let {
            data: M
          } = x;
          return M[a.fieldNames.value] === $;
        });
        O !== -1 && (p(O), mt(() => {
          c(O);
        }));
      }
      r.open && mt(() => {
        var $;
        ($ = u.current) === null || $ === void 0 || $.scrollTo(void 0);
      });
    }, {
      immediate: !0,
      flush: "post"
    });
    const g = ($) => {
      $ !== void 0 && a.onSelect($, {
        selected: !a.rawValues.has($)
      }), r.multiple || r.toggleOpen(!1);
    }, b = ($) => typeof $.label == "function" ? $.label() : $.label;
    function y($) {
      const O = l.value[$];
      if (!O)
        return null;
      const x = O.data || {}, {
        value: M
      } = x, {
        group: _
      } = O, N = _r(x, !0), I = b(O);
      return O ? m("div", L(L({
        "aria-label": typeof I == "string" && !_ ? I : null
      }, N), {}, {
        key: $,
        role: _ ? "presentation" : "option",
        id: `${r.id}_list_${$}`,
        "aria-selected": v(M)
      }), [M]) : null;
    }
    return n({
      onKeydown: ($) => {
        const {
          which: O,
          ctrlKey: x
        } = $;
        switch (O) {
          case ee.N:
          case ee.P:
          case ee.UP:
          case ee.DOWN: {
            let M = 0;
            if (O === ee.UP ? M = -1 : O === ee.DOWN ? M = 1 : ME() && x && (O === ee.N ? M = 1 : O === ee.P && (M = -1)), M !== 0) {
              const _ = d(f.activeIndex + M, M);
              c(_), p(_, !0);
            }
            break;
          }
          case ee.ENTER: {
            const M = l.value[f.activeIndex];
            M && !M.data.disabled ? g(M.value) : g(void 0), r.open && $.preventDefault();
            break;
          }
          case ee.ESC:
            r.toggleOpen(!1), r.open && $.stopPropagation();
        }
      },
      onKeyup: () => {
      },
      scrollTo: ($) => {
        c($);
      }
    }), () => {
      const {
        id: $,
        notFoundContent: O,
        onPopupScroll: x
      } = r, {
        menuItemSelectedIcon: M,
        fieldNames: _,
        virtual: N,
        listHeight: I,
        listItemHeight: E
      } = a, B = o.option, {
        activeIndex: k
      } = f, P = Object.keys(_).map((R) => _[R]);
      return l.value.length === 0 ? m("div", {
        role: "listbox",
        id: `${$}_list`,
        class: `${i.value}-empty`,
        onMousedown: s
      }, [O]) : m(We, null, [m("div", {
        role: "listbox",
        id: `${$}_list`,
        style: {
          height: 0,
          width: 0,
          overflow: "hidden"
        }
      }, [y(k - 1), y(k), y(k + 1)]), m(u0, {
        itemKey: "key",
        ref: u,
        data: l.value,
        height: I,
        itemHeight: E,
        fullHeight: !1,
        onMousedown: s,
        onScroll: x,
        virtual: N
      }, {
        default: (R, D) => {
          var A;
          const {
            group: H,
            groupOption: j,
            data: z,
            value: F
          } = R, {
            key: U
          } = z, Q = typeof R.label == "function" ? R.label() : R.label;
          if (H) {
            const xe = (A = z.title) !== null && A !== void 0 ? A : im(Q) && Q;
            return m("div", {
              class: ae(i.value, `${i.value}-group`),
              title: xe
            }, [B ? B(z) : Q !== void 0 ? Q : U]);
          }
          const {
            disabled: q,
            title: oe,
            children: Z,
            style: ne,
            class: Y,
            className: V
          } = z, X = AE(z, ["disabled", "title", "children", "style", "class", "className"]), re = pt(X, P), ie = v(F), he = `${i.value}-option`, ge = ae(i.value, he, Y, V, {
            [`${he}-grouped`]: j,
            [`${he}-active`]: k === D && !q,
            [`${he}-disabled`]: q,
            [`${he}-selected`]: ie
          }), we = b(R), Le = !M || typeof M == "function" || ie, be = typeof we == "number" ? we : we || F;
          let pe = im(be) ? be.toString() : void 0;
          return oe !== void 0 && (pe = oe), m("div", L(L({}, re), {}, {
            "aria-selected": ie,
            class: ge,
            title: pe,
            onMousemove: (xe) => {
              X.onMousemove && X.onMousemove(xe), !(k === D || q) && p(D);
            },
            onClick: (xe) => {
              q || g(F), X.onClick && X.onClick(xe);
            },
            style: ne
          }), [m("div", {
            class: `${he}-content`
          }, [B ? B(z) : be]), on(M) || ie, Le && m(xr, {
            class: `${i.value}-option-state`,
            customizeIcon: M,
            customizeIconProps: {
              isSelected: ie
            }
          }, {
            default: () => [ie ? "✓" : null]
          })]);
        }
      })]);
    };
  }
});
var RE = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function FE(e) {
  const t = e, {
    key: n,
    children: o
  } = t, r = t.props, {
    value: a,
    disabled: i
  } = r, l = RE(r, ["value", "disabled"]), u = o == null ? void 0 : o.default;
  return h({
    key: n,
    value: a !== void 0 ? a : n,
    children: u,
    disabled: i || i === ""
  }, l);
}
function ef(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  return xt(e).map((o, r) => {
    var a;
    if (!on(o) || !o.type)
      return null;
    const {
      type: {
        isSelectOptGroup: i
      },
      key: l,
      children: u,
      props: s
    } = o;
    if (t || !i)
      return FE(o);
    const c = u && u.default ? u.default() : void 0, d = (s == null ? void 0 : s.label) || ((a = u.label) === null || a === void 0 ? void 0 : a.call(u)) || l;
    return h(h({
      key: `__RC_SELECT_GRP__${l === null ? r : String(l)}__`
    }, s), {
      label: d,
      options: ef(c || [])
    });
  }).filter((o) => o);
}
function BE(e, t, n) {
  const o = K(), r = K(), a = K(), i = K([]);
  return le([e, t], () => {
    e.value ? i.value = Ft(e.value).slice() : i.value = ef(t.value);
  }, {
    immediate: !0,
    deep: !0
  }), Ve(() => {
    const l = i.value, u = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), c = n.value;
    function d(f) {
      let p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      for (let v = 0; v < f.length; v += 1) {
        const g = f[v];
        !g[c.options] || p ? (u.set(g[c.value], g), s.set(g[c.label], g)) : d(g[c.options], !0);
      }
    }
    d(l), o.value = l, r.value = u, a.value = s;
  }), {
    options: o,
    valueOptions: r,
    labelOptions: a
  };
}
let lm = 0;
const kE = process.env.NODE_ENV !== "test" && Nn();
function LE() {
  let e;
  return kE ? (e = lm, lm += 1) : e = "TEST_OR_SSR", e;
}
function d0() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : G("");
  const t = `rc_select_${LE()}`;
  return e.value || t;
}
function tf(e) {
  return Array.isArray(e) ? e : e !== void 0 ? [e] : [];
}
const HE = typeof window < "u" && window.document && window.document.documentElement;
process.env.NODE_ENV;
function zE(e) {
  const {
    mode: t,
    options: n,
    children: o,
    backfill: r,
    allowClear: a,
    placeholder: i,
    getInputElement: l,
    showSearch: u,
    onSearch: s,
    defaultOpen: c,
    autofocus: d,
    labelInValue: f,
    value: p,
    inputValue: v,
    optionLabelProp: g
  } = e, b = Zd(t), y = u !== void 0 ? u : b || t === "combobox", S = n || ef(o);
  if (yn(t !== "tags" || S.every((w) => !w.disabled), "Please avoid setting option to disabled in tags mode since user can always type text as tag."), yn(t !== "combobox" || !g, "`combobox` mode not support `optionLabelProp`. Please set `value` on Option directly."), yn(t === "combobox" || !r, "`backfill` only works with `combobox` mode."), yn(t === "combobox" || !l, "`getInputElement` only work with `combobox` mode."), cc(t !== "combobox" || !l || !a || !i, "Customize `getInputElement` should customize clear and placeholder logic instead of configuring `allowClear` and `placeholder`."), s && !y && t !== "combobox" && t !== "tags" && yn(!1, "`onSearch` should work with `showSearch` instead of use alone."), cc(!c || d, "`defaultOpen` makes Select open without focus which means it will not close by click outside. You can set `autofocus` if needed."), p != null) {
    const w = tf(p);
    yn(!f || w.every((C) => typeof C == "object" && ("key" in C || "value" in C)), "`value` should in shape of `{ value: string | number, label?: any }` when you set `labelInValue` to `true`"), yn(!b || Array.isArray(p), "`value` should be array when `mode` is `multiple` or `tags`");
  }
  if (o) {
    let w = null;
    o.some((C) => {
      var $;
      if (!on(C) || !C.type)
        return !1;
      const {
        type: O
      } = C;
      return O.isSelectOption ? !1 : O.isSelectOptGroup ? !((($ = C.children) === null || $ === void 0 ? void 0 : $.default()) || []).every((_) => !on(_) || !C.type || _.type.isSelectOption ? !0 : (w = _.type, !1)) : (w = O, !0);
    }), w && yn(!1, `\`children\` should be \`Select.Option\` or \`Select.OptGroup\` instead of \`${w.displayName || w.name || w}\`.`), yn(v === void 0, "`inputValue` is deprecated, please use `searchValue` instead.");
  }
}
function yu(e, t) {
  return tf(e).join("").toUpperCase().includes(t);
}
const jE = (e, t, n, o, r) => T(() => {
  const a = n.value, i = r == null ? void 0 : r.value, l = o == null ? void 0 : o.value;
  if (!a || l === !1)
    return e.value;
  const {
    options: u,
    label: s,
    value: c
  } = t.value, d = [], f = typeof l == "function", p = a.toUpperCase(), v = f ? l : (b, y) => i ? yu(y[i], p) : y[u] ? yu(y[s !== "children" ? s : "label"], p) : yu(y[c], p), g = f ? (b) => Cc(b) : (b) => b;
  return e.value.forEach((b) => {
    if (b[u]) {
      if (v(a, g(b)))
        d.push(b);
      else {
        const S = b[u].filter((w) => v(a, g(w)));
        S.length && d.push(h(h({}, b), {
          [u]: S
        }));
      }
      return;
    }
    v(a, g(b)) && d.push(b);
  }), d;
}), VE = (e, t) => {
  const n = K({
    values: /* @__PURE__ */ new Map(),
    options: /* @__PURE__ */ new Map()
  });
  return [T(() => {
    const {
      values: a,
      options: i
    } = n.value, l = e.value.map((c) => {
      var d;
      return c.label === void 0 ? h(h({}, c), {
        label: (d = a.get(c.value)) === null || d === void 0 ? void 0 : d.label
      }) : c;
    }), u = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map();
    return l.forEach((c) => {
      u.set(c.value, c), s.set(c.value, t.value.get(c.value) || i.get(c.value));
    }), n.value.values = u, n.value.options = s, l;
  }), (a) => t.value.get(a) || n.value.options.get(a)];
};
function Gt(e, t) {
  const {
    defaultValue: n,
    value: o = G()
  } = t || {};
  let r = typeof e == "function" ? e() : e;
  o.value !== void 0 && (r = Ye(o)), n !== void 0 && (r = typeof n == "function" ? n() : n);
  const a = G(r), i = G(r);
  Ve(() => {
    let u = o.value !== void 0 ? o.value : a.value;
    t.postState && (u = t.postState(u)), i.value = u;
  });
  function l(u) {
    const s = i.value;
    a.value = u, Ft(i.value) !== u && t.onChange && t.onChange(u, s);
  }
  return le(o, () => {
    a.value = o.value;
  }), [i, l];
}
function yt(e) {
  const t = typeof e == "function" ? e() : e, n = G(t);
  function o(r) {
    n.value = r;
  }
  return [n, o];
}
const WE = ["inputValue"];
function f0() {
  return h(h({}, Qd()), {
    prefixCls: String,
    id: String,
    backfill: {
      type: Boolean,
      default: void 0
    },
    // >>> Field Names
    fieldNames: Object,
    // >>> Search
    /** @deprecated Use `searchValue` instead */
    inputValue: String,
    searchValue: String,
    onSearch: Function,
    autoClearSearchValue: {
      type: Boolean,
      default: void 0
    },
    // >>> Select
    onSelect: Function,
    onDeselect: Function,
    // >>> Options
    /**
     * In Select, `false` means do nothing.
     * In TreeSelect, `false` will highlight match item.
     * It's by design.
     */
    filterOption: {
      type: [Boolean, Function],
      default: void 0
    },
    filterSort: Function,
    optionFilterProp: String,
    optionLabelProp: String,
    options: Array,
    defaultActiveFirstOption: {
      type: Boolean,
      default: void 0
    },
    virtual: {
      type: Boolean,
      default: void 0
    },
    listHeight: Number,
    listItemHeight: Number,
    // >>> Icon
    menuItemSelectedIcon: W.any,
    mode: String,
    labelInValue: {
      type: Boolean,
      default: void 0
    },
    value: W.any,
    defaultValue: W.any,
    onChange: Function,
    children: Array
  });
}
function KE(e) {
  return !e || typeof e != "object";
}
const UE = J({
  compatConfig: {
    MODE: 3
  },
  name: "VcSelect",
  inheritAttrs: !1,
  props: bt(f0(), {
    prefixCls: "vc-select",
    autoClearSearchValue: !0,
    listHeight: 200,
    listItemHeight: 20,
    dropdownMatchSelectWidth: !0
  }),
  setup(e, t) {
    let {
      expose: n,
      attrs: o,
      slots: r
    } = t;
    const a = d0(Je(e, "id")), i = T(() => Zd(e.mode)), l = T(() => !!(!e.options && e.children)), u = T(() => e.filterOption === void 0 && e.mode === "combobox" ? !1 : e.filterOption), s = T(() => Oy(e.fieldNames, l.value)), [c, d] = Gt("", {
      value: T(() => e.searchValue !== void 0 ? e.searchValue : e.inputValue),
      postState: (Y) => Y || ""
    }), f = BE(Je(e, "options"), Je(e, "children"), s), {
      valueOptions: p,
      labelOptions: v,
      options: g
    } = f, b = (Y) => tf(Y).map((X) => {
      var re, ie;
      let he, ge, we, Le;
      KE(X) ? he = X : (we = X.key, ge = X.label, he = (re = X.value) !== null && re !== void 0 ? re : we);
      const be = p.value.get(he);
      return be && (ge === void 0 && (ge = be == null ? void 0 : be[e.optionLabelProp || s.value.label]), we === void 0 && (we = (ie = be == null ? void 0 : be.key) !== null && ie !== void 0 ? ie : he), Le = be == null ? void 0 : be.disabled), {
        label: ge,
        value: he,
        key: we,
        disabled: Le,
        option: be
      };
    }), [y, S] = Gt(e.defaultValue, {
      value: Je(e, "value")
    }), w = T(() => {
      var Y;
      const V = b(y.value);
      return e.mode === "combobox" && !(!((Y = V[0]) === null || Y === void 0) && Y.value) ? [] : V;
    }), [C, $] = VE(w, p), O = T(() => {
      if (!e.mode && C.value.length === 1) {
        const Y = C.value[0];
        if (Y.value === null && (Y.label === null || Y.label === void 0))
          return [];
      }
      return C.value.map((Y) => {
        var V;
        return h(h({}, Y), {
          label: (V = typeof Y.label == "function" ? Y.label() : Y.label) !== null && V !== void 0 ? V : Y.value
        });
      });
    }), x = T(() => new Set(C.value.map((Y) => Y.value)));
    Ve(() => {
      var Y;
      if (e.mode === "combobox") {
        const V = (Y = C.value[0]) === null || Y === void 0 ? void 0 : Y.value;
        V != null && d(String(V));
      }
    }, {
      flush: "post"
    });
    const M = (Y, V) => {
      const X = V ?? Y;
      return {
        [s.value.value]: Y,
        [s.value.label]: X
      };
    }, _ = K();
    Ve(() => {
      if (e.mode !== "tags") {
        _.value = g.value;
        return;
      }
      const Y = g.value.slice(), V = (X) => p.value.has(X);
      [...C.value].sort((X, re) => X.value < re.value ? -1 : 1).forEach((X) => {
        const re = X.value;
        V(re) || Y.push(M(re, X.label));
      }), _.value = Y;
    });
    const N = jE(_, s, c, u, Je(e, "optionFilterProp")), I = T(() => e.mode !== "tags" || !c.value || N.value.some((Y) => Y[e.optionFilterProp || "value"] === c.value) ? N.value : [M(c.value), ...N.value]), E = T(() => e.filterSort ? [...I.value].sort((Y, V) => e.filterSort(Y, V)) : I.value), B = T(() => bO(E.value, {
      fieldNames: s.value,
      childrenAsData: l.value
    })), k = (Y) => {
      const V = b(Y);
      if (S(V), e.onChange && // Trigger event only when value changed
      (V.length !== C.value.length || V.some((X, re) => {
        var ie;
        return ((ie = C.value[re]) === null || ie === void 0 ? void 0 : ie.value) !== (X == null ? void 0 : X.value);
      }))) {
        const X = e.labelInValue ? V.map((ie) => h(h({}, ie), {
          originLabel: ie.label,
          label: typeof ie.label == "function" ? ie.label() : ie.label
        })) : V.map((ie) => ie.value), re = V.map((ie) => Cc($(ie.value)));
        e.onChange(
          // Value
          i.value ? X : X[0],
          // Option
          i.value ? re : re[0]
        );
      }
    }, [P, R] = yt(null), [D, A] = yt(0), H = T(() => e.defaultActiveFirstOption !== void 0 ? e.defaultActiveFirstOption : e.mode !== "combobox"), j = function(Y, V) {
      let {
        source: X = "keyboard"
      } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      A(V), e.backfill && e.mode === "combobox" && Y !== null && X === "keyboard" && R(String(Y));
    }, z = (Y, V) => {
      const X = () => {
        var re;
        const ie = $(Y), he = ie == null ? void 0 : ie[s.value.label];
        return [e.labelInValue ? {
          label: typeof he == "function" ? he() : he,
          originLabel: he,
          value: Y,
          key: (re = ie == null ? void 0 : ie.key) !== null && re !== void 0 ? re : Y
        } : Y, Cc(ie)];
      };
      if (V && e.onSelect) {
        const [re, ie] = X();
        e.onSelect(re, ie);
      } else if (!V && e.onDeselect) {
        const [re, ie] = X();
        e.onDeselect(re, ie);
      }
    }, F = (Y, V) => {
      let X;
      const re = i.value ? V.selected : !0;
      re ? X = i.value ? [...C.value, Y] : [Y] : X = C.value.filter((ie) => ie.value !== Y), k(X), z(Y, re), e.mode === "combobox" ? R("") : (!i.value || e.autoClearSearchValue) && (d(""), R(""));
    }, U = (Y, V) => {
      k(Y), (V.type === "remove" || V.type === "clear") && V.values.forEach((X) => {
        z(X.value, !1);
      });
    }, Q = (Y, V) => {
      var X;
      if (d(Y), R(null), V.source === "submit") {
        const re = (Y || "").trim();
        if (re) {
          const ie = Array.from(/* @__PURE__ */ new Set([...x.value, re]));
          k(ie), z(re, !0), d("");
        }
        return;
      }
      V.source !== "blur" && (e.mode === "combobox" && k(Y), (X = e.onSearch) === null || X === void 0 || X.call(e, Y));
    }, q = (Y) => {
      let V = Y;
      e.mode !== "tags" && (V = Y.map((re) => {
        const ie = v.value.get(re);
        return ie == null ? void 0 : ie.value;
      }).filter((re) => re !== void 0));
      const X = Array.from(/* @__PURE__ */ new Set([...x.value, ...V]));
      k(X), X.forEach((re) => {
        z(re, !0);
      });
    }, oe = T(() => e.virtual !== !1 && e.dropdownMatchSelectWidth !== !1);
    _E(Fl(h(h({}, f), {
      flattenOptions: B,
      onActiveValue: j,
      defaultActiveFirstOption: H,
      onSelect: F,
      menuItemSelectedIcon: Je(e, "menuItemSelectedIcon"),
      rawValues: x,
      fieldNames: s,
      virtual: oe,
      listHeight: Je(e, "listHeight"),
      listItemHeight: Je(e, "listItemHeight"),
      childrenAsData: l
    }))), process.env.NODE_ENV !== "production" && Ve(() => {
      zE(e);
    }, {
      flush: "post"
    });
    const Z = G();
    n({
      focus() {
        var Y;
        (Y = Z.value) === null || Y === void 0 || Y.focus();
      },
      blur() {
        var Y;
        (Y = Z.value) === null || Y === void 0 || Y.blur();
      },
      scrollTo(Y) {
        var V;
        (V = Z.value) === null || V === void 0 || V.scrollTo(Y);
      }
    });
    const ne = T(() => pt(e, [
      "id",
      "mode",
      "prefixCls",
      "backfill",
      "fieldNames",
      // Search
      "inputValue",
      "searchValue",
      "onSearch",
      "autoClearSearchValue",
      // Select
      "onSelect",
      "onDeselect",
      "dropdownMatchSelectWidth",
      // Options
      "filterOption",
      "filterSort",
      "optionFilterProp",
      "optionLabelProp",
      "options",
      "children",
      "defaultActiveFirstOption",
      "menuItemSelectedIcon",
      "virtual",
      "listHeight",
      "listItemHeight",
      // Value
      "value",
      "defaultValue",
      "labelInValue",
      "onChange"
    ]));
    return () => m(i0, L(L(L({}, ne.value), o), {}, {
      id: a,
      prefixCls: e.prefixCls,
      ref: Z,
      omitDomProps: WE,
      mode: e.mode,
      displayValues: O.value,
      onDisplayValuesChange: U,
      searchValue: c.value,
      onSearch: Q,
      onSearchSplit: q,
      dropdownMatchSelectWidth: e.dropdownMatchSelectWidth,
      OptionList: NE,
      emptyOptions: !B.value.length,
      activeValue: P.value,
      activeDescendantId: `${a}_list_${D.value}`
    }), r);
  }
}), nf = () => null;
nf.isSelectOption = !0;
nf.displayName = "ASelectOption";
const of = () => null;
of.isSelectOptGroup = !0;
of.displayName = "ASelectOptGroup";
var GE = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z" } }] }, name: "down", theme: "outlined" }, YE = Symbol("iconContext"), p0 = function() {
  return nt(YE, {
    prefixCls: G("anticon"),
    rootClassName: G(""),
    csp: G()
  });
};
function rf() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function XE(e, t) {
  return e && e.contains ? e.contains(t) : !1;
}
var sm = "data-vc-order", qE = "vc-icon-key", Dc = /* @__PURE__ */ new Map();
function v0() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = e.mark;
  return t ? t.startsWith("data-") ? t : "data-".concat(t) : qE;
}
function af(e) {
  if (e.attachTo)
    return e.attachTo;
  var t = document.querySelector("head");
  return t || document.body;
}
function QE(e) {
  return e === "queue" ? "prependQueue" : e ? "prepend" : "append";
}
function m0(e) {
  return Array.from((Dc.get(e) || e).children).filter(function(t) {
    return t.tagName === "STYLE";
  });
}
function g0(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!rf())
    return null;
  var n = t.csp, o = t.prepend, r = document.createElement("style");
  r.setAttribute(sm, QE(o)), n && n.nonce && (r.nonce = n.nonce), r.innerHTML = e;
  var a = af(t), i = a.firstChild;
  if (o) {
    if (o === "queue") {
      var l = m0(a).filter(function(u) {
        return ["prepend", "prependQueue"].includes(u.getAttribute(sm));
      });
      if (l.length)
        return a.insertBefore(r, l[l.length - 1].nextSibling), r;
    }
    a.insertBefore(r, i);
  } else
    a.appendChild(r);
  return r;
}
function ZE(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = af(t);
  return m0(n).find(function(o) {
    return o.getAttribute(v0(t)) === e;
  });
}
function JE(e, t) {
  var n = Dc.get(e);
  if (!n || !XE(document, n)) {
    var o = g0("", t), r = o.parentNode;
    Dc.set(e, r), e.removeChild(o);
  }
}
function e2(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = af(n);
  JE(o, n);
  var r = ZE(t, n);
  if (r)
    return n.csp && n.csp.nonce && r.nonce !== n.csp.nonce && (r.nonce = n.csp.nonce), r.innerHTML !== e && (r.innerHTML = e), r;
  var a = g0(e, n);
  return a.setAttribute(v0(n), t), a;
}
function um(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      t2(e, r, n[r]);
    });
  }
  return e;
}
function t2(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function n2(e, t) {
  process.env.NODE_ENV !== "production" && !e && console !== void 0 && console.error("Warning: ".concat(t));
}
function o2(e, t) {
  n2(e, "[@ant-design/icons-vue] ".concat(t));
}
function cm(e) {
  return typeof e == "object" && typeof e.name == "string" && typeof e.theme == "string" && (typeof e.icon == "object" || typeof e.icon == "function");
}
function Ac(e, t, n) {
  return n ? rc(e.tag, um({
    key: t
  }, n, e.attrs), (e.children || []).map(function(o, r) {
    return Ac(o, "".concat(t, "-").concat(e.tag, "-").concat(r));
  })) : rc(e.tag, um({
    key: t
  }, e.attrs), (e.children || []).map(function(o, r) {
    return Ac(o, "".concat(t, "-").concat(e.tag, "-").concat(r));
  }));
}
function h0(e) {
  return yr(e)[0];
}
function b0(e) {
  return e ? Array.isArray(e) ? e : [e] : [];
}
var r2 = `
.anticon {
  display: inline-block;
  color: inherit;
  font-style: normal;
  line-height: 0;
  text-align: center;
  text-transform: none;
  vertical-align: -0.125em;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.anticon > * {
  line-height: 1;
}

.anticon svg {
  display: inline-block;
}

.anticon::before {
  display: none;
}

.anticon .anticon-icon {
  display: block;
}

.anticon[tabindex] {
  cursor: pointer;
}

.anticon-spin::before,
.anticon-spin {
  display: inline-block;
  -webkit-animation: loadingCircle 1s infinite linear;
  animation: loadingCircle 1s infinite linear;
}

@-webkit-keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}

@keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}
`;
function y0(e) {
  return e && e.getRootNode && e.getRootNode();
}
function a2(e) {
  return rf() ? y0(e) instanceof ShadowRoot : !1;
}
function i2(e) {
  return a2(e) ? y0(e) : null;
}
var l2 = function() {
  var t = p0(), n = t.prefixCls, o = t.csp, r = On(), a = r2;
  n && (a = a.replace(/anticon/g, n.value)), mt(function() {
    if (rf()) {
      var i = r.vnode.el, l = i2(i);
      e2(a, "@ant-design-vue-icons", {
        prepend: !0,
        csp: o.value,
        attachTo: l
      });
    }
  });
}, s2 = ["icon", "primaryColor", "secondaryColor"];
function u2(e, t) {
  if (e == null)
    return {};
  var n = c2(e, t), o, r;
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(e);
    for (r = 0; r < a.length; r++)
      o = a[r], !(t.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(e, o) && (n[o] = e[o]);
  }
  return n;
}
function c2(e, t) {
  if (e == null)
    return {};
  var n = {}, o = Object.keys(e), r, a;
  for (a = 0; a < o.length; a++)
    r = o[a], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function dl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      d2(e, r, n[r]);
    });
  }
  return e;
}
function d2(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Ga = Et({
  primaryColor: "#333",
  secondaryColor: "#E6E6E6",
  calculated: !1
});
function f2(e) {
  var t = e.primaryColor, n = e.secondaryColor;
  Ga.primaryColor = t, Ga.secondaryColor = n || h0(t), Ga.calculated = !!n;
}
function p2() {
  return dl({}, Ga);
}
var qo = function(t, n) {
  var o = dl({}, t, n.attrs), r = o.icon, a = o.primaryColor, i = o.secondaryColor, l = u2(o, s2), u = Ga;
  if (a && (u = {
    primaryColor: a,
    secondaryColor: i || h0(a)
  }), o2(cm(r), "icon should be icon definiton, but got ".concat(r)), !cm(r))
    return null;
  var s = r;
  return s && typeof s.icon == "function" && (s = dl({}, s, {
    icon: s.icon(u.primaryColor, u.secondaryColor)
  })), Ac(s.icon, "svg-".concat(s.name), dl({}, l, {
    "data-icon": s.name,
    width: "1em",
    height: "1em",
    fill: "currentColor",
    "aria-hidden": "true"
  }));
};
qo.props = {
  icon: Object,
  primaryColor: String,
  secondaryColor: String,
  focusable: String
};
qo.inheritAttrs = !1;
qo.displayName = "IconBase";
qo.getTwoToneColors = p2;
qo.setTwoToneColors = f2;
function v2(e, t) {
  return b2(e) || h2(e, t) || g2(e, t) || m2();
}
function m2() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function g2(e, t) {
  if (e) {
    if (typeof e == "string")
      return dm(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set")
      return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return dm(e, t);
  }
}
function dm(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, o = new Array(t); n < t; n++)
    o[n] = e[n];
  return o;
}
function h2(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var o = [], r = !0, a = !1, i, l;
    try {
      for (n = n.call(e); !(r = (i = n.next()).done) && (o.push(i.value), !(t && o.length === t)); r = !0)
        ;
    } catch (u) {
      a = !0, l = u;
    } finally {
      try {
        !r && n.return != null && n.return();
      } finally {
        if (a)
          throw l;
      }
    }
    return o;
  }
}
function b2(e) {
  if (Array.isArray(e))
    return e;
}
function S0(e) {
  var t = b0(e), n = v2(t, 2), o = n[0], r = n[1];
  return qo.setTwoToneColors({
    primaryColor: o,
    secondaryColor: r
  });
}
function y2() {
  var e = qo.getTwoToneColors();
  return e.calculated ? [e.primaryColor, e.secondaryColor] : e.primaryColor;
}
var S2 = J({
  name: "InsertStyles",
  setup: function() {
    return l2(), function() {
      return null;
    };
  }
}), $2 = ["class", "icon", "spin", "rotate", "tabindex", "twoToneColor", "onClick"];
function C2(e, t) {
  return P2(e) || O2(e, t) || x2(e, t) || w2();
}
function w2() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function x2(e, t) {
  if (e) {
    if (typeof e == "string")
      return fm(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set")
      return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return fm(e, t);
  }
}
function fm(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, o = new Array(t); n < t; n++)
    o[n] = e[n];
  return o;
}
function O2(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var o = [], r = !0, a = !1, i, l;
    try {
      for (n = n.call(e); !(r = (i = n.next()).done) && (o.push(i.value), !(t && o.length === t)); r = !0)
        ;
    } catch (u) {
      a = !0, l = u;
    } finally {
      try {
        !r && n.return != null && n.return();
      } finally {
        if (a)
          throw l;
      }
    }
    return o;
  }
}
function P2(e) {
  if (Array.isArray(e))
    return e;
}
function pm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      za(e, r, n[r]);
    });
  }
  return e;
}
function za(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function I2(e, t) {
  if (e == null)
    return {};
  var n = T2(e, t), o, r;
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(e);
    for (r = 0; r < a.length; r++)
      o = a[r], !(t.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(e, o) && (n[o] = e[o]);
  }
  return n;
}
function T2(e, t) {
  if (e == null)
    return {};
  var n = {}, o = Object.keys(e), r, a;
  for (a = 0; a < o.length; a++)
    r = o[a], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
S0(w1.primary);
var it = function(t, n) {
  var o, r = pm({}, t, n.attrs), a = r.class, i = r.icon, l = r.spin, u = r.rotate, s = r.tabindex, c = r.twoToneColor, d = r.onClick, f = I2(r, $2), p = p0(), v = p.prefixCls, g = p.rootClassName, b = (o = {}, za(o, g.value, !!g.value), za(o, v.value, !0), za(o, "".concat(v.value, "-").concat(i.name), !!i.name), za(o, "".concat(v.value, "-spin"), !!l || i.name === "loading"), o), y = s;
  y === void 0 && d && (y = -1);
  var S = u ? {
    msTransform: "rotate(".concat(u, "deg)"),
    transform: "rotate(".concat(u, "deg)")
  } : void 0, w = b0(c), C = C2(w, 2), $ = C[0], O = C[1];
  return m("span", pm({
    role: "img",
    "aria-label": i.name
  }, f, {
    onClick: d,
    class: [b, a],
    tabindex: y
  }), [m(qo, {
    icon: i,
    primaryColor: $,
    secondaryColor: O,
    style: S
  }, null), m(S2, null, null)]);
};
it.props = {
  spin: Boolean,
  rotate: Number,
  icon: Object,
  twoToneColor: [String, Array]
};
it.displayName = "AntdIcon";
it.inheritAttrs = !1;
it.getTwoToneColor = y2;
it.setTwoToneColor = S0;
function vm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      E2(e, r, n[r]);
    });
  }
  return e;
}
function E2(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var ws = function(t, n) {
  var o = vm({}, t, n.attrs);
  return m(it, vm({}, o, {
    icon: GE
  }), null);
};
ws.displayName = "DownOutlined";
ws.inheritAttrs = !1;
var M2 = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, name: "loading", theme: "outlined" };
function mm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      _2(e, r, n[r]);
    });
  }
  return e;
}
function _2(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var pn = function(t, n) {
  var o = mm({}, t, n.attrs);
  return m(it, mm({}, o, {
    icon: M2
  }), null);
};
pn.displayName = "LoadingOutlined";
pn.inheritAttrs = !1;
var D2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, name: "check", theme: "outlined" };
function gm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      A2(e, r, n[r]);
    });
  }
  return e;
}
function A2(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var xs = function(t, n) {
  var o = gm({}, t, n.attrs);
  return m(it, gm({}, o, {
    icon: D2
  }), null);
};
xs.displayName = "CheckOutlined";
xs.inheritAttrs = !1;
var N2 = { icon: { tag: "svg", attrs: { "fill-rule": "evenodd", viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z" } }] }, name: "close", theme: "outlined" };
function hm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      R2(e, r, n[r]);
    });
  }
  return e;
}
function R2(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Qn = function(t, n) {
  var o = hm({}, t, n.attrs);
  return m(it, hm({}, o, {
    icon: N2
  }), null);
};
Qn.displayName = "CloseOutlined";
Qn.inheritAttrs = !1;
var F2 = { icon: { tag: "svg", attrs: { "fill-rule": "evenodd", viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z" } }] }, name: "close-circle", theme: "filled" };
function bm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      B2(e, r, n[r]);
    });
  }
  return e;
}
function B2(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var vn = function(t, n) {
  var o = bm({}, t, n.attrs);
  return m(it, bm({}, o, {
    icon: F2
  }), null);
};
vn.displayName = "CloseCircleFilled";
vn.inheritAttrs = !1;
var k2 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, name: "search", theme: "outlined" };
function ym(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      L2(e, r, n[r]);
    });
  }
  return e;
}
function L2(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Os = function(t, n) {
  var o = ym({}, t, n.attrs);
  return m(it, ym({}, o, {
    icon: k2
  }), null);
};
Os.displayName = "SearchOutlined";
Os.inheritAttrs = !1;
function $0(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    loading: n,
    multiple: o,
    prefixCls: r,
    hasFeedback: a,
    feedbackIcon: i,
    showArrow: l
  } = e, u = e.suffixIcon || t.suffixIcon && t.suffixIcon(), s = e.clearIcon || t.clearIcon && t.clearIcon(), c = e.menuItemSelectedIcon || t.menuItemSelectedIcon && t.menuItemSelectedIcon(), d = e.removeIcon || t.removeIcon && t.removeIcon(), f = s ?? m(vn, null, null), p = (y) => m(We, null, [l !== !1 && y, a && i]);
  let v = null;
  if (u !== void 0)
    v = p(u);
  else if (n)
    v = p(m(pn, {
      spin: !0
    }, null));
  else {
    const y = `${r}-suffix`;
    v = (S) => {
      let {
        open: w,
        showSearch: C
      } = S;
      return p(w && C ? m(Os, {
        class: y
      }, null) : m(ws, {
        class: y
      }, null));
    };
  }
  let g = null;
  c !== void 0 ? g = c : o ? g = m(xs, null, null) : g = null;
  let b = null;
  return d !== void 0 ? b = d : b = m(Qn, null, null), {
    clearIcon: f,
    suffixIcon: v,
    itemIcon: g,
    removeIcon: b
  };
}
function lf(e) {
  const t = Symbol("contextKey");
  return {
    useProvide: (r, a) => {
      const i = Et({});
      return ot(t, i), Ve(() => {
        h(i, r, a || {});
      }), i;
    },
    useInject: () => nt(t, e) || {}
  };
}
const Bl = Symbol("ContextProps"), kl = Symbol("InternalContextProps"), H2 = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : T(() => !0);
  const n = G(/* @__PURE__ */ new Map()), o = (i, l) => {
    n.value.set(i, l), n.value = new Map(n.value);
  }, r = (i) => {
    n.value.delete(i), n.value = new Map(n.value);
  }, a = On();
  le([t, n], () => {
    if (process.env.NODE_ENV !== "production" && t.value && n.value.size > 1) {
      gt(!1, "Form.Item", `FormItem can only collect one field item, you haved set ${[...n.value.values()].map((l) => `\`${l.name}\``).join(", ")} ${n.value.size} field items.
        You can set not need to be collected fields into \`a-form-item-rest\``);
      let i = a;
      for (; i.parent; )
        console.warn("at", i.type), i = i.parent;
    }
  }), ot(Bl, e), ot(kl, {
    addFormItemField: o,
    removeFormItemField: r
  });
}, Nc = {
  id: T(() => {
  }),
  onFieldBlur: () => {
  },
  onFieldChange: () => {
  },
  clearValidate: () => {
  }
}, Rc = {
  addFormItemField: () => {
  },
  removeFormItemField: () => {
  }
}, Lt = () => {
  const e = nt(kl, Rc), t = Symbol("FormItemFieldKey"), n = On();
  return e.addFormItemField(t, n.type), at(() => {
    e.removeFormItemField(t);
  }), ot(kl, Rc), ot(Bl, Nc), nt(Bl, Nc);
}, Fc = J({
  compatConfig: {
    MODE: 3
  },
  name: "AFormItemRest",
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ot(kl, Rc), ot(Bl, Nc), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
}), rn = lf({}), Ll = J({
  name: "NoFormStatus",
  setup(e, t) {
    let {
      slots: n
    } = t;
    return rn.useProvide({}), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
});
function dn(e, t, n) {
  return ae({
    [`${e}-status-success`]: t === "success",
    [`${e}-status-warning`]: t === "warning",
    [`${e}-status-error`]: t === "error",
    [`${e}-status-validating`]: t === "validating",
    [`${e}-has-feedback`]: n
  });
}
const Po = (e, t) => t || e, z2 = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      display: "inline-flex",
      "&-block": {
        display: "flex",
        width: "100%"
      },
      "&-vertical": {
        flexDirection: "column"
      }
    }
  };
}, j2 = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      display: "inline-flex",
      "&-rtl": {
        direction: "rtl"
      },
      "&-vertical": {
        flexDirection: "column"
      },
      "&-align": {
        flexDirection: "column",
        "&-center": {
          alignItems: "center"
        },
        "&-start": {
          alignItems: "flex-start"
        },
        "&-end": {
          alignItems: "flex-end"
        },
        "&-baseline": {
          alignItems: "baseline"
        }
      },
      [`${t}-space-item`]: {
        "&:empty": {
          display: "none"
        }
      }
    }
  };
}, V2 = ht("Space", (e) => [j2(e), z2(e)]);
var W2 = "[object Symbol]";
function Ps(e) {
  return typeof e == "symbol" || io(e) && Tr(e) == W2;
}
function Is(e, t) {
  for (var n = -1, o = e == null ? 0 : e.length, r = Array(o); ++n < o; )
    r[n] = t(e[n], n, e);
  return r;
}
var K2 = 1 / 0, Sm = Fn ? Fn.prototype : void 0, $m = Sm ? Sm.toString : void 0;
function C0(e) {
  if (typeof e == "string")
    return e;
  if (xn(e))
    return Is(e, C0) + "";
  if (Ps(e))
    return $m ? $m.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -K2 ? "-0" : t;
}
var U2 = /\s/;
function G2(e) {
  for (var t = e.length; t-- && U2.test(e.charAt(t)); )
    ;
  return t;
}
var Y2 = /^\s+/;
function X2(e) {
  return e && e.slice(0, G2(e) + 1).replace(Y2, "");
}
var Cm = NaN, q2 = /^[-+]0x[0-9a-f]+$/i, Q2 = /^0b[01]+$/i, Z2 = /^0o[0-7]+$/i, J2 = parseInt;
function Bc(e) {
  if (typeof e == "number")
    return e;
  if (Ps(e))
    return Cm;
  if (Gn(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Gn(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = X2(e);
  var n = Q2.test(e);
  return n || Z2.test(e) ? J2(e.slice(2), n ? 2 : 8) : q2.test(e) ? Cm : +e;
}
var wm = 1 / 0, eM = 17976931348623157e292;
function tM(e) {
  if (!e)
    return e === 0 ? e : 0;
  if (e = Bc(e), e === wm || e === -wm) {
    var t = e < 0 ? -1 : 1;
    return t * eM;
  }
  return e === e ? e : 0;
}
function nM(e) {
  var t = tM(e), n = t % 1;
  return t === t ? n ? t - n : t : 0;
}
function sf(e) {
  return e;
}
var xm = Object.create, oM = /* @__PURE__ */ function() {
  function e() {
  }
  return function(t) {
    if (!Gn(t))
      return {};
    if (xm)
      return xm(t);
    e.prototype = t;
    var n = new e();
    return e.prototype = void 0, n;
  };
}();
function rM(e, t, n) {
  switch (n.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, n[0]);
    case 2:
      return e.call(t, n[0], n[1]);
    case 3:
      return e.call(t, n[0], n[1], n[2]);
  }
  return e.apply(t, n);
}
function aM() {
}
function iM(e, t) {
  var n = -1, o = e.length;
  for (t || (t = Array(o)); ++n < o; )
    t[n] = e[n];
  return t;
}
var lM = 800, sM = 16, uM = Date.now;
function cM(e) {
  var t = 0, n = 0;
  return function() {
    var o = uM(), r = sM - (o - n);
    if (n = o, r > 0) {
      if (++t >= lM)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
function dM(e) {
  return function() {
    return e;
  };
}
var Hl = function() {
  try {
    var e = Mr(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
}(), fM = Hl ? function(e, t) {
  return Hl(e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: dM(t),
    writable: !0
  });
} : sf, w0 = cM(fM);
function pM(e, t) {
  for (var n = -1, o = e == null ? 0 : e.length; ++n < o && t(e[n], n, e) !== !1; )
    ;
  return e;
}
function x0(e, t, n, o) {
  for (var r = e.length, a = n + -1; ++a < r; )
    if (t(e[a], a, e))
      return a;
  return -1;
}
function vM(e) {
  return e !== e;
}
function mM(e, t, n) {
  for (var o = n - 1, r = e.length; ++o < r; )
    if (e[o] === t)
      return o;
  return -1;
}
function gM(e, t, n) {
  return t === t ? mM(e, t, n) : x0(e, vM, n);
}
function O0(e, t) {
  var n = e == null ? 0 : e.length;
  return !!n && gM(e, t, 0) > -1;
}
function P0(e, t, n) {
  t == "__proto__" && Hl ? Hl(e, t, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : e[t] = n;
}
var hM = Object.prototype, bM = hM.hasOwnProperty;
function uf(e, t, n) {
  var o = e[t];
  (!(bM.call(e, t) && Hd(o, n)) || n === void 0 && !(t in e)) && P0(e, t, n);
}
function wi(e, t, n, o) {
  var r = !n;
  n || (n = {});
  for (var a = -1, i = t.length; ++a < i; ) {
    var l = t[a], u = void 0;
    u === void 0 && (u = e[l]), r ? P0(n, l, u) : uf(n, l, u);
  }
  return n;
}
var Om = Math.max;
function I0(e, t, n) {
  return t = Om(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var o = arguments, r = -1, a = Om(o.length - t, 0), i = Array(a); ++r < a; )
      i[r] = o[t + r];
    r = -1;
    for (var l = Array(t + 1); ++r < t; )
      l[r] = o[r];
    return l[t] = n(i), rM(e, this, l);
  };
}
function yM(e, t) {
  return w0(I0(e, t, sf), e + "");
}
function SM(e) {
  var t = [];
  if (e != null)
    for (var n in Object(e))
      t.push(n);
  return t;
}
var $M = Object.prototype, CM = $M.hasOwnProperty;
function wM(e) {
  if (!Gn(e))
    return SM(e);
  var t = gs(e), n = [];
  for (var o in e)
    o == "constructor" && (t || !CM.call(e, o)) || n.push(o);
  return n;
}
function cf(e) {
  return Sa(e) ? Ky(e, !0) : wM(e);
}
var xM = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, OM = /^\w*$/;
function df(e, t) {
  if (xn(e))
    return !1;
  var n = typeof e;
  return n == "number" || n == "symbol" || n == "boolean" || e == null || Ps(e) ? !0 : OM.test(e) || !xM.test(e) || t != null && e in Object(t);
}
var PM = "Expected a function";
function ff(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(PM);
  var n = function() {
    var o = arguments, r = t ? t.apply(this, o) : o[0], a = n.cache;
    if (a.has(r))
      return a.get(r);
    var i = e.apply(this, o);
    return n.cache = a.set(r, i) || a, i;
  };
  return n.cache = new (ff.Cache || Oo)(), n;
}
ff.Cache = Oo;
var IM = 500;
function TM(e) {
  var t = ff(e, function(o) {
    return n.size === IM && n.clear(), o;
  }), n = t.cache;
  return t;
}
var EM = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, MM = /\\(\\)?/g, _M = TM(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(EM, function(n, o, r, a) {
    t.push(r ? a.replace(MM, "$1") : o || n);
  }), t;
});
function DM(e) {
  return e == null ? "" : C0(e);
}
function xa(e, t) {
  return xn(e) ? e : df(e, t) ? [e] : _M(DM(e));
}
var AM = 1 / 0;
function Oa(e) {
  if (typeof e == "string" || Ps(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -AM ? "-0" : t;
}
function Ts(e, t) {
  t = xa(t, e);
  for (var n = 0, o = t.length; e != null && n < o; )
    e = e[Oa(t[n++])];
  return n && n == o ? e : void 0;
}
function NM(e, t, n) {
  var o = e == null ? void 0 : Ts(e, t);
  return o === void 0 ? n : o;
}
var Pm = Fn ? Fn.isConcatSpreadable : void 0;
function RM(e) {
  return xn(e) || vs(e) || !!(Pm && e && e[Pm]);
}
function FM(e, t, n, o, r) {
  var a = -1, i = e.length;
  for (n || (n = RM), r || (r = []); ++a < i; ) {
    var l = e[a];
    n(l) ? jd(r, l) : r[r.length] = l;
  }
  return r;
}
function BM(e) {
  var t = e == null ? 0 : e.length;
  return t ? FM(e) : [];
}
function T0(e) {
  return w0(I0(e, void 0, BM), e + "");
}
var pf = Uy(Object.getPrototypeOf, Object), kM = "[object Object]", LM = Function.prototype, HM = Object.prototype, E0 = LM.toString, zM = HM.hasOwnProperty, jM = E0.call(Object);
function M0(e) {
  if (!io(e) || Tr(e) != kM)
    return !1;
  var t = pf(e);
  if (t === null)
    return !0;
  var n = zM.call(t, "constructor") && t.constructor;
  return typeof n == "function" && n instanceof n && E0.call(n) == jM;
}
function VM(e, t, n) {
  var o = -1, r = e.length;
  t < 0 && (t = -t > r ? 0 : r + t), n = n > r ? r : n, n < 0 && (n += r), r = t > n ? 0 : n - t >>> 0, t >>>= 0;
  for (var a = Array(r); ++o < r; )
    a[o] = e[o + t];
  return a;
}
function WM(e, t) {
  return e && wi(t, $a(t), e);
}
function KM(e, t) {
  return e && wi(t, cf(t), e);
}
var _0 = typeof exports == "object" && exports && !exports.nodeType && exports, Im = _0 && typeof module == "object" && module && !module.nodeType && module, UM = Im && Im.exports === _0, Tm = UM ? qn.Buffer : void 0, Em = Tm ? Tm.allocUnsafe : void 0;
function GM(e, t) {
  if (t)
    return e.slice();
  var n = e.length, o = Em ? Em(n) : new e.constructor(n);
  return e.copy(o), o;
}
function YM(e, t) {
  return wi(e, Vd(e), t);
}
var XM = Object.getOwnPropertySymbols, D0 = XM ? function(e) {
  for (var t = []; e; )
    jd(t, Vd(e)), e = pf(e);
  return t;
} : zy;
function qM(e, t) {
  return wi(e, D0(e), t);
}
function A0(e) {
  return Hy(e, cf, D0);
}
var QM = Object.prototype, ZM = QM.hasOwnProperty;
function JM(e) {
  var t = e.length, n = new e.constructor(t);
  return t && typeof e[0] == "string" && ZM.call(e, "index") && (n.index = e.index, n.input = e.input), n;
}
function vf(e) {
  var t = new e.constructor(e.byteLength);
  return new Rl(t).set(new Rl(e)), t;
}
function e_(e, t) {
  var n = t ? vf(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.byteLength);
}
var t_ = /\w*$/;
function n_(e) {
  var t = new e.constructor(e.source, t_.exec(e));
  return t.lastIndex = e.lastIndex, t;
}
var Mm = Fn ? Fn.prototype : void 0, _m = Mm ? Mm.valueOf : void 0;
function o_(e) {
  return _m ? Object(_m.call(e)) : {};
}
function r_(e, t) {
  var n = t ? vf(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.length);
}
var a_ = "[object Boolean]", i_ = "[object Date]", l_ = "[object Map]", s_ = "[object Number]", u_ = "[object RegExp]", c_ = "[object Set]", d_ = "[object String]", f_ = "[object Symbol]", p_ = "[object ArrayBuffer]", v_ = "[object DataView]", m_ = "[object Float32Array]", g_ = "[object Float64Array]", h_ = "[object Int8Array]", b_ = "[object Int16Array]", y_ = "[object Int32Array]", S_ = "[object Uint8Array]", $_ = "[object Uint8ClampedArray]", C_ = "[object Uint16Array]", w_ = "[object Uint32Array]";
function x_(e, t, n) {
  var o = e.constructor;
  switch (t) {
    case p_:
      return vf(e);
    case a_:
    case i_:
      return new o(+e);
    case v_:
      return e_(e, n);
    case m_:
    case g_:
    case h_:
    case b_:
    case y_:
    case S_:
    case $_:
    case C_:
    case w_:
      return r_(e, n);
    case l_:
      return new o();
    case s_:
    case d_:
      return new o(e);
    case u_:
      return n_(e);
    case c_:
      return new o();
    case f_:
      return o_(e);
  }
}
function O_(e) {
  return typeof e.constructor == "function" && !gs(e) ? oM(pf(e)) : {};
}
var P_ = "[object Map]";
function I_(e) {
  return io(e) && Dn(e) == P_;
}
var Dm = va && va.isMap, T_ = Dm ? ms(Dm) : I_, E_ = "[object Set]";
function M_(e) {
  return io(e) && Dn(e) == E_;
}
var Am = va && va.isSet, __ = Am ? ms(Am) : M_, D_ = 1, A_ = 2, N_ = 4, N0 = "[object Arguments]", R_ = "[object Array]", F_ = "[object Boolean]", B_ = "[object Date]", k_ = "[object Error]", R0 = "[object Function]", L_ = "[object GeneratorFunction]", H_ = "[object Map]", z_ = "[object Number]", F0 = "[object Object]", j_ = "[object RegExp]", V_ = "[object Set]", W_ = "[object String]", K_ = "[object Symbol]", U_ = "[object WeakMap]", G_ = "[object ArrayBuffer]", Y_ = "[object DataView]", X_ = "[object Float32Array]", q_ = "[object Float64Array]", Q_ = "[object Int8Array]", Z_ = "[object Int16Array]", J_ = "[object Int32Array]", eD = "[object Uint8Array]", tD = "[object Uint8ClampedArray]", nD = "[object Uint16Array]", oD = "[object Uint32Array]", $t = {};
$t[N0] = $t[R_] = $t[G_] = $t[Y_] = $t[F_] = $t[B_] = $t[X_] = $t[q_] = $t[Q_] = $t[Z_] = $t[J_] = $t[H_] = $t[z_] = $t[F0] = $t[j_] = $t[V_] = $t[W_] = $t[K_] = $t[eD] = $t[tD] = $t[nD] = $t[oD] = !0;
$t[k_] = $t[R0] = $t[U_] = !1;
function Ya(e, t, n, o, r, a) {
  var i, l = t & D_, u = t & A_, s = t & N_;
  if (n && (i = r ? n(e, o, r, a) : n(e)), i !== void 0)
    return i;
  if (!Gn(e))
    return e;
  var c = xn(e);
  if (c) {
    if (i = JM(e), !l)
      return iM(e, i);
  } else {
    var d = Dn(e), f = d == R0 || d == L_;
    if (mi(e))
      return GM(e, l);
    if (d == F0 || d == N0 || f && !r) {
      if (i = u || f ? {} : O_(e), !l)
        return u ? qM(e, KM(i, e)) : YM(e, WM(i, e));
    } else {
      if (!$t[d])
        return r ? e : {};
      i = x_(e, d, l);
    }
  }
  a || (a = new oo());
  var p = a.get(e);
  if (p)
    return p;
  a.set(e, i), __(e) ? e.forEach(function(b) {
    i.add(Ya(b, t, n, b, e, a));
  }) : T_(e) && e.forEach(function(b, y) {
    i.set(y, Ya(b, t, n, y, e, a));
  });
  var v = s ? u ? A0 : Ic : u ? cf : $a, g = c ? void 0 : v(e);
  return pM(g || e, function(b, y) {
    g && (y = b, b = e[y]), uf(i, y, Ya(b, t, n, y, e, a));
  }), i;
}
var rD = 1, aD = 4;
function fl(e) {
  return Ya(e, rD | aD);
}
var iD = 1, lD = 2;
function sD(e, t, n, o) {
  var r = n.length, a = r;
  if (e == null)
    return !a;
  for (e = Object(e); r--; ) {
    var i = n[r];
    if (i[2] ? i[1] !== e[i[0]] : !(i[0] in e))
      return !1;
  }
  for (; ++r < a; ) {
    i = n[r];
    var l = i[0], u = e[l], s = i[1];
    if (i[2]) {
      if (u === void 0 && !(l in e))
        return !1;
    } else {
      var c = new oo(), d;
      if (!(d === void 0 ? hs(s, u, iD | lD, o, c) : d))
        return !1;
    }
  }
  return !0;
}
function B0(e) {
  return e === e && !Gn(e);
}
function uD(e) {
  for (var t = $a(e), n = t.length; n--; ) {
    var o = t[n], r = e[o];
    t[n] = [o, r, B0(r)];
  }
  return t;
}
function k0(e, t) {
  return function(n) {
    return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n));
  };
}
function cD(e) {
  var t = uD(e);
  return t.length == 1 && t[0][2] ? k0(t[0][0], t[0][1]) : function(n) {
    return n === e || sD(n, e, t);
  };
}
function dD(e, t) {
  return e != null && t in Object(e);
}
function fD(e, t, n) {
  t = xa(t, e);
  for (var o = -1, r = t.length, a = !1; ++o < r; ) {
    var i = Oa(t[o]);
    if (!(a = e != null && n(e, i)))
      break;
    e = e[i];
  }
  return a || ++o != r ? a : (r = e == null ? 0 : e.length, !!r && Kd(r) && Wd(i, r) && (xn(e) || vs(e)));
}
function L0(e, t) {
  return e != null && fD(e, t, dD);
}
var pD = 1, vD = 2;
function mD(e, t) {
  return df(e) && B0(t) ? k0(Oa(e), t) : function(n) {
    var o = NM(n, e);
    return o === void 0 && o === t ? L0(n, e) : hs(t, o, pD | vD);
  };
}
function gD(e) {
  return function(t) {
    return t == null ? void 0 : t[e];
  };
}
function hD(e) {
  return function(t) {
    return Ts(t, e);
  };
}
function bD(e) {
  return df(e) ? gD(Oa(e)) : hD(e);
}
function mf(e) {
  return typeof e == "function" ? e : e == null ? sf : typeof e == "object" ? xn(e) ? mD(e[0], e[1]) : cD(e) : bD(e);
}
function yD(e, t, n, o) {
  for (var r = -1, a = e == null ? 0 : e.length; ++r < a; ) {
    var i = e[r];
    t(o, i, n(i), e);
  }
  return o;
}
function SD(e) {
  return function(t, n, o) {
    for (var r = -1, a = Object(t), i = o(t), l = i.length; l--; ) {
      var u = i[++r];
      if (n(a[u], u, a) === !1)
        break;
    }
    return t;
  };
}
var $D = SD();
function CD(e, t) {
  return e && $D(e, t, $a);
}
function wD(e, t) {
  return function(n, o) {
    if (n == null)
      return n;
    if (!Sa(n))
      return e(n, o);
    for (var r = n.length, a = -1, i = Object(n); ++a < r && o(i[a], a, i) !== !1; )
      ;
    return n;
  };
}
var xD = wD(CD);
function OD(e, t, n, o) {
  return xD(e, function(r, a, i) {
    t(o, r, n(r), i);
  }), o;
}
function PD(e, t) {
  return function(n, o) {
    var r = xn(n) ? yD : OD, a = t ? t() : {};
    return r(n, e, mf(o), a);
  };
}
var Su = function() {
  return qn.Date.now();
}, ID = "Expected a function", TD = Math.max, ED = Math.min;
function MD(e, t, n) {
  var o, r, a, i, l, u, s = 0, c = !1, d = !1, f = !0;
  if (typeof e != "function")
    throw new TypeError(ID);
  t = Bc(t) || 0, Gn(n) && (c = !!n.leading, d = "maxWait" in n, a = d ? TD(Bc(n.maxWait) || 0, t) : a, f = "trailing" in n ? !!n.trailing : f);
  function p(O) {
    var x = o, M = r;
    return o = r = void 0, s = O, i = e.apply(M, x), i;
  }
  function v(O) {
    return s = O, l = setTimeout(y, t), c ? p(O) : i;
  }
  function g(O) {
    var x = O - u, M = O - s, _ = t - x;
    return d ? ED(_, a - M) : _;
  }
  function b(O) {
    var x = O - u, M = O - s;
    return u === void 0 || x >= t || x < 0 || d && M >= a;
  }
  function y() {
    var O = Su();
    if (b(O))
      return S(O);
    l = setTimeout(y, g(O));
  }
  function S(O) {
    return l = void 0, f && o ? p(O) : (o = r = void 0, i);
  }
  function w() {
    l !== void 0 && clearTimeout(l), s = 0, o = u = r = l = void 0;
  }
  function C() {
    return l === void 0 ? i : S(Su());
  }
  function $() {
    var O = Su(), x = b(O);
    if (o = arguments, r = this, u = O, x) {
      if (l === void 0)
        return v(u);
      if (d)
        return clearTimeout(l), l = setTimeout(y, t), p(u);
    }
    return l === void 0 && (l = setTimeout(y, t)), i;
  }
  return $.cancel = w, $.flush = C, $;
}
function _D(e) {
  return io(e) && Sa(e);
}
function DD(e) {
  var t = e == null ? 0 : e.length;
  return t ? e[t - 1] : void 0;
}
function AD(e) {
  return function(t, n, o) {
    var r = Object(t);
    if (!Sa(t)) {
      var a = mf(n);
      t = $a(t), n = function(l) {
        return a(r[l], l, r);
      };
    }
    var i = e(t, n, o);
    return i > -1 ? r[a ? t[i] : i] : void 0;
  };
}
var ND = Math.max;
function RD(e, t, n) {
  var o = e == null ? 0 : e.length;
  if (!o)
    return -1;
  var r = n == null ? 0 : nM(n);
  return r < 0 && (r = ND(o + r, 0)), x0(e, mf(t), r);
}
var FD = AD(RD), BD = Math.min;
function kD(e, t, n) {
  for (var o = O0, r = e[0].length, a = e.length, i = a, l = Array(a), u = 1 / 0, s = []; i--; ) {
    var c = e[i];
    i && t && (c = Is(c, ms(t))), u = BD(c.length, u), l[i] = r >= 120 && c.length >= 120 ? new pa(i && c) : void 0;
  }
  c = e[0];
  var d = -1, f = l[0];
  e:
    for (; ++d < r && s.length < u; ) {
      var p = c[d], v = p;
      if (p = p !== 0 ? p : 0, !(f ? Nl(f, v) : o(s, v))) {
        for (i = a; --i; ) {
          var g = l[i];
          if (!(g ? Nl(g, v) : o(e[i], v)))
            continue e;
        }
        f && f.push(v), s.push(p);
      }
    }
  return s;
}
function LD(e) {
  return _D(e) ? e : [];
}
var HD = yM(function(e) {
  var t = Is(e, LD);
  return t.length && t[0] === e[0] ? kD(t) : [];
});
function zD(e, t) {
  return t.length < 2 ? e : Ts(e, VM(t, 0, -1));
}
var jD = "[object Map]", VD = "[object Set]", WD = Object.prototype, KD = WD.hasOwnProperty;
function H0(e) {
  if (e == null)
    return !0;
  if (Sa(e) && (xn(e) || typeof e == "string" || typeof e.splice == "function" || mi(e) || Ud(e) || vs(e)))
    return !e.length;
  var t = Dn(e);
  if (t == jD || t == VD)
    return !e.size;
  if (gs(e))
    return !Gy(e).length;
  for (var n in e)
    if (KD.call(e, n))
      return !1;
  return !0;
}
function UD(e, t) {
  return t = xa(t, e), e = zD(e, t), e == null || delete e[Oa(DD(t))];
}
function GD(e) {
  return M0(e) ? void 0 : e;
}
var YD = 1, XD = 2, qD = 4, QD = T0(function(e, t) {
  var n = {};
  if (e == null)
    return n;
  var o = !1;
  t = Is(t, function(a) {
    return a = xa(a, e), o || (o = a.length > 1), a;
  }), wi(e, A0(e), n), o && (n = Ya(n, YD | XD | qD, GD));
  for (var r = t.length; r--; )
    UD(n, t[r]);
  return n;
});
function ZD(e, t, n, o) {
  if (!Gn(e))
    return e;
  t = xa(t, e);
  for (var r = -1, a = t.length, i = a - 1, l = e; l != null && ++r < a; ) {
    var u = Oa(t[r]), s = n;
    if (u === "__proto__" || u === "constructor" || u === "prototype")
      return e;
    if (r != i) {
      var c = l[u];
      s = void 0, s === void 0 && (s = Gn(c) ? c : Wd(t[r + 1]) ? [] : {});
    }
    uf(l, u, s), l = l[u];
  }
  return e;
}
function JD(e, t, n) {
  for (var o = -1, r = t.length, a = {}; ++o < r; ) {
    var i = t[o], l = Ts(e, i);
    n(l, i) && ZD(a, xa(i, e), l);
  }
  return a;
}
var eA = PD(function(e, t, n) {
  e[n ? 0 : 1].push(t);
}, function() {
  return [[], []];
});
function tA(e, t) {
  return JD(e, t, function(n, o) {
    return L0(e, o);
  });
}
var z0 = T0(function(e, t) {
  return e == null ? {} : tA(e, t);
}), nA = 1 / 0, oA = Jr && 1 / zd(new Jr([, -0]))[1] == nA ? function(e) {
  return new Jr(e);
} : aM, rA = 200;
function aA(e, t, n) {
  var o = -1, r = O0, a = e.length, i = !0, l = [], u = l;
  if (a >= rA) {
    var s = oA(e);
    if (s)
      return zd(s);
    i = !1, r = Nl, u = new pa();
  } else
    u = l;
  e:
    for (; ++o < a; ) {
      var c = e[o], d = c;
      if (c = c !== 0 ? c : 0, i && d === d) {
        for (var f = u.length; f--; )
          if (u[f] === d)
            continue e;
        l.push(c);
      } else
        r(u, d, n) || (u !== l && u.push(d), l.push(c));
    }
  return l;
}
function $u(e) {
  return e && e.length ? aA(e) : [];
}
const iA = () => ({
  compactSize: String,
  compactDirection: W.oneOf(ro("horizontal", "vertical")).def("horizontal"),
  isFirstItem: Me(),
  isLastItem: Me()
}), Es = lf(null), Dr = (e, t) => {
  const n = Es.useInject(), o = T(() => {
    if (!n || H0(n))
      return "";
    const {
      compactDirection: r,
      isFirstItem: a,
      isLastItem: i
    } = n, l = r === "vertical" ? "-vertical-" : "-";
    return ae({
      [`${e.value}-compact${l}item`]: !0,
      [`${e.value}-compact${l}first-item`]: a,
      [`${e.value}-compact${l}last-item`]: i,
      [`${e.value}-compact${l}item-rtl`]: t.value === "rtl"
    });
  });
  return {
    compactSize: T(() => n == null ? void 0 : n.compactSize),
    compactDirection: T(() => n == null ? void 0 : n.compactDirection),
    compactItemClassnames: o
  };
}, zl = J({
  name: "NoCompactStyle",
  setup(e, t) {
    let {
      slots: n
    } = t;
    return Es.useProvide(null), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
}), lA = () => ({
  prefixCls: String,
  size: {
    type: String
  },
  direction: W.oneOf(ro("horizontal", "vertical")).def("horizontal"),
  align: W.oneOf(ro("start", "end", "center", "baseline")),
  block: {
    type: Boolean,
    default: void 0
  }
}), sA = J({
  name: "CompactItem",
  props: iA(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return Es.useProvide(e), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
});
J({
  name: "ASpaceCompact",
  inheritAttrs: !1,
  props: lA(),
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const {
      prefixCls: r,
      direction: a
    } = Ke("space-compact", e), i = Es.useInject(), [l, u] = V2(r), s = T(() => ae(r.value, u.value, {
      [`${r.value}-rtl`]: a.value === "rtl",
      [`${r.value}-block`]: e.block,
      [`${r.value}-vertical`]: e.direction === "vertical"
    }));
    return () => {
      var c;
      const d = xt(((c = o.default) === null || c === void 0 ? void 0 : c.call(o)) || []);
      return d.length === 0 ? null : l(m("div", L(L({}, n), {}, {
        class: [s.value, n.class]
      }), [d.map((f, p) => {
        var v;
        const g = f && f.key || `${r.value}-item-${p}`, b = !i || H0(i);
        return m(sA, {
          key: g,
          compactSize: (v = e.size) !== null && v !== void 0 ? v : "middle",
          compactDirection: e.direction,
          isFirstItem: p === 0 && (b || (i == null ? void 0 : i.isFirstItem)),
          isLastItem: p === d.length - 1 && (b || (i == null ? void 0 : i.isLastItem))
        }, {
          default: () => [f]
        });
      })]));
    };
  }
});
const uA = (e) => ({
  animationDuration: e,
  animationFillMode: "both"
}), cA = (e) => ({
  animationDuration: e,
  animationFillMode: "both"
}), Ms = function(e, t, n, o) {
  const a = (arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1) ? "&" : "";
  return {
    [`
      ${a}${e}-enter,
      ${a}${e}-appear
    `]: h(h({}, uA(o)), {
      animationPlayState: "paused"
    }),
    [`${a}${e}-leave`]: h(h({}, cA(o)), {
      animationPlayState: "paused"
    }),
    [`
      ${a}${e}-enter${e}-enter-active,
      ${a}${e}-appear${e}-appear-active
    `]: {
      animationName: t,
      animationPlayState: "running"
    },
    [`${a}${e}-leave${e}-leave-active`]: {
      animationName: n,
      animationPlayState: "running",
      pointerEvents: "none"
    }
  };
}, dA = new Xe("antFadeIn", {
  "0%": {
    opacity: 0
  },
  "100%": {
    opacity: 1
  }
}), fA = new Xe("antFadeOut", {
  "0%": {
    opacity: 1
  },
  "100%": {
    opacity: 0
  }
}), pA = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  const {
    antCls: n
  } = e, o = `${n}-fade`, r = t ? "&" : "";
  return [Ms(o, dA, fA, e.motionDurationMid, t), {
    [`
        ${r}${o}-enter,
        ${r}${o}-appear
      `]: {
      opacity: 0,
      animationTimingFunction: "linear"
    },
    [`${r}${o}-leave`]: {
      animationTimingFunction: "linear"
    }
  }];
}, vA = new Xe("antMoveDownIn", {
  "0%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), mA = new Xe("antMoveDownOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), gA = new Xe("antMoveLeftIn", {
  "0%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), hA = new Xe("antMoveLeftOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), bA = new Xe("antMoveRightIn", {
  "0%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), yA = new Xe("antMoveRightOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), SA = new Xe("antMoveUpIn", {
  "0%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), $A = new Xe("antMoveUpOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), CA = {
  "move-up": {
    inKeyframes: SA,
    outKeyframes: $A
  },
  "move-down": {
    inKeyframes: vA,
    outKeyframes: mA
  },
  "move-left": {
    inKeyframes: gA,
    outKeyframes: hA
  },
  "move-right": {
    inKeyframes: bA,
    outKeyframes: yA
  }
}, jl = (e, t) => {
  const {
    antCls: n
  } = e, o = `${n}-${t}`, {
    inKeyframes: r,
    outKeyframes: a
  } = CA[t];
  return [Ms(o, r, a, e.motionDurationMid), {
    [`
        ${o}-enter,
        ${o}-appear
      `]: {
      opacity: 0,
      animationTimingFunction: e.motionEaseOutCirc
    },
    [`${o}-leave`]: {
      animationTimingFunction: e.motionEaseInOutCirc
    }
  }];
}, gf = new Xe("antSlideUpIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
}), hf = new Xe("antSlideUpOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
}), bf = new Xe("antSlideDownIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  }
}), yf = new Xe("antSlideDownOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  }
}), wA = new Xe("antSlideLeftIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
}), xA = new Xe("antSlideLeftOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
}), OA = new Xe("antSlideRightIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  }
}), PA = new Xe("antSlideRightOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  }
}), IA = {
  "slide-up": {
    inKeyframes: gf,
    outKeyframes: hf
  },
  "slide-down": {
    inKeyframes: bf,
    outKeyframes: yf
  },
  "slide-left": {
    inKeyframes: wA,
    outKeyframes: xA
  },
  "slide-right": {
    inKeyframes: OA,
    outKeyframes: PA
  }
}, Go = (e, t) => {
  const {
    antCls: n
  } = e, o = `${n}-${t}`, {
    inKeyframes: r,
    outKeyframes: a
  } = IA[t];
  return [Ms(o, r, a, e.motionDurationMid), {
    [`
      ${o}-enter,
      ${o}-appear
    `]: {
      transform: "scale(0)",
      transformOrigin: "0% 0%",
      opacity: 0,
      animationTimingFunction: e.motionEaseOutQuint
    },
    [`${o}-leave`]: {
      animationTimingFunction: e.motionEaseInQuint
    }
  }];
}, Sf = new Xe("antZoomIn", {
  "0%": {
    transform: "scale(0.2)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
}), TA = new Xe("antZoomOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.2)",
    opacity: 0
  }
}), Nm = new Xe("antZoomBigIn", {
  "0%": {
    transform: "scale(0.8)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
}), Rm = new Xe("antZoomBigOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.8)",
    opacity: 0
  }
}), EA = new Xe("antZoomUpIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  }
}), MA = new Xe("antZoomUpOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  }
}), _A = new Xe("antZoomLeftIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  }
}), DA = new Xe("antZoomLeftOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  }
}), AA = new Xe("antZoomRightIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  }
}), NA = new Xe("antZoomRightOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  }
}), RA = new Xe("antZoomDownIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  }
}), FA = new Xe("antZoomDownOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  }
}), BA = {
  zoom: {
    inKeyframes: Sf,
    outKeyframes: TA
  },
  "zoom-big": {
    inKeyframes: Nm,
    outKeyframes: Rm
  },
  "zoom-big-fast": {
    inKeyframes: Nm,
    outKeyframes: Rm
  },
  "zoom-left": {
    inKeyframes: _A,
    outKeyframes: DA
  },
  "zoom-right": {
    inKeyframes: AA,
    outKeyframes: NA
  },
  "zoom-up": {
    inKeyframes: EA,
    outKeyframes: MA
  },
  "zoom-down": {
    inKeyframes: RA,
    outKeyframes: FA
  }
}, _s = (e, t) => {
  const {
    antCls: n
  } = e, o = `${n}-${t}`, {
    inKeyframes: r,
    outKeyframes: a
  } = BA[t];
  return [Ms(o, r, a, t === "zoom-big-fast" ? e.motionDurationFast : e.motionDurationMid), {
    [`
        ${o}-enter,
        ${o}-appear
      `]: {
      transform: "scale(0)",
      opacity: 0,
      animationTimingFunction: e.motionEaseOutCirc,
      "&-prepare": {
        transform: "none"
      }
    },
    [`${o}-leave`]: {
      animationTimingFunction: e.motionEaseInOutCirc
    }
  }];
}, $f = (e) => ({
  [e.componentCls]: {
    // For common/openAnimation
    [`${e.antCls}-motion-collapse-legacy`]: {
      overflow: "hidden",
      "&-active": {
        transition: `height ${e.motionDurationMid} ${e.motionEaseInOut},
        opacity ${e.motionDurationMid} ${e.motionEaseInOut} !important`
      }
    },
    [`${e.antCls}-motion-collapse`]: {
      overflow: "hidden",
      transition: `height ${e.motionDurationMid} ${e.motionEaseInOut},
        opacity ${e.motionDurationMid} ${e.motionEaseInOut} !important`
    }
  }
}), Fm = (e) => {
  const {
    controlPaddingHorizontal: t
  } = e;
  return {
    position: "relative",
    display: "block",
    minHeight: e.controlHeight,
    padding: `${(e.controlHeight - e.fontSize * e.lineHeight) / 2}px ${t}px`,
    color: e.colorText,
    fontWeight: "normal",
    fontSize: e.fontSize,
    lineHeight: e.lineHeight,
    boxSizing: "border-box"
  };
}, kA = (e) => {
  const {
    antCls: t,
    componentCls: n
  } = e, o = `${n}-item`;
  return [
    {
      [`${n}-dropdown`]: h(h({}, st(e)), {
        position: "absolute",
        top: -9999,
        zIndex: e.zIndexPopup,
        boxSizing: "border-box",
        padding: e.paddingXXS,
        overflow: "hidden",
        fontSize: e.fontSize,
        // Fix select render lag of long text in chrome
        // https://github.com/ant-design/ant-design/issues/11456
        // https://github.com/ant-design/ant-design/issues/11843
        fontVariant: "initial",
        backgroundColor: e.colorBgElevated,
        borderRadius: e.borderRadiusLG,
        outline: "none",
        boxShadow: e.boxShadowSecondary,
        [`
            &${t}-slide-up-enter${t}-slide-up-enter-active${n}-dropdown-placement-bottomLeft,
            &${t}-slide-up-appear${t}-slide-up-appear-active${n}-dropdown-placement-bottomLeft
          `]: {
          animationName: gf
        },
        [`
            &${t}-slide-up-enter${t}-slide-up-enter-active${n}-dropdown-placement-topLeft,
            &${t}-slide-up-appear${t}-slide-up-appear-active${n}-dropdown-placement-topLeft
          `]: {
          animationName: bf
        },
        [`&${t}-slide-up-leave${t}-slide-up-leave-active${n}-dropdown-placement-bottomLeft`]: {
          animationName: hf
        },
        [`&${t}-slide-up-leave${t}-slide-up-leave-active${n}-dropdown-placement-topLeft`]: {
          animationName: yf
        },
        "&-hidden": {
          display: "none"
        },
        "&-empty": {
          color: e.colorTextDisabled
        },
        // ========================= Options =========================
        [`${o}-empty`]: h(h({}, Fm(e)), {
          color: e.colorTextDisabled
        }),
        [`${o}`]: h(h({}, Fm(e)), {
          cursor: "pointer",
          transition: `background ${e.motionDurationSlow} ease`,
          borderRadius: e.borderRadiusSM,
          // =========== Group ============
          "&-group": {
            color: e.colorTextDescription,
            fontSize: e.fontSizeSM,
            cursor: "default"
          },
          // =========== Option ===========
          "&-option": {
            display: "flex",
            "&-content": h({
              flex: "auto"
            }, So),
            "&-state": {
              flex: "none"
            },
            [`&-active:not(${o}-option-disabled)`]: {
              backgroundColor: e.controlItemBgHover
            },
            [`&-selected:not(${o}-option-disabled)`]: {
              color: e.colorText,
              fontWeight: e.fontWeightStrong,
              backgroundColor: e.controlItemBgActive,
              [`${o}-option-state`]: {
                color: e.colorPrimary
              }
            },
            "&-disabled": {
              [`&${o}-option-selected`]: {
                backgroundColor: e.colorBgContainerDisabled
              },
              color: e.colorTextDisabled,
              cursor: "not-allowed"
            },
            "&-grouped": {
              paddingInlineStart: e.controlPaddingHorizontal * 2
            }
          }
        }),
        // =========================== RTL ===========================
        "&-rtl": {
          direction: "rtl"
        }
      })
    },
    // Follow code may reuse in other components
    Go(e, "slide-up"),
    Go(e, "slide-down"),
    jl(e, "move-up"),
    jl(e, "move-down")
  ];
}, Lr = 2;
function j0(e) {
  let {
    controlHeightSM: t,
    controlHeight: n,
    lineWidth: o
  } = e;
  const r = (n - t) / 2 - o, a = Math.ceil(r / 2);
  return [r, a];
}
function Cu(e, t) {
  const {
    componentCls: n,
    iconCls: o
  } = e, r = `${n}-selection-overflow`, a = e.controlHeightSM, [i] = j0(e), l = t ? `${n}-${t}` : "";
  return {
    [`${n}-multiple${l}`]: {
      fontSize: e.fontSize,
      /**
       * Do not merge `height` & `line-height` under style with `selection` & `search`, since chrome
       * may update to redesign with its align logic.
       */
      // =========================== Overflow ===========================
      [r]: {
        position: "relative",
        display: "flex",
        flex: "auto",
        flexWrap: "wrap",
        maxWidth: "100%",
        "&-item": {
          flex: "none",
          alignSelf: "center",
          maxWidth: "100%",
          display: "inline-flex"
        }
      },
      // ========================= Selector =========================
      [`${n}-selector`]: {
        display: "flex",
        flexWrap: "wrap",
        alignItems: "center",
        // Multiple is little different that horizontal is follow the vertical
        padding: `${i - Lr}px ${Lr * 2}px`,
        borderRadius: e.borderRadius,
        [`${n}-show-search&`]: {
          cursor: "text"
        },
        [`${n}-disabled&`]: {
          background: e.colorBgContainerDisabled,
          cursor: "not-allowed"
        },
        "&:after": {
          display: "inline-block",
          width: 0,
          margin: `${Lr}px 0`,
          lineHeight: `${a}px`,
          content: '"\\a0"'
        }
      },
      [`
        &${n}-show-arrow ${n}-selector,
        &${n}-allow-clear ${n}-selector
      `]: {
        paddingInlineEnd: e.fontSizeIcon + e.controlPaddingHorizontal
      },
      // ======================== Selections ========================
      [`${n}-selection-item`]: {
        position: "relative",
        display: "flex",
        flex: "none",
        boxSizing: "border-box",
        maxWidth: "100%",
        height: a,
        marginTop: Lr,
        marginBottom: Lr,
        lineHeight: `${a - e.lineWidth * 2}px`,
        background: e.colorFillSecondary,
        border: `${e.lineWidth}px solid ${e.colorSplit}`,
        borderRadius: e.borderRadiusSM,
        cursor: "default",
        transition: `font-size ${e.motionDurationSlow}, line-height ${e.motionDurationSlow}, height ${e.motionDurationSlow}`,
        userSelect: "none",
        marginInlineEnd: Lr * 2,
        paddingInlineStart: e.paddingXS,
        paddingInlineEnd: e.paddingXS / 2,
        [`${n}-disabled&`]: {
          color: e.colorTextDisabled,
          borderColor: e.colorBorder,
          cursor: "not-allowed"
        },
        // It's ok not to do this, but 24px makes bottom narrow in view should adjust
        "&-content": {
          display: "inline-block",
          marginInlineEnd: e.paddingXS / 2,
          overflow: "hidden",
          whiteSpace: "pre",
          textOverflow: "ellipsis"
        },
        "&-remove": h(h({}, Si()), {
          display: "inline-block",
          color: e.colorIcon,
          fontWeight: "bold",
          fontSize: 10,
          lineHeight: "inherit",
          cursor: "pointer",
          [`> ${o}`]: {
            verticalAlign: "-0.2em"
          },
          "&:hover": {
            color: e.colorIconHover
          }
        })
      },
      // ========================== Input ==========================
      [`${r}-item + ${r}-item`]: {
        [`${n}-selection-search`]: {
          marginInlineStart: 0
        }
      },
      [`${n}-selection-search`]: {
        display: "inline-flex",
        position: "relative",
        maxWidth: "100%",
        marginInlineStart: e.inputPaddingHorizontalBase - i,
        "\n          &-input,\n          &-mirror\n        ": {
          height: a,
          fontFamily: e.fontFamily,
          lineHeight: `${a}px`,
          transition: `all ${e.motionDurationSlow}`
        },
        "&-input": {
          width: "100%",
          minWidth: 4.1
          // fix search cursor missing
        },
        "&-mirror": {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          insetInlineEnd: "auto",
          zIndex: 999,
          whiteSpace: "pre",
          visibility: "hidden"
        }
      },
      // ======================= Placeholder =======================
      [`${n}-selection-placeholder `]: {
        position: "absolute",
        top: "50%",
        insetInlineStart: e.inputPaddingHorizontalBase,
        insetInlineEnd: e.inputPaddingHorizontalBase,
        transform: "translateY(-50%)",
        transition: `all ${e.motionDurationSlow}`
      }
    }
  };
}
function LA(e) {
  const {
    componentCls: t
  } = e, n = qe(e, {
    controlHeight: e.controlHeightSM,
    controlHeightSM: e.controlHeightXS,
    borderRadius: e.borderRadiusSM,
    borderRadiusSM: e.borderRadiusXS
  }), [, o] = j0(e);
  return [
    Cu(e),
    // ======================== Small ========================
    // Shared
    Cu(n, "sm"),
    // Padding
    {
      [`${t}-multiple${t}-sm`]: {
        [`${t}-selection-placeholder`]: {
          insetInlineStart: e.controlPaddingHorizontalSM - e.lineWidth,
          insetInlineEnd: "auto"
        },
        // https://github.com/ant-design/ant-design/issues/29559
        [`${t}-selection-search`]: {
          marginInlineStart: o
        }
      }
    },
    // ======================== Large ========================
    // Shared
    Cu(qe(e, {
      fontSize: e.fontSizeLG,
      controlHeight: e.controlHeightLG,
      controlHeightSM: e.controlHeight,
      borderRadius: e.borderRadiusLG,
      borderRadiusSM: e.borderRadius
    }), "lg")
  ];
}
function wu(e, t) {
  const {
    componentCls: n,
    inputPaddingHorizontalBase: o,
    borderRadius: r
  } = e, a = e.controlHeight - e.lineWidth * 2, i = Math.ceil(e.fontSize * 1.25), l = t ? `${n}-${t}` : "";
  return {
    [`${n}-single${l}`]: {
      fontSize: e.fontSize,
      // ========================= Selector =========================
      [`${n}-selector`]: h(h({}, st(e)), {
        display: "flex",
        borderRadius: r,
        [`${n}-selection-search`]: {
          position: "absolute",
          top: 0,
          insetInlineStart: o,
          insetInlineEnd: o,
          bottom: 0,
          "&-input": {
            width: "100%"
          }
        },
        [`
          ${n}-selection-item,
          ${n}-selection-placeholder
        `]: {
          padding: 0,
          lineHeight: `${a}px`,
          transition: `all ${e.motionDurationSlow}`,
          // Firefox inline-block position calculation is not same as Chrome & Safari. Patch this:
          "@supports (-moz-appearance: meterbar)": {
            lineHeight: `${a}px`
          }
        },
        [`${n}-selection-item`]: {
          position: "relative",
          userSelect: "none"
        },
        [`${n}-selection-placeholder`]: {
          transition: "none",
          pointerEvents: "none"
        },
        // For common baseline align
        [[
          "&:after",
          /* For '' value baseline align */
          `${n}-selection-item:after`,
          /* For undefined value baseline align */
          `${n}-selection-placeholder:after`
        ].join(",")]: {
          display: "inline-block",
          width: 0,
          visibility: "hidden",
          content: '"\\a0"'
        }
      }),
      [`
        &${n}-show-arrow ${n}-selection-item,
        &${n}-show-arrow ${n}-selection-placeholder
      `]: {
        paddingInlineEnd: i
      },
      // Opacity selection if open
      [`&${n}-open ${n}-selection-item`]: {
        color: e.colorTextPlaceholder
      },
      // ========================== Input ==========================
      // We only change the style of non-customize input which is only support by `combobox` mode.
      // Not customize
      [`&:not(${n}-customize-input)`]: {
        [`${n}-selector`]: {
          width: "100%",
          height: e.controlHeight,
          padding: `0 ${o}px`,
          [`${n}-selection-search-input`]: {
            height: a
          },
          "&:after": {
            lineHeight: `${a}px`
          }
        }
      },
      [`&${n}-customize-input`]: {
        [`${n}-selector`]: {
          "&:after": {
            display: "none"
          },
          [`${n}-selection-search`]: {
            position: "static",
            width: "100%"
          },
          [`${n}-selection-placeholder`]: {
            position: "absolute",
            insetInlineStart: 0,
            insetInlineEnd: 0,
            padding: `0 ${o}px`,
            "&:after": {
              display: "none"
            }
          }
        }
      }
    }
  };
}
function HA(e) {
  const {
    componentCls: t
  } = e, n = e.controlPaddingHorizontalSM - e.lineWidth;
  return [
    wu(e),
    // ======================== Small ========================
    // Shared
    wu(qe(e, {
      controlHeight: e.controlHeightSM,
      borderRadius: e.borderRadiusSM
    }), "sm"),
    // padding
    {
      [`${t}-single${t}-sm`]: {
        [`&:not(${t}-customize-input)`]: {
          [`${t}-selection-search`]: {
            insetInlineStart: n,
            insetInlineEnd: n
          },
          [`${t}-selector`]: {
            padding: `0 ${n}px`
          },
          // With arrow should provides `padding-right` to show the arrow
          [`&${t}-show-arrow ${t}-selection-search`]: {
            insetInlineEnd: n + e.fontSize * 1.5
          },
          [`
            &${t}-show-arrow ${t}-selection-item,
            &${t}-show-arrow ${t}-selection-placeholder
          `]: {
            paddingInlineEnd: e.fontSize * 1.5
          }
        }
      }
    },
    // ======================== Large ========================
    // Shared
    wu(qe(e, {
      controlHeight: e.controlHeightLG,
      fontSize: e.fontSizeLG,
      borderRadius: e.borderRadiusLG
    }), "lg")
  ];
}
function zA(e, t, n) {
  const {
    focusElCls: o,
    focus: r,
    borderElCls: a
  } = n, i = a ? "> *" : "", l = ["hover", r ? "focus" : null, "active"].filter(Boolean).map((u) => `&:${u} ${i}`).join(",");
  return {
    [`&-item:not(${t}-last-item)`]: {
      marginInlineEnd: -e.lineWidth
    },
    "&-item": h(h({
      [l]: {
        zIndex: 2
      }
    }, o ? {
      [`&${o}`]: {
        zIndex: 2
      }
    } : {}), {
      [`&[disabled] ${i}`]: {
        zIndex: 0
      }
    })
  };
}
function jA(e, t, n) {
  const {
    borderElCls: o
  } = n, r = o ? `> ${o}` : "";
  return {
    [`&-item:not(${t}-first-item):not(${t}-last-item) ${r}`]: {
      borderRadius: 0
    },
    [`&-item:not(${t}-last-item)${t}-first-item`]: {
      [`& ${r}, &${e}-sm ${r}, &${e}-lg ${r}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`&-item:not(${t}-first-item)${t}-last-item`]: {
      [`& ${r}, &${e}-sm ${r}, &${e}-lg ${r}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    }
  };
}
function xi(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    focus: !0
  };
  const {
    componentCls: n
  } = e, o = `${n}-compact`;
  return {
    [o]: h(h({}, zA(e, o, t)), jA(n, o, t))
  };
}
const VA = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    position: "relative",
    backgroundColor: e.colorBgContainer,
    border: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`,
    transition: `all ${e.motionDurationMid} ${e.motionEaseInOut}`,
    input: {
      cursor: "pointer"
    },
    [`${t}-show-search&`]: {
      cursor: "text",
      input: {
        cursor: "auto",
        color: "inherit"
      }
    },
    [`${t}-disabled&`]: {
      color: e.colorTextDisabled,
      background: e.colorBgContainerDisabled,
      cursor: "not-allowed",
      [`${t}-multiple&`]: {
        background: e.colorBgContainerDisabled
      },
      input: {
        cursor: "not-allowed"
      }
    }
  };
}, xu = function(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  const {
    componentCls: o,
    borderHoverColor: r,
    outlineColor: a,
    antCls: i
  } = t, l = n ? {
    [`${o}-selector`]: {
      borderColor: r
    }
  } : {};
  return {
    [e]: {
      [`&:not(${o}-disabled):not(${o}-customize-input):not(${i}-pagination-size-changer)`]: h(h({}, l), {
        [`${o}-focused& ${o}-selector`]: {
          borderColor: r,
          boxShadow: `0 0 0 ${t.controlOutlineWidth}px ${a}`,
          borderInlineEndWidth: `${t.controlLineWidth}px !important`,
          outline: 0
        },
        [`&:hover ${o}-selector`]: {
          borderColor: r,
          borderInlineEndWidth: `${t.controlLineWidth}px !important`
        }
      })
    }
  };
}, WA = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-selection-search-input`]: {
      margin: 0,
      padding: 0,
      background: "transparent",
      border: "none",
      outline: "none",
      appearance: "none",
      "&::-webkit-search-cancel-button": {
        display: "none",
        "-webkit-appearance": "none"
      }
    }
  };
}, KA = (e) => {
  const {
    componentCls: t,
    inputPaddingHorizontalBase: n,
    iconCls: o
  } = e;
  return {
    [t]: h(h({}, st(e)), {
      position: "relative",
      display: "inline-block",
      cursor: "pointer",
      [`&:not(${t}-customize-input) ${t}-selector`]: h(h({}, VA(e)), WA(e)),
      // [`&:not(&-disabled):hover ${selectCls}-selector`]: {
      //   ...genHoverStyle(token),
      // },
      // ======================== Selection ========================
      [`${t}-selection-item`]: h({
        flex: 1,
        fontWeight: "normal"
      }, So),
      // ======================= Placeholder =======================
      [`${t}-selection-placeholder`]: h(h({}, So), {
        flex: 1,
        color: e.colorTextPlaceholder,
        pointerEvents: "none"
      }),
      // ========================== Arrow ==========================
      [`${t}-arrow`]: h(h({}, Si()), {
        position: "absolute",
        top: "50%",
        insetInlineStart: "auto",
        insetInlineEnd: n,
        height: e.fontSizeIcon,
        marginTop: -e.fontSizeIcon / 2,
        color: e.colorTextQuaternary,
        fontSize: e.fontSizeIcon,
        lineHeight: 1,
        textAlign: "center",
        pointerEvents: "none",
        display: "flex",
        alignItems: "center",
        [o]: {
          verticalAlign: "top",
          transition: `transform ${e.motionDurationSlow}`,
          "> svg": {
            verticalAlign: "top"
          },
          [`&:not(${t}-suffix)`]: {
            pointerEvents: "auto"
          }
        },
        [`${t}-disabled &`]: {
          cursor: "not-allowed"
        },
        "> *:not(:last-child)": {
          marginInlineEnd: 8
          // FIXME: magic
        }
      }),
      // ========================== Clear ==========================
      [`${t}-clear`]: {
        position: "absolute",
        top: "50%",
        insetInlineStart: "auto",
        insetInlineEnd: n,
        zIndex: 1,
        display: "inline-block",
        width: e.fontSizeIcon,
        height: e.fontSizeIcon,
        marginTop: -e.fontSizeIcon / 2,
        color: e.colorTextQuaternary,
        fontSize: e.fontSizeIcon,
        fontStyle: "normal",
        lineHeight: 1,
        textAlign: "center",
        textTransform: "none",
        background: e.colorBgContainer,
        cursor: "pointer",
        opacity: 0,
        transition: `color ${e.motionDurationMid} ease, opacity ${e.motionDurationSlow} ease`,
        textRendering: "auto",
        "&:before": {
          display: "block"
        },
        "&:hover": {
          color: e.colorTextTertiary
        }
      },
      "&:hover": {
        [`${t}-clear`]: {
          opacity: 1
        }
      }
    }),
    // ========================= Feedback ==========================
    [`${t}-has-feedback`]: {
      [`${t}-clear`]: {
        insetInlineEnd: n + e.fontSize + e.paddingXXS
      }
    }
  };
}, UA = (e) => {
  const {
    componentCls: t
  } = e;
  return [
    {
      [t]: {
        // ==================== BorderLess ====================
        [`&-borderless ${t}-selector`]: {
          backgroundColor: "transparent !important",
          borderColor: "transparent !important",
          boxShadow: "none !important"
        },
        // ==================== In Form ====================
        [`&${t}-in-form-item`]: {
          width: "100%"
        }
      }
    },
    // =====================================================
    // ==                       LTR                       ==
    // =====================================================
    // Base
    KA(e),
    // Single
    HA(e),
    // Multiple
    LA(e),
    // Dropdown
    kA(e),
    // =====================================================
    // ==                       RTL                       ==
    // =====================================================
    {
      [`${t}-rtl`]: {
        direction: "rtl"
      }
    },
    // =====================================================
    // ==                     Status                      ==
    // =====================================================
    xu(t, qe(e, {
      borderHoverColor: e.colorPrimaryHover,
      outlineColor: e.controlOutline
    })),
    xu(`${t}-status-error`, qe(e, {
      borderHoverColor: e.colorErrorHover,
      outlineColor: e.colorErrorOutline
    }), !0),
    xu(`${t}-status-warning`, qe(e, {
      borderHoverColor: e.colorWarningHover,
      outlineColor: e.colorWarningOutline
    }), !0),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    xi(e, {
      borderElCls: `${t}-selector`,
      focusElCls: `${t}-focused`
    })
  ];
}, V0 = ht("Select", (e, t) => {
  let {
    rootPrefixCls: n
  } = t;
  const o = qe(e, {
    rootPrefixCls: n,
    inputPaddingHorizontalBase: e.paddingSM - 1
  });
  return [UA(o)];
}, (e) => ({
  zIndexPopup: e.zIndexPopupBase + 50
})), W0 = () => h(h({}, pt(f0(), ["inputIcon", "mode", "getInputElement", "getRawInputElement", "backfill"])), {
  value: dt([Array, Object, String, Number]),
  defaultValue: dt([Array, Object, String, Number]),
  notFoundContent: W.any,
  suffixIcon: W.any,
  itemIcon: W.any,
  size: Ze(),
  mode: Ze(),
  bordered: Me(!0),
  transitionName: String,
  choiceTransitionName: Ze(""),
  popupClassName: String,
  /** @deprecated Please use `popupClassName` instead */
  dropdownClassName: String,
  placement: Ze(),
  status: Ze(),
  "onUpdate:value": de()
}), Bm = "SECRET_COMBOBOX_MODE_DO_NOT_USE", Sn = J({
  compatConfig: {
    MODE: 3
  },
  name: "ASelect",
  Option: nf,
  OptGroup: of,
  inheritAttrs: !1,
  props: bt(W0(), {
    listHeight: 256,
    listItemHeight: 24
  }),
  SECRET_COMBOBOX_MODE_DO_NOT_USE: Bm,
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      emit: o,
      slots: r,
      expose: a
    } = t;
    const i = G(), l = Lt(), u = rn.useInject(), s = T(() => Po(u.status, e.status)), c = () => {
      var F;
      (F = i.value) === null || F === void 0 || F.focus();
    }, d = () => {
      var F;
      (F = i.value) === null || F === void 0 || F.blur();
    }, f = (F) => {
      var U;
      (U = i.value) === null || U === void 0 || U.scrollTo(F);
    }, p = T(() => {
      const {
        mode: F
      } = e;
      if (F !== "combobox")
        return F === Bm ? "combobox" : F;
    });
    process.env.NODE_ENV !== "production" && gt(!e.dropdownClassName, "Select", "`dropdownClassName` is deprecated. Please use `popupClassName` instead.");
    const {
      prefixCls: v,
      direction: g,
      configProvider: b,
      renderEmpty: y,
      size: S,
      getPrefixCls: w,
      getPopupContainer: C,
      disabled: $,
      select: O
    } = Ke("select", e), {
      compactSize: x,
      compactItemClassnames: M
    } = Dr(v, g), _ = T(() => x.value || S.value), N = Cn(), I = T(() => {
      var F;
      return (F = $.value) !== null && F !== void 0 ? F : N.value;
    }), [E, B] = V0(v), k = T(() => w()), P = T(() => e.placement !== void 0 ? e.placement : g.value === "rtl" ? "bottomRight" : "bottomLeft"), R = T(() => wr(k.value, Yy(P.value), e.transitionName)), D = T(() => ae({
      [`${v.value}-lg`]: _.value === "large",
      [`${v.value}-sm`]: _.value === "small",
      [`${v.value}-rtl`]: g.value === "rtl",
      [`${v.value}-borderless`]: !e.bordered,
      [`${v.value}-in-form-item`]: u.isFormItemInput
    }, dn(v.value, s.value, u.hasFeedback), M.value, B.value)), A = function() {
      for (var F = arguments.length, U = new Array(F), Q = 0; Q < F; Q++)
        U[Q] = arguments[Q];
      o("update:value", U[0]), o("change", ...U), l.onFieldChange();
    }, H = (F) => {
      o("blur", F), l.onFieldBlur();
    };
    a({
      blur: d,
      focus: c,
      scrollTo: f
    });
    const j = T(() => p.value === "multiple" || p.value === "tags"), z = T(() => e.showArrow !== void 0 ? e.showArrow : e.loading || !(j.value || p.value === "combobox"));
    return () => {
      var F, U, Q, q;
      const {
        notFoundContent: oe,
        listHeight: Z = 256,
        listItemHeight: ne = 24,
        popupClassName: Y,
        dropdownClassName: V,
        virtual: X,
        dropdownMatchSelectWidth: re,
        id: ie = l.id.value,
        placeholder: he = (F = r.placeholder) === null || F === void 0 ? void 0 : F.call(r),
        showArrow: ge
      } = e, {
        hasFeedback: we,
        feedbackIcon: Le
      } = u;
      let be;
      oe !== void 0 ? be = oe : r.notFoundContent ? be = r.notFoundContent() : p.value === "combobox" ? be = null : be = (y == null ? void 0 : y("Select")) || m(Md, {
        componentName: "Select"
      }, null);
      const {
        suffixIcon: pe,
        itemIcon: xe,
        removeIcon: Ne,
        clearIcon: ye
      } = $0(h(h({}, e), {
        multiple: j.value,
        prefixCls: v.value,
        hasFeedback: we,
        feedbackIcon: Le,
        showArrow: z.value
      }), r), Ce = pt(e, ["prefixCls", "suffixIcon", "itemIcon", "removeIcon", "clearIcon", "size", "bordered", "status"]), Te = ae(Y || V, {
        [`${v.value}-dropdown-${g.value}`]: g.value === "rtl"
      }, B.value);
      return E(m(UE, L(L(L({
        ref: i,
        virtual: X,
        dropdownMatchSelectWidth: re
      }, Ce), n), {}, {
        showSearch: (U = e.showSearch) !== null && U !== void 0 ? U : (Q = O == null ? void 0 : O.value) === null || Q === void 0 ? void 0 : Q.showSearch,
        placeholder: he,
        listHeight: Z,
        listItemHeight: ne,
        mode: p.value,
        prefixCls: v.value,
        direction: g.value,
        inputIcon: pe,
        menuItemSelectedIcon: xe,
        removeIcon: Ne,
        clearIcon: ye,
        notFoundContent: be,
        class: [D.value, n.class],
        getPopupContainer: C == null ? void 0 : C.value,
        dropdownClassName: Te,
        onChange: A,
        onBlur: H,
        id: ie,
        dropdownRender: Ce.dropdownRender || r.dropdownRender,
        transitionName: R.value,
        children: (q = r.default) === null || q === void 0 ? void 0 : q.call(r),
        tagRender: e.tagRender || r.tagRender,
        optionLabelRender: r.optionLabel,
        maxTagPlaceholder: e.maxTagPlaceholder || r.maxTagPlaceholder,
        showArrow: we || ge,
        disabled: I.value
      }), {
        option: r.option
      }));
    };
  }
});
Sn.install = function(e) {
  return e.component(Sn.name, Sn), e.component(Sn.Option.displayName, Sn.Option), e.component(Sn.OptGroup.displayName, Sn.OptGroup), e;
};
const GA = Sn.Option;
Sn.OptGroup;
const mr = () => null;
mr.isSelectOption = !0;
mr.displayName = "AAutoCompleteOption";
const Xa = () => null;
Xa.isSelectOptGroup = !0;
Xa.displayName = "AAutoCompleteOptGroup";
function YA(e) {
  var t, n;
  return ((t = e == null ? void 0 : e.type) === null || t === void 0 ? void 0 : t.isSelectOption) || ((n = e == null ? void 0 : e.type) === null || n === void 0 ? void 0 : n.isSelectOptGroup);
}
const XA = () => h(h({}, pt(W0(), ["loading", "mode", "optionLabelProp", "labelInValue"])), {
  dataSource: Array,
  dropdownMenuStyle: {
    type: Object,
    default: void 0
  },
  // optionLabelProp: String,
  dropdownMatchSelectWidth: {
    type: [Number, Boolean],
    default: !0
  },
  prefixCls: String,
  showSearch: {
    type: Boolean,
    default: void 0
  },
  transitionName: String,
  choiceTransitionName: {
    type: String,
    default: "zoom"
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  backfill: {
    type: Boolean,
    default: void 0
  },
  // optionLabelProp: PropTypes.string.def('children'),
  filterOption: {
    type: [Boolean, Function],
    default: !1
  },
  defaultActiveFirstOption: {
    type: Boolean,
    default: !0
  },
  status: String
}), Ou = J({
  compatConfig: {
    MODE: 3
  },
  name: "AAutoComplete",
  inheritAttrs: !1,
  props: XA(),
  // emits: ['change', 'select', 'focus', 'blur'],
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: r
    } = t;
    Pt(!("dataSource" in n), "AutoComplete", "`dataSource` slot is deprecated, please use props `options` instead."), Pt(!("options" in n), "AutoComplete", "`options` slot is deprecated, please use props `options` instead."), Pt(!e.dropdownClassName, "AutoComplete", "`dropdownClassName` is deprecated, please use `popupClassName` instead.");
    const a = G(), i = () => {
      var c;
      const d = xt((c = n.default) === null || c === void 0 ? void 0 : c.call(n));
      return d.length ? d[0] : void 0;
    };
    r({
      focus: () => {
        var c;
        (c = a.value) === null || c === void 0 || c.focus();
      },
      blur: () => {
        var c;
        (c = a.value) === null || c === void 0 || c.blur();
      }
    });
    const {
      prefixCls: s
    } = Ke("select", e);
    return () => {
      var c, d, f;
      const {
        size: p,
        dataSource: v,
        notFoundContent: g = (c = n.notFoundContent) === null || c === void 0 ? void 0 : c.call(n)
      } = e;
      let b;
      const {
        class: y
      } = o, S = {
        [y]: !!y,
        [`${s.value}-lg`]: p === "large",
        [`${s.value}-sm`]: p === "small",
        [`${s.value}-show-search`]: !0,
        [`${s.value}-auto-complete`]: !0
      };
      if (e.options === void 0) {
        const C = ((d = n.dataSource) === null || d === void 0 ? void 0 : d.call(n)) || ((f = n.options) === null || f === void 0 ? void 0 : f.call(n)) || [];
        C.length && YA(C[0]) ? b = C : b = v ? v.map(($) => {
          if (on($))
            return $;
          switch (typeof $) {
            case "string":
              return m(mr, {
                key: $,
                value: $
              }, {
                default: () => [$]
              });
            case "object":
              return m(mr, {
                key: $.value,
                value: $.value
              }, {
                default: () => [$.text]
              });
            default:
              throw new Error("AutoComplete[dataSource] only supports type `string[] | Object[]`.");
          }
        }) : [];
      }
      const w = pt(h(h(h({}, e), o), {
        mode: Sn.SECRET_COMBOBOX_MODE_DO_NOT_USE,
        // optionLabelProp,
        getInputElement: i,
        notFoundContent: g,
        // placeholder: '',
        class: S,
        popupClassName: e.popupClassName || e.dropdownClassName,
        ref: a
      }), ["dataSource", "loading"]);
      return m(Sn, w, L({
        default: () => [b]
      }, pt(n, ["default", "dataSource", "options"])));
    };
  }
}), qA = h(Ou, {
  Option: mr,
  OptGroup: Xa,
  install(e) {
    return e.component(Ou.name, Ou), e.component(mr.displayName, mr), e.component(Xa.displayName, Xa), e;
  }
});
var QA = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M699 353h-46.9c-10.2 0-19.9 4.9-25.9 13.3L469 584.3l-71.2-98.8c-6-8.3-15.6-13.3-25.9-13.3H325c-6.5 0-10.3 7.4-6.5 12.7l124.6 172.8a31.8 31.8 0 0051.7 0l210.6-292c3.9-5.3.1-12.7-6.4-12.7z" } }, { tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }] }, name: "check-circle", theme: "outlined" };
function km(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      ZA(e, r, n[r]);
    });
  }
  return e;
}
function ZA(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Cf = function(t, n) {
  var o = km({}, t, n.attrs);
  return m(it, km({}, o, {
    icon: QA
  }), null);
};
Cf.displayName = "CheckCircleOutlined";
Cf.inheritAttrs = !1;
var JA = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { tag: "path", attrs: { d: "M464 688a48 48 0 1096 0 48 48 0 10-96 0zm24-112h48c4.4 0 8-3.6 8-8V296c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8z" } }] }, name: "exclamation-circle", theme: "outlined" };
function Lm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      eN(e, r, n[r]);
    });
  }
  return e;
}
function eN(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var wf = function(t, n) {
  var o = Lm({}, t, n.attrs);
  return m(it, Lm({}, o, {
    icon: JA
  }), null);
};
wf.displayName = "ExclamationCircleOutlined";
wf.inheritAttrs = !1;
var tN = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { tag: "path", attrs: { d: "M464 336a48 48 0 1096 0 48 48 0 10-96 0zm72 112h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V456c0-4.4-3.6-8-8-8z" } }] }, name: "info-circle", theme: "outlined" };
function Hm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      nN(e, r, n[r]);
    });
  }
  return e;
}
function nN(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var xf = function(t, n) {
  var o = Hm({}, t, n.attrs);
  return m(it, Hm({}, o, {
    icon: tN
  }), null);
};
xf.displayName = "InfoCircleOutlined";
xf.inheritAttrs = !1;
var oN = { icon: { tag: "svg", attrs: { "fill-rule": "evenodd", viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm0 76c-205.4 0-372 166.6-372 372s166.6 372 372 372 372-166.6 372-372-166.6-372-372-372zm128.01 198.83c.03 0 .05.01.09.06l45.02 45.01a.2.2 0 01.05.09.12.12 0 010 .07c0 .02-.01.04-.05.08L557.25 512l127.87 127.86a.27.27 0 01.05.06v.02a.12.12 0 010 .07c0 .03-.01.05-.05.09l-45.02 45.02a.2.2 0 01-.09.05.12.12 0 01-.07 0c-.02 0-.04-.01-.08-.05L512 557.25 384.14 685.12c-.04.04-.06.05-.08.05a.12.12 0 01-.07 0c-.03 0-.05-.01-.09-.05l-45.02-45.02a.2.2 0 01-.05-.09.12.12 0 010-.07c0-.02.01-.04.06-.08L466.75 512 338.88 384.14a.27.27 0 01-.05-.06l-.01-.02a.12.12 0 010-.07c0-.03.01-.05.05-.09l45.02-45.02a.2.2 0 01.09-.05.12.12 0 01.07 0c.02 0 .04.01.08.06L512 466.75l127.86-127.86c.04-.05.06-.06.08-.06a.12.12 0 01.07 0z" } }] }, name: "close-circle", theme: "outlined" };
function zm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      rN(e, r, n[r]);
    });
  }
  return e;
}
function rN(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Of = function(t, n) {
  var o = zm({}, t, n.attrs);
  return m(it, zm({}, o, {
    icon: oN
  }), null);
};
Of.displayName = "CloseCircleOutlined";
Of.inheritAttrs = !1;
var aN = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, name: "check-circle", theme: "filled" };
function jm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      iN(e, r, n[r]);
    });
  }
  return e;
}
function iN(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Io = function(t, n) {
  var o = jm({}, t, n.attrs);
  return m(it, jm({}, o, {
    icon: aN
  }), null);
};
Io.displayName = "CheckCircleFilled";
Io.inheritAttrs = !1;
var lN = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, name: "exclamation-circle", theme: "filled" };
function Vm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      sN(e, r, n[r]);
    });
  }
  return e;
}
function sN(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Qo = function(t, n) {
  var o = Vm({}, t, n.attrs);
  return m(it, Vm({}, o, {
    icon: lN
  }), null);
};
Qo.displayName = "ExclamationCircleFilled";
Qo.inheritAttrs = !1;
var uN = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, name: "info-circle", theme: "filled" };
function Wm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      cN(e, r, n[r]);
    });
  }
  return e;
}
function cN(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Ar = function(t, n) {
  var o = Wm({}, t, n.attrs);
  return m(it, Wm({}, o, {
    icon: uN
  }), null);
};
Ar.displayName = "InfoCircleFilled";
Ar.inheritAttrs = !1;
const ja = ["xxxl", "xxl", "xl", "lg", "md", "sm", "xs"], dN = (e) => ({
  xs: `(max-width: ${e.screenXSMax}px)`,
  sm: `(min-width: ${e.screenSM}px)`,
  md: `(min-width: ${e.screenMD}px)`,
  lg: `(min-width: ${e.screenLG}px)`,
  xl: `(min-width: ${e.screenXL}px)`,
  xxl: `(min-width: ${e.screenXXL}px)`,
  xxxl: `{min-width: ${e.screenXXXL}px}`
});
function K0() {
  const [, e] = ya();
  return T(() => {
    const t = dN(e.value), n = /* @__PURE__ */ new Map();
    let o = -1, r = {};
    return {
      matchHandlers: {},
      dispatch(a) {
        return r = a, n.forEach((i) => i(r)), n.size >= 1;
      },
      subscribe(a) {
        return n.size || this.register(), o += 1, n.set(o, a), a(r), o;
      },
      unsubscribe(a) {
        n.delete(a), n.size || this.unregister();
      },
      unregister() {
        Object.keys(t).forEach((a) => {
          const i = t[a], l = this.matchHandlers[i];
          l == null || l.mql.removeListener(l == null ? void 0 : l.listener);
        }), n.clear();
      },
      register() {
        Object.keys(t).forEach((a) => {
          const i = t[a], l = (s) => {
            let {
              matches: c
            } = s;
            this.dispatch(h(h({}, r), {
              [a]: c
            }));
          }, u = window.matchMedia(i);
          u.addListener(l), this.matchHandlers[i] = {
            mql: u,
            listener: l
          }, l(u);
        });
      },
      responsiveMap: t
    };
  });
}
function fN() {
  const e = K({});
  let t = null;
  const n = K0();
  return ze(() => {
    t = n.value.subscribe((o) => {
      e.value = o;
    });
  }), Xo(() => {
    n.value.unsubscribe(t);
  }), e;
}
function jn(e) {
  const t = K();
  return Ve(() => {
    t.value = e();
  }, {
    flush: "sync"
    // needed so updates are immediate.
  }), t;
}
const pN = (e) => {
  const {
    antCls: t,
    componentCls: n,
    iconCls: o,
    avatarBg: r,
    avatarColor: a,
    containerSize: i,
    containerSizeLG: l,
    containerSizeSM: u,
    textFontSize: s,
    textFontSizeLG: c,
    textFontSizeSM: d,
    borderRadius: f,
    borderRadiusLG: p,
    borderRadiusSM: v,
    lineWidth: g,
    lineType: b
  } = e, y = (S, w, C) => ({
    width: S,
    height: S,
    lineHeight: `${S - g * 2}px`,
    borderRadius: "50%",
    [`&${n}-square`]: {
      borderRadius: C
    },
    [`${n}-string`]: {
      position: "absolute",
      left: {
        _skip_check_: !0,
        value: "50%"
      },
      transformOrigin: "0 center"
    },
    [`&${n}-icon`]: {
      fontSize: w,
      [`> ${o}`]: {
        margin: 0
      }
    }
  });
  return {
    [n]: h(h(h(h({}, st(e)), {
      position: "relative",
      display: "inline-block",
      overflow: "hidden",
      color: a,
      whiteSpace: "nowrap",
      textAlign: "center",
      verticalAlign: "middle",
      background: r,
      border: `${g}px ${b} transparent`,
      "&-image": {
        background: "transparent"
      },
      [`${t}-image-img`]: {
        display: "block"
      }
    }), y(i, s, f)), {
      "&-lg": h({}, y(l, c, p)),
      "&-sm": h({}, y(u, d, v)),
      "> img": {
        display: "block",
        width: "100%",
        height: "100%",
        objectFit: "cover"
      }
    })
  };
}, vN = (e) => {
  const {
    componentCls: t,
    groupBorderColor: n,
    groupOverlapping: o,
    groupSpace: r
  } = e;
  return {
    [`${t}-group`]: {
      display: "inline-flex",
      [`${t}`]: {
        borderColor: n
      },
      "> *:not(:first-child)": {
        marginInlineStart: o
      }
    },
    [`${t}-group-popover`]: {
      [`${t} + ${t}`]: {
        marginInlineStart: r
      }
    }
  };
}, U0 = ht("Avatar", (e) => {
  const {
    colorTextLightSolid: t,
    colorTextPlaceholder: n
  } = e, o = qe(e, {
    avatarBg: n,
    avatarColor: t
  });
  return [pN(o), vN(o)];
}, (e) => {
  const {
    controlHeight: t,
    controlHeightLG: n,
    controlHeightSM: o,
    fontSize: r,
    fontSizeLG: a,
    fontSizeXL: i,
    fontSizeHeading3: l,
    marginXS: u,
    marginXXS: s,
    colorBorderBg: c
  } = e;
  return {
    containerSize: t,
    containerSizeLG: n,
    containerSizeSM: o,
    textFontSize: Math.round((a + i) / 2),
    textFontSizeLG: l,
    textFontSizeSM: r,
    groupSpace: s,
    groupOverlapping: -u,
    groupBorderColor: c
  };
}), G0 = Symbol("AvatarContextKey"), mN = () => nt(G0, {}), gN = (e) => ot(G0, e), hN = () => ({
  prefixCls: String,
  shape: {
    type: String,
    default: "circle"
  },
  size: {
    type: [Number, String, Object],
    default: () => "default"
  },
  src: String,
  /** Srcset of image avatar */
  srcset: String,
  icon: W.any,
  alt: String,
  gap: Number,
  draggable: {
    type: Boolean,
    default: void 0
  },
  crossOrigin: String,
  loadError: {
    type: Function
  }
}), ea = J({
  compatConfig: {
    MODE: 3
  },
  name: "AAvatar",
  inheritAttrs: !1,
  props: hN(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const r = K(!0), a = K(!1), i = K(1), l = K(null), u = K(null), {
      prefixCls: s
    } = Ke("avatar", e), [c, d] = U0(s), f = mN(), p = T(() => e.size === "default" ? f.size : e.size), v = fN(), g = jn(() => {
      if (typeof e.size != "object")
        return;
      const w = ja.find(($) => v.value[$]);
      return e.size[w];
    }), b = (w) => g.value ? {
      width: `${g.value}px`,
      height: `${g.value}px`,
      lineHeight: `${g.value}px`,
      fontSize: `${w ? g.value / 2 : 18}px`
    } : {}, y = () => {
      if (!l.value || !u.value)
        return;
      const w = l.value.offsetWidth, C = u.value.offsetWidth;
      if (w !== 0 && C !== 0) {
        const {
          gap: $ = 4
        } = e;
        $ * 2 < C && (i.value = C - $ * 2 < w ? (C - $ * 2) / w : 1);
      }
    }, S = () => {
      const {
        loadError: w
      } = e;
      (w == null ? void 0 : w()) !== !1 && (r.value = !1);
    };
    return le(() => e.src, () => {
      mt(() => {
        r.value = !0, i.value = 1;
      });
    }), le(() => e.gap, () => {
      mt(() => {
        y();
      });
    }), ze(() => {
      mt(() => {
        y(), a.value = !0;
      });
    }), () => {
      var w, C;
      const {
        shape: $,
        src: O,
        alt: x,
        srcset: M,
        draggable: _,
        crossOrigin: N
      } = e, I = (w = f.shape) !== null && w !== void 0 ? w : $, E = Uo(n, e, "icon"), B = s.value, k = {
        [`${o.class}`]: !!o.class,
        [B]: !0,
        [`${B}-lg`]: p.value === "large",
        [`${B}-sm`]: p.value === "small",
        [`${B}-${I}`]: !0,
        [`${B}-image`]: O && r.value,
        [`${B}-icon`]: E,
        [d.value]: !0
      }, P = typeof p.value == "number" ? {
        width: `${p.value}px`,
        height: `${p.value}px`,
        lineHeight: `${p.value}px`,
        fontSize: E ? `${p.value / 2}px` : "18px"
      } : {}, R = (C = n.default) === null || C === void 0 ? void 0 : C.call(n);
      let D;
      if (O && r.value)
        D = m("img", {
          draggable: _,
          src: O,
          srcset: M,
          onError: S,
          alt: x,
          crossorigin: N
        }, null);
      else if (E)
        D = E;
      else if (a.value || i.value !== 1) {
        const A = `scale(${i.value}) translateX(-50%)`, H = {
          msTransform: A,
          WebkitTransform: A,
          transform: A
        }, j = typeof p.value == "number" ? {
          lineHeight: `${p.value}px`
        } : {};
        D = m(br, {
          onResize: y
        }, {
          default: () => [m("span", {
            class: `${B}-string`,
            ref: l,
            style: h(h({}, j), H)
          }, [R])]
        });
      } else
        D = m("span", {
          class: `${B}-string`,
          ref: l,
          style: {
            opacity: 0
          }
        }, [R]);
      return c(m("span", L(L({}, o), {}, {
        ref: u,
        class: k,
        style: [P, b(!!E), o.style]
      }), [D]));
    };
  }
}), Tn = {
  adjustX: 1,
  adjustY: 1
}, En = [0, 0], Y0 = {
  left: {
    points: ["cr", "cl"],
    overflow: Tn,
    offset: [-4, 0],
    targetOffset: En
  },
  right: {
    points: ["cl", "cr"],
    overflow: Tn,
    offset: [4, 0],
    targetOffset: En
  },
  top: {
    points: ["bc", "tc"],
    overflow: Tn,
    offset: [0, -4],
    targetOffset: En
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: Tn,
    offset: [0, 4],
    targetOffset: En
  },
  topLeft: {
    points: ["bl", "tl"],
    overflow: Tn,
    offset: [0, -4],
    targetOffset: En
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: Tn,
    offset: [-4, 0],
    targetOffset: En
  },
  topRight: {
    points: ["br", "tr"],
    overflow: Tn,
    offset: [0, -4],
    targetOffset: En
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: Tn,
    offset: [4, 0],
    targetOffset: En
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: Tn,
    offset: [0, 4],
    targetOffset: En
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: Tn,
    offset: [4, 0],
    targetOffset: En
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: Tn,
    offset: [0, 4],
    targetOffset: En
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: Tn,
    offset: [-4, 0],
    targetOffset: En
  }
}, bN = {
  prefixCls: String,
  id: String,
  overlayInnerStyle: W.any
}, yN = J({
  compatConfig: {
    MODE: 3
  },
  name: "TooltipContent",
  props: bN,
  setup(e, t) {
    let {
      slots: n
    } = t;
    return () => {
      var o;
      return m("div", {
        class: `${e.prefixCls}-inner`,
        id: e.id,
        role: "tooltip",
        style: e.overlayInnerStyle
      }, [(o = n.overlay) === null || o === void 0 ? void 0 : o.call(n)]);
    };
  }
});
var SN = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function Km() {
}
const $N = J({
  compatConfig: {
    MODE: 3
  },
  name: "Tooltip",
  inheritAttrs: !1,
  props: {
    trigger: W.any.def(["hover"]),
    defaultVisible: {
      type: Boolean,
      default: void 0
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    placement: W.string.def("right"),
    transitionName: String,
    animation: W.any,
    afterVisibleChange: W.func.def(() => {
    }),
    overlayStyle: {
      type: Object,
      default: void 0
    },
    overlayClassName: String,
    prefixCls: W.string.def("rc-tooltip"),
    mouseEnterDelay: W.number.def(0.1),
    mouseLeaveDelay: W.number.def(0.1),
    getPopupContainer: Function,
    destroyTooltipOnHide: {
      type: Boolean,
      default: !1
    },
    align: W.object.def(() => ({})),
    arrowContent: W.any.def(null),
    tipId: String,
    builtinPlacements: W.object,
    overlayInnerStyle: {
      type: Object,
      default: void 0
    },
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    onVisibleChange: Function,
    onPopupAlign: Function,
    arrow: {
      type: Boolean,
      default: !0
    }
  },
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: r
    } = t;
    const a = K(), i = () => {
      const {
        prefixCls: c,
        tipId: d,
        overlayInnerStyle: f
      } = e;
      return [e.arrow ? m("div", {
        class: `${c}-arrow`,
        key: "arrow"
      }, [Uo(n, e, "arrowContent")]) : null, m(yN, {
        key: "content",
        prefixCls: c,
        id: d,
        overlayInnerStyle: f
      }, {
        overlay: n.overlay
      })];
    };
    r({
      getPopupDomNode: () => a.value.getPopupDomNode(),
      triggerDOM: a,
      forcePopupAlign: () => {
        var c;
        return (c = a.value) === null || c === void 0 ? void 0 : c.forcePopupAlign();
      }
    });
    const u = K(!1), s = K(!1);
    return Ve(() => {
      const {
        destroyTooltipOnHide: c
      } = e;
      if (typeof c == "boolean")
        u.value = c;
      else if (c && typeof c == "object") {
        const {
          keepParent: d
        } = c;
        u.value = d === !0, s.value = d === !1;
      }
    }), () => {
      const {
        overlayClassName: c,
        trigger: d,
        mouseEnterDelay: f,
        mouseLeaveDelay: p,
        overlayStyle: v,
        prefixCls: g,
        afterVisibleChange: b,
        transitionName: y,
        animation: S,
        placement: w,
        align: C,
        destroyTooltipOnHide: $,
        defaultVisible: O
      } = e, x = SN(e, ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "afterVisibleChange", "transitionName", "animation", "placement", "align", "destroyTooltipOnHide", "defaultVisible"]), M = h({}, x);
      e.visible !== void 0 && (M.popupVisible = e.visible);
      const _ = h(h(h({
        popupClassName: c,
        prefixCls: g,
        action: d,
        builtinPlacements: Y0,
        popupPlacement: w,
        popupAlign: C,
        afterPopupVisibleChange: b,
        popupTransitionName: y,
        popupAnimation: S,
        defaultPopupVisible: O,
        destroyPopupOnHide: u.value,
        autoDestroy: s.value,
        mouseLeaveDelay: p,
        popupStyle: v,
        mouseEnterDelay: f
      }, M), o), {
        onPopupVisibleChange: e.onVisibleChange || Km,
        onPopupAlign: e.onPopupAlign || Km,
        ref: a,
        arrow: !!e.arrow,
        popup: i()
      });
      return m(wa, _, {
        default: n.default
      });
    };
  }
}), X0 = () => ({
  trigger: [String, Array],
  open: {
    type: Boolean,
    default: void 0
  },
  /** @deprecated Please use `open` instead. */
  visible: {
    type: Boolean,
    default: void 0
  },
  placement: String,
  color: String,
  transitionName: String,
  overlayStyle: He(),
  overlayInnerStyle: He(),
  overlayClassName: String,
  openClassName: String,
  prefixCls: String,
  mouseEnterDelay: Number,
  mouseLeaveDelay: Number,
  getPopupContainer: Function,
  /**@deprecated Please use `arrow={{ pointAtCenter: true }}` instead. */
  arrowPointAtCenter: {
    type: Boolean,
    default: void 0
  },
  arrow: {
    type: [Boolean, Object],
    default: !0
  },
  autoAdjustOverflow: {
    type: [Boolean, Object],
    default: void 0
  },
  destroyTooltipOnHide: {
    type: Boolean,
    default: void 0
  },
  align: He(),
  builtinPlacements: He(),
  children: Array,
  /** @deprecated Please use `onOpenChange` instead. */
  onVisibleChange: Function,
  /** @deprecated Please use `onUpdate:open` instead. */
  "onUpdate:visible": Function,
  onOpenChange: Function,
  "onUpdate:open": Function
}), CN = {
  adjustX: 1,
  adjustY: 1
}, Um = {
  adjustX: 0,
  adjustY: 0
}, wN = [0, 0];
function Gm(e) {
  return typeof e == "boolean" ? e ? CN : Um : h(h({}, Um), e);
}
function xN(e) {
  const {
    arrowWidth: t = 4,
    horizontalArrowShift: n = 16,
    verticalArrowShift: o = 8,
    autoAdjustOverflow: r,
    arrowPointAtCenter: a
  } = e, i = {
    left: {
      points: ["cr", "cl"],
      offset: [-4, 0]
    },
    right: {
      points: ["cl", "cr"],
      offset: [4, 0]
    },
    top: {
      points: ["bc", "tc"],
      offset: [0, -4]
    },
    bottom: {
      points: ["tc", "bc"],
      offset: [0, 4]
    },
    topLeft: {
      points: ["bl", "tc"],
      offset: [-(n + t), -4]
    },
    leftTop: {
      points: ["tr", "cl"],
      offset: [-4, -(o + t)]
    },
    topRight: {
      points: ["br", "tc"],
      offset: [n + t, -4]
    },
    rightTop: {
      points: ["tl", "cr"],
      offset: [4, -(o + t)]
    },
    bottomRight: {
      points: ["tr", "bc"],
      offset: [n + t, 4]
    },
    rightBottom: {
      points: ["bl", "cr"],
      offset: [4, o + t]
    },
    bottomLeft: {
      points: ["tl", "bc"],
      offset: [-(n + t), 4]
    },
    leftBottom: {
      points: ["br", "cl"],
      offset: [-4, o + t]
    }
  };
  return Object.keys(i).forEach((l) => {
    i[l] = a ? h(h({}, i[l]), {
      overflow: Gm(r),
      targetOffset: wN
    }) : h(h({}, Y0[l]), {
      overflow: Gm(r)
    }), i[l].ignoreShake = !0;
  }), i;
}
function ON() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  for (let t = 0, n = e.length; t < n; t++)
    if (e[t] !== void 0)
      return e[t];
}
const PN = ci.map((e) => `${e}-inverse`), IN = ["success", "processing", "error", "default", "warning"];
function q0(e) {
  return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0) ? [...PN, ...ci].includes(e) : ci.includes(e);
}
function TN(e) {
  return IN.includes(e);
}
function EN(e, t) {
  const n = q0(t), o = ae({
    [`${e}-${t}`]: t && n
  }), r = {}, a = {};
  return t && !n && (r.background = t, a["--antd-arrow-background-color"] = t), {
    className: o,
    overlayStyle: r,
    arrowStyle: a
  };
}
function Wi(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return e.map((n) => `${t}${n}`).join(",");
}
const Q0 = 8;
function MN(e) {
  const t = Q0, {
    sizePopupArrow: n,
    contentRadius: o,
    borderRadiusOuter: r,
    limitVerticalRadius: a
  } = e, i = n / 2 - Math.ceil(r * (Math.sqrt(2) - 1)), l = (o > 12 ? o + 2 : 12) - i, u = a ? t - i : l;
  return {
    dropdownArrowOffset: l,
    dropdownArrowOffsetVertical: u
  };
}
function Z0(e, t) {
  const {
    componentCls: n,
    sizePopupArrow: o,
    marginXXS: r,
    borderRadiusXS: a,
    borderRadiusOuter: i,
    boxShadowPopoverArrow: l
  } = e, {
    colorBg: u,
    showArrowCls: s,
    contentRadius: c = e.borderRadiusLG,
    limitVerticalRadius: d
  } = t, {
    dropdownArrowOffsetVertical: f,
    dropdownArrowOffset: p
  } = MN({
    sizePopupArrow: o,
    contentRadius: c,
    borderRadiusOuter: i,
    limitVerticalRadius: d
  }), v = o / 2 + r;
  return {
    [n]: {
      // ============================ Basic ============================
      [`${n}-arrow`]: [h(h({
        position: "absolute",
        zIndex: 1,
        display: "block"
      }, oy(o, a, i, u, l)), {
        "&:before": {
          background: u
        }
      })],
      // ========================== Placement ==========================
      // Here handle the arrow position and rotate stuff
      // >>>>> Top
      [[`&-placement-top ${n}-arrow`, `&-placement-topLeft ${n}-arrow`, `&-placement-topRight ${n}-arrow`].join(",")]: {
        bottom: 0,
        transform: "translateY(100%) rotate(180deg)"
      },
      [`&-placement-top ${n}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateX(-50%) translateY(100%) rotate(180deg)"
      },
      [`&-placement-topLeft ${n}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: p
        }
      },
      [`&-placement-topRight ${n}-arrow`]: {
        right: {
          _skip_check_: !0,
          value: p
        }
      },
      // >>>>> Bottom
      [[`&-placement-bottom ${n}-arrow`, `&-placement-bottomLeft ${n}-arrow`, `&-placement-bottomRight ${n}-arrow`].join(",")]: {
        top: 0,
        transform: "translateY(-100%)"
      },
      [`&-placement-bottom ${n}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateX(-50%) translateY(-100%)"
      },
      [`&-placement-bottomLeft ${n}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: p
        }
      },
      [`&-placement-bottomRight ${n}-arrow`]: {
        right: {
          _skip_check_: !0,
          value: p
        }
      },
      // >>>>> Left
      [[`&-placement-left ${n}-arrow`, `&-placement-leftTop ${n}-arrow`, `&-placement-leftBottom ${n}-arrow`].join(",")]: {
        right: {
          _skip_check_: !0,
          value: 0
        },
        transform: "translateX(100%) rotate(90deg)"
      },
      [`&-placement-left ${n}-arrow`]: {
        top: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateY(-50%) translateX(100%) rotate(90deg)"
      },
      [`&-placement-leftTop ${n}-arrow`]: {
        top: f
      },
      [`&-placement-leftBottom ${n}-arrow`]: {
        bottom: f
      },
      // >>>>> Right
      [[`&-placement-right ${n}-arrow`, `&-placement-rightTop ${n}-arrow`, `&-placement-rightBottom ${n}-arrow`].join(",")]: {
        left: {
          _skip_check_: !0,
          value: 0
        },
        transform: "translateX(-100%) rotate(-90deg)"
      },
      [`&-placement-right ${n}-arrow`]: {
        top: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
      },
      [`&-placement-rightTop ${n}-arrow`]: {
        top: f
      },
      [`&-placement-rightBottom ${n}-arrow`]: {
        bottom: f
      },
      // =========================== Offset ============================
      // Offset the popover to account for the dropdown arrow
      // >>>>> Top
      [Wi(["&-placement-topLeft", "&-placement-top", "&-placement-topRight"].map((g) => g += ":not(&-arrow-hidden)"), s)]: {
        paddingBottom: v
      },
      // >>>>> Bottom
      [Wi(["&-placement-bottomLeft", "&-placement-bottom", "&-placement-bottomRight"].map((g) => g += ":not(&-arrow-hidden)"), s)]: {
        paddingTop: v
      },
      // >>>>> Left
      [Wi(["&-placement-leftTop", "&-placement-left", "&-placement-leftBottom"].map((g) => g += ":not(&-arrow-hidden)"), s)]: {
        paddingRight: {
          _skip_check_: !0,
          value: v
        }
      },
      // >>>>> Right
      [Wi(["&-placement-rightTop", "&-placement-right", "&-placement-rightBottom"].map((g) => g += ":not(&-arrow-hidden)"), s)]: {
        paddingLeft: {
          _skip_check_: !0,
          value: v
        }
      }
    }
  };
}
const _N = (e) => {
  const {
    componentCls: t,
    // ant-tooltip
    tooltipMaxWidth: n,
    tooltipColor: o,
    tooltipBg: r,
    tooltipBorderRadius: a,
    zIndexPopup: i,
    controlHeight: l,
    boxShadowSecondary: u,
    paddingSM: s,
    paddingXS: c,
    tooltipRadiusOuter: d
  } = e;
  return [
    {
      [t]: h(h(h(h({}, st(e)), {
        position: "absolute",
        zIndex: i,
        display: "block",
        "&": [{
          width: "max-content"
        }, {
          width: "intrinsic"
        }],
        maxWidth: n,
        visibility: "visible",
        "&-hidden": {
          display: "none"
        },
        "--antd-arrow-background-color": r,
        // Wrapper for the tooltip content
        [`${t}-inner`]: {
          minWidth: l,
          minHeight: l,
          padding: `${s / 2}px ${c}px`,
          color: o,
          textAlign: "start",
          textDecoration: "none",
          wordWrap: "break-word",
          backgroundColor: r,
          borderRadius: a,
          boxShadow: u
        },
        // Limit left and right placement radius
        [["&-placement-left", "&-placement-leftTop", "&-placement-leftBottom", "&-placement-right", "&-placement-rightTop", "&-placement-rightBottom"].join(",")]: {
          [`${t}-inner`]: {
            borderRadius: Math.min(a, Q0)
          }
        },
        [`${t}-content`]: {
          position: "relative"
        }
      }), ry(e, (f, p) => {
        let {
          darkColor: v
        } = p;
        return {
          [`&${t}-${f}`]: {
            [`${t}-inner`]: {
              backgroundColor: v
            },
            [`${t}-arrow`]: {
              "--antd-arrow-background-color": v
            }
          }
        };
      })), {
        // RTL
        "&-rtl": {
          direction: "rtl"
        }
      })
    },
    // Arrow Style
    Z0(qe(e, {
      borderRadiusOuter: d
    }), {
      colorBg: "var(--antd-arrow-background-color)",
      showArrowCls: "",
      contentRadius: a,
      limitVerticalRadius: !0
    }),
    // Pure Render
    {
      [`${t}-pure`]: {
        position: "relative",
        maxWidth: "none"
      }
    }
  ];
}, DN = (e, t) => ht("Tooltip", (o) => {
  if ((t == null ? void 0 : t.value) === !1)
    return [];
  const {
    borderRadius: r,
    colorTextLightSolid: a,
    colorBgDefault: i,
    borderRadiusOuter: l
  } = o, u = qe(o, {
    // default variables
    tooltipMaxWidth: 250,
    tooltipColor: a,
    tooltipBorderRadius: r,
    tooltipBg: i,
    tooltipRadiusOuter: l > 4 ? 4 : l
  });
  return [_N(u), _s(o, "zoom-big-fast")];
}, (o) => {
  let {
    zIndexPopupBase: r,
    colorBgSpotlight: a
  } = o;
  return {
    zIndexPopup: r + 70,
    colorBgDefault: a
  };
})(e), AN = (e, t) => {
  const n = {}, o = h({}, e);
  return t.forEach((r) => {
    e && r in e && (n[r] = e[r], delete o[r]);
  }), {
    picked: n,
    omitted: o
  };
}, J0 = () => h(h({}, X0()), {
  title: W.any
}), NN = () => ({
  trigger: "hover",
  align: {},
  placement: "top",
  mouseEnterDelay: 0.1,
  mouseLeaveDelay: 0.1,
  arrowPointAtCenter: !1,
  autoAdjustOverflow: !0
}), RN = J({
  compatConfig: {
    MODE: 3
  },
  name: "ATooltip",
  inheritAttrs: !1,
  props: bt(J0(), {
    trigger: "hover",
    align: {},
    placement: "top",
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    arrowPointAtCenter: !1,
    autoAdjustOverflow: !0
  }),
  slots: Object,
  // emits: ['update:visible', 'visibleChange'],
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: r,
      expose: a
    } = t;
    process.env.NODE_ENV !== "production" && [["visible", "open"], ["onVisibleChange", "onOpenChange"]].forEach((N) => {
      let [I, E] = N;
      Pt(e[I] === void 0, "Tooltip", `\`${I}\` is deprecated, please use \`${E}\` instead.`);
    });
    const {
      prefixCls: i,
      getPopupContainer: l,
      direction: u,
      rootPrefixCls: s
    } = Ke("tooltip", e), c = T(() => {
      var N;
      return (N = e.open) !== null && N !== void 0 ? N : e.visible;
    }), d = G(ON([e.open, e.visible])), f = G();
    let p;
    le(c, (N) => {
      Ue.cancel(p), p = Ue(() => {
        d.value = !!N;
      });
    });
    const v = () => {
      var N;
      const I = (N = e.title) !== null && N !== void 0 ? N : n.title;
      return !I && I !== 0;
    }, g = (N) => {
      const I = v();
      c.value === void 0 && (d.value = I ? !1 : N), I || (o("update:visible", N), o("visibleChange", N), o("update:open", N), o("openChange", N));
    };
    a({
      getPopupDomNode: () => f.value.getPopupDomNode(),
      open: d,
      forcePopupAlign: () => {
        var N;
        return (N = f.value) === null || N === void 0 ? void 0 : N.forcePopupAlign();
      }
    });
    const y = T(() => {
      var N;
      const {
        builtinPlacements: I,
        autoAdjustOverflow: E,
        arrow: B,
        arrowPointAtCenter: k
      } = e;
      let P = k;
      return typeof B == "object" && (P = (N = B.pointAtCenter) !== null && N !== void 0 ? N : k), I || xN({
        arrowPointAtCenter: P,
        autoAdjustOverflow: E
      });
    }), S = (N) => N || N === "", w = (N) => {
      const I = N.type;
      if (typeof I == "object" && N.props && ((I.__ANT_BUTTON === !0 || I === "button") && S(N.props.disabled) || I.__ANT_SWITCH === !0 && (S(N.props.disabled) || S(N.props.loading)) || I.__ANT_RADIO === !0 && S(N.props.disabled))) {
        const {
          picked: E,
          omitted: B
        } = AN(ex(N), ["position", "left", "right", "top", "bottom", "float", "display", "zIndex"]), k = h(h({
          display: "inline-block"
        }, E), {
          cursor: "not-allowed",
          lineHeight: 1,
          width: N.props && N.props.block ? "100%" : void 0
        }), P = h(h({}, B), {
          pointerEvents: "none"
        }), R = Tt(N, {
          style: P
        }, !0);
        return m("span", {
          style: k,
          class: `${i.value}-disabled-compatible-wrapper`
        }, [R]);
      }
      return N;
    }, C = () => {
      var N, I;
      return (N = e.title) !== null && N !== void 0 ? N : (I = n.title) === null || I === void 0 ? void 0 : I.call(n);
    }, $ = (N, I) => {
      const E = y.value, B = Object.keys(E).find((k) => {
        var P, R;
        return E[k].points[0] === ((P = I.points) === null || P === void 0 ? void 0 : P[0]) && E[k].points[1] === ((R = I.points) === null || R === void 0 ? void 0 : R[1]);
      });
      if (B) {
        const k = N.getBoundingClientRect(), P = {
          top: "50%",
          left: "50%"
        };
        B.indexOf("top") >= 0 || B.indexOf("Bottom") >= 0 ? P.top = `${k.height - I.offset[1]}px` : (B.indexOf("Top") >= 0 || B.indexOf("bottom") >= 0) && (P.top = `${-I.offset[1]}px`), B.indexOf("left") >= 0 || B.indexOf("Right") >= 0 ? P.left = `${k.width - I.offset[0]}px` : (B.indexOf("right") >= 0 || B.indexOf("Left") >= 0) && (P.left = `${-I.offset[0]}px`), N.style.transformOrigin = `${P.left} ${P.top}`;
      }
    }, O = T(() => EN(i.value, e.color)), x = T(() => r["data-popover-inject"]), [M, _] = DN(i, T(() => !x.value));
    return () => {
      var N, I;
      const {
        openClassName: E,
        overlayClassName: B,
        overlayStyle: k,
        overlayInnerStyle: P
      } = e;
      let R = (I = nn((N = n.default) === null || N === void 0 ? void 0 : N.call(n))) !== null && I !== void 0 ? I : null;
      R = R.length === 1 ? R[0] : R;
      let D = d.value;
      if (c.value === void 0 && v() && (D = !1), !R)
        return null;
      const A = w(on(R) && !tx(R) ? R : m("span", null, [R])), H = ae({
        [E || `${i.value}-open`]: !0,
        [A.props && A.props.class]: A.props && A.props.class
      }), j = ae(B, {
        [`${i.value}-rtl`]: u.value === "rtl"
      }, O.value.className, _.value), z = h(h({}, O.value.overlayStyle), P), F = O.value.arrowStyle, U = h(h(h({}, r), e), {
        prefixCls: i.value,
        arrow: !!e.arrow,
        getPopupContainer: l == null ? void 0 : l.value,
        builtinPlacements: y.value,
        visible: D,
        ref: f,
        overlayClassName: j,
        overlayStyle: h(h({}, F), k),
        overlayInnerStyle: z,
        onVisibleChange: g,
        onPopupAlign: $,
        transitionName: wr(s.value, "zoom-big-fast", e.transitionName)
      });
      return M(m($N, U, {
        default: () => [d.value ? Tt(A, {
          class: H
        }) : A],
        arrowContent: () => m("span", {
          class: `${i.value}-arrow-content`
        }, null),
        overlay: C
      }));
    };
  }
}), Nr = Xn(RN), FN = (e) => {
  const {
    componentCls: t,
    popoverBg: n,
    popoverColor: o,
    width: r,
    fontWeightStrong: a,
    popoverPadding: i,
    boxShadowSecondary: l,
    colorTextHeading: u,
    borderRadiusLG: s,
    zIndexPopup: c,
    marginXS: d,
    colorBgElevated: f
  } = e;
  return [
    {
      [t]: h(h({}, st(e)), {
        position: "absolute",
        top: 0,
        // use `left` to fix https://github.com/ant-design/ant-design/issues/39195
        left: {
          _skip_check_: !0,
          value: 0
        },
        zIndex: c,
        fontWeight: "normal",
        whiteSpace: "normal",
        textAlign: "start",
        cursor: "auto",
        userSelect: "text",
        "--antd-arrow-background-color": f,
        "&-rtl": {
          direction: "rtl"
        },
        "&-hidden": {
          display: "none"
        },
        [`${t}-content`]: {
          position: "relative"
        },
        [`${t}-inner`]: {
          backgroundColor: n,
          backgroundClip: "padding-box",
          borderRadius: s,
          boxShadow: l,
          padding: i
        },
        [`${t}-title`]: {
          minWidth: r,
          marginBottom: d,
          color: u,
          fontWeight: a
        },
        [`${t}-inner-content`]: {
          color: o
        }
      })
    },
    // Arrow Style
    Z0(e, {
      colorBg: "var(--antd-arrow-background-color)"
    }),
    // Pure Render
    {
      [`${t}-pure`]: {
        position: "relative",
        maxWidth: "none",
        [`${t}-content`]: {
          display: "inline-block"
        }
      }
    }
  ];
}, BN = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: ci.map((n) => {
      const o = e[`${n}-6`];
      return {
        [`&${t}-${n}`]: {
          "--antd-arrow-background-color": o,
          [`${t}-inner`]: {
            backgroundColor: o
          },
          [`${t}-arrow`]: {
            background: "transparent"
          }
        }
      };
    })
  };
}, kN = (e) => {
  const {
    componentCls: t,
    lineWidth: n,
    lineType: o,
    colorSplit: r,
    paddingSM: a,
    controlHeight: i,
    fontSize: l,
    lineHeight: u,
    padding: s
  } = e, c = i - Math.round(l * u), d = c / 2, f = c / 2 - n, p = s;
  return {
    [t]: {
      [`${t}-inner`]: {
        padding: 0
      },
      [`${t}-title`]: {
        margin: 0,
        padding: `${d}px ${p}px ${f}px`,
        borderBottom: `${n}px ${o} ${r}`
      },
      [`${t}-inner-content`]: {
        padding: `${a}px ${p}px`
      }
    }
  };
}, LN = ht("Popover", (e) => {
  const {
    colorBgElevated: t,
    colorText: n,
    wireframe: o
  } = e, r = qe(e, {
    popoverBg: t,
    popoverColor: n,
    popoverPadding: 12
    // Fixed Value
  });
  return [FN(r), BN(r), o && kN(r), _s(r, "zoom-big")];
}, (e) => {
  let {
    zIndexPopupBase: t
  } = e;
  return {
    zIndexPopup: t + 30,
    width: 177
  };
}), HN = () => h(h({}, X0()), {
  content: Wt(),
  title: Wt()
}), zN = J({
  compatConfig: {
    MODE: 3
  },
  name: "APopover",
  inheritAttrs: !1,
  props: bt(HN(), h(h({}, NN()), {
    trigger: "hover",
    placement: "top",
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1
  })),
  setup(e, t) {
    let {
      expose: n,
      slots: o,
      attrs: r
    } = t;
    const a = G();
    Pt(e.visible === void 0, "popover", "`visible` will be removed in next major version, please use `open` instead."), n({
      getPopupDomNode: () => {
        var f, p;
        return (p = (f = a.value) === null || f === void 0 ? void 0 : f.getPopupDomNode) === null || p === void 0 ? void 0 : p.call(f);
      }
    });
    const {
      prefixCls: i,
      configProvider: l
    } = Ke("popover", e), [u, s] = LN(i), c = T(() => l.getPrefixCls()), d = () => {
      var f, p;
      const {
        title: v = nn((f = o.title) === null || f === void 0 ? void 0 : f.call(o)),
        content: g = nn((p = o.content) === null || p === void 0 ? void 0 : p.call(o))
      } = e, b = !!(Array.isArray(v) ? v.length : v), y = !!(Array.isArray(g) ? g.length : v);
      return !b && !y ? null : m(We, null, [b && m("div", {
        class: `${i.value}-title`
      }, [v]), m("div", {
        class: `${i.value}-inner-content`
      }, [g])]);
    };
    return () => {
      const f = ae(e.overlayClassName, s.value);
      return u(m(Nr, L(L(L({}, pt(e, ["title", "content"])), r), {}, {
        prefixCls: i.value,
        ref: a,
        overlayClassName: f,
        transitionName: wr(c.value, "zoom-big", e.transitionName),
        "data-popover-inject": !0
      }), {
        title: d,
        default: o.default
      }));
    };
  }
}), jN = Xn(zN), VN = () => ({
  prefixCls: String,
  maxCount: Number,
  maxStyle: {
    type: Object,
    default: void 0
  },
  maxPopoverPlacement: {
    type: String,
    default: "top"
  },
  maxPopoverTrigger: String,
  /*
   * Size of avatar, options: `large`, `small`, `default`
   * or a custom number size
   * */
  size: {
    type: [Number, String, Object],
    default: "default"
  },
  shape: {
    type: String,
    default: "circle"
  }
}), Vl = J({
  compatConfig: {
    MODE: 3
  },
  name: "AAvatarGroup",
  inheritAttrs: !1,
  props: VN(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r,
      direction: a
    } = Ke("avatar", e), i = T(() => `${r.value}-group`), [l, u] = U0(r);
    return Ve(() => {
      const s = {
        size: e.size,
        shape: e.shape
      };
      gN(s);
    }), () => {
      const {
        maxPopoverPlacement: s = "top",
        maxCount: c,
        maxStyle: d,
        maxPopoverTrigger: f = "hover",
        shape: p
      } = e, v = {
        [i.value]: !0,
        [`${i.value}-rtl`]: a.value === "rtl",
        [`${o.class}`]: !!o.class,
        [u.value]: !0
      }, g = Uo(n, e), b = xt(g).map((S, w) => Tt(S, {
        key: `avatar-key-${w}`
      })), y = b.length;
      if (c && c < y) {
        const S = b.slice(0, c), w = b.slice(c, y);
        return S.push(m(jN, {
          key: "avatar-popover-key",
          content: w,
          trigger: f,
          placement: s,
          overlayClassName: `${i.value}-popover`
        }, {
          default: () => [m(ea, {
            style: d,
            shape: p
          }, {
            default: () => [`+${y - c}`]
          })]
        })), l(m("div", L(L({}, o), {}, {
          class: v,
          style: o.style
        }), [S]));
      }
      return l(m("div", L(L({}, o), {}, {
        class: v,
        style: o.style
      }), [b]));
    };
  }
});
ea.Group = Vl;
ea.install = function(e) {
  return e.component(ea.name, ea), e.component(Vl.name, Vl), e;
};
const Hr = {
  adjustX: 1,
  adjustY: 1
}, zr = [0, 0], WN = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: Hr,
    offset: [0, -4],
    targetOffset: zr
  },
  topCenter: {
    points: ["bc", "tc"],
    overflow: Hr,
    offset: [0, -4],
    targetOffset: zr
  },
  topRight: {
    points: ["br", "tr"],
    overflow: Hr,
    offset: [0, -4],
    targetOffset: zr
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: Hr,
    offset: [0, 4],
    targetOffset: zr
  },
  bottomCenter: {
    points: ["tc", "bc"],
    overflow: Hr,
    offset: [0, 4],
    targetOffset: zr
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: Hr,
    offset: [0, 4],
    targetOffset: zr
  }
};
var KN = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const UN = J({
  compatConfig: {
    MODE: 3
  },
  props: {
    minOverlayWidthMatchTrigger: {
      type: Boolean,
      default: void 0
    },
    arrow: {
      type: Boolean,
      default: !1
    },
    prefixCls: W.string.def("rc-dropdown"),
    transitionName: String,
    overlayClassName: W.string.def(""),
    openClassName: String,
    animation: W.any,
    align: W.object,
    overlayStyle: {
      type: Object,
      default: void 0
    },
    placement: W.string.def("bottomLeft"),
    overlay: W.any,
    trigger: W.oneOfType([W.string, W.arrayOf(W.string)]).def("hover"),
    alignPoint: {
      type: Boolean,
      default: void 0
    },
    showAction: W.array,
    hideAction: W.array,
    getPopupContainer: Function,
    visible: {
      type: Boolean,
      default: void 0
    },
    defaultVisible: {
      type: Boolean,
      default: !1
    },
    mouseEnterDelay: W.number.def(0.15),
    mouseLeaveDelay: W.number.def(0.1)
  },
  emits: ["visibleChange", "overlayClick"],
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      expose: r
    } = t;
    const a = G(!!e.visible);
    le(() => e.visible, (p) => {
      p !== void 0 && (a.value = p);
    });
    const i = G();
    r({
      triggerRef: i
    });
    const l = (p) => {
      e.visible === void 0 && (a.value = !1), o("overlayClick", p);
    }, u = (p) => {
      e.visible === void 0 && (a.value = p), o("visibleChange", p);
    }, s = () => {
      var p;
      const v = (p = n.overlay) === null || p === void 0 ? void 0 : p.call(n), g = {
        prefixCls: `${e.prefixCls}-menu`,
        onClick: l
      };
      return m(We, {
        key: hb
      }, [e.arrow && m("div", {
        class: `${e.prefixCls}-arrow`
      }, null), Tt(v, g, !1)]);
    }, c = T(() => {
      const {
        minOverlayWidthMatchTrigger: p = !e.alignPoint
      } = e;
      return p;
    }), d = () => {
      var p;
      const v = (p = n.default) === null || p === void 0 ? void 0 : p.call(n);
      return a.value && v ? Tt(v[0], {
        class: e.openClassName || `${e.prefixCls}-open`
      }, !1) : v;
    }, f = T(() => !e.hideAction && e.trigger.indexOf("contextmenu") !== -1 ? ["click"] : e.hideAction);
    return () => {
      const {
        prefixCls: p,
        arrow: v,
        showAction: g,
        overlayStyle: b,
        trigger: y,
        placement: S,
        align: w,
        getPopupContainer: C,
        transitionName: $,
        animation: O,
        overlayClassName: x
      } = e, M = KN(e, ["prefixCls", "arrow", "showAction", "overlayStyle", "trigger", "placement", "align", "getPopupContainer", "transitionName", "animation", "overlayClassName"]);
      return m(wa, L(L({}, M), {}, {
        prefixCls: p,
        ref: i,
        popupClassName: ae(x, {
          [`${p}-show-arrow`]: v
        }),
        popupStyle: b,
        builtinPlacements: WN,
        action: y,
        showAction: g,
        hideAction: f.value || [],
        popupPlacement: S,
        popupAlign: w,
        popupTransitionName: $,
        popupAnimation: O,
        popupVisible: a.value,
        stretch: c.value ? "minWidth" : "",
        onPopupVisibleChange: u,
        getPopupContainer: C
      }), {
        popup: s,
        default: d
      });
    };
  }
}), GN = (e) => {
  const {
    componentCls: t,
    colorPrimary: n
  } = e;
  return {
    [t]: {
      position: "absolute",
      background: "transparent",
      pointerEvents: "none",
      boxSizing: "border-box",
      color: `var(--wave-color, ${n})`,
      boxShadow: "0 0 0 0 currentcolor",
      opacity: 0.2,
      // =================== Motion ===================
      "&.wave-motion-appear": {
        transition: [`box-shadow 0.4s ${e.motionEaseOutCirc}`, `opacity 2s ${e.motionEaseOutCirc}`].join(","),
        "&-active": {
          boxShadow: "0 0 0 6px currentcolor",
          opacity: 0
        }
      }
    }
  };
}, YN = ht("Wave", (e) => [GN(e)]);
function XN(e) {
  const t = (e || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
  return t && t[1] && t[2] && t[3] ? !(t[1] === t[2] && t[2] === t[3]) : !0;
}
function Pu(e) {
  return e && e !== "#fff" && e !== "#ffffff" && e !== "rgb(255, 255, 255)" && e !== "rgba(255, 255, 255, 1)" && XN(e) && !/rgba\((?:\d*, ){3}0\)/.test(e) && // any transparent rgba color
  e !== "transparent";
}
function qN(e) {
  const {
    borderTopColor: t,
    borderColor: n,
    backgroundColor: o
  } = getComputedStyle(e);
  return Pu(t) ? t : Pu(n) ? n : Pu(o) ? o : null;
}
function Iu(e) {
  return Number.isNaN(e) ? 0 : e;
}
const QN = J({
  props: {
    target: He(),
    className: String
  },
  setup(e) {
    const t = K(null), [n, o] = yt(null), [r, a] = yt([]), [i, l] = yt(0), [u, s] = yt(0), [c, d] = yt(0), [f, p] = yt(0), [v, g] = yt(!1);
    function b() {
      const {
        target: x
      } = e, M = getComputedStyle(x);
      o(qN(x));
      const _ = M.position === "static", {
        borderLeftWidth: N,
        borderTopWidth: I
      } = M;
      l(_ ? x.offsetLeft : Iu(-parseFloat(N))), s(_ ? x.offsetTop : Iu(-parseFloat(I))), d(x.offsetWidth), p(x.offsetHeight);
      const {
        borderTopLeftRadius: E,
        borderTopRightRadius: B,
        borderBottomLeftRadius: k,
        borderBottomRightRadius: P
      } = M;
      a([E, B, P, k].map((R) => Iu(parseFloat(R))));
    }
    let y, S, w;
    const C = () => {
      clearTimeout(w), Ue.cancel(S), y == null || y.disconnect();
    }, $ = () => {
      var x;
      const M = (x = t.value) === null || x === void 0 ? void 0 : x.parentElement;
      M && (hr(null, M), M.parentElement && M.parentElement.removeChild(M));
    };
    ze(() => {
      C(), w = setTimeout(() => {
        $();
      }, 5e3);
      const {
        target: x
      } = e;
      x && (S = Ue(() => {
        b(), g(!0);
      }), typeof ResizeObserver < "u" && (y = new ResizeObserver(b), y.observe(x)));
    }), at(() => {
      C();
    });
    const O = (x) => {
      x.propertyName === "opacity" && $();
    };
    return () => {
      if (!v.value)
        return null;
      const x = {
        left: `${i.value}px`,
        top: `${u.value}px`,
        width: `${c.value}px`,
        height: `${f.value}px`,
        borderRadius: r.value.map((M) => `${M}px`).join(" ")
      };
      return n && (x["--wave-color"] = n.value), m(Yn, {
        appear: !0,
        name: "wave-motion",
        appearFromClass: "wave-motion-appear",
        appearActiveClass: "wave-motion-appear",
        appearToClass: "wave-motion-appear wave-motion-appear-active"
      }, {
        default: () => [m("div", {
          ref: t,
          class: e.className,
          style: x,
          onTransitionend: O
        }, null)]
      });
    };
  }
});
function ZN(e, t) {
  const n = document.createElement("div");
  n.style.position = "absolute", n.style.left = "0px", n.style.top = "0px", e == null || e.insertBefore(n, e == null ? void 0 : e.firstChild), hr(m(QN, {
    target: e,
    className: t
  }, null), n);
}
function JN(e, t, n) {
  function o() {
    var r;
    const a = to(e);
    !((r = n == null ? void 0 : n.value) === null || r === void 0) && r.disabled || !a || ZN(a, t.value);
  }
  return o;
}
const Pf = J({
  compatConfig: {
    MODE: 3
  },
  name: "Wave",
  props: {
    disabled: Boolean
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = On(), {
      prefixCls: r,
      wave: a
    } = Ke("wave", e), [, i] = YN(r), l = JN(o, T(() => ae(r.value, i.value)), a);
    let u;
    const s = () => {
      to(o).removeEventListener("click", u, !0);
    };
    return ze(() => {
      le(() => e.disabled, () => {
        s(), mt(() => {
          const c = to(o);
          c == null || c.removeEventListener("click", u, !0), !(!c || c.nodeType !== 1 || e.disabled) && (u = (d) => {
            d.target.tagName === "INPUT" || !Ld(d.target) || // No need wave
            !c.getAttribute || c.getAttribute("disabled") || c.disabled || c.className.includes("disabled") || c.className.includes("-leave") || l();
          }, c.addEventListener("click", u, !0));
        });
      }, {
        immediate: !0,
        flush: "post"
      });
    }), at(() => {
      s();
    }), () => {
      var c;
      return (c = n.default) === null || c === void 0 ? void 0 : c.call(n)[0];
    };
  }
});
function eS(e) {
  return e === "danger" ? {
    danger: !0
  } : {
    type: e
  };
}
const eR = () => ({
  prefixCls: String,
  type: String,
  htmlType: {
    type: String,
    default: "button"
  },
  shape: {
    type: String
  },
  size: {
    type: String
  },
  loading: {
    type: [Boolean, Object],
    default: () => !1
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  ghost: {
    type: Boolean,
    default: void 0
  },
  block: {
    type: Boolean,
    default: void 0
  },
  danger: {
    type: Boolean,
    default: void 0
  },
  icon: W.any,
  href: String,
  target: String,
  title: String,
  onClick: ai(),
  onMousedown: ai()
}), Ym = (e) => {
  e && (e.style.width = "0px", e.style.opacity = "0", e.style.transform = "scale(0)");
}, Xm = (e) => {
  mt(() => {
    e && (e.style.width = `${e.scrollWidth}px`, e.style.opacity = "1", e.style.transform = "scale(1)");
  });
}, qm = (e) => {
  e && e.style && (e.style.width = null, e.style.opacity = null, e.style.transform = null);
}, tR = J({
  compatConfig: {
    MODE: 3
  },
  name: "LoadingIcon",
  props: {
    prefixCls: String,
    loading: [Boolean, Object],
    existIcon: Boolean
  },
  setup(e) {
    return () => {
      const {
        existIcon: t,
        prefixCls: n,
        loading: o
      } = e;
      if (t)
        return m("span", {
          class: `${n}-loading-icon`
        }, [m(pn, null, null)]);
      const r = !!o;
      return m(Yn, {
        name: `${n}-loading-icon-motion`,
        onBeforeEnter: Ym,
        onEnter: Xm,
        onAfterEnter: qm,
        onBeforeLeave: Xm,
        onLeave: (a) => {
          setTimeout(() => {
            Ym(a);
          });
        },
        onAfterLeave: qm
      }, {
        default: () => [r ? m("span", {
          class: `${n}-loading-icon`
        }, [m(pn, null, null)]) : null]
      });
    };
  }
}), Qm = (e, t) => ({
  // Border
  [`> span, > ${e}`]: {
    "&:not(:last-child)": {
      [`&, & > ${e}`]: {
        "&:not(:disabled)": {
          borderInlineEndColor: t
        }
      }
    },
    "&:not(:first-child)": {
      [`&, & > ${e}`]: {
        "&:not(:disabled)": {
          borderInlineStartColor: t
        }
      }
    }
  }
}), nR = (e) => {
  const {
    componentCls: t,
    fontSize: n,
    lineWidth: o,
    colorPrimaryHover: r,
    colorErrorHover: a
  } = e;
  return {
    [`${t}-group`]: [
      {
        position: "relative",
        display: "inline-flex",
        // Border
        [`> span, > ${t}`]: {
          "&:not(:last-child)": {
            [`&, & > ${t}`]: {
              borderStartEndRadius: 0,
              borderEndEndRadius: 0
            }
          },
          "&:not(:first-child)": {
            marginInlineStart: -o,
            [`&, & > ${t}`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0
            }
          }
        },
        [t]: {
          position: "relative",
          zIndex: 1,
          "&:hover,\n          &:focus,\n          &:active": {
            zIndex: 2
          },
          "&[disabled]": {
            zIndex: 0
          }
        },
        [`${t}-icon-only`]: {
          fontSize: n
        }
      },
      // Border Color
      Qm(`${t}-primary`, r),
      Qm(`${t}-danger`, a)
    ]
  };
};
function oR(e, t) {
  return {
    // border collapse
    [`&-item:not(${t}-last-item)`]: {
      marginBottom: -e.lineWidth
    },
    "&-item": {
      "&:hover,&:focus,&:active": {
        zIndex: 2
      },
      "&[disabled]": {
        zIndex: 0
      }
    }
  };
}
function rR(e, t) {
  return {
    [`&-item:not(${t}-first-item):not(${t}-last-item)`]: {
      borderRadius: 0
    },
    [`&-item${t}-first-item:not(${t}-last-item)`]: {
      [`&, &${e}-sm, &${e}-lg`]: {
        borderEndEndRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&-item${t}-last-item:not(${t}-first-item)`]: {
      [`&, &${e}-sm, &${e}-lg`]: {
        borderStartStartRadius: 0,
        borderStartEndRadius: 0
      }
    }
  };
}
function aR(e) {
  const t = `${e.componentCls}-compact-vertical`;
  return {
    [t]: h(h({}, oR(e, t)), rR(e.componentCls, t))
  };
}
const iR = (e) => {
  const {
    componentCls: t,
    iconCls: n
  } = e;
  return {
    [t]: {
      outline: "none",
      position: "relative",
      display: "inline-block",
      fontWeight: 400,
      whiteSpace: "nowrap",
      textAlign: "center",
      backgroundImage: "none",
      backgroundColor: "transparent",
      border: `${e.lineWidth}px ${e.lineType} transparent`,
      cursor: "pointer",
      transition: `all ${e.motionDurationMid} ${e.motionEaseInOut}`,
      userSelect: "none",
      touchAction: "manipulation",
      lineHeight: e.lineHeight,
      color: e.colorText,
      "> span": {
        display: "inline-block"
      },
      // Leave a space between icon and text.
      [`> ${n} + span, > span + ${n}`]: {
        marginInlineStart: e.marginXS
      },
      "> a": {
        color: "currentColor"
      },
      "&:not(:disabled)": h({}, $i(e)),
      // make `btn-icon-only` not too narrow
      [`&-icon-only${t}-compact-item`]: {
        flex: "none"
      },
      // Special styles for Primary Button
      [`&-compact-item${t}-primary`]: {
        [`&:not([disabled]) + ${t}-compact-item${t}-primary:not([disabled])`]: {
          position: "relative",
          "&:before": {
            position: "absolute",
            top: -e.lineWidth,
            insetInlineStart: -e.lineWidth,
            display: "inline-block",
            width: e.lineWidth,
            height: `calc(100% + ${e.lineWidth * 2}px)`,
            backgroundColor: e.colorPrimaryHover,
            content: '""'
          }
        }
      },
      // Special styles for Primary Button
      "&-compact-vertical-item": {
        [`&${t}-primary`]: {
          [`&:not([disabled]) + ${t}-compact-vertical-item${t}-primary:not([disabled])`]: {
            position: "relative",
            "&:before": {
              position: "absolute",
              top: -e.lineWidth,
              insetInlineStart: -e.lineWidth,
              display: "inline-block",
              width: `calc(100% + ${e.lineWidth * 2}px)`,
              height: e.lineWidth,
              backgroundColor: e.colorPrimaryHover,
              content: '""'
            }
          }
        }
      }
    }
  };
}, $o = (e, t) => ({
  "&:not(:disabled)": {
    "&:hover": e,
    "&:active": t
  }
}), lR = (e) => ({
  minWidth: e.controlHeight,
  paddingInlineStart: 0,
  paddingInlineEnd: 0,
  borderRadius: "50%"
}), sR = (e) => ({
  borderRadius: e.controlHeight,
  paddingInlineStart: e.controlHeight / 2,
  paddingInlineEnd: e.controlHeight / 2
}), kc = (e) => ({
  cursor: "not-allowed",
  borderColor: e.colorBorder,
  color: e.colorTextDisabled,
  backgroundColor: e.colorBgContainerDisabled,
  boxShadow: "none"
}), Wl = (e, t, n, o, r, a, i) => ({
  [`&${e}-background-ghost`]: h(h({
    color: t || void 0,
    backgroundColor: "transparent",
    borderColor: n || void 0,
    boxShadow: "none"
  }, $o(h({
    backgroundColor: "transparent"
  }, a), h({
    backgroundColor: "transparent"
  }, i))), {
    "&:disabled": {
      cursor: "not-allowed",
      color: o || void 0,
      borderColor: r || void 0
    }
  })
}), If = (e) => ({
  "&:disabled": h({}, kc(e))
}), tS = (e) => h({}, If(e)), Kl = (e) => ({
  "&:disabled": {
    cursor: "not-allowed",
    color: e.colorTextDisabled
  }
}), nS = (e) => h(h(h(h(h({}, tS(e)), {
  backgroundColor: e.colorBgContainer,
  borderColor: e.colorBorder,
  boxShadow: `0 ${e.controlOutlineWidth}px 0 ${e.controlTmpOutline}`
}), $o({
  color: e.colorPrimaryHover,
  borderColor: e.colorPrimaryHover
}, {
  color: e.colorPrimaryActive,
  borderColor: e.colorPrimaryActive
})), Wl(e.componentCls, e.colorBgContainer, e.colorBgContainer, e.colorTextDisabled, e.colorBorder)), {
  [`&${e.componentCls}-dangerous`]: h(h(h({
    color: e.colorError,
    borderColor: e.colorError
  }, $o({
    color: e.colorErrorHover,
    borderColor: e.colorErrorBorderHover
  }, {
    color: e.colorErrorActive,
    borderColor: e.colorErrorActive
  })), Wl(e.componentCls, e.colorError, e.colorError, e.colorTextDisabled, e.colorBorder)), If(e))
}), uR = (e) => h(h(h(h(h({}, tS(e)), {
  color: e.colorTextLightSolid,
  backgroundColor: e.colorPrimary,
  boxShadow: `0 ${e.controlOutlineWidth}px 0 ${e.controlOutline}`
}), $o({
  color: e.colorTextLightSolid,
  backgroundColor: e.colorPrimaryHover
}, {
  color: e.colorTextLightSolid,
  backgroundColor: e.colorPrimaryActive
})), Wl(e.componentCls, e.colorPrimary, e.colorPrimary, e.colorTextDisabled, e.colorBorder, {
  color: e.colorPrimaryHover,
  borderColor: e.colorPrimaryHover
}, {
  color: e.colorPrimaryActive,
  borderColor: e.colorPrimaryActive
})), {
  [`&${e.componentCls}-dangerous`]: h(h(h({
    backgroundColor: e.colorError,
    boxShadow: `0 ${e.controlOutlineWidth}px 0 ${e.colorErrorOutline}`
  }, $o({
    backgroundColor: e.colorErrorHover
  }, {
    backgroundColor: e.colorErrorActive
  })), Wl(e.componentCls, e.colorError, e.colorError, e.colorTextDisabled, e.colorBorder, {
    color: e.colorErrorHover,
    borderColor: e.colorErrorHover
  }, {
    color: e.colorErrorActive,
    borderColor: e.colorErrorActive
  })), If(e))
}), cR = (e) => h(h({}, nS(e)), {
  borderStyle: "dashed"
}), dR = (e) => h(h(h({
  color: e.colorLink
}, $o({
  color: e.colorLinkHover
}, {
  color: e.colorLinkActive
})), Kl(e)), {
  [`&${e.componentCls}-dangerous`]: h(h({
    color: e.colorError
  }, $o({
    color: e.colorErrorHover
  }, {
    color: e.colorErrorActive
  })), Kl(e))
}), fR = (e) => h(h(h({}, $o({
  color: e.colorText,
  backgroundColor: e.colorBgTextHover
}, {
  color: e.colorText,
  backgroundColor: e.colorBgTextActive
})), Kl(e)), {
  [`&${e.componentCls}-dangerous`]: h(h({
    color: e.colorError
  }, Kl(e)), $o({
    color: e.colorErrorHover,
    backgroundColor: e.colorErrorBg
  }, {
    color: e.colorErrorHover,
    backgroundColor: e.colorErrorBg
  }))
}), pR = (e) => h(h({}, kc(e)), {
  [`&${e.componentCls}:hover`]: h({}, kc(e))
}), vR = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-default`]: nS(e),
    [`${t}-primary`]: uR(e),
    [`${t}-dashed`]: cR(e),
    [`${t}-link`]: dR(e),
    [`${t}-text`]: fR(e),
    [`${t}-disabled`]: pR(e)
  };
}, Tf = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  const {
    componentCls: n,
    iconCls: o,
    controlHeight: r,
    fontSize: a,
    lineHeight: i,
    lineWidth: l,
    borderRadius: u,
    buttonPaddingHorizontal: s
  } = e, c = Math.max(0, (r - a * i) / 2 - l), d = s - l, f = `${n}-icon-only`;
  return [
    // Size
    {
      [`${n}${t}`]: {
        fontSize: a,
        height: r,
        padding: `${c}px ${d}px`,
        borderRadius: u,
        [`&${f}`]: {
          width: r,
          paddingInlineStart: 0,
          paddingInlineEnd: 0,
          [`&${n}-round`]: {
            width: "auto"
          },
          "> span": {
            transform: "scale(1.143)"
            // 14px -> 16px
          }
        },
        // Loading
        [`&${n}-loading`]: {
          opacity: e.opacityLoading,
          cursor: "default"
        },
        [`${n}-loading-icon`]: {
          transition: `width ${e.motionDurationSlow} ${e.motionEaseInOut}, opacity ${e.motionDurationSlow} ${e.motionEaseInOut}`
        },
        [`&:not(${f}) ${n}-loading-icon > ${o}`]: {
          marginInlineEnd: e.marginXS
        }
      }
    },
    // Shape - patch prefixCls again to override solid border radius style
    {
      [`${n}${n}-circle${t}`]: lR(e)
    },
    {
      [`${n}${n}-round${t}`]: sR(e)
    }
  ];
}, mR = (e) => Tf(e), gR = (e) => {
  const t = qe(e, {
    controlHeight: e.controlHeightSM,
    padding: e.paddingXS,
    buttonPaddingHorizontal: 8,
    borderRadius: e.borderRadiusSM
  });
  return Tf(t, `${e.componentCls}-sm`);
}, hR = (e) => {
  const t = qe(e, {
    controlHeight: e.controlHeightLG,
    fontSize: e.fontSizeLG,
    borderRadius: e.borderRadiusLG
  });
  return Tf(t, `${e.componentCls}-lg`);
}, bR = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      [`&${t}-block`]: {
        width: "100%"
      }
    }
  };
}, yR = ht("Button", (e) => {
  const {
    controlTmpOutline: t,
    paddingContentHorizontal: n
  } = e, o = qe(e, {
    colorOutlineDefault: t,
    buttonPaddingHorizontal: n
  });
  return [
    // Shared
    iR(o),
    // Size
    gR(o),
    mR(o),
    hR(o),
    // Block
    bR(o),
    // Group (type, ghost, danger, disabled, loading)
    vR(o),
    // Button Group
    nR(o),
    // Space Compact
    xi(e, {
      focus: !1
    }),
    aR(e)
  ];
}), SR = () => ({
  prefixCls: String,
  size: {
    type: String
  }
}), oS = lf(), Lc = J({
  compatConfig: {
    MODE: 3
  },
  name: "AButtonGroup",
  props: SR(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      prefixCls: o,
      direction: r
    } = Ke("btn-group", e), [, , a] = ya();
    oS.useProvide(Et({
      size: T(() => e.size)
    }));
    const i = T(() => {
      const {
        size: l
      } = e;
      let u = "";
      switch (l) {
        case "large":
          u = "lg";
          break;
        case "small":
          u = "sm";
          break;
        case "middle":
        case void 0:
          break;
        default:
          gt(!l, "Button.Group", "Invalid prop `size`.");
      }
      return {
        [`${o.value}`]: !0,
        [`${o.value}-${u}`]: u,
        [`${o.value}-rtl`]: r.value === "rtl",
        [a.value]: !0
      };
    });
    return () => {
      var l;
      return m("div", {
        class: i.value
      }, [xt((l = n.default) === null || l === void 0 ? void 0 : l.call(n))]);
    };
  }
}), Zm = /^[\u4e00-\u9fa5]{2}$/, Jm = Zm.test.bind(Zm);
function Ki(e) {
  return e === "text" || e === "link";
}
const Zt = J({
  compatConfig: {
    MODE: 3
  },
  name: "AButton",
  inheritAttrs: !1,
  __ANT_BUTTON: !0,
  props: bt(eR(), {
    type: "default"
  }),
  slots: Object,
  // emits: ['click', 'mousedown'],
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      emit: r,
      expose: a
    } = t;
    const {
      prefixCls: i,
      autoInsertSpaceInButton: l,
      direction: u,
      size: s
    } = Ke("btn", e), [c, d] = yR(i), f = oS.useInject(), p = Cn(), v = T(() => {
      var P;
      return (P = e.disabled) !== null && P !== void 0 ? P : p.value;
    }), g = K(null), b = K(void 0);
    let y = !1;
    const S = K(!1), w = K(!1), C = T(() => l.value !== !1), {
      compactSize: $,
      compactItemClassnames: O
    } = Dr(i, u), x = T(() => typeof e.loading == "object" && e.loading.delay ? e.loading.delay || !0 : !!e.loading);
    le(x, (P) => {
      clearTimeout(b.value), typeof x.value == "number" ? b.value = setTimeout(() => {
        S.value = P;
      }, x.value) : S.value = P;
    }, {
      immediate: !0
    });
    const M = T(() => {
      const {
        type: P,
        shape: R = "default",
        ghost: D,
        block: A,
        danger: H
      } = e, j = i.value, z = {
        large: "lg",
        small: "sm",
        middle: void 0
      }, F = $.value || (f == null ? void 0 : f.size) || s.value, U = F && z[F] || "";
      return [O.value, {
        [d.value]: !0,
        [`${j}`]: !0,
        [`${j}-${R}`]: R !== "default" && R,
        [`${j}-${P}`]: P,
        [`${j}-${U}`]: U,
        [`${j}-loading`]: S.value,
        [`${j}-background-ghost`]: D && !Ki(P),
        [`${j}-two-chinese-chars`]: w.value && C.value,
        [`${j}-block`]: A,
        [`${j}-dangerous`]: !!H,
        [`${j}-rtl`]: u.value === "rtl"
      }];
    }), _ = () => {
      const P = g.value;
      if (!P || l.value === !1)
        return;
      const R = P.textContent;
      y && Jm(R) ? w.value || (w.value = !0) : w.value && (w.value = !1);
    }, N = (P) => {
      if (S.value || v.value) {
        P.preventDefault();
        return;
      }
      r("click", P);
    }, I = (P) => {
      r("mousedown", P);
    }, E = (P, R) => {
      const D = R ? " " : "";
      if (P.type === sb) {
        let A = P.children.trim();
        return Jm(A) && (A = A.split("").join(D)), m("span", null, [A]);
      }
      return P;
    };
    return Ve(() => {
      gt(!(e.ghost && Ki(e.type)), "Button", "`link` or `text` button can't be a `ghost` button.");
    }), ze(_), Co(_), at(() => {
      b.value && clearTimeout(b.value);
    }), a({
      focus: () => {
        var P;
        (P = g.value) === null || P === void 0 || P.focus();
      },
      blur: () => {
        var P;
        (P = g.value) === null || P === void 0 || P.blur();
      }
    }), () => {
      var P, R;
      const {
        icon: D = (P = n.icon) === null || P === void 0 ? void 0 : P.call(n)
      } = e, A = xt((R = n.default) === null || R === void 0 ? void 0 : R.call(n));
      y = A.length === 1 && !D && !Ki(e.type);
      const {
        type: H,
        htmlType: j,
        href: z,
        title: F,
        target: U
      } = e, Q = S.value ? "loading" : D, q = h(h({}, o), {
        title: F,
        disabled: v.value,
        class: [M.value, o.class, {
          [`${i.value}-icon-only`]: A.length === 0 && !!Q
        }],
        onClick: N,
        onMousedown: I
      });
      v.value || delete q.disabled;
      const oe = D && !S.value ? D : m(tR, {
        existIcon: !!D,
        prefixCls: i.value,
        loading: !!S.value
      }, null), Z = A.map((Y) => E(Y, y && C.value));
      if (z !== void 0)
        return c(m("a", L(L({}, q), {}, {
          href: z,
          target: U,
          ref: g
        }), [oe, Z]));
      let ne = m("button", L(L({}, q), {}, {
        ref: g,
        type: j
      }), [oe, Z]);
      if (!Ki(H)) {
        const Y = /* @__PURE__ */ function() {
          return ne;
        }();
        ne = m(Pf, {
          ref: "wave",
          disabled: !!S.value
        }, {
          default: () => [Y]
        });
      }
      return c(ne);
    };
  }
});
Zt.Group = Lc;
Zt.install = function(e) {
  return e.component(Zt.name, Zt), e.component(Lc.name, Lc), e;
};
var $R = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, name: "ellipsis", theme: "outlined" };
function eg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      CR(e, r, n[r]);
    });
  }
  return e;
}
function CR(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Ds = function(t, n) {
  var o = eg({}, t, n.attrs);
  return m(it, eg({}, o, {
    icon: $R
  }), null);
};
Ds.displayName = "EllipsisOutlined";
Ds.inheritAttrs = !1;
const rS = Symbol("OverrideContextKey"), aS = () => nt(rS, void 0), iS = (e) => {
  var t, n, o;
  const {
    prefixCls: r,
    mode: a,
    selectable: i,
    validator: l,
    onClick: u,
    expandIcon: s
  } = aS() || {};
  ot(rS, {
    prefixCls: T(() => {
      var c, d;
      return (d = (c = e.prefixCls) === null || c === void 0 ? void 0 : c.value) !== null && d !== void 0 ? d : r == null ? void 0 : r.value;
    }),
    mode: T(() => {
      var c, d;
      return (d = (c = e.mode) === null || c === void 0 ? void 0 : c.value) !== null && d !== void 0 ? d : a == null ? void 0 : a.value;
    }),
    selectable: T(() => {
      var c, d;
      return (d = (c = e.selectable) === null || c === void 0 ? void 0 : c.value) !== null && d !== void 0 ? d : i == null ? void 0 : i.value;
    }),
    validator: (t = e.validator) !== null && t !== void 0 ? t : l,
    onClick: (n = e.onClick) !== null && n !== void 0 ? n : u,
    expandIcon: (o = e.expandIcon) !== null && o !== void 0 ? o : s == null ? void 0 : s.value
  });
};
function wR(e, t, n, o) {
  let r;
  if (r !== void 0)
    return !!r;
  if (e === t)
    return !0;
  if (typeof e != "object" || !e || typeof t != "object" || !t)
    return !1;
  const a = Object.keys(e), i = Object.keys(t);
  if (a.length !== i.length)
    return !1;
  const l = Object.prototype.hasOwnProperty.bind(t);
  for (let u = 0; u < a.length; u++) {
    const s = a[u];
    if (!l(s))
      return !1;
    const c = e[s], d = t[s];
    if (r = void 0, r === !1 || r === void 0 && c !== d)
      return !1;
  }
  return !0;
}
function Kr(e, t) {
  return wR(Ft(e), Ft(t));
}
const lS = Symbol("menuContextKey"), sS = (e) => {
  ot(lS, e);
}, To = () => nt(lS), uS = Symbol("ForceRenderKey"), xR = (e) => {
  ot(uS, e);
}, cS = () => nt(uS, !1), dS = Symbol("menuFirstLevelContextKey"), fS = (e) => {
  ot(dS, e);
}, OR = () => nt(dS, !0), Ul = J({
  compatConfig: {
    MODE: 3
  },
  name: "MenuContextProvider",
  inheritAttrs: !1,
  props: {
    mode: {
      type: String,
      default: void 0
    },
    overflowDisabled: {
      type: Boolean,
      default: void 0
    }
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = To(), r = h({}, o);
    return e.mode !== void 0 && (r.mode = Je(e, "mode")), e.overflowDisabled !== void 0 && (r.overflowDisabled = Je(e, "overflowDisabled")), sS(r), () => {
      var a;
      return (a = n.default) === null || a === void 0 ? void 0 : a.call(n);
    };
  }
}), PR = sS, IR = Symbol("siderCollapsed"), Ui = "$$__vc-menu-more__key", pS = Symbol("KeyPathContext"), Ef = () => nt(pS, {
  parentEventKeys: T(() => []),
  parentKeys: T(() => []),
  parentInfo: {}
}), TR = (e, t, n) => {
  const {
    parentEventKeys: o,
    parentKeys: r
  } = Ef(), a = T(() => [...o.value, e]), i = T(() => [...r.value, t]);
  return ot(pS, {
    parentEventKeys: a,
    parentKeys: i,
    parentInfo: n
  }), i;
}, vS = Symbol("measure"), tg = J({
  compatConfig: {
    MODE: 3
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ot(vS, !0), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
}), Mf = () => nt(vS, !1), ER = TR;
function mS(e) {
  const {
    mode: t,
    rtl: n,
    inlineIndent: o
  } = To();
  return T(() => t.value !== "inline" ? null : n.value ? {
    paddingRight: `${e.value * o.value}px`
  } : {
    paddingLeft: `${e.value * o.value}px`
  });
}
let MR = 0;
const _R = () => ({
  id: String,
  role: String,
  disabled: Boolean,
  danger: Boolean,
  title: {
    type: [String, Boolean],
    default: void 0
  },
  icon: W.any,
  onMouseenter: Function,
  onMouseleave: Function,
  onClick: Function,
  onKeydown: Function,
  onFocus: Function,
  // Internal user prop
  originItemValue: He()
}), go = J({
  compatConfig: {
    MODE: 3
  },
  name: "AMenuItem",
  inheritAttrs: !1,
  props: _R(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: r
    } = t;
    const a = On(), i = Mf(), l = typeof a.vnode.key == "symbol" ? String(a.vnode.key) : a.vnode.key;
    gt(typeof a.vnode.key != "symbol", "MenuItem", `MenuItem \`:key="${String(l)}"\` not support Symbol type`);
    const u = `menu_item_${++MR}_$$_${l}`, {
      parentEventKeys: s,
      parentKeys: c
    } = Ef(), {
      prefixCls: d,
      activeKeys: f,
      disabled: p,
      changeActiveKeys: v,
      rtl: g,
      inlineCollapsed: b,
      siderCollapsed: y,
      onItemClick: S,
      selectedKeys: w,
      registerMenuInfo: C,
      unRegisterMenuInfo: $
    } = To(), O = OR(), x = K(!1), M = T(() => [...c.value, l]);
    C(u, {
      eventKey: u,
      key: l,
      parentEventKeys: s,
      parentKeys: c,
      isLeaf: !0
    }), at(() => {
      $(u);
    }), le(f, () => {
      x.value = !!f.value.find((z) => z === l);
    }, {
      immediate: !0
    });
    const N = T(() => p.value || e.disabled), I = T(() => w.value.includes(l)), E = T(() => {
      const z = `${d.value}-item`;
      return {
        [`${z}`]: !0,
        [`${z}-danger`]: e.danger,
        [`${z}-active`]: x.value,
        [`${z}-selected`]: I.value,
        [`${z}-disabled`]: N.value
      };
    }), B = (z) => ({
      key: l,
      eventKey: u,
      keyPath: M.value,
      eventKeyPath: [...s.value, u],
      domEvent: z,
      item: h(h({}, e), r)
    }), k = (z) => {
      if (N.value)
        return;
      const F = B(z);
      o("click", z), S(F);
    }, P = (z) => {
      N.value || (v(M.value), o("mouseenter", z));
    }, R = (z) => {
      N.value || (v([]), o("mouseleave", z));
    }, D = (z) => {
      if (o("keydown", z), z.which === ee.ENTER) {
        const F = B(z);
        o("click", z), S(F);
      }
    }, A = (z) => {
      v(M.value), o("focus", z);
    }, H = (z, F) => {
      const U = m("span", {
        class: `${d.value}-title-content`
      }, [F]);
      return (!z || on(F) && F.type === "span") && F && b.value && O && typeof F == "string" ? m("div", {
        class: `${d.value}-inline-collapsed-noicon`
      }, [F.charAt(0)]) : U;
    }, j = mS(T(() => M.value.length));
    return () => {
      var z, F, U, Q, q;
      if (i)
        return null;
      const oe = (z = e.title) !== null && z !== void 0 ? z : (F = n.title) === null || F === void 0 ? void 0 : F.call(n), Z = xt((U = n.default) === null || U === void 0 ? void 0 : U.call(n)), ne = Z.length;
      let Y = oe;
      typeof oe > "u" ? Y = O && ne ? Z : "" : oe === !1 && (Y = "");
      const V = {
        title: Y
      };
      !y.value && !b.value && (V.title = null, V.open = !1);
      const X = {};
      e.role === "option" && (X["aria-selected"] = I.value);
      const re = (Q = e.icon) !== null && Q !== void 0 ? Q : (q = n.icon) === null || q === void 0 ? void 0 : q.call(n, e);
      return m(Nr, L(L({}, V), {}, {
        placement: g.value ? "left" : "right",
        overlayClassName: `${d.value}-inline-collapsed-tooltip`
      }), {
        default: () => [m(mo.Item, L(L(L({
          component: "li"
        }, r), {}, {
          id: e.id,
          style: h(h({}, r.style || {}), j.value),
          class: [E.value, {
            [`${r.class}`]: !!r.class,
            [`${d.value}-item-only-child`]: (re ? ne + 1 : ne) === 1
          }],
          role: e.role || "menuitem",
          tabindex: e.disabled ? null : -1,
          "data-menu-id": l,
          "aria-disabled": e.disabled
        }, X), {}, {
          onMouseenter: P,
          onMouseleave: R,
          onClick: k,
          onKeydown: D,
          onFocus: A,
          title: typeof oe == "string" ? oe : void 0
        }), {
          default: () => [Tt(typeof re == "function" ? re(e.originItemValue) : re, {
            class: `${d.value}-item-icon`
          }, !1), H(re, Z)]
        })]
      });
    };
  }
}), zo = {
  adjustX: 1,
  adjustY: 1
}, DR = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: zo,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: zo,
    offset: [0, 7]
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: zo,
    offset: [-4, 0]
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: zo,
    offset: [4, 0]
  }
}, AR = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: zo,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: zo,
    offset: [0, 7]
  },
  rightTop: {
    points: ["tr", "tl"],
    overflow: zo,
    offset: [-4, 0]
  },
  leftTop: {
    points: ["tl", "tr"],
    overflow: zo,
    offset: [4, 0]
  }
}, NR = {
  horizontal: "bottomLeft",
  vertical: "rightTop",
  "vertical-left": "rightTop",
  "vertical-right": "leftTop"
}, ng = J({
  compatConfig: {
    MODE: 3
  },
  name: "PopupTrigger",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    mode: String,
    visible: Boolean,
    // popup: React.ReactNode;
    popupClassName: String,
    popupOffset: Array,
    disabled: Boolean,
    onVisibleChange: Function
  },
  slots: Object,
  emits: ["visibleChange"],
  setup(e, t) {
    let {
      slots: n,
      emit: o
    } = t;
    const r = K(!1), {
      getPopupContainer: a,
      rtl: i,
      subMenuOpenDelay: l,
      subMenuCloseDelay: u,
      builtinPlacements: s,
      triggerSubMenuAction: c,
      forceSubMenuRender: d,
      motion: f,
      defaultMotions: p,
      rootClassName: v
    } = To(), g = cS(), b = T(() => i.value ? h(h({}, AR), s.value) : h(h({}, DR), s.value)), y = T(() => NR[e.mode]), S = K();
    le(() => e.visible, ($) => {
      Ue.cancel(S.value), S.value = Ue(() => {
        r.value = $;
      });
    }, {
      immediate: !0
    }), at(() => {
      Ue.cancel(S.value);
    });
    const w = ($) => {
      o("visibleChange", $);
    }, C = T(() => {
      var $, O;
      const x = f.value || (($ = p.value) === null || $ === void 0 ? void 0 : $[e.mode]) || ((O = p.value) === null || O === void 0 ? void 0 : O.other), M = typeof x == "function" ? x() : x;
      return M ? Ca(M.name, {
        css: !0
      }) : void 0;
    });
    return () => {
      const {
        prefixCls: $,
        popupClassName: O,
        mode: x,
        popupOffset: M,
        disabled: _
      } = e;
      return m(wa, {
        prefixCls: $,
        popupClassName: ae(`${$}-popup`, {
          [`${$}-rtl`]: i.value
        }, O, v.value),
        stretch: x === "horizontal" ? "minWidth" : null,
        getPopupContainer: a.value,
        builtinPlacements: b.value,
        popupPlacement: y.value,
        popupVisible: r.value,
        popupAlign: M && {
          offset: M
        },
        action: _ ? [] : [c.value],
        mouseEnterDelay: l.value,
        mouseLeaveDelay: u.value,
        onPopupVisibleChange: w,
        forceRender: g || d.value,
        popupAnimation: C.value
      }, {
        popup: n.popup,
        default: n.default
      });
    };
  }
}), _f = (e, t) => {
  let {
    slots: n,
    attrs: o
  } = t;
  var r;
  const {
    prefixCls: a,
    mode: i
  } = To();
  return m("ul", L(L({}, o), {}, {
    class: ae(a.value, `${a.value}-sub`, `${a.value}-${i.value === "inline" ? "inline" : "vertical"}`),
    "data-menu-list": !0
  }), [(r = n.default) === null || r === void 0 ? void 0 : r.call(n)]);
};
_f.displayName = "SubMenuList";
const RR = J({
  compatConfig: {
    MODE: 3
  },
  name: "InlineSubMenuList",
  inheritAttrs: !1,
  props: {
    id: String,
    open: Boolean,
    keyPath: Array
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = T(() => "inline"), {
      motion: r,
      mode: a,
      defaultMotions: i
    } = To(), l = T(() => a.value === o.value), u = G(!l.value), s = T(() => l.value ? e.open : !1);
    le(a, () => {
      l.value && (u.value = !1);
    }, {
      flush: "post"
    });
    const c = T(() => {
      var d, f;
      const p = r.value || ((d = i.value) === null || d === void 0 ? void 0 : d[o.value]) || ((f = i.value) === null || f === void 0 ? void 0 : f.other), v = typeof p == "function" ? p() : p;
      return h(h({}, v), {
        appear: e.keyPath.length <= 1
      });
    });
    return () => {
      var d;
      return u.value ? null : m(Ul, {
        mode: o.value
      }, {
        default: () => [m(Yn, c.value, {
          default: () => [An(m(_f, {
            id: e.id
          }, {
            default: () => [(d = n.default) === null || d === void 0 ? void 0 : d.call(n)]
          }), [[wo, s.value]])]
        })]
      });
    };
  }
});
let og = 0;
const FR = () => ({
  icon: W.any,
  title: W.any,
  disabled: Boolean,
  level: Number,
  popupClassName: String,
  popupOffset: Array,
  internalPopupClose: Boolean,
  eventKey: String,
  expandIcon: Function,
  theme: String,
  onMouseenter: Function,
  onMouseleave: Function,
  onTitleClick: Function,
  // Internal user prop
  originItemValue: He()
}), ma = J({
  compatConfig: {
    MODE: 3
  },
  name: "ASubMenu",
  inheritAttrs: !1,
  props: FR(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      emit: r
    } = t;
    var a, i;
    fS(!1);
    const l = Mf(), u = On(), s = typeof u.vnode.key == "symbol" ? String(u.vnode.key) : u.vnode.key;
    gt(typeof u.vnode.key != "symbol", "SubMenu", `SubMenu \`:key="${String(s)}"\` not support Symbol type`);
    const c = ic(s) ? s : `sub_menu_${++og}_$$_not_set_key`, d = (a = e.eventKey) !== null && a !== void 0 ? a : ic(s) ? `sub_menu_${++og}_$$_${s}` : c, {
      parentEventKeys: f,
      parentInfo: p,
      parentKeys: v
    } = Ef(), g = T(() => [...v.value, c]), b = K([]), y = {
      eventKey: d,
      key: c,
      parentEventKeys: f,
      childrenEventKeys: b,
      parentKeys: v
    };
    (i = p.childrenEventKeys) === null || i === void 0 || i.value.push(d), at(() => {
      var pe;
      p.childrenEventKeys && (p.childrenEventKeys.value = (pe = p.childrenEventKeys) === null || pe === void 0 ? void 0 : pe.value.filter((xe) => xe != d));
    }), ER(d, c, y);
    const {
      prefixCls: S,
      activeKeys: w,
      disabled: C,
      changeActiveKeys: $,
      mode: O,
      inlineCollapsed: x,
      openKeys: M,
      overflowDisabled: _,
      onOpenChange: N,
      registerMenuInfo: I,
      unRegisterMenuInfo: E,
      selectedSubMenuKeys: B,
      expandIcon: k,
      theme: P
    } = To(), R = s != null, D = !l && (cS() || !R);
    xR(D), (l && R || !l && !R || D) && (I(d, y), at(() => {
      E(d);
    }));
    const A = T(() => `${S.value}-submenu`), H = T(() => C.value || e.disabled), j = K(), z = K(), F = T(() => M.value.includes(c)), U = T(() => !_.value && F.value), Q = T(() => B.value.includes(c)), q = K(!1);
    le(w, () => {
      q.value = !!w.value.find((pe) => pe === c);
    }, {
      immediate: !0
    });
    const oe = (pe) => {
      H.value || (r("titleClick", pe, c), O.value === "inline" && N(c, !F.value));
    }, Z = (pe) => {
      H.value || ($(g.value), r("mouseenter", pe));
    }, ne = (pe) => {
      H.value || ($([]), r("mouseleave", pe));
    }, Y = mS(T(() => g.value.length)), V = (pe) => {
      O.value !== "inline" && N(c, pe);
    }, X = () => {
      $(g.value);
    }, re = d && `${d}-popup`, ie = T(() => ae(S.value, `${S.value}-${e.theme || P.value}`, e.popupClassName)), he = (pe, xe) => {
      if (!xe)
        return x.value && !v.value.length && pe && typeof pe == "string" ? m("div", {
          class: `${S.value}-inline-collapsed-noicon`
        }, [pe.charAt(0)]) : m("span", {
          class: `${S.value}-title-content`
        }, [pe]);
      const Ne = on(pe) && pe.type === "span";
      return m(We, null, [Tt(typeof xe == "function" ? xe(e.originItemValue) : xe, {
        class: `${S.value}-item-icon`
      }, !1), Ne ? pe : m("span", {
        class: `${S.value}-title-content`
      }, [pe])]);
    }, ge = T(() => O.value !== "inline" && g.value.length > 1 ? "vertical" : O.value), we = T(() => O.value === "horizontal" ? "vertical" : O.value), Le = T(() => ge.value === "horizontal" ? "vertical" : ge.value), be = () => {
      var pe, xe;
      const Ne = A.value, ye = (pe = e.icon) !== null && pe !== void 0 ? pe : (xe = n.icon) === null || xe === void 0 ? void 0 : xe.call(n, e), Ce = e.expandIcon || n.expandIcon || k.value, Te = he(Uo(n, e, "title"), ye);
      return m("div", {
        style: Y.value,
        class: `${Ne}-title`,
        tabindex: H.value ? null : -1,
        ref: j,
        title: typeof Te == "string" ? Te : null,
        "data-menu-id": c,
        "aria-expanded": U.value,
        "aria-haspopup": !0,
        "aria-controls": re,
        "aria-disabled": H.value,
        onClick: oe,
        onFocus: X
      }, [Te, O.value !== "horizontal" && Ce ? Ce(h(h({}, e), {
        isOpen: U.value
      })) : m("i", {
        class: `${Ne}-arrow`
      }, null)]);
    };
    return () => {
      var pe;
      if (l)
        return R ? (pe = n.default) === null || pe === void 0 ? void 0 : pe.call(n) : null;
      const xe = A.value;
      let Ne = () => null;
      if (!_.value && O.value !== "inline") {
        const ye = O.value === "horizontal" ? [0, 8] : [10, 0];
        Ne = () => m(ng, {
          mode: ge.value,
          prefixCls: xe,
          visible: !e.internalPopupClose && U.value,
          popupClassName: ie.value,
          popupOffset: e.popupOffset || ye,
          disabled: H.value,
          onVisibleChange: V
        }, {
          default: () => [be()],
          popup: () => m(Ul, {
            mode: Le.value
          }, {
            default: () => [m(_f, {
              id: re,
              ref: z
            }, {
              default: n.default
            })]
          })
        });
      } else
        Ne = () => m(ng, null, {
          default: be
        });
      return m(Ul, {
        mode: we.value
      }, {
        default: () => [m(mo.Item, L(L({
          component: "li"
        }, o), {}, {
          role: "none",
          class: ae(xe, `${xe}-${O.value}`, o.class, {
            [`${xe}-open`]: U.value,
            [`${xe}-active`]: q.value,
            [`${xe}-selected`]: Q.value,
            [`${xe}-disabled`]: H.value
          }),
          onMouseenter: Z,
          onMouseleave: ne,
          "data-submenu-id": c
        }), {
          default: () => m(We, null, [Ne(), !_.value && m(RR, {
            id: re,
            open: U.value,
            keyPath: g.value
          }, {
            default: n.default
          })])
        })]
      });
    };
  }
});
function gS(e, t) {
  return e.classList ? e.classList.contains(t) : ` ${e.className} `.indexOf(` ${t} `) > -1;
}
function rg(e, t) {
  e.classList ? e.classList.add(t) : gS(e, t) || (e.className = `${e.className} ${t}`);
}
function ag(e, t) {
  if (e.classList)
    e.classList.remove(t);
  else if (gS(e, t)) {
    const n = e.className;
    e.className = ` ${n} `.replace(` ${t} `, " ");
  }
}
const As = function() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "ant-motion-collapse", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return {
    name: e,
    appear: t,
    css: !0,
    onBeforeEnter: (n) => {
      n.style.height = "0px", n.style.opacity = "0", rg(n, e);
    },
    onEnter: (n) => {
      mt(() => {
        n.style.height = `${n.scrollHeight}px`, n.style.opacity = "1";
      });
    },
    onAfterEnter: (n) => {
      n && (ag(n, e), n.style.height = null, n.style.opacity = null);
    },
    onBeforeLeave: (n) => {
      rg(n, e), n.style.height = `${n.offsetHeight}px`, n.style.opacity = null;
    },
    onLeave: (n) => {
      setTimeout(() => {
        n.style.height = "0px", n.style.opacity = "0";
      });
    },
    onAfterLeave: (n) => {
      n && (ag(n, e), n.style && (n.style.height = null, n.style.opacity = null));
    }
  };
}, BR = () => ({
  title: W.any,
  // Internal user prop
  originItemValue: He()
}), Gl = J({
  compatConfig: {
    MODE: 3
  },
  name: "AMenuItemGroup",
  inheritAttrs: !1,
  props: BR(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r
    } = To(), a = T(() => `${r.value}-item-group`), i = Mf();
    return () => {
      var l, u;
      return i ? (l = n.default) === null || l === void 0 ? void 0 : l.call(n) : m("li", L(L({}, o), {}, {
        onClick: (s) => s.stopPropagation(),
        class: a.value
      }), [m("div", {
        title: typeof e.title == "string" ? e.title : void 0,
        class: `${a.value}-title`
      }, [Uo(n, e, "title")]), m("ul", {
        class: `${a.value}-list`
      }, [(u = n.default) === null || u === void 0 ? void 0 : u.call(n)])]);
    };
  }
}), kR = () => ({
  prefixCls: String,
  dashed: Boolean
}), Yl = J({
  compatConfig: {
    MODE: 3
  },
  name: "AMenuDivider",
  props: kR(),
  setup(e) {
    const {
      prefixCls: t
    } = To(), n = T(() => ({
      [`${t.value}-item-divider`]: !0,
      [`${t.value}-item-divider-dashed`]: !!e.dashed
    }));
    return () => m("li", {
      class: n.value
    }, null);
  }
});
var LR = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function Hc(e, t, n) {
  return (e || []).map((o, r) => {
    if (o && typeof o == "object") {
      const a = o, {
        label: i,
        children: l,
        key: u,
        type: s
      } = a, c = LR(a, ["label", "children", "key", "type"]), d = u ?? `tmp-${r}`, f = n ? n.parentKeys.slice() : [], p = [], v = {
        eventKey: d,
        key: d,
        parentEventKeys: G(f),
        parentKeys: G(f),
        childrenEventKeys: G(p),
        isLeaf: !1
      };
      if (l || s === "group") {
        if (s === "group") {
          const b = Hc(l, t, n);
          return m(Gl, L(L({
            key: d
          }, c), {}, {
            title: i,
            originItemValue: o
          }), {
            default: () => [b]
          });
        }
        t.set(d, v), n && n.childrenEventKeys.push(d);
        const g = Hc(l, t, {
          childrenEventKeys: p,
          parentKeys: [].concat(f, d)
        });
        return m(ma, L(L({
          key: d
        }, c), {}, {
          title: i,
          originItemValue: o
        }), {
          default: () => [g]
        });
      }
      return s === "divider" ? m(Yl, L({
        key: d
      }, c), null) : (v.isLeaf = !0, t.set(d, v), m(go, L(L({
        key: d
      }, c), {}, {
        originItemValue: o
      }), {
        default: () => [i]
      }));
    }
    return null;
  }).filter((o) => o);
}
function HR(e) {
  const t = K([]), n = K(!1), o = K(/* @__PURE__ */ new Map());
  return le(() => e.items, () => {
    const r = /* @__PURE__ */ new Map();
    n.value = !1, e.items ? (n.value = !0, t.value = Hc(e.items, r)) : t.value = void 0, o.value = r;
  }, {
    immediate: !0,
    deep: !0
  }), {
    itemsNodes: t,
    store: o,
    hasItmes: n
  };
}
const zR = (e) => {
  const {
    componentCls: t,
    motionDurationSlow: n,
    menuHorizontalHeight: o,
    colorSplit: r,
    lineWidth: a,
    lineType: i,
    menuItemPaddingInline: l
  } = e;
  return {
    [`${t}-horizontal`]: {
      lineHeight: `${o}px`,
      border: 0,
      borderBottom: `${a}px ${i} ${r}`,
      boxShadow: "none",
      "&::after": {
        display: "block",
        clear: "both",
        height: 0,
        content: '"\\20"'
      },
      // ======================= Item =======================
      [`${t}-item, ${t}-submenu`]: {
        position: "relative",
        display: "inline-block",
        verticalAlign: "bottom",
        paddingInline: l
      },
      [`> ${t}-item:hover,
        > ${t}-item-active,
        > ${t}-submenu ${t}-submenu-title:hover`]: {
        backgroundColor: "transparent"
      },
      [`${t}-item, ${t}-submenu-title`]: {
        transition: [`border-color ${n}`, `background ${n}`].join(",")
      },
      // ===================== Sub Menu =====================
      [`${t}-submenu-arrow`]: {
        display: "none"
      }
    }
  };
}, jR = (e) => {
  let {
    componentCls: t,
    menuArrowOffset: n
  } = e;
  return {
    [`${t}-rtl`]: {
      direction: "rtl"
    },
    [`${t}-submenu-rtl`]: {
      transformOrigin: "100% 0"
    },
    // Vertical Arrow
    [`${t}-rtl${t}-vertical,
    ${t}-submenu-rtl ${t}-vertical`]: {
      [`${t}-submenu-arrow`]: {
        "&::before": {
          transform: `rotate(-45deg) translateY(-${n})`
        },
        "&::after": {
          transform: `rotate(45deg) translateY(${n})`
        }
      }
    }
  };
}, ig = (e) => h({}, Sr(e)), lg = (e, t) => {
  const {
    componentCls: n,
    colorItemText: o,
    colorItemTextSelected: r,
    colorGroupTitle: a,
    colorItemBg: i,
    colorSubItemBg: l,
    colorItemBgSelected: u,
    colorActiveBarHeight: s,
    colorActiveBarWidth: c,
    colorActiveBarBorderSize: d,
    motionDurationSlow: f,
    motionEaseInOut: p,
    motionEaseOut: v,
    menuItemPaddingInline: g,
    motionDurationMid: b,
    colorItemTextHover: y,
    lineType: S,
    colorSplit: w,
    // Disabled
    colorItemTextDisabled: C,
    // Danger
    colorDangerItemText: $,
    colorDangerItemTextHover: O,
    colorDangerItemTextSelected: x,
    colorDangerItemBgActive: M,
    colorDangerItemBgSelected: _,
    colorItemBgHover: N,
    menuSubMenuBg: I,
    // Horizontal
    colorItemTextSelectedHorizontal: E,
    colorItemBgSelectedHorizontal: B
  } = e;
  return {
    [`${n}-${t}`]: {
      color: o,
      background: i,
      [`&${n}-root:focus-visible`]: h({}, ig(e)),
      // ======================== Item ========================
      [`${n}-item-group-title`]: {
        color: a
      },
      [`${n}-submenu-selected`]: {
        [`> ${n}-submenu-title`]: {
          color: r
        }
      },
      // Disabled
      [`${n}-item-disabled, ${n}-submenu-disabled`]: {
        color: `${C} !important`
      },
      // Hover
      [`${n}-item:hover, ${n}-submenu-title:hover`]: {
        [`&:not(${n}-item-selected):not(${n}-submenu-selected)`]: {
          color: y
        }
      },
      [`&:not(${n}-horizontal)`]: {
        [`${n}-item:not(${n}-item-selected)`]: {
          "&:hover": {
            backgroundColor: N
          },
          "&:active": {
            backgroundColor: u
          }
        },
        [`${n}-submenu-title`]: {
          "&:hover": {
            backgroundColor: N
          },
          "&:active": {
            backgroundColor: u
          }
        }
      },
      // Danger - only Item has
      [`${n}-item-danger`]: {
        color: $,
        [`&${n}-item:hover`]: {
          [`&:not(${n}-item-selected):not(${n}-submenu-selected)`]: {
            color: O
          }
        },
        [`&${n}-item:active`]: {
          background: M
        }
      },
      [`${n}-item a`]: {
        "&, &:hover": {
          color: "inherit"
        }
      },
      [`${n}-item-selected`]: {
        color: r,
        // Danger
        [`&${n}-item-danger`]: {
          color: x
        },
        "a, a:hover": {
          color: "inherit"
        }
      },
      [`& ${n}-item-selected`]: {
        backgroundColor: u,
        // Danger
        [`&${n}-item-danger`]: {
          backgroundColor: _
        }
      },
      [`${n}-item, ${n}-submenu-title`]: {
        [`&:not(${n}-item-disabled):focus-visible`]: h({}, ig(e))
      },
      [`&${n}-submenu > ${n}`]: {
        backgroundColor: I
      },
      [`&${n}-popup > ${n}`]: {
        backgroundColor: i
      },
      // ====================== Horizontal ======================
      [`&${n}-horizontal`]: h(h({}, t === "dark" ? {
        borderBottom: 0
      } : {}), {
        [`> ${n}-item, > ${n}-submenu`]: {
          top: d,
          marginTop: -d,
          marginBottom: 0,
          borderRadius: 0,
          "&::after": {
            position: "absolute",
            insetInline: g,
            bottom: 0,
            borderBottom: `${s}px solid transparent`,
            transition: `border-color ${f} ${p}`,
            content: '""'
          },
          "&:hover, &-active, &-open": {
            "&::after": {
              borderBottomWidth: s,
              borderBottomColor: E
            }
          },
          "&-selected": {
            color: E,
            backgroundColor: B,
            "&::after": {
              borderBottomWidth: s,
              borderBottomColor: E
            }
          }
        }
      }),
      // ================== Inline & Vertical ===================
      //
      [`&${n}-root`]: {
        [`&${n}-inline, &${n}-vertical`]: {
          borderInlineEnd: `${d}px ${S} ${w}`
        }
      },
      // ======================== Inline ========================
      [`&${n}-inline`]: {
        // Sub
        [`${n}-sub${n}-inline`]: {
          background: l
        },
        // Item
        [`${n}-item, ${n}-submenu-title`]: d && c ? {
          width: `calc(100% + ${d}px)`
        } : {},
        [`${n}-item`]: {
          position: "relative",
          "&::after": {
            position: "absolute",
            insetBlock: 0,
            insetInlineEnd: 0,
            borderInlineEnd: `${c}px solid ${r}`,
            transform: "scaleY(0.0001)",
            opacity: 0,
            transition: [`transform ${b} ${v}`, `opacity ${b} ${v}`].join(","),
            content: '""'
          },
          // Danger
          [`&${n}-item-danger`]: {
            "&::after": {
              borderInlineEndColor: x
            }
          }
        },
        [`${n}-selected, ${n}-item-selected`]: {
          "&::after": {
            transform: "scaleY(1)",
            opacity: 1,
            transition: [`transform ${b} ${p}`, `opacity ${b} ${p}`].join(",")
          }
        }
      }
    }
  };
}, sg = (e) => {
  const {
    componentCls: t,
    menuItemHeight: n,
    itemMarginInline: o,
    padding: r,
    menuArrowSize: a,
    marginXS: i,
    marginXXS: l
  } = e, u = r + a + i;
  return {
    [`${t}-item`]: {
      position: "relative"
    },
    [`${t}-item, ${t}-submenu-title`]: {
      height: n,
      lineHeight: `${n}px`,
      paddingInline: r,
      overflow: "hidden",
      textOverflow: "ellipsis",
      marginInline: o,
      marginBlock: l,
      width: `calc(100% - ${o * 2}px)`
    },
    // disable margin collapsed
    [`${t}-submenu`]: {
      paddingBottom: 0.02
    },
    [`> ${t}-item,
            > ${t}-submenu > ${t}-submenu-title`]: {
      height: n,
      lineHeight: `${n}px`
    },
    [`${t}-item-group-list ${t}-submenu-title,
            ${t}-submenu-title`]: {
      paddingInlineEnd: u
    }
  };
}, VR = (e) => {
  const {
    componentCls: t,
    iconCls: n,
    menuItemHeight: o,
    colorTextLightSolid: r,
    dropdownWidth: a,
    controlHeightLG: i,
    motionDurationMid: l,
    motionEaseOut: u,
    paddingXL: s,
    fontSizeSM: c,
    fontSizeLG: d,
    motionDurationSlow: f,
    paddingXS: p,
    boxShadowSecondary: v
  } = e, g = {
    height: o,
    lineHeight: `${o}px`,
    listStylePosition: "inside",
    listStyleType: "disc"
  };
  return [
    {
      [t]: {
        "&-inline, &-vertical": h({
          [`&${t}-root`]: {
            boxShadow: "none"
          }
        }, sg(e))
      },
      [`${t}-submenu-popup`]: {
        [`${t}-vertical`]: h(h({}, sg(e)), {
          boxShadow: v
        })
      }
    },
    // Vertical only
    {
      [`${t}-submenu-popup ${t}-vertical${t}-sub`]: {
        minWidth: a,
        maxHeight: `calc(100vh - ${i * 2.5}px)`,
        padding: "0",
        overflow: "hidden",
        borderInlineEnd: 0,
        // https://github.com/ant-design/ant-design/issues/22244
        // https://github.com/ant-design/ant-design/issues/26812
        "&:not([class*='-active'])": {
          overflowX: "hidden",
          overflowY: "auto"
        }
      }
    },
    // Inline Only
    {
      [`${t}-inline`]: {
        width: "100%",
        // Motion enhance for first level
        [`&${t}-root`]: {
          [`${t}-item, ${t}-submenu-title`]: {
            display: "flex",
            alignItems: "center",
            transition: [`border-color ${f}`, `background ${f}`, `padding ${l} ${u}`].join(","),
            [`> ${t}-title-content`]: {
              flex: "auto",
              minWidth: 0,
              overflow: "hidden",
              textOverflow: "ellipsis"
            },
            "> *": {
              flex: "none"
            }
          }
        },
        // >>>>> Sub
        [`${t}-sub${t}-inline`]: {
          padding: 0,
          border: 0,
          borderRadius: 0,
          boxShadow: "none",
          [`& > ${t}-submenu > ${t}-submenu-title`]: g,
          [`& ${t}-item-group-title`]: {
            paddingInlineStart: s
          }
        },
        // >>>>> Item
        [`${t}-item`]: g
      }
    },
    // Inline Collapse Only
    {
      [`${t}-inline-collapsed`]: {
        width: o * 2,
        [`&${t}-root`]: {
          [`${t}-item, ${t}-submenu ${t}-submenu-title`]: {
            [`> ${t}-inline-collapsed-noicon`]: {
              fontSize: d,
              textAlign: "center"
            }
          }
        },
        [`> ${t}-item,
          > ${t}-item-group > ${t}-item-group-list > ${t}-item,
          > ${t}-item-group > ${t}-item-group-list > ${t}-submenu > ${t}-submenu-title,
          > ${t}-submenu > ${t}-submenu-title`]: {
          insetInlineStart: 0,
          paddingInline: `calc(50% - ${c}px)`,
          textOverflow: "clip",
          [`
            ${t}-submenu-arrow,
            ${t}-submenu-expand-icon
          `]: {
            opacity: 0
          },
          [`${t}-item-icon, ${n}`]: {
            margin: 0,
            fontSize: d,
            lineHeight: `${o}px`,
            "+ span": {
              display: "inline-block",
              opacity: 0
            }
          }
        },
        [`${t}-item-icon, ${n}`]: {
          display: "inline-block"
        },
        "&-tooltip": {
          pointerEvents: "none",
          [`${t}-item-icon, ${n}`]: {
            display: "none"
          },
          "a, a:hover": {
            color: r
          }
        },
        [`${t}-item-group-title`]: h(h({}, So), {
          paddingInline: p
        })
      }
    }
  ];
}, ug = (e) => {
  const {
    componentCls: t,
    fontSize: n,
    motionDurationSlow: o,
    motionDurationMid: r,
    motionEaseInOut: a,
    motionEaseOut: i,
    iconCls: l,
    controlHeightSM: u
  } = e;
  return {
    // >>>>> Item
    [`${t}-item, ${t}-submenu-title`]: {
      position: "relative",
      display: "block",
      margin: 0,
      whiteSpace: "nowrap",
      cursor: "pointer",
      transition: [`border-color ${o}`, `background ${o}`, `padding ${o} ${a}`].join(","),
      [`${t}-item-icon, ${l}`]: {
        minWidth: n,
        fontSize: n,
        transition: [`font-size ${r} ${i}`, `margin ${o} ${a}`, `color ${o}`].join(","),
        "+ span": {
          marginInlineStart: u - n,
          opacity: 1,
          transition: [`opacity ${o} ${a}`, `margin ${o}`, `color ${o}`].join(",")
        }
      },
      [`${t}-item-icon`]: h({}, Si()),
      [`&${t}-item-only-child`]: {
        [`> ${l}, > ${t}-item-icon`]: {
          marginInlineEnd: 0
        }
      }
    },
    // Disabled state sets text to gray and nukes hover/tab effects
    [`${t}-item-disabled, ${t}-submenu-disabled`]: {
      background: "none !important",
      cursor: "not-allowed",
      "&::after": {
        borderColor: "transparent !important"
      },
      a: {
        color: "inherit !important"
      },
      [`> ${t}-submenu-title`]: {
        color: "inherit !important",
        cursor: "not-allowed"
      }
    }
  };
}, cg = (e) => {
  const {
    componentCls: t,
    motionDurationSlow: n,
    motionEaseInOut: o,
    borderRadius: r,
    menuArrowSize: a,
    menuArrowOffset: i
  } = e;
  return {
    [`${t}-submenu`]: {
      "&-expand-icon, &-arrow": {
        position: "absolute",
        top: "50%",
        insetInlineEnd: e.margin,
        width: a,
        color: "currentcolor",
        transform: "translateY(-50%)",
        transition: `transform ${n} ${o}, opacity ${n}`
      },
      "&-arrow": {
        // →
        "&::before, &::after": {
          position: "absolute",
          width: a * 0.6,
          height: a * 0.15,
          backgroundColor: "currentcolor",
          borderRadius: r,
          transition: [`background ${n} ${o}`, `transform ${n} ${o}`, `top ${n} ${o}`, `color ${n} ${o}`].join(","),
          content: '""'
        },
        "&::before": {
          transform: `rotate(45deg) translateY(-${i})`
        },
        "&::after": {
          transform: `rotate(-45deg) translateY(${i})`
        }
      }
    }
  };
}, WR = (e) => {
  const {
    antCls: t,
    componentCls: n,
    fontSize: o,
    motionDurationSlow: r,
    motionDurationMid: a,
    motionEaseInOut: i,
    lineHeight: l,
    paddingXS: u,
    padding: s,
    colorSplit: c,
    lineWidth: d,
    zIndexPopup: f,
    borderRadiusLG: p,
    radiusSubMenuItem: v,
    menuArrowSize: g,
    menuArrowOffset: b,
    lineType: y,
    menuPanelMaskInset: S
  } = e;
  return [
    // Misc
    {
      "": {
        [`${n}`]: h(h({}, ca()), {
          // Hidden
          "&-hidden": {
            display: "none"
          }
        })
      },
      [`${n}-submenu-hidden`]: {
        display: "none"
      }
    },
    {
      [n]: h(h(h(h(h(h(h({}, st(e)), ca()), {
        marginBottom: 0,
        paddingInlineStart: 0,
        // Override default ul/ol
        fontSize: o,
        lineHeight: 0,
        listStyle: "none",
        outline: "none",
        transition: `width ${r} cubic-bezier(0.2, 0, 0, 1) 0s`,
        "ul, ol": {
          margin: 0,
          padding: 0,
          listStyle: "none"
        },
        // Overflow ellipsis
        "&-overflow": {
          display: "flex",
          [`${n}-item`]: {
            flex: "none"
          }
        },
        [`${n}-item, ${n}-submenu, ${n}-submenu-title`]: {
          borderRadius: e.radiusItem
        },
        [`${n}-item-group-title`]: {
          padding: `${u}px ${s}px`,
          fontSize: o,
          lineHeight: l,
          transition: `all ${r}`
        },
        [`&-horizontal ${n}-submenu`]: {
          transition: [`border-color ${r} ${i}`, `background ${r} ${i}`].join(",")
        },
        [`${n}-submenu, ${n}-submenu-inline`]: {
          transition: [`border-color ${r} ${i}`, `background ${r} ${i}`, `padding ${a} ${i}`].join(",")
        },
        [`${n}-submenu ${n}-sub`]: {
          cursor: "initial",
          transition: [`background ${r} ${i}`, `padding ${r} ${i}`].join(",")
        },
        [`${n}-title-content`]: {
          transition: `color ${r}`
        },
        [`${n}-item a`]: {
          "&::before": {
            position: "absolute",
            inset: 0,
            backgroundColor: "transparent",
            content: '""'
          }
        },
        // Removed a Badge related style seems it's safe
        // https://github.com/ant-design/ant-design/issues/19809
        // >>>>> Divider
        [`${n}-item-divider`]: {
          overflow: "hidden",
          lineHeight: 0,
          borderColor: c,
          borderStyle: y,
          borderWidth: 0,
          borderTopWidth: d,
          marginBlock: d,
          padding: 0,
          "&-dashed": {
            borderStyle: "dashed"
          }
        }
      }), ug(e)), {
        [`${n}-item-group`]: {
          [`${n}-item-group-list`]: {
            margin: 0,
            padding: 0,
            [`${n}-item, ${n}-submenu-title`]: {
              paddingInline: `${o * 2}px ${s}px`
            }
          }
        },
        // ======================= Sub Menu =======================
        "&-submenu": {
          "&-popup": {
            position: "absolute",
            zIndex: f,
            background: "transparent",
            borderRadius: p,
            boxShadow: "none",
            transformOrigin: "0 0",
            // https://github.com/ant-design/ant-design/issues/13955
            "&::before": {
              position: "absolute",
              inset: `${S}px 0 0`,
              zIndex: -1,
              width: "100%",
              height: "100%",
              opacity: 0,
              content: '""'
            }
          },
          // https://github.com/ant-design/ant-design/issues/13955
          "&-placement-rightTop::before": {
            top: 0,
            insetInlineStart: S
          },
          [`> ${n}`]: h(h(h({
            borderRadius: p
          }, ug(e)), cg(e)), {
            [`${n}-item, ${n}-submenu > ${n}-submenu-title`]: {
              borderRadius: v
            },
            [`${n}-submenu-title::after`]: {
              transition: `transform ${r} ${i}`
            }
          })
        }
      }), cg(e)), {
        [`&-inline-collapsed ${n}-submenu-arrow,
        &-inline ${n}-submenu-arrow`]: {
          // ↓
          "&::before": {
            transform: `rotate(-45deg) translateX(${b})`
          },
          "&::after": {
            transform: `rotate(45deg) translateX(-${b})`
          }
        },
        [`${n}-submenu-open${n}-submenu-inline > ${n}-submenu-title > ${n}-submenu-arrow`]: {
          // ↑
          transform: `translateY(-${g * 0.2}px)`,
          "&::after": {
            transform: `rotate(-45deg) translateX(-${b})`
          },
          "&::before": {
            transform: `rotate(45deg) translateX(${b})`
          }
        }
      })
    },
    // Integration with header element so menu items have the same height
    {
      [`${t}-layout-header`]: {
        [n]: {
          lineHeight: "inherit"
        }
      }
    }
  ];
}, KR = (e, t) => ht("Menu", (o, r) => {
  let {
    overrideComponentToken: a
  } = r;
  if ((t == null ? void 0 : t.value) === !1)
    return [];
  const {
    colorBgElevated: i,
    colorPrimary: l,
    colorError: u,
    colorErrorHover: s,
    colorTextLightSolid: c
  } = o, {
    controlHeightLG: d,
    fontSize: f
  } = o, p = f / 7 * 5, v = qe(o, {
    menuItemHeight: d,
    menuItemPaddingInline: o.margin,
    menuArrowSize: p,
    menuHorizontalHeight: d * 1.15,
    menuArrowOffset: `${p * 0.25}px`,
    menuPanelMaskInset: -7,
    menuSubMenuBg: i
  }), g = new Ct(c).setAlpha(0.65).toRgbString(), b = qe(v, {
    colorItemText: g,
    colorItemTextHover: c,
    colorGroupTitle: g,
    colorItemTextSelected: c,
    colorItemBg: "#001529",
    colorSubItemBg: "#000c17",
    colorItemBgActive: "transparent",
    colorItemBgSelected: l,
    colorActiveBarWidth: 0,
    colorActiveBarHeight: 0,
    colorActiveBarBorderSize: 0,
    // Disabled
    colorItemTextDisabled: new Ct(c).setAlpha(0.25).toRgbString(),
    // Danger
    colorDangerItemText: u,
    colorDangerItemTextHover: s,
    colorDangerItemTextSelected: c,
    colorDangerItemBgActive: u,
    colorDangerItemBgSelected: u,
    menuSubMenuBg: "#001529",
    // Horizontal
    colorItemTextSelectedHorizontal: c,
    colorItemBgSelectedHorizontal: l
  }, h({}, a));
  return [
    // Basic
    WR(v),
    // Horizontal
    zR(v),
    // Vertical
    VR(v),
    // Theme
    lg(v, "light"),
    lg(b, "dark"),
    // RTL
    jR(v),
    // Motion
    $f(v),
    Go(v, "slide-up"),
    Go(v, "slide-down"),
    _s(v, "zoom-big")
  ];
}, (o) => {
  const {
    colorPrimary: r,
    colorError: a,
    colorTextDisabled: i,
    colorErrorBg: l,
    colorText: u,
    colorTextDescription: s,
    colorBgContainer: c,
    colorFillAlter: d,
    colorFillContent: f,
    lineWidth: p,
    lineWidthBold: v,
    controlItemBgActive: g,
    colorBgTextHover: b
  } = o;
  return {
    dropdownWidth: 160,
    zIndexPopup: o.zIndexPopupBase + 50,
    radiusItem: o.borderRadiusLG,
    radiusSubMenuItem: o.borderRadiusSM,
    colorItemText: u,
    colorItemTextHover: u,
    colorItemTextHoverHorizontal: r,
    colorGroupTitle: s,
    colorItemTextSelected: r,
    colorItemTextSelectedHorizontal: r,
    colorItemBg: c,
    colorItemBgHover: b,
    colorItemBgActive: f,
    colorSubItemBg: d,
    colorItemBgSelected: g,
    colorItemBgSelectedHorizontal: "transparent",
    colorActiveBarWidth: 0,
    colorActiveBarHeight: v,
    colorActiveBarBorderSize: p,
    // Disabled
    colorItemTextDisabled: i,
    // Danger
    colorDangerItemText: a,
    colorDangerItemTextHover: a,
    colorDangerItemTextSelected: a,
    colorDangerItemBgActive: l,
    colorDangerItemBgSelected: l,
    itemMarginInline: o.marginXXS
  };
})(e), UR = () => ({
  id: String,
  prefixCls: String,
  // donot use items, now only support inner use
  items: Array,
  disabled: Boolean,
  inlineCollapsed: Boolean,
  disabledOverflow: Boolean,
  forceSubMenuRender: Boolean,
  openKeys: Array,
  selectedKeys: Array,
  activeKey: String,
  selectable: {
    type: Boolean,
    default: !0
  },
  multiple: {
    type: Boolean,
    default: !1
  },
  tabindex: {
    type: [Number, String]
  },
  motion: Object,
  role: String,
  theme: {
    type: String,
    default: "light"
  },
  mode: {
    type: String,
    default: "vertical"
  },
  inlineIndent: {
    type: Number,
    default: 24
  },
  subMenuOpenDelay: {
    type: Number,
    default: 0
  },
  subMenuCloseDelay: {
    type: Number,
    default: 0.1
  },
  builtinPlacements: {
    type: Object
  },
  triggerSubMenuAction: {
    type: String,
    default: "hover"
  },
  getPopupContainer: Function,
  expandIcon: Function,
  onOpenChange: Function,
  onSelect: Function,
  onDeselect: Function,
  onClick: [Function, Array],
  onFocus: Function,
  onBlur: Function,
  onMousedown: Function,
  "onUpdate:openKeys": Function,
  "onUpdate:selectedKeys": Function,
  "onUpdate:activeKey": Function
}), dg = [], ho = J({
  compatConfig: {
    MODE: 3
  },
  name: "AMenu",
  inheritAttrs: !1,
  props: UR(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: r
    } = t;
    const {
      direction: a,
      getPrefixCls: i
    } = Ke("menu", e), l = aS(), u = T(() => {
      var Z;
      return i("menu", e.prefixCls || ((Z = l == null ? void 0 : l.prefixCls) === null || Z === void 0 ? void 0 : Z.value));
    }), [s, c] = KR(u, T(() => !l)), d = K(/* @__PURE__ */ new Map()), f = nt(IR, G(void 0)), p = T(() => f.value !== void 0 ? f.value : e.inlineCollapsed), {
      itemsNodes: v
    } = HR(e), g = K(!1);
    ze(() => {
      g.value = !0;
    }), Ve(() => {
      gt(!(e.inlineCollapsed === !0 && e.mode !== "inline"), "Menu", "`inlineCollapsed` should only be used when `mode` is inline."), gt(!(f.value !== void 0 && e.inlineCollapsed === !0), "Menu", "`inlineCollapsed` not control Menu under Sider. Should set `collapsed` on Sider instead.");
    });
    const b = G([]), y = G([]), S = G({});
    le(d, () => {
      const Z = {};
      for (const ne of d.value.values())
        Z[ne.key] = ne;
      S.value = Z;
    }, {
      flush: "post"
    }), Ve(() => {
      if (e.activeKey !== void 0) {
        let Z = [];
        const ne = e.activeKey ? S.value[e.activeKey] : void 0;
        ne && e.activeKey !== void 0 ? Z = $u([].concat(Ye(ne.parentKeys), e.activeKey)) : Z = [], Kr(b.value, Z) || (b.value = Z);
      }
    }), le(() => e.selectedKeys, (Z) => {
      Z && (y.value = Z.slice());
    }, {
      immediate: !0,
      deep: !0
    });
    const w = G([]);
    le([S, y], () => {
      let Z = [];
      y.value.forEach((ne) => {
        const Y = S.value[ne];
        Y && (Z = Z.concat(Ye(Y.parentKeys)));
      }), Z = $u(Z), Kr(w.value, Z) || (w.value = Z);
    }, {
      immediate: !0
    });
    const C = (Z) => {
      if (e.selectable) {
        const {
          key: ne
        } = Z, Y = y.value.includes(ne);
        let V;
        e.multiple ? Y ? V = y.value.filter((re) => re !== ne) : V = [...y.value, ne] : V = [ne];
        const X = h(h({}, Z), {
          selectedKeys: V
        });
        Kr(V, y.value) || (e.selectedKeys === void 0 && (y.value = V), o("update:selectedKeys", V), Y && e.multiple ? o("deselect", X) : o("select", X));
      }
      N.value !== "inline" && !e.multiple && $.value.length && B(dg);
    }, $ = G([]);
    le(() => e.openKeys, function() {
      let Z = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : $.value;
      Kr($.value, Z) || ($.value = Z.slice());
    }, {
      immediate: !0,
      deep: !0
    });
    let O;
    const x = (Z) => {
      clearTimeout(O), O = setTimeout(() => {
        e.activeKey === void 0 && (b.value = Z), o("update:activeKey", Z[Z.length - 1]);
      });
    }, M = T(() => !!e.disabled), _ = T(() => a.value === "rtl"), N = G("vertical"), I = K(!1);
    Ve(() => {
      var Z;
      (e.mode === "inline" || e.mode === "vertical") && p.value ? (N.value = "vertical", I.value = p.value) : (N.value = e.mode, I.value = !1), !((Z = l == null ? void 0 : l.mode) === null || Z === void 0) && Z.value && (N.value = l.mode.value);
    });
    const E = T(() => N.value === "inline"), B = (Z) => {
      $.value = Z, o("update:openKeys", Z), o("openChange", Z);
    }, k = G($.value), P = K(!1);
    le($, () => {
      E.value && (k.value = $.value);
    }, {
      immediate: !0
    }), le(E, () => {
      if (!P.value) {
        P.value = !0;
        return;
      }
      E.value ? $.value = k.value : B(dg);
    }, {
      immediate: !0
    });
    const R = T(() => ({
      [`${u.value}`]: !0,
      [`${u.value}-root`]: !0,
      [`${u.value}-${N.value}`]: !0,
      [`${u.value}-inline-collapsed`]: I.value,
      [`${u.value}-rtl`]: _.value,
      [`${u.value}-${e.theme}`]: !0
    })), D = T(() => i()), A = T(() => ({
      horizontal: {
        name: `${D.value}-slide-up`
      },
      inline: As(`${D.value}-motion-collapse`),
      other: {
        name: `${D.value}-zoom-big`
      }
    }));
    fS(!0);
    const H = function() {
      let Z = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      const ne = [], Y = d.value;
      return Z.forEach((V) => {
        const {
          key: X,
          childrenEventKeys: re
        } = Y.get(V);
        ne.push(X, ...H(Ye(re)));
      }), ne;
    }, j = (Z) => {
      var ne;
      o("click", Z), C(Z), (ne = l == null ? void 0 : l.onClick) === null || ne === void 0 || ne.call(l);
    }, z = (Z, ne) => {
      var Y;
      const V = ((Y = S.value[Z]) === null || Y === void 0 ? void 0 : Y.childrenEventKeys) || [];
      let X = $.value.filter((re) => re !== Z);
      if (ne)
        X.push(Z);
      else if (N.value !== "inline") {
        const re = H(Ye(V));
        X = $u(X.filter((ie) => !re.includes(ie)));
      }
      Kr($, X) || B(X);
    }, F = (Z, ne) => {
      d.value.set(Z, ne), d.value = new Map(d.value);
    }, U = (Z) => {
      d.value.delete(Z), d.value = new Map(d.value);
    }, Q = G(0), q = T(() => {
      var Z;
      return e.expandIcon || n.expandIcon || !((Z = l == null ? void 0 : l.expandIcon) === null || Z === void 0) && Z.value ? (ne) => {
        let Y = e.expandIcon || n.expandIcon;
        return Y = typeof Y == "function" ? Y(ne) : Y, Tt(Y, {
          class: `${u.value}-submenu-expand-icon`
        }, !1);
      } : null;
    });
    PR({
      prefixCls: u,
      activeKeys: b,
      openKeys: $,
      selectedKeys: y,
      changeActiveKeys: x,
      disabled: M,
      rtl: _,
      mode: N,
      inlineIndent: T(() => e.inlineIndent),
      subMenuCloseDelay: T(() => e.subMenuCloseDelay),
      subMenuOpenDelay: T(() => e.subMenuOpenDelay),
      builtinPlacements: T(() => e.builtinPlacements),
      triggerSubMenuAction: T(() => e.triggerSubMenuAction),
      getPopupContainer: T(() => e.getPopupContainer),
      inlineCollapsed: I,
      theme: T(() => e.theme),
      siderCollapsed: f,
      defaultMotions: T(() => g.value ? A.value : null),
      motion: T(() => g.value ? e.motion : null),
      overflowDisabled: K(void 0),
      onOpenChange: z,
      onItemClick: j,
      registerMenuInfo: F,
      unRegisterMenuInfo: U,
      selectedSubMenuKeys: w,
      expandIcon: q,
      forceSubMenuRender: T(() => e.forceSubMenuRender),
      rootClassName: c
    });
    const oe = () => {
      var Z;
      return v.value || xt((Z = n.default) === null || Z === void 0 ? void 0 : Z.call(n));
    };
    return () => {
      var Z;
      const ne = oe(), Y = Q.value >= ne.length - 1 || N.value !== "horizontal" || e.disabledOverflow, V = (re) => N.value !== "horizontal" || e.disabledOverflow ? re : (
        // Need wrap for overflow dropdown that do not response for open
        re.map((ie, he) => (
          // Always wrap provider to avoid sub node re-mount
          m(Ul, {
            key: ie.key,
            overflowDisabled: he > Q.value
          }, {
            default: () => ie
          })
        ))
      ), X = ((Z = n.overflowedIndicator) === null || Z === void 0 ? void 0 : Z.call(n)) || m(Ds, null, null);
      return s(m(mo, L(L({}, r), {}, {
        onMousedown: e.onMousedown,
        prefixCls: `${u.value}-overflow`,
        component: "ul",
        itemComponent: go,
        class: [R.value, r.class, c.value],
        role: "menu",
        id: e.id,
        data: V(ne),
        renderRawItem: (re) => re,
        renderRawRest: (re) => {
          const ie = re.length, he = ie ? ne.slice(-ie) : null;
          return m(We, null, [m(ma, {
            eventKey: Ui,
            key: Ui,
            title: X,
            disabled: Y,
            internalPopupClose: ie === 0
          }, {
            default: () => he
          }), m(tg, null, {
            default: () => [m(ma, {
              eventKey: Ui,
              key: Ui,
              title: X,
              disabled: Y,
              internalPopupClose: ie === 0
            }, {
              default: () => he
            })]
          })]);
        },
        maxCount: N.value !== "horizontal" || e.disabledOverflow ? mo.INVALIDATE : mo.RESPONSIVE,
        ssr: "full",
        "data-menu-list": !0,
        onVisibleChange: (re) => {
          Q.value = re;
        }
      }), {
        default: () => [m(hd, {
          to: "body"
        }, {
          default: () => [m("div", {
            style: {
              display: "none"
            },
            "aria-hidden": !0
          }, [m(tg, null, {
            default: () => [V(oe())]
          })])]
        })]
      }));
    };
  }
});
ho.install = function(e) {
  return e.component(ho.name, ho), e.component(go.name, go), e.component(ma.name, ma), e.component(Yl.name, Yl), e.component(Gl.name, Gl), e;
};
ho.Item = go;
ho.Divider = Yl;
ho.SubMenu = ma;
ho.ItemGroup = Gl;
var Zo = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Jo(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var hS = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Zo, function() {
    var n = 1e3, o = 6e4, r = 36e5, a = "millisecond", i = "second", l = "minute", u = "hour", s = "day", c = "week", d = "month", f = "quarter", p = "year", v = "date", g = "Invalid Date", b = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, S = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(k) {
      var P = ["th", "st", "nd", "rd"], R = k % 100;
      return "[" + k + (P[(R - 20) % 10] || P[R] || P[0]) + "]";
    } }, w = function(k, P, R) {
      var D = String(k);
      return !D || D.length >= P ? k : "" + Array(P + 1 - D.length).join(R) + k;
    }, C = { s: w, z: function(k) {
      var P = -k.utcOffset(), R = Math.abs(P), D = Math.floor(R / 60), A = R % 60;
      return (P <= 0 ? "+" : "-") + w(D, 2, "0") + ":" + w(A, 2, "0");
    }, m: function k(P, R) {
      if (P.date() < R.date())
        return -k(R, P);
      var D = 12 * (R.year() - P.year()) + (R.month() - P.month()), A = P.clone().add(D, d), H = R - A < 0, j = P.clone().add(D + (H ? -1 : 1), d);
      return +(-(D + (R - A) / (H ? A - j : j - A)) || 0);
    }, a: function(k) {
      return k < 0 ? Math.ceil(k) || 0 : Math.floor(k);
    }, p: function(k) {
      return { M: d, y: p, w: c, d: s, D: v, h: u, m: l, s: i, ms: a, Q: f }[k] || String(k || "").toLowerCase().replace(/s$/, "");
    }, u: function(k) {
      return k === void 0;
    } }, $ = "en", O = {};
    O[$] = S;
    var x = "$isDayjsObject", M = function(k) {
      return k instanceof E || !(!k || !k[x]);
    }, _ = function k(P, R, D) {
      var A;
      if (!P)
        return $;
      if (typeof P == "string") {
        var H = P.toLowerCase();
        O[H] && (A = H), R && (O[H] = R, A = H);
        var j = P.split("-");
        if (!A && j.length > 1)
          return k(j[0]);
      } else {
        var z = P.name;
        O[z] = P, A = z;
      }
      return !D && A && ($ = A), A || !D && $;
    }, N = function(k, P) {
      if (M(k))
        return k.clone();
      var R = typeof P == "object" ? P : {};
      return R.date = k, R.args = arguments, new E(R);
    }, I = C;
    I.l = _, I.i = M, I.w = function(k, P) {
      return N(k, { locale: P.$L, utc: P.$u, x: P.$x, $offset: P.$offset });
    };
    var E = function() {
      function k(R) {
        this.$L = _(R.locale, null, !0), this.parse(R), this.$x = this.$x || R.x || {}, this[x] = !0;
      }
      var P = k.prototype;
      return P.parse = function(R) {
        this.$d = function(D) {
          var A = D.date, H = D.utc;
          if (A === null)
            return /* @__PURE__ */ new Date(NaN);
          if (I.u(A))
            return /* @__PURE__ */ new Date();
          if (A instanceof Date)
            return new Date(A);
          if (typeof A == "string" && !/Z$/i.test(A)) {
            var j = A.match(b);
            if (j) {
              var z = j[2] - 1 || 0, F = (j[7] || "0").substring(0, 3);
              return H ? new Date(Date.UTC(j[1], z, j[3] || 1, j[4] || 0, j[5] || 0, j[6] || 0, F)) : new Date(j[1], z, j[3] || 1, j[4] || 0, j[5] || 0, j[6] || 0, F);
            }
          }
          return new Date(A);
        }(R), this.init();
      }, P.init = function() {
        var R = this.$d;
        this.$y = R.getFullYear(), this.$M = R.getMonth(), this.$D = R.getDate(), this.$W = R.getDay(), this.$H = R.getHours(), this.$m = R.getMinutes(), this.$s = R.getSeconds(), this.$ms = R.getMilliseconds();
      }, P.$utils = function() {
        return I;
      }, P.isValid = function() {
        return this.$d.toString() !== g;
      }, P.isSame = function(R, D) {
        var A = N(R);
        return this.startOf(D) <= A && A <= this.endOf(D);
      }, P.isAfter = function(R, D) {
        return N(R) < this.startOf(D);
      }, P.isBefore = function(R, D) {
        return this.endOf(D) < N(R);
      }, P.$g = function(R, D, A) {
        return I.u(R) ? this[D] : this.set(A, R);
      }, P.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, P.valueOf = function() {
        return this.$d.getTime();
      }, P.startOf = function(R, D) {
        var A = this, H = !!I.u(D) || D, j = I.p(R), z = function(Y, V) {
          var X = I.w(A.$u ? Date.UTC(A.$y, V, Y) : new Date(A.$y, V, Y), A);
          return H ? X : X.endOf(s);
        }, F = function(Y, V) {
          return I.w(A.toDate()[Y].apply(A.toDate("s"), (H ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(V)), A);
        }, U = this.$W, Q = this.$M, q = this.$D, oe = "set" + (this.$u ? "UTC" : "");
        switch (j) {
          case p:
            return H ? z(1, 0) : z(31, 11);
          case d:
            return H ? z(1, Q) : z(0, Q + 1);
          case c:
            var Z = this.$locale().weekStart || 0, ne = (U < Z ? U + 7 : U) - Z;
            return z(H ? q - ne : q + (6 - ne), Q);
          case s:
          case v:
            return F(oe + "Hours", 0);
          case u:
            return F(oe + "Minutes", 1);
          case l:
            return F(oe + "Seconds", 2);
          case i:
            return F(oe + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, P.endOf = function(R) {
        return this.startOf(R, !1);
      }, P.$set = function(R, D) {
        var A, H = I.p(R), j = "set" + (this.$u ? "UTC" : ""), z = (A = {}, A[s] = j + "Date", A[v] = j + "Date", A[d] = j + "Month", A[p] = j + "FullYear", A[u] = j + "Hours", A[l] = j + "Minutes", A[i] = j + "Seconds", A[a] = j + "Milliseconds", A)[H], F = H === s ? this.$D + (D - this.$W) : D;
        if (H === d || H === p) {
          var U = this.clone().set(v, 1);
          U.$d[z](F), U.init(), this.$d = U.set(v, Math.min(this.$D, U.daysInMonth())).$d;
        } else
          z && this.$d[z](F);
        return this.init(), this;
      }, P.set = function(R, D) {
        return this.clone().$set(R, D);
      }, P.get = function(R) {
        return this[I.p(R)]();
      }, P.add = function(R, D) {
        var A, H = this;
        R = Number(R);
        var j = I.p(D), z = function(Q) {
          var q = N(H);
          return I.w(q.date(q.date() + Math.round(Q * R)), H);
        };
        if (j === d)
          return this.set(d, this.$M + R);
        if (j === p)
          return this.set(p, this.$y + R);
        if (j === s)
          return z(1);
        if (j === c)
          return z(7);
        var F = (A = {}, A[l] = o, A[u] = r, A[i] = n, A)[j] || 1, U = this.$d.getTime() + R * F;
        return I.w(U, this);
      }, P.subtract = function(R, D) {
        return this.add(-1 * R, D);
      }, P.format = function(R) {
        var D = this, A = this.$locale();
        if (!this.isValid())
          return A.invalidDate || g;
        var H = R || "YYYY-MM-DDTHH:mm:ssZ", j = I.z(this), z = this.$H, F = this.$m, U = this.$M, Q = A.weekdays, q = A.months, oe = A.meridiem, Z = function(V, X, re, ie) {
          return V && (V[X] || V(D, H)) || re[X].slice(0, ie);
        }, ne = function(V) {
          return I.s(z % 12 || 12, V, "0");
        }, Y = oe || function(V, X, re) {
          var ie = V < 12 ? "AM" : "PM";
          return re ? ie.toLowerCase() : ie;
        };
        return H.replace(y, function(V, X) {
          return X || function(re) {
            switch (re) {
              case "YY":
                return String(D.$y).slice(-2);
              case "YYYY":
                return I.s(D.$y, 4, "0");
              case "M":
                return U + 1;
              case "MM":
                return I.s(U + 1, 2, "0");
              case "MMM":
                return Z(A.monthsShort, U, q, 3);
              case "MMMM":
                return Z(q, U);
              case "D":
                return D.$D;
              case "DD":
                return I.s(D.$D, 2, "0");
              case "d":
                return String(D.$W);
              case "dd":
                return Z(A.weekdaysMin, D.$W, Q, 2);
              case "ddd":
                return Z(A.weekdaysShort, D.$W, Q, 3);
              case "dddd":
                return Q[D.$W];
              case "H":
                return String(z);
              case "HH":
                return I.s(z, 2, "0");
              case "h":
                return ne(1);
              case "hh":
                return ne(2);
              case "a":
                return Y(z, F, !0);
              case "A":
                return Y(z, F, !1);
              case "m":
                return String(F);
              case "mm":
                return I.s(F, 2, "0");
              case "s":
                return String(D.$s);
              case "ss":
                return I.s(D.$s, 2, "0");
              case "SSS":
                return I.s(D.$ms, 3, "0");
              case "Z":
                return j;
            }
            return null;
          }(V) || j.replace(":", "");
        });
      }, P.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, P.diff = function(R, D, A) {
        var H, j = this, z = I.p(D), F = N(R), U = (F.utcOffset() - this.utcOffset()) * o, Q = this - F, q = function() {
          return I.m(j, F);
        };
        switch (z) {
          case p:
            H = q() / 12;
            break;
          case d:
            H = q();
            break;
          case f:
            H = q() / 3;
            break;
          case c:
            H = (Q - U) / 6048e5;
            break;
          case s:
            H = (Q - U) / 864e5;
            break;
          case u:
            H = Q / r;
            break;
          case l:
            H = Q / o;
            break;
          case i:
            H = Q / n;
            break;
          default:
            H = Q;
        }
        return A ? H : I.a(H);
      }, P.daysInMonth = function() {
        return this.endOf(d).$D;
      }, P.$locale = function() {
        return O[this.$L];
      }, P.locale = function(R, D) {
        if (!R)
          return this.$L;
        var A = this.clone(), H = _(R, D, !0);
        return H && (A.$L = H), A;
      }, P.clone = function() {
        return I.w(this.$d, this);
      }, P.toDate = function() {
        return new Date(this.valueOf());
      }, P.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, P.toISOString = function() {
        return this.$d.toISOString();
      }, P.toString = function() {
        return this.$d.toUTCString();
      }, k;
    }(), B = E.prototype;
    return N.prototype = B, [["$ms", a], ["$s", i], ["$m", l], ["$H", u], ["$W", s], ["$M", d], ["$y", p], ["$D", v]].forEach(function(k) {
      B[k[1]] = function(P) {
        return this.$g(P, k[0], k[1]);
      };
    }), N.extend = function(k, P) {
      return k.$i || (k(P, E, N), k.$i = !0), N;
    }, N.locale = _, N.isDayjs = M, N.unix = function(k) {
      return N(1e3 * k);
    }, N.en = O[$], N.Ls = O, N.p = {}, N;
  });
})(hS);
var GR = hS.exports;
const kt = /* @__PURE__ */ Jo(GR);
var bS = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Zo, function() {
    return function(n, o) {
      o.prototype.weekday = function(r) {
        var a = this.$locale().weekStart || 0, i = this.$W, l = (i < a ? i + 7 : i) - a;
        return this.$utils().u(r) ? l : this.subtract(l, "day").add(r, "day");
      };
    };
  });
})(bS);
var YR = bS.exports;
const XR = /* @__PURE__ */ Jo(YR);
var yS = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Zo, function() {
    return function(n, o, r) {
      var a = o.prototype, i = function(d) {
        return d && (d.indexOf ? d : d.s);
      }, l = function(d, f, p, v, g) {
        var b = d.name ? d : d.$locale(), y = i(b[f]), S = i(b[p]), w = y || S.map(function($) {
          return $.slice(0, v);
        });
        if (!g)
          return w;
        var C = b.weekStart;
        return w.map(function($, O) {
          return w[(O + (C || 0)) % 7];
        });
      }, u = function() {
        return r.Ls[r.locale()];
      }, s = function(d, f) {
        return d.formats[f] || function(p) {
          return p.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(v, g, b) {
            return g || b.slice(1);
          });
        }(d.formats[f.toUpperCase()]);
      }, c = function() {
        var d = this;
        return { months: function(f) {
          return f ? f.format("MMMM") : l(d, "months");
        }, monthsShort: function(f) {
          return f ? f.format("MMM") : l(d, "monthsShort", "months", 3);
        }, firstDayOfWeek: function() {
          return d.$locale().weekStart || 0;
        }, weekdays: function(f) {
          return f ? f.format("dddd") : l(d, "weekdays");
        }, weekdaysMin: function(f) {
          return f ? f.format("dd") : l(d, "weekdaysMin", "weekdays", 2);
        }, weekdaysShort: function(f) {
          return f ? f.format("ddd") : l(d, "weekdaysShort", "weekdays", 3);
        }, longDateFormat: function(f) {
          return s(d.$locale(), f);
        }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
      };
      a.localeData = function() {
        return c.bind(this)();
      }, r.localeData = function() {
        var d = u();
        return { firstDayOfWeek: function() {
          return d.weekStart || 0;
        }, weekdays: function() {
          return r.weekdays();
        }, weekdaysShort: function() {
          return r.weekdaysShort();
        }, weekdaysMin: function() {
          return r.weekdaysMin();
        }, months: function() {
          return r.months();
        }, monthsShort: function() {
          return r.monthsShort();
        }, longDateFormat: function(f) {
          return s(d, f);
        }, meridiem: d.meridiem, ordinal: d.ordinal };
      }, r.months = function() {
        return l(u(), "months");
      }, r.monthsShort = function() {
        return l(u(), "monthsShort", "months", 3);
      }, r.weekdays = function(d) {
        return l(u(), "weekdays", null, null, d);
      }, r.weekdaysShort = function(d) {
        return l(u(), "weekdaysShort", "weekdays", 3, d);
      }, r.weekdaysMin = function(d) {
        return l(u(), "weekdaysMin", "weekdays", 2, d);
      };
    };
  });
})(yS);
var qR = yS.exports;
const QR = /* @__PURE__ */ Jo(qR);
var SS = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Zo, function() {
    var n = "week", o = "year";
    return function(r, a, i) {
      var l = a.prototype;
      l.week = function(u) {
        if (u === void 0 && (u = null), u !== null)
          return this.add(7 * (u - this.week()), "day");
        var s = this.$locale().yearStart || 1;
        if (this.month() === 11 && this.date() > 25) {
          var c = i(this).startOf(o).add(1, o).date(s), d = i(this).endOf(n);
          if (c.isBefore(d))
            return 1;
        }
        var f = i(this).startOf(o).date(s).startOf(n).subtract(1, "millisecond"), p = this.diff(f, n, !0);
        return p < 0 ? i(this).startOf("week").week() : Math.ceil(p);
      }, l.weeks = function(u) {
        return u === void 0 && (u = null), this.week(u);
      };
    };
  });
})(SS);
var ZR = SS.exports;
const JR = /* @__PURE__ */ Jo(ZR);
var $S = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Zo, function() {
    return function(n, o) {
      o.prototype.weekYear = function() {
        var r = this.month(), a = this.week(), i = this.year();
        return a === 1 && r === 11 ? i + 1 : r === 0 && a >= 52 ? i - 1 : i;
      };
    };
  });
})($S);
var e4 = $S.exports;
const t4 = /* @__PURE__ */ Jo(e4);
var CS = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Zo, function() {
    var n = "month", o = "quarter";
    return function(r, a) {
      var i = a.prototype;
      i.quarter = function(s) {
        return this.$utils().u(s) ? Math.ceil((this.month() + 1) / 3) : this.month(this.month() % 3 + 3 * (s - 1));
      };
      var l = i.add;
      i.add = function(s, c) {
        return s = Number(s), this.$utils().p(c) === o ? this.add(3 * s, n) : l.bind(this)(s, c);
      };
      var u = i.startOf;
      i.startOf = function(s, c) {
        var d = this.$utils(), f = !!d.u(c) || c;
        if (d.p(s) === o) {
          var p = this.quarter() - 1;
          return f ? this.month(3 * p).startOf(n).startOf("day") : this.month(3 * p + 2).endOf(n).endOf("day");
        }
        return u.bind(this)(s, c);
      };
    };
  });
})(CS);
var n4 = CS.exports;
const o4 = /* @__PURE__ */ Jo(n4);
var wS = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Zo, function() {
    return function(n, o) {
      var r = o.prototype, a = r.format;
      r.format = function(i) {
        var l = this, u = this.$locale();
        if (!this.isValid())
          return a.bind(this)(i);
        var s = this.$utils(), c = (i || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(d) {
          switch (d) {
            case "Q":
              return Math.ceil((l.$M + 1) / 3);
            case "Do":
              return u.ordinal(l.$D);
            case "gggg":
              return l.weekYear();
            case "GGGG":
              return l.isoWeekYear();
            case "wo":
              return u.ordinal(l.week(), "W");
            case "w":
            case "ww":
              return s.s(l.week(), d === "w" ? 1 : 2, "0");
            case "W":
            case "WW":
              return s.s(l.isoWeek(), d === "W" ? 1 : 2, "0");
            case "k":
            case "kk":
              return s.s(String(l.$H === 0 ? 24 : l.$H), d === "k" ? 1 : 2, "0");
            case "X":
              return Math.floor(l.$d.getTime() / 1e3);
            case "x":
              return l.$d.getTime();
            case "z":
              return "[" + l.offsetName() + "]";
            case "zzz":
              return "[" + l.offsetName("long") + "]";
            default:
              return d;
          }
        });
        return a.bind(this)(c);
      };
    };
  });
})(wS);
var r4 = wS.exports;
const a4 = /* @__PURE__ */ Jo(r4);
var xS = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Zo, function() {
    var n = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, o = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, r = /\d\d/, a = /\d\d?/, i = /\d*[^-_:/,()\s\d]+/, l = {}, u = function(g) {
      return (g = +g) + (g > 68 ? 1900 : 2e3);
    }, s = function(g) {
      return function(b) {
        this[g] = +b;
      };
    }, c = [/[+-]\d\d:?(\d\d)?|Z/, function(g) {
      (this.zone || (this.zone = {})).offset = function(b) {
        if (!b || b === "Z")
          return 0;
        var y = b.match(/([+-]|\d\d)/g), S = 60 * y[1] + (+y[2] || 0);
        return S === 0 ? 0 : y[0] === "+" ? -S : S;
      }(g);
    }], d = function(g) {
      var b = l[g];
      return b && (b.indexOf ? b : b.s.concat(b.f));
    }, f = function(g, b) {
      var y, S = l.meridiem;
      if (S) {
        for (var w = 1; w <= 24; w += 1)
          if (g.indexOf(S(w, 0, b)) > -1) {
            y = w > 12;
            break;
          }
      } else
        y = g === (b ? "pm" : "PM");
      return y;
    }, p = { A: [i, function(g) {
      this.afternoon = f(g, !1);
    }], a: [i, function(g) {
      this.afternoon = f(g, !0);
    }], S: [/\d/, function(g) {
      this.milliseconds = 100 * +g;
    }], SS: [r, function(g) {
      this.milliseconds = 10 * +g;
    }], SSS: [/\d{3}/, function(g) {
      this.milliseconds = +g;
    }], s: [a, s("seconds")], ss: [a, s("seconds")], m: [a, s("minutes")], mm: [a, s("minutes")], H: [a, s("hours")], h: [a, s("hours")], HH: [a, s("hours")], hh: [a, s("hours")], D: [a, s("day")], DD: [r, s("day")], Do: [i, function(g) {
      var b = l.ordinal, y = g.match(/\d+/);
      if (this.day = y[0], b)
        for (var S = 1; S <= 31; S += 1)
          b(S).replace(/\[|\]/g, "") === g && (this.day = S);
    }], M: [a, s("month")], MM: [r, s("month")], MMM: [i, function(g) {
      var b = d("months"), y = (d("monthsShort") || b.map(function(S) {
        return S.slice(0, 3);
      })).indexOf(g) + 1;
      if (y < 1)
        throw new Error();
      this.month = y % 12 || y;
    }], MMMM: [i, function(g) {
      var b = d("months").indexOf(g) + 1;
      if (b < 1)
        throw new Error();
      this.month = b % 12 || b;
    }], Y: [/[+-]?\d+/, s("year")], YY: [r, function(g) {
      this.year = u(g);
    }], YYYY: [/\d{4}/, s("year")], Z: c, ZZ: c };
    function v(g) {
      var b, y;
      b = g, y = l && l.formats;
      for (var S = (g = b.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(_, N, I) {
        var E = I && I.toUpperCase();
        return N || y[I] || n[I] || y[E].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(B, k, P) {
          return k || P.slice(1);
        });
      })).match(o), w = S.length, C = 0; C < w; C += 1) {
        var $ = S[C], O = p[$], x = O && O[0], M = O && O[1];
        S[C] = M ? { regex: x, parser: M } : $.replace(/^\[|\]$/g, "");
      }
      return function(_) {
        for (var N = {}, I = 0, E = 0; I < w; I += 1) {
          var B = S[I];
          if (typeof B == "string")
            E += B.length;
          else {
            var k = B.regex, P = B.parser, R = _.slice(E), D = k.exec(R)[0];
            P.call(N, D), _ = _.replace(D, "");
          }
        }
        return function(A) {
          var H = A.afternoon;
          if (H !== void 0) {
            var j = A.hours;
            H ? j < 12 && (A.hours += 12) : j === 12 && (A.hours = 0), delete A.afternoon;
          }
        }(N), N;
      };
    }
    return function(g, b, y) {
      y.p.customParseFormat = !0, g && g.parseTwoDigitYear && (u = g.parseTwoDigitYear);
      var S = b.prototype, w = S.parse;
      S.parse = function(C) {
        var $ = C.date, O = C.utc, x = C.args;
        this.$u = O;
        var M = x[1];
        if (typeof M == "string") {
          var _ = x[2] === !0, N = x[3] === !0, I = _ || N, E = x[2];
          N && (E = x[2]), l = this.$locale(), !_ && E && (l = y.Ls[E]), this.$d = function(R, D, A) {
            try {
              if (["x", "X"].indexOf(D) > -1)
                return new Date((D === "X" ? 1e3 : 1) * R);
              var H = v(D)(R), j = H.year, z = H.month, F = H.day, U = H.hours, Q = H.minutes, q = H.seconds, oe = H.milliseconds, Z = H.zone, ne = /* @__PURE__ */ new Date(), Y = F || (j || z ? 1 : ne.getDate()), V = j || ne.getFullYear(), X = 0;
              j && !z || (X = z > 0 ? z - 1 : ne.getMonth());
              var re = U || 0, ie = Q || 0, he = q || 0, ge = oe || 0;
              return Z ? new Date(Date.UTC(V, X, Y, re, ie, he, ge + 60 * Z.offset * 1e3)) : A ? new Date(Date.UTC(V, X, Y, re, ie, he, ge)) : new Date(V, X, Y, re, ie, he, ge);
            } catch {
              return /* @__PURE__ */ new Date("");
            }
          }($, M, O), this.init(), E && E !== !0 && (this.$L = this.locale(E).$L), I && $ != this.format(M) && (this.$d = /* @__PURE__ */ new Date("")), l = {};
        } else if (M instanceof Array)
          for (var B = M.length, k = 1; k <= B; k += 1) {
            x[1] = M[k - 1];
            var P = y.apply(this, x);
            if (P.isValid()) {
              this.$d = P.$d, this.$L = P.$L, this.init();
              break;
            }
            k === B && (this.$d = /* @__PURE__ */ new Date(""));
          }
        else
          w.call(this, C);
      };
    };
  });
})(xS);
var i4 = xS.exports;
const l4 = /* @__PURE__ */ Jo(i4);
kt.extend(l4);
kt.extend(a4);
kt.extend(XR);
kt.extend(QR);
kt.extend(JR);
kt.extend(t4);
kt.extend(o4);
kt.extend((e, t) => {
  const n = t.prototype, o = n.format;
  n.format = function(a) {
    const i = (a || "").replace("Wo", "wo");
    return o.bind(this)(i);
  };
});
const s4 = {
  // ar_EG:
  // az_AZ:
  // bg_BG:
  bn_BD: "bn-bd",
  by_BY: "be",
  // ca_ES:
  // cs_CZ:
  // da_DK:
  // de_DE:
  // el_GR:
  en_GB: "en-gb",
  en_US: "en",
  // es_ES:
  // et_EE:
  // fa_IR:
  // fi_FI:
  fr_BE: "fr",
  fr_CA: "fr-ca",
  // fr_FR:
  // ga_IE:
  // gl_ES:
  // he_IL:
  // hi_IN:
  // hr_HR:
  // hu_HU:
  hy_AM: "hy-am",
  // id_ID:
  // is_IS:
  // it_IT:
  // ja_JP:
  // ka_GE:
  // kk_KZ:
  // km_KH:
  kmr_IQ: "ku",
  // kn_IN:
  // ko_KR:
  // ku_IQ: // previous ku in antd
  // lt_LT:
  // lv_LV:
  // mk_MK:
  // ml_IN:
  // mn_MN:
  // ms_MY:
  // nb_NO:
  // ne_NP:
  nl_BE: "nl-be",
  // nl_NL:
  // pl_PL:
  pt_BR: "pt-br",
  // pt_PT:
  // ro_RO:
  // ru_RU:
  // sk_SK:
  // sl_SI:
  // sr_RS:
  // sv_SE:
  // ta_IN:
  // th_TH:
  // tr_TR:
  // uk_UA:
  // ur_PK:
  // vi_VN:
  zh_CN: "zh-cn",
  zh_HK: "zh-hk",
  zh_TW: "zh-tw"
}, rr = (e) => s4[e] || e.split("_")[0], fg = () => {
  cc(!1, "Not match any format. Please help to fire a issue about this.");
}, u4 = /\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|k{1,2}|S/g;
function pg(e, t, n) {
  const o = [...new Set(e.split(n))];
  let r = 0;
  for (let a = 0; a < o.length; a++) {
    const i = o[a];
    if (r += i.length, r > t)
      return i;
    r += n.length;
  }
}
const vg = (e, t) => {
  if (!e)
    return null;
  if (kt.isDayjs(e))
    return e;
  const n = t.matchAll(u4);
  let o = kt(e, t);
  if (n === null)
    return o;
  for (const r of n) {
    const a = r[0], i = r.index;
    if (a === "Q") {
      const l = e.slice(i - 1, i), u = pg(e, i, l).match(/\d+/)[0];
      o = o.quarter(parseInt(u));
    }
    if (a.toLowerCase() === "wo") {
      const l = e.slice(i - 1, i), u = pg(e, i, l).match(/\d+/)[0];
      o = o.week(parseInt(u));
    }
    a.toLowerCase() === "ww" && (o = o.week(parseInt(e.slice(i, i + a.length)))), a.toLowerCase() === "w" && (o = o.week(parseInt(e.slice(i, i + a.length + 1))));
  }
  return o;
}, OS = {
  // get
  getNow: () => kt(),
  getFixedDate: (e) => kt(e, ["YYYY-M-DD", "YYYY-MM-DD"]),
  getEndDate: (e) => e.endOf("month"),
  getWeekDay: (e) => {
    const t = e.locale("en");
    return t.weekday() + t.localeData().firstDayOfWeek();
  },
  getYear: (e) => e.year(),
  getMonth: (e) => e.month(),
  getDate: (e) => e.date(),
  getHour: (e) => e.hour(),
  getMinute: (e) => e.minute(),
  getSecond: (e) => e.second(),
  // set
  addYear: (e, t) => e.add(t, "year"),
  addMonth: (e, t) => e.add(t, "month"),
  addDate: (e, t) => e.add(t, "day"),
  setYear: (e, t) => e.year(t),
  setMonth: (e, t) => e.month(t),
  setDate: (e, t) => e.date(t),
  setHour: (e, t) => e.hour(t),
  setMinute: (e, t) => e.minute(t),
  setSecond: (e, t) => e.second(t),
  // Compare
  isAfter: (e, t) => e.isAfter(t),
  isValidate: (e) => e.isValid(),
  locale: {
    getWeekFirstDay: (e) => kt().locale(rr(e)).localeData().firstDayOfWeek(),
    getWeekFirstDate: (e, t) => t.locale(rr(e)).weekday(0),
    getWeek: (e, t) => t.locale(rr(e)).week(),
    getShortWeekDays: (e) => kt().locale(rr(e)).localeData().weekdaysMin(),
    getShortMonths: (e) => kt().locale(rr(e)).localeData().monthsShort(),
    format: (e, t, n) => t.locale(rr(e)).format(n),
    parse: (e, t, n) => {
      const o = rr(e);
      for (let r = 0; r < n.length; r += 1) {
        const a = n[r], i = t;
        if (a.includes("wo") || a.includes("Wo")) {
          const u = i.split("-")[0], s = i.split("-")[1], c = kt(u, "YYYY").startOf("year").locale(o);
          for (let d = 0; d <= 52; d += 1) {
            const f = c.add(d, "week");
            if (f.format("Wo") === s)
              return f;
          }
          return fg(), null;
        }
        const l = kt(i, a, !0).locale(o);
        if (l.isValid())
          return l;
      }
      return t || fg(), null;
    }
  },
  toDate: (e, t) => Array.isArray(e) ? e.map((n) => vg(n, t)) : vg(e, t),
  toString: (e, t) => Array.isArray(e) ? e.map((n) => kt.isDayjs(n) ? n.format(t) : n) : kt.isDayjs(e) ? e.format(t) : e
};
function Mt(e) {
  const t = uw();
  return h(h({}, e), t);
}
const PS = Symbol("PanelContextProps"), Df = (e) => {
  ot(PS, e);
}, lo = () => nt(PS, {}), Gi = {
  visibility: "hidden"
};
function er(e, t) {
  let {
    slots: n
  } = t;
  var o;
  const r = Mt(e), {
    prefixCls: a,
    prevIcon: i = "‹",
    nextIcon: l = "›",
    superPrevIcon: u = "«",
    superNextIcon: s = "»",
    onSuperPrev: c,
    onSuperNext: d,
    onPrev: f,
    onNext: p
  } = r, {
    hideNextBtn: v,
    hidePrevBtn: g
  } = lo();
  return m("div", {
    class: a
  }, [c && m("button", {
    type: "button",
    onClick: c,
    tabindex: -1,
    class: `${a}-super-prev-btn`,
    style: g.value ? Gi : {}
  }, [u]), f && m("button", {
    type: "button",
    onClick: f,
    tabindex: -1,
    class: `${a}-prev-btn`,
    style: g.value ? Gi : {}
  }, [i]), m("div", {
    class: `${a}-view`
  }, [(o = n.default) === null || o === void 0 ? void 0 : o.call(n)]), p && m("button", {
    type: "button",
    onClick: p,
    tabindex: -1,
    class: `${a}-next-btn`,
    style: v.value ? Gi : {}
  }, [l]), d && m("button", {
    type: "button",
    onClick: d,
    tabindex: -1,
    class: `${a}-super-next-btn`,
    style: v.value ? Gi : {}
  }, [s])]);
}
er.displayName = "Header";
er.inheritAttrs = !1;
function Af(e) {
  const t = Mt(e), {
    prefixCls: n,
    generateConfig: o,
    viewDate: r,
    onPrevDecades: a,
    onNextDecades: i
  } = t, {
    hideHeader: l
  } = lo();
  if (l)
    return null;
  const u = `${n}-header`, s = o.getYear(r), c = Math.floor(s / po) * po, d = c + po - 1;
  return m(er, L(L({}, t), {}, {
    prefixCls: u,
    onSuperPrev: a,
    onSuperNext: i
  }), {
    default: () => [c, Se("-"), d]
  });
}
Af.displayName = "DecadeHeader";
Af.inheritAttrs = !1;
function IS(e, t, n, o, r) {
  let a = e.setHour(t, n);
  return a = e.setMinute(a, o), a = e.setSecond(a, r), a;
}
function pl(e, t, n) {
  if (!n)
    return t;
  let o = t;
  return o = e.setHour(o, e.getHour(n)), o = e.setMinute(o, e.getMinute(n)), o = e.setSecond(o, e.getSecond(n)), o;
}
function c4(e, t, n, o, r, a) {
  const i = Math.floor(e / o) * o;
  if (i < e)
    return [i, 60 - r, 60 - a];
  const l = Math.floor(t / r) * r;
  if (l < t)
    return [i, l, 60 - a];
  const u = Math.floor(n / a) * a;
  return [i, l, u];
}
function d4(e, t) {
  const n = e.getYear(t), o = e.getMonth(t) + 1, r = e.getEndDate(e.getFixedDate(`${n}-${o}-01`)), a = e.getDate(r), i = o < 10 ? `0${o}` : `${o}`;
  return `${n}-${i}-${a}`;
}
function Rr(e) {
  const {
    prefixCls: t,
    disabledDate: n,
    onSelect: o,
    picker: r,
    rowNum: a,
    colNum: i,
    prefixColumn: l,
    rowClassName: u,
    baseDate: s,
    getCellClassName: c,
    getCellText: d,
    getCellNode: f,
    getCellDate: p,
    generateConfig: v,
    titleCell: g,
    headerCells: b
  } = Mt(e), {
    onDateMouseenter: y,
    onDateMouseleave: S,
    mode: w
  } = lo(), C = `${t}-cell`, $ = [];
  for (let O = 0; O < a; O += 1) {
    const x = [];
    let M;
    for (let _ = 0; _ < i; _ += 1) {
      const N = O * i + _, I = p(s, N), E = Wc({
        cellDate: I,
        mode: w.value,
        disabledDate: n,
        generateConfig: v
      });
      _ === 0 && (M = I, l && x.push(l(M)));
      const B = g && g(I);
      x.push(m("td", {
        key: _,
        title: B,
        class: ae(C, h({
          [`${C}-disabled`]: E,
          [`${C}-start`]: d(I) === 1 || r === "year" && Number(B) % 10 === 0,
          [`${C}-end`]: B === d4(v, I) || r === "year" && Number(B) % 10 === 9
        }, c(I))),
        onClick: (k) => {
          k.stopPropagation(), E || o(I);
        },
        onMouseenter: () => {
          !E && y && y(I);
        },
        onMouseleave: () => {
          !E && S && S(I);
        }
      }, [f ? f(I) : m("div", {
        class: `${C}-inner`
      }, [d(I)])]));
    }
    $.push(m("tr", {
      key: O,
      class: u && u(M)
    }, [x]));
  }
  return m("div", {
    class: `${t}-body`
  }, [m("table", {
    class: `${t}-content`
  }, [b && m("thead", null, [m("tr", null, [b])]), m("tbody", null, [$])])]);
}
Rr.displayName = "PanelBody";
Rr.inheritAttrs = !1;
const zc = 3, mg = 4;
function Nf(e) {
  const t = Mt(e), n = Wn - 1, {
    prefixCls: o,
    viewDate: r,
    generateConfig: a
  } = t, i = `${o}-cell`, l = a.getYear(r), u = Math.floor(l / Wn) * Wn, s = Math.floor(l / po) * po, c = s + po - 1, d = a.setYear(r, s - Math.ceil((zc * mg * Wn - po) / 2)), f = (p) => {
    const v = a.getYear(p), g = v + n;
    return {
      [`${i}-in-view`]: s <= v && g <= c,
      [`${i}-selected`]: v === u
    };
  };
  return m(Rr, L(L({}, t), {}, {
    rowNum: mg,
    colNum: zc,
    baseDate: d,
    getCellText: (p) => {
      const v = a.getYear(p);
      return `${v}-${v + n}`;
    },
    getCellClassName: f,
    getCellDate: (p, v) => a.addYear(p, v * Wn)
  }), null);
}
Nf.displayName = "DecadeBody";
Nf.inheritAttrs = !1;
const Yi = /* @__PURE__ */ new Map();
function f4(e, t) {
  let n;
  function o() {
    Ld(e) ? t() : n = Ue(() => {
      o();
    });
  }
  return o(), () => {
    Ue.cancel(n);
  };
}
function jc(e, t, n) {
  if (Yi.get(e) && Ue.cancel(Yi.get(e)), n <= 0) {
    Yi.set(e, Ue(() => {
      e.scrollTop = t;
    }));
    return;
  }
  const r = (t - e.scrollTop) / n * 10;
  Yi.set(e, Ue(() => {
    e.scrollTop += r, e.scrollTop !== t && jc(e, t, n - 10);
  }));
}
function Pa(e, t) {
  let {
    onLeftRight: n,
    onCtrlLeftRight: o,
    onUpDown: r,
    onPageUpDown: a,
    onEnter: i
  } = t;
  const {
    which: l,
    ctrlKey: u,
    metaKey: s
  } = e;
  switch (l) {
    case ee.LEFT:
      if (u || s) {
        if (o)
          return o(-1), !0;
      } else if (n)
        return n(-1), !0;
      break;
    case ee.RIGHT:
      if (u || s) {
        if (o)
          return o(1), !0;
      } else if (n)
        return n(1), !0;
      break;
    case ee.UP:
      if (r)
        return r(-1), !0;
      break;
    case ee.DOWN:
      if (r)
        return r(1), !0;
      break;
    case ee.PAGE_UP:
      if (a)
        return a(-1), !0;
      break;
    case ee.PAGE_DOWN:
      if (a)
        return a(1), !0;
      break;
    case ee.ENTER:
      if (i)
        return i(), !0;
      break;
  }
  return !1;
}
function TS(e, t, n, o) {
  let r = e;
  if (!r)
    switch (t) {
      case "time":
        r = o ? "hh:mm:ss a" : "HH:mm:ss";
        break;
      case "week":
        r = "gggg-wo";
        break;
      case "month":
        r = "YYYY-MM";
        break;
      case "quarter":
        r = "YYYY-[Q]Q";
        break;
      case "year":
        r = "YYYY";
        break;
      default:
        r = n ? "YYYY-MM-DD HH:mm:ss" : "YYYY-MM-DD";
    }
  return r;
}
function ES(e, t, n) {
  const o = e === "time" ? 8 : 10, r = typeof t == "function" ? t(n.getNow()).length : t.length;
  return Math.max(o, r) + 2;
}
let Ba = null;
const Xi = /* @__PURE__ */ new Set();
function p4(e) {
  return !Ba && typeof window < "u" && window.addEventListener && (Ba = (t) => {
    [...Xi].forEach((n) => {
      n(t);
    });
  }, window.addEventListener("mousedown", Ba)), Xi.add(e), () => {
    Xi.delete(e), Xi.size === 0 && (window.removeEventListener("mousedown", Ba), Ba = null);
  };
}
function v4(e) {
  var t;
  const n = e.target;
  return e.composed && n.shadowRoot && ((t = e.composedPath) === null || t === void 0 ? void 0 : t.call(e)[0]) || n;
}
const m4 = (e) => e === "month" || e === "date" ? "year" : e, g4 = (e) => e === "date" ? "month" : e, h4 = (e) => e === "month" || e === "date" ? "quarter" : e, b4 = (e) => e === "date" ? "week" : e, y4 = {
  year: m4,
  month: g4,
  quarter: h4,
  week: b4,
  time: null,
  date: null
};
function MS(e, t) {
  return process.env.NODE_ENV === "test" ? !1 : e.some((n) => n && n.contains(t));
}
const Wn = 10, po = Wn * 10;
function Rf(e) {
  const t = Mt(e), {
    prefixCls: n,
    onViewDateChange: o,
    generateConfig: r,
    viewDate: a,
    operationRef: i,
    onSelect: l,
    onPanelChange: u
  } = t, s = `${n}-decade-panel`;
  i.value = {
    onKeydown: (f) => Pa(f, {
      onLeftRight: (p) => {
        l(r.addYear(a, p * Wn), "key");
      },
      onCtrlLeftRight: (p) => {
        l(r.addYear(a, p * po), "key");
      },
      onUpDown: (p) => {
        l(r.addYear(a, p * Wn * zc), "key");
      },
      onEnter: () => {
        u("year", a);
      }
    })
  };
  const c = (f) => {
    const p = r.addYear(a, f * po);
    o(p), u(null, p);
  }, d = (f) => {
    l(f, "mouse"), u("year", f);
  };
  return m("div", {
    class: s
  }, [m(Af, L(L({}, t), {}, {
    prefixCls: n,
    onPrevDecades: () => {
      c(-1);
    },
    onNextDecades: () => {
      c(1);
    }
  }), null), m(Nf, L(L({}, t), {}, {
    prefixCls: n,
    onSelect: d
  }), null)]);
}
Rf.displayName = "DecadePanel";
Rf.inheritAttrs = !1;
const vl = 7;
function Fr(e, t) {
  if (!e && !t)
    return !0;
  if (!e || !t)
    return !1;
}
function S4(e, t, n) {
  const o = Fr(t, n);
  if (typeof o == "boolean")
    return o;
  const r = Math.floor(e.getYear(t) / 10), a = Math.floor(e.getYear(n) / 10);
  return r === a;
}
function Ns(e, t, n) {
  const o = Fr(t, n);
  return typeof o == "boolean" ? o : e.getYear(t) === e.getYear(n);
}
function Vc(e, t) {
  return Math.floor(e.getMonth(t) / 3) + 1;
}
function _S(e, t, n) {
  const o = Fr(t, n);
  return typeof o == "boolean" ? o : Ns(e, t, n) && Vc(e, t) === Vc(e, n);
}
function Ff(e, t, n) {
  const o = Fr(t, n);
  return typeof o == "boolean" ? o : Ns(e, t, n) && e.getMonth(t) === e.getMonth(n);
}
function vo(e, t, n) {
  const o = Fr(t, n);
  return typeof o == "boolean" ? o : e.getYear(t) === e.getYear(n) && e.getMonth(t) === e.getMonth(n) && e.getDate(t) === e.getDate(n);
}
function $4(e, t, n) {
  const o = Fr(t, n);
  return typeof o == "boolean" ? o : e.getHour(t) === e.getHour(n) && e.getMinute(t) === e.getMinute(n) && e.getSecond(t) === e.getSecond(n);
}
function DS(e, t, n, o) {
  const r = Fr(n, o);
  return typeof r == "boolean" ? r : e.locale.getWeek(t, n) === e.locale.getWeek(t, o);
}
function ta(e, t, n) {
  return vo(e, t, n) && $4(e, t, n);
}
function qi(e, t, n, o) {
  return !t || !n || !o ? !1 : !vo(e, t, o) && !vo(e, n, o) && e.isAfter(o, t) && e.isAfter(n, o);
}
function C4(e, t, n) {
  const o = t.locale.getWeekFirstDay(e), r = t.setDate(n, 1), a = t.getWeekDay(r);
  let i = t.addDate(r, o - a);
  return t.getMonth(i) === t.getMonth(n) && t.getDate(i) > 1 && (i = t.addDate(i, -7)), i;
}
function qa(e, t, n) {
  let o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  switch (t) {
    case "year":
      return n.addYear(e, o * 10);
    case "quarter":
    case "month":
      return n.addYear(e, o);
    default:
      return n.addMonth(e, o);
  }
}
function Yt(e, t) {
  let {
    generateConfig: n,
    locale: o,
    format: r
  } = t;
  return typeof r == "function" ? r(e) : n.locale.format(o.locale, e, r);
}
function AS(e, t) {
  let {
    generateConfig: n,
    locale: o,
    formatList: r
  } = t;
  return !e || typeof r[0] == "function" ? null : n.locale.parse(o.locale, e, r);
}
function Wc(e) {
  let {
    cellDate: t,
    mode: n,
    disabledDate: o,
    generateConfig: r
  } = e;
  if (!o)
    return !1;
  const a = (i, l, u) => {
    let s = l;
    for (; s <= u; ) {
      let c;
      switch (i) {
        case "date": {
          if (c = r.setDate(t, s), !o(c))
            return !1;
          break;
        }
        case "month": {
          if (c = r.setMonth(t, s), !Wc({
            cellDate: c,
            mode: "month",
            generateConfig: r,
            disabledDate: o
          }))
            return !1;
          break;
        }
        case "year": {
          if (c = r.setYear(t, s), !Wc({
            cellDate: c,
            mode: "year",
            generateConfig: r,
            disabledDate: o
          }))
            return !1;
          break;
        }
      }
      s += 1;
    }
    return !0;
  };
  switch (n) {
    case "date":
    case "week":
      return o(t);
    case "month": {
      const l = r.getDate(r.getEndDate(t));
      return a("date", 1, l);
    }
    case "quarter": {
      const i = Math.floor(r.getMonth(t) / 3) * 3, l = i + 2;
      return a("month", i, l);
    }
    case "year":
      return a("month", 0, 11);
    case "decade": {
      const i = r.getYear(t), l = Math.floor(i / Wn) * Wn, u = l + Wn - 1;
      return a("year", l, u);
    }
  }
}
function Bf(e) {
  const t = Mt(e), {
    hideHeader: n
  } = lo();
  if (n.value)
    return null;
  const {
    prefixCls: o,
    generateConfig: r,
    locale: a,
    value: i,
    format: l
  } = t, u = `${o}-header`;
  return m(er, {
    prefixCls: u
  }, {
    default: () => [i ? Yt(i, {
      locale: a,
      format: l,
      generateConfig: r
    }) : " "]
  });
}
Bf.displayName = "TimeHeader";
Bf.inheritAttrs = !1;
const Qi = J({
  name: "TimeUnitColumn",
  props: ["prefixCls", "units", "onSelect", "value", "active", "hideDisabledOptions"],
  setup(e) {
    const {
      open: t
    } = lo(), n = K(null), o = G(/* @__PURE__ */ new Map()), r = G();
    return le(() => e.value, () => {
      const a = o.value.get(e.value);
      a && t.value !== !1 && jc(n.value, a.offsetTop, 120);
    }), at(() => {
      var a;
      (a = r.value) === null || a === void 0 || a.call(r);
    }), le(t, () => {
      var a;
      (a = r.value) === null || a === void 0 || a.call(r), mt(() => {
        if (t.value) {
          const i = o.value.get(e.value);
          i && (r.value = f4(i, () => {
            jc(n.value, i.offsetTop, 0);
          }));
        }
      });
    }, {
      immediate: !0,
      flush: "post"
    }), () => {
      const {
        prefixCls: a,
        units: i,
        onSelect: l,
        value: u,
        active: s,
        hideDisabledOptions: c
      } = e, d = `${a}-cell`;
      return m("ul", {
        class: ae(`${a}-column`, {
          [`${a}-column-active`]: s
        }),
        ref: n,
        style: {
          position: "relative"
        }
      }, [i.map((f) => c && f.disabled ? null : m("li", {
        key: f.value,
        ref: (p) => {
          o.value.set(f.value, p);
        },
        class: ae(d, {
          [`${d}-disabled`]: f.disabled,
          [`${d}-selected`]: u === f.value
        }),
        onClick: () => {
          f.disabled || l(f.value);
        }
      }, [m("div", {
        class: `${d}-inner`
      }, [f.label])]))]);
    };
  }
});
function NS(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0", o = String(e);
  for (; o.length < t; )
    o = `${n}${e}`;
  return o;
}
const w4 = function() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return t;
};
function RS(e) {
  return e == null ? [] : Array.isArray(e) ? e : [e];
}
function FS(e) {
  const t = {};
  return Object.keys(e).forEach((n) => {
    (n.startsWith("data-") || n.startsWith("aria-") || n === "role" || n === "name") && !n.startsWith("data-__") && (t[n] = e[n]);
  }), t;
}
function rt(e, t) {
  return e ? e[t] : null;
}
function _n(e, t, n) {
  const o = [rt(e, 0), rt(e, 1)];
  return o[n] = typeof t == "function" ? t(o[n]) : t, !o[0] && !o[1] ? null : o;
}
function Tu(e, t, n, o) {
  const r = [];
  for (let a = e; a <= t; a += n)
    r.push({
      label: NS(a, 2),
      value: a,
      disabled: (o || []).includes(a)
    });
  return r;
}
const x4 = J({
  compatConfig: {
    MODE: 3
  },
  name: "TimeBody",
  inheritAttrs: !1,
  props: ["generateConfig", "prefixCls", "operationRef", "activeColumnIndex", "value", "showHour", "showMinute", "showSecond", "use12Hours", "hourStep", "minuteStep", "secondStep", "disabledHours", "disabledMinutes", "disabledSeconds", "disabledTime", "hideDisabledOptions", "onSelect"],
  setup(e) {
    const t = T(() => e.value ? e.generateConfig.getHour(e.value) : -1), n = T(() => e.use12Hours ? t.value >= 12 : !1), o = T(() => e.use12Hours ? t.value % 12 : t.value), r = T(() => e.value ? e.generateConfig.getMinute(e.value) : -1), a = T(() => e.value ? e.generateConfig.getSecond(e.value) : -1), i = G(e.generateConfig.getNow()), l = G(), u = G(), s = G();
    yd(() => {
      i.value = e.generateConfig.getNow();
    }), Ve(() => {
      if (e.disabledTime) {
        const b = e.disabledTime(i);
        [l.value, u.value, s.value] = [b.disabledHours, b.disabledMinutes, b.disabledSeconds];
      } else
        [l.value, u.value, s.value] = [e.disabledHours, e.disabledMinutes, e.disabledSeconds];
    });
    const c = (b, y, S, w) => {
      let C = e.value || e.generateConfig.getNow();
      const $ = Math.max(0, y), O = Math.max(0, S), x = Math.max(0, w);
      return C = IS(e.generateConfig, C, !e.use12Hours || !b ? $ : $ + 12, O, x), C;
    }, d = T(() => {
      var b;
      return Tu(0, 23, (b = e.hourStep) !== null && b !== void 0 ? b : 1, l.value && l.value());
    }), f = T(() => {
      if (!e.use12Hours)
        return [!1, !1];
      const b = [!0, !0];
      return d.value.forEach((y) => {
        let {
          disabled: S,
          value: w
        } = y;
        S || (w >= 12 ? b[1] = !1 : b[0] = !1);
      }), b;
    }), p = T(() => e.use12Hours ? d.value.filter(n.value ? (b) => b.value >= 12 : (b) => b.value < 12).map((b) => {
      const y = b.value % 12, S = y === 0 ? "12" : NS(y, 2);
      return h(h({}, b), {
        label: S,
        value: y
      });
    }) : d.value), v = T(() => {
      var b;
      return Tu(0, 59, (b = e.minuteStep) !== null && b !== void 0 ? b : 1, u.value && u.value(t.value));
    }), g = T(() => {
      var b;
      return Tu(0, 59, (b = e.secondStep) !== null && b !== void 0 ? b : 1, s.value && s.value(t.value, r.value));
    });
    return () => {
      const {
        prefixCls: b,
        operationRef: y,
        activeColumnIndex: S,
        showHour: w,
        showMinute: C,
        showSecond: $,
        use12Hours: O,
        hideDisabledOptions: x,
        onSelect: M
      } = e, _ = [], N = `${b}-content`, I = `${b}-time-panel`;
      y.value = {
        onUpDown: (k) => {
          const P = _[S];
          if (P) {
            const R = P.units.findIndex((A) => A.value === P.value), D = P.units.length;
            for (let A = 1; A < D; A += 1) {
              const H = P.units[(R + k * A + D) % D];
              if (H.disabled !== !0) {
                P.onSelect(H.value);
                break;
              }
            }
          }
        }
      };
      function E(k, P, R, D, A) {
        k !== !1 && _.push({
          node: Tt(P, {
            prefixCls: I,
            value: R,
            active: S === _.length,
            onSelect: A,
            units: D,
            hideDisabledOptions: x
          }),
          onSelect: A,
          value: R,
          units: D
        });
      }
      E(w, m(Qi, {
        key: "hour"
      }, null), o.value, p.value, (k) => {
        M(c(n.value, k, r.value, a.value), "mouse");
      }), E(C, m(Qi, {
        key: "minute"
      }, null), r.value, v.value, (k) => {
        M(c(n.value, o.value, k, a.value), "mouse");
      }), E($, m(Qi, {
        key: "second"
      }, null), a.value, g.value, (k) => {
        M(c(n.value, o.value, r.value, k), "mouse");
      });
      let B = -1;
      return typeof n.value == "boolean" && (B = n.value ? 1 : 0), E(O === !0, m(Qi, {
        key: "12hours"
      }, null), B, [{
        label: "AM",
        value: 0,
        disabled: f.value[0]
      }, {
        label: "PM",
        value: 1,
        disabled: f.value[1]
      }], (k) => {
        M(c(!!k, o.value, r.value, a.value), "mouse");
      }), m("div", {
        class: N
      }, [_.map((k) => {
        let {
          node: P
        } = k;
        return P;
      })]);
    };
  }
}), O4 = (e) => e.filter((t) => t !== !1).length;
function Rs(e) {
  const t = Mt(e), {
    generateConfig: n,
    format: o = "HH:mm:ss",
    prefixCls: r,
    active: a,
    operationRef: i,
    showHour: l,
    showMinute: u,
    showSecond: s,
    use12Hours: c = !1,
    onSelect: d,
    value: f
  } = t, p = `${r}-time-panel`, v = G(), g = G(-1), b = O4([l, u, s, c]);
  return i.value = {
    onKeydown: (y) => Pa(y, {
      onLeftRight: (S) => {
        g.value = (g.value + S + b) % b;
      },
      onUpDown: (S) => {
        g.value === -1 ? g.value = 0 : v.value && v.value.onUpDown(S);
      },
      onEnter: () => {
        d(f || n.getNow(), "key"), g.value = -1;
      }
    }),
    onBlur: () => {
      g.value = -1;
    }
  }, m("div", {
    class: ae(p, {
      [`${p}-active`]: a
    })
  }, [m(Bf, L(L({}, t), {}, {
    format: o,
    prefixCls: r
  }), null), m(x4, L(L({}, t), {}, {
    prefixCls: r,
    activeColumnIndex: g.value,
    operationRef: v
  }), null)]);
}
Rs.displayName = "TimePanel";
Rs.inheritAttrs = !1;
function Fs(e) {
  let {
    cellPrefixCls: t,
    generateConfig: n,
    rangedValue: o,
    hoverRangedValue: r,
    isInView: a,
    isSameCell: i,
    offsetCell: l,
    today: u,
    value: s
  } = e;
  function c(d) {
    const f = l(d, -1), p = l(d, 1), v = rt(o, 0), g = rt(o, 1), b = rt(r, 0), y = rt(r, 1), S = qi(n, b, y, d);
    function w(_) {
      return i(v, _);
    }
    function C(_) {
      return i(g, _);
    }
    const $ = i(b, d), O = i(y, d), x = (S || O) && (!a(f) || C(f)), M = (S || $) && (!a(p) || w(p));
    return {
      // In view
      [`${t}-in-view`]: a(d),
      // Range
      [`${t}-in-range`]: qi(n, v, g, d),
      [`${t}-range-start`]: w(d),
      [`${t}-range-end`]: C(d),
      [`${t}-range-start-single`]: w(d) && !g,
      [`${t}-range-end-single`]: C(d) && !v,
      [`${t}-range-start-near-hover`]: w(d) && (i(f, b) || qi(n, b, y, f)),
      [`${t}-range-end-near-hover`]: C(d) && (i(p, y) || qi(n, b, y, p)),
      // Range Hover
      [`${t}-range-hover`]: S,
      [`${t}-range-hover-start`]: $,
      [`${t}-range-hover-end`]: O,
      // Range Edge
      [`${t}-range-hover-edge-start`]: x,
      [`${t}-range-hover-edge-end`]: M,
      [`${t}-range-hover-edge-start-near-range`]: x && i(f, g),
      [`${t}-range-hover-edge-end-near-range`]: M && i(p, v),
      // Others
      [`${t}-today`]: i(u, d),
      [`${t}-selected`]: i(s, d)
    };
  }
  return c;
}
const BS = Symbol("RangeContextProps"), P4 = (e) => {
  ot(BS, e);
}, Oi = () => nt(BS, {
  rangedValue: G(),
  hoverRangedValue: G(),
  inRange: G(),
  panelPosition: G()
}), I4 = J({
  compatConfig: {
    MODE: 3
  },
  name: "PanelContextProvider",
  inheritAttrs: !1,
  props: {
    value: {
      type: Object,
      default: () => ({})
    }
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = {
      rangedValue: G(e.value.rangedValue),
      hoverRangedValue: G(e.value.hoverRangedValue),
      inRange: G(e.value.inRange),
      panelPosition: G(e.value.panelPosition)
    };
    return P4(o), le(() => e.value, () => {
      Object.keys(e.value).forEach((r) => {
        o[r] && (o[r].value = e.value[r]);
      });
    }), () => {
      var r;
      return (r = n.default) === null || r === void 0 ? void 0 : r.call(n);
    };
  }
});
function Bs(e) {
  const t = Mt(e), {
    prefixCls: n,
    generateConfig: o,
    prefixColumn: r,
    locale: a,
    rowCount: i,
    viewDate: l,
    value: u,
    dateRender: s
  } = t, {
    rangedValue: c,
    hoverRangedValue: d
  } = Oi(), f = C4(a.locale, o, l), p = `${n}-cell`, v = o.locale.getWeekFirstDay(a.locale), g = o.getNow(), b = [], y = a.shortWeekDays || (o.locale.getShortWeekDays ? o.locale.getShortWeekDays(a.locale) : []);
  r && b.push(m("th", {
    key: "empty",
    "aria-label": "empty cell"
  }, null));
  for (let C = 0; C < vl; C += 1)
    b.push(m("th", {
      key: C
    }, [y[(C + v) % vl]]));
  const S = Fs({
    cellPrefixCls: p,
    today: g,
    value: u,
    generateConfig: o,
    rangedValue: r ? null : c.value,
    hoverRangedValue: r ? null : d.value,
    isSameCell: (C, $) => vo(o, C, $),
    isInView: (C) => Ff(o, C, l),
    offsetCell: (C, $) => o.addDate(C, $)
  }), w = s ? (C) => s({
    current: C,
    today: g
  }) : void 0;
  return m(Rr, L(L({}, t), {}, {
    rowNum: i,
    colNum: vl,
    baseDate: f,
    getCellNode: w,
    getCellText: o.getDate,
    getCellClassName: S,
    getCellDate: o.addDate,
    titleCell: (C) => Yt(C, {
      locale: a,
      format: "YYYY-MM-DD",
      generateConfig: o
    }),
    headerCells: b
  }), null);
}
Bs.displayName = "DateBody";
Bs.inheritAttrs = !1;
Bs.props = [
  "prefixCls",
  "generateConfig",
  "value?",
  "viewDate",
  "locale",
  "rowCount",
  "onSelect",
  "dateRender?",
  "disabledDate?",
  // Used for week panel
  "prefixColumn?",
  "rowClassName?"
];
function kf(e) {
  const t = Mt(e), {
    prefixCls: n,
    generateConfig: o,
    locale: r,
    viewDate: a,
    onNextMonth: i,
    onPrevMonth: l,
    onNextYear: u,
    onPrevYear: s,
    onYearClick: c,
    onMonthClick: d
  } = t, {
    hideHeader: f
  } = lo();
  if (f.value)
    return null;
  const p = `${n}-header`, v = r.shortMonths || (o.locale.getShortMonths ? o.locale.getShortMonths(r.locale) : []), g = o.getMonth(a), b = m("button", {
    type: "button",
    key: "year",
    onClick: c,
    tabindex: -1,
    class: `${n}-year-btn`
  }, [Yt(a, {
    locale: r,
    format: r.yearFormat,
    generateConfig: o
  })]), y = m("button", {
    type: "button",
    key: "month",
    onClick: d,
    tabindex: -1,
    class: `${n}-month-btn`
  }, [r.monthFormat ? Yt(a, {
    locale: r,
    format: r.monthFormat,
    generateConfig: o
  }) : v[g]]), S = r.monthBeforeYear ? [y, b] : [b, y];
  return m(er, L(L({}, t), {}, {
    prefixCls: p,
    onSuperPrev: s,
    onPrev: l,
    onNext: i,
    onSuperNext: u
  }), {
    default: () => [S]
  });
}
kf.displayName = "DateHeader";
kf.inheritAttrs = !1;
const T4 = 6;
function Pi(e) {
  const t = Mt(e), {
    prefixCls: n,
    panelName: o = "date",
    keyboardConfig: r,
    active: a,
    operationRef: i,
    generateConfig: l,
    value: u,
    viewDate: s,
    onViewDateChange: c,
    onPanelChange: d,
    onSelect: f
  } = t, p = `${n}-${o}-panel`;
  i.value = {
    onKeydown: (b) => Pa(b, h({
      onLeftRight: (y) => {
        f(l.addDate(u || s, y), "key");
      },
      onCtrlLeftRight: (y) => {
        f(l.addYear(u || s, y), "key");
      },
      onUpDown: (y) => {
        f(l.addDate(u || s, y * vl), "key");
      },
      onPageUpDown: (y) => {
        f(l.addMonth(u || s, y), "key");
      }
    }, r))
  };
  const v = (b) => {
    const y = l.addYear(s, b);
    c(y), d(null, y);
  }, g = (b) => {
    const y = l.addMonth(s, b);
    c(y), d(null, y);
  };
  return m("div", {
    class: ae(p, {
      [`${p}-active`]: a
    })
  }, [m(kf, L(L({}, t), {}, {
    prefixCls: n,
    value: u,
    viewDate: s,
    onPrevYear: () => {
      v(-1);
    },
    onNextYear: () => {
      v(1);
    },
    onPrevMonth: () => {
      g(-1);
    },
    onNextMonth: () => {
      g(1);
    },
    onMonthClick: () => {
      d("month", s);
    },
    onYearClick: () => {
      d("year", s);
    }
  }), null), m(Bs, L(L({}, t), {}, {
    onSelect: (b) => f(b, "mouse"),
    prefixCls: n,
    value: u,
    viewDate: s,
    rowCount: T4
  }), null)]);
}
Pi.displayName = "DatePanel";
Pi.inheritAttrs = !1;
const gg = w4("date", "time");
function Lf(e) {
  const t = Mt(e), {
    prefixCls: n,
    operationRef: o,
    generateConfig: r,
    value: a,
    defaultValue: i,
    disabledTime: l,
    showTime: u,
    onSelect: s
  } = t, c = `${n}-datetime-panel`, d = G(null), f = G({}), p = G({}), v = typeof u == "object" ? h({}, u) : {};
  function g(w) {
    const C = gg.indexOf(d.value) + w;
    return gg[C] || null;
  }
  const b = (w) => {
    p.value.onBlur && p.value.onBlur(w), d.value = null;
  };
  o.value = {
    onKeydown: (w) => {
      if (w.which === ee.TAB) {
        const C = g(w.shiftKey ? -1 : 1);
        return d.value = C, C && w.preventDefault(), !0;
      }
      if (d.value) {
        const C = d.value === "date" ? f : p;
        return C.value && C.value.onKeydown && C.value.onKeydown(w), !0;
      }
      return [ee.LEFT, ee.RIGHT, ee.UP, ee.DOWN].includes(w.which) ? (d.value = "date", !0) : !1;
    },
    onBlur: b,
    onClose: b
  };
  const y = (w, C) => {
    let $ = w;
    C === "date" && !a && v.defaultValue ? ($ = r.setHour($, r.getHour(v.defaultValue)), $ = r.setMinute($, r.getMinute(v.defaultValue)), $ = r.setSecond($, r.getSecond(v.defaultValue))) : C === "time" && !a && i && ($ = r.setYear($, r.getYear(i)), $ = r.setMonth($, r.getMonth(i)), $ = r.setDate($, r.getDate(i))), s && s($, "mouse");
  }, S = l ? l(a || null) : {};
  return m("div", {
    class: ae(c, {
      [`${c}-active`]: d.value
    })
  }, [m(Pi, L(L({}, t), {}, {
    operationRef: f,
    active: d.value === "date",
    onSelect: (w) => {
      y(pl(r, w, !a && typeof u == "object" ? u.defaultValue : null), "date");
    }
  }), null), m(Rs, L(L(L(L({}, t), {}, {
    format: void 0
  }, v), S), {}, {
    disabledTime: null,
    defaultValue: void 0,
    operationRef: p,
    active: d.value === "time",
    onSelect: (w) => {
      y(w, "time");
    }
  }), null)]);
}
Lf.displayName = "DatetimePanel";
Lf.inheritAttrs = !1;
function Hf(e) {
  const t = Mt(e), {
    prefixCls: n,
    generateConfig: o,
    locale: r,
    value: a
  } = t, i = `${n}-cell`, l = (c) => m("td", {
    key: "week",
    class: ae(i, `${i}-week`)
  }, [o.locale.getWeek(r.locale, c)]), u = `${n}-week-panel-row`, s = (c) => ae(u, {
    [`${u}-selected`]: DS(o, r.locale, a, c)
  });
  return m(Pi, L(L({}, t), {}, {
    panelName: "week",
    prefixColumn: l,
    rowClassName: s,
    keyboardConfig: {
      onLeftRight: null
    }
  }), null);
}
Hf.displayName = "WeekPanel";
Hf.inheritAttrs = !1;
function zf(e) {
  const t = Mt(e), {
    prefixCls: n,
    generateConfig: o,
    locale: r,
    viewDate: a,
    onNextYear: i,
    onPrevYear: l,
    onYearClick: u
  } = t, {
    hideHeader: s
  } = lo();
  if (s.value)
    return null;
  const c = `${n}-header`;
  return m(er, L(L({}, t), {}, {
    prefixCls: c,
    onSuperPrev: l,
    onSuperNext: i
  }), {
    default: () => [m("button", {
      type: "button",
      onClick: u,
      class: `${n}-year-btn`
    }, [Yt(a, {
      locale: r,
      format: r.yearFormat,
      generateConfig: o
    })])]
  });
}
zf.displayName = "MonthHeader";
zf.inheritAttrs = !1;
const kS = 3, E4 = 4;
function jf(e) {
  const t = Mt(e), {
    prefixCls: n,
    locale: o,
    value: r,
    viewDate: a,
    generateConfig: i,
    monthCellRender: l
  } = t, {
    rangedValue: u,
    hoverRangedValue: s
  } = Oi(), c = `${n}-cell`, d = Fs({
    cellPrefixCls: c,
    value: r,
    generateConfig: i,
    rangedValue: u.value,
    hoverRangedValue: s.value,
    isSameCell: (g, b) => Ff(i, g, b),
    isInView: () => !0,
    offsetCell: (g, b) => i.addMonth(g, b)
  }), f = o.shortMonths || (i.locale.getShortMonths ? i.locale.getShortMonths(o.locale) : []), p = i.setMonth(a, 0), v = l ? (g) => l({
    current: g,
    locale: o
  }) : void 0;
  return m(Rr, L(L({}, t), {}, {
    rowNum: E4,
    colNum: kS,
    baseDate: p,
    getCellNode: v,
    getCellText: (g) => o.monthFormat ? Yt(g, {
      locale: o,
      format: o.monthFormat,
      generateConfig: i
    }) : f[i.getMonth(g)],
    getCellClassName: d,
    getCellDate: i.addMonth,
    titleCell: (g) => Yt(g, {
      locale: o,
      format: "YYYY-MM",
      generateConfig: i
    })
  }), null);
}
jf.displayName = "MonthBody";
jf.inheritAttrs = !1;
function Vf(e) {
  const t = Mt(e), {
    prefixCls: n,
    operationRef: o,
    onViewDateChange: r,
    generateConfig: a,
    value: i,
    viewDate: l,
    onPanelChange: u,
    onSelect: s
  } = t, c = `${n}-month-panel`;
  o.value = {
    onKeydown: (f) => Pa(f, {
      onLeftRight: (p) => {
        s(a.addMonth(i || l, p), "key");
      },
      onCtrlLeftRight: (p) => {
        s(a.addYear(i || l, p), "key");
      },
      onUpDown: (p) => {
        s(a.addMonth(i || l, p * kS), "key");
      },
      onEnter: () => {
        u("date", i || l);
      }
    })
  };
  const d = (f) => {
    const p = a.addYear(l, f);
    r(p), u(null, p);
  };
  return m("div", {
    class: c
  }, [m(zf, L(L({}, t), {}, {
    prefixCls: n,
    onPrevYear: () => {
      d(-1);
    },
    onNextYear: () => {
      d(1);
    },
    onYearClick: () => {
      u("year", l);
    }
  }), null), m(jf, L(L({}, t), {}, {
    prefixCls: n,
    onSelect: (f) => {
      s(f, "mouse"), u("date", f);
    }
  }), null)]);
}
Vf.displayName = "MonthPanel";
Vf.inheritAttrs = !1;
function Wf(e) {
  const t = Mt(e), {
    prefixCls: n,
    generateConfig: o,
    locale: r,
    viewDate: a,
    onNextYear: i,
    onPrevYear: l,
    onYearClick: u
  } = t, {
    hideHeader: s
  } = lo();
  if (s.value)
    return null;
  const c = `${n}-header`;
  return m(er, L(L({}, t), {}, {
    prefixCls: c,
    onSuperPrev: l,
    onSuperNext: i
  }), {
    default: () => [m("button", {
      type: "button",
      onClick: u,
      class: `${n}-year-btn`
    }, [Yt(a, {
      locale: r,
      format: r.yearFormat,
      generateConfig: o
    })])]
  });
}
Wf.displayName = "QuarterHeader";
Wf.inheritAttrs = !1;
const M4 = 4, _4 = 1;
function Kf(e) {
  const t = Mt(e), {
    prefixCls: n,
    locale: o,
    value: r,
    viewDate: a,
    generateConfig: i
  } = t, {
    rangedValue: l,
    hoverRangedValue: u
  } = Oi(), s = `${n}-cell`, c = Fs({
    cellPrefixCls: s,
    value: r,
    generateConfig: i,
    rangedValue: l.value,
    hoverRangedValue: u.value,
    isSameCell: (f, p) => _S(i, f, p),
    isInView: () => !0,
    offsetCell: (f, p) => i.addMonth(f, p * 3)
  }), d = i.setDate(i.setMonth(a, 0), 1);
  return m(Rr, L(L({}, t), {}, {
    rowNum: _4,
    colNum: M4,
    baseDate: d,
    getCellText: (f) => Yt(f, {
      locale: o,
      format: o.quarterFormat || "[Q]Q",
      generateConfig: i
    }),
    getCellClassName: c,
    getCellDate: (f, p) => i.addMonth(f, p * 3),
    titleCell: (f) => Yt(f, {
      locale: o,
      format: "YYYY-[Q]Q",
      generateConfig: i
    })
  }), null);
}
Kf.displayName = "QuarterBody";
Kf.inheritAttrs = !1;
function Uf(e) {
  const t = Mt(e), {
    prefixCls: n,
    operationRef: o,
    onViewDateChange: r,
    generateConfig: a,
    value: i,
    viewDate: l,
    onPanelChange: u,
    onSelect: s
  } = t, c = `${n}-quarter-panel`;
  o.value = {
    onKeydown: (f) => Pa(f, {
      onLeftRight: (p) => {
        s(a.addMonth(i || l, p * 3), "key");
      },
      onCtrlLeftRight: (p) => {
        s(a.addYear(i || l, p), "key");
      },
      onUpDown: (p) => {
        s(a.addYear(i || l, p), "key");
      }
    })
  };
  const d = (f) => {
    const p = a.addYear(l, f);
    r(p), u(null, p);
  };
  return m("div", {
    class: c
  }, [m(Wf, L(L({}, t), {}, {
    prefixCls: n,
    onPrevYear: () => {
      d(-1);
    },
    onNextYear: () => {
      d(1);
    },
    onYearClick: () => {
      u("year", l);
    }
  }), null), m(Kf, L(L({}, t), {}, {
    prefixCls: n,
    onSelect: (f) => {
      s(f, "mouse");
    }
  }), null)]);
}
Uf.displayName = "QuarterPanel";
Uf.inheritAttrs = !1;
function Gf(e) {
  const t = Mt(e), {
    prefixCls: n,
    generateConfig: o,
    viewDate: r,
    onPrevDecade: a,
    onNextDecade: i,
    onDecadeClick: l
  } = t, {
    hideHeader: u
  } = lo();
  if (u.value)
    return null;
  const s = `${n}-header`, c = o.getYear(r), d = Math.floor(c / jo) * jo, f = d + jo - 1;
  return m(er, L(L({}, t), {}, {
    prefixCls: s,
    onSuperPrev: a,
    onSuperNext: i
  }), {
    default: () => [m("button", {
      type: "button",
      onClick: l,
      class: `${n}-decade-btn`
    }, [d, Se("-"), f])]
  });
}
Gf.displayName = "YearHeader";
Gf.inheritAttrs = !1;
const Kc = 3, hg = 4;
function Yf(e) {
  const t = Mt(e), {
    prefixCls: n,
    value: o,
    viewDate: r,
    locale: a,
    generateConfig: i
  } = t, {
    rangedValue: l,
    hoverRangedValue: u
  } = Oi(), s = `${n}-cell`, c = i.getYear(r), d = Math.floor(c / jo) * jo, f = d + jo - 1, p = i.setYear(r, d - Math.ceil((Kc * hg - jo) / 2)), v = (b) => {
    const y = i.getYear(b);
    return d <= y && y <= f;
  }, g = Fs({
    cellPrefixCls: s,
    value: o,
    generateConfig: i,
    rangedValue: l.value,
    hoverRangedValue: u.value,
    isSameCell: (b, y) => Ns(i, b, y),
    isInView: v,
    offsetCell: (b, y) => i.addYear(b, y)
  });
  return m(Rr, L(L({}, t), {}, {
    rowNum: hg,
    colNum: Kc,
    baseDate: p,
    getCellText: i.getYear,
    getCellClassName: g,
    getCellDate: i.addYear,
    titleCell: (b) => Yt(b, {
      locale: a,
      format: "YYYY",
      generateConfig: i
    })
  }), null);
}
Yf.displayName = "YearBody";
Yf.inheritAttrs = !1;
const jo = 10;
function Xf(e) {
  const t = Mt(e), {
    prefixCls: n,
    operationRef: o,
    onViewDateChange: r,
    generateConfig: a,
    value: i,
    viewDate: l,
    sourceMode: u,
    onSelect: s,
    onPanelChange: c
  } = t, d = `${n}-year-panel`;
  o.value = {
    onKeydown: (p) => Pa(p, {
      onLeftRight: (v) => {
        s(a.addYear(i || l, v), "key");
      },
      onCtrlLeftRight: (v) => {
        s(a.addYear(i || l, v * jo), "key");
      },
      onUpDown: (v) => {
        s(a.addYear(i || l, v * Kc), "key");
      },
      onEnter: () => {
        c(u === "date" ? "date" : "month", i || l);
      }
    })
  };
  const f = (p) => {
    const v = a.addYear(l, p * 10);
    r(v), c(null, v);
  };
  return m("div", {
    class: d
  }, [m(Gf, L(L({}, t), {}, {
    prefixCls: n,
    onPrevDecade: () => {
      f(-1);
    },
    onNextDecade: () => {
      f(1);
    },
    onDecadeClick: () => {
      c("decade", l);
    }
  }), null), m(Yf, L(L({}, t), {}, {
    prefixCls: n,
    onSelect: (p) => {
      c(u === "date" ? "date" : "month", p), s(p, "mouse");
    }
  }), null)]);
}
Xf.displayName = "YearPanel";
Xf.inheritAttrs = !1;
function LS(e, t, n) {
  return n ? m("div", {
    class: `${e}-footer-extra`
  }, [n(t)]) : null;
}
function HS(e) {
  let {
    prefixCls: t,
    components: n = {},
    needConfirmButton: o,
    onNow: r,
    onOk: a,
    okDisabled: i,
    showNow: l,
    locale: u
  } = e, s, c;
  if (o) {
    const d = n.button || "button";
    r && l !== !1 && (s = m("li", {
      class: `${t}-now`
    }, [m("a", {
      class: `${t}-now-btn`,
      onClick: r
    }, [u.now])])), c = o && m("li", {
      class: `${t}-ok`
    }, [m(d, {
      disabled: i,
      onClick: (f) => {
        f.stopPropagation(), a && a();
      }
    }, {
      default: () => [u.ok]
    })]);
  }
  return !s && !c ? null : m("ul", {
    class: `${t}-ranges`
  }, [s, c]);
}
function D4() {
  return J({
    name: "PickerPanel",
    inheritAttrs: !1,
    props: {
      prefixCls: String,
      locale: Object,
      generateConfig: Object,
      value: Object,
      defaultValue: Object,
      pickerValue: Object,
      defaultPickerValue: Object,
      disabledDate: Function,
      mode: String,
      picker: {
        type: String,
        default: "date"
      },
      tabindex: {
        type: [Number, String],
        default: 0
      },
      showNow: {
        type: Boolean,
        default: void 0
      },
      showTime: [Boolean, Object],
      showToday: Boolean,
      renderExtraFooter: Function,
      dateRender: Function,
      hideHeader: {
        type: Boolean,
        default: void 0
      },
      onSelect: Function,
      onChange: Function,
      onPanelChange: Function,
      onMousedown: Function,
      onPickerValueChange: Function,
      onOk: Function,
      components: Object,
      direction: String,
      hourStep: {
        type: Number,
        default: 1
      },
      minuteStep: {
        type: Number,
        default: 1
      },
      secondStep: {
        type: Number,
        default: 1
      }
    },
    setup(e, t) {
      let {
        attrs: n
      } = t;
      const o = T(() => e.picker === "date" && !!e.showTime || e.picker === "time"), r = T(() => 24 % e.hourStep === 0), a = T(() => 60 % e.minuteStep === 0), i = T(() => 60 % e.secondStep === 0);
      process.env.NODE_ENV !== "production" && Ve(() => {
        const {
          generateConfig: D,
          value: A,
          hourStep: H = 1,
          minuteStep: j = 1,
          secondStep: z = 1
        } = e;
        lt(!A || D.isValidate(A), "Invalidate date pass to `value`."), lt(!A || D.isValidate(A), "Invalidate date pass to `defaultValue`."), lt(r.value, `\`hourStep\` ${H} is invalid. It should be a factor of 24.`), lt(a.value, `\`minuteStep\` ${j} is invalid. It should be a factor of 60.`), lt(i.value, `\`secondStep\` ${z} is invalid. It should be a factor of 60.`);
      });
      const l = lo(), {
        operationRef: u,
        onSelect: s,
        hideRanges: c,
        defaultOpenValue: d
      } = l, {
        inRange: f,
        panelPosition: p,
        rangedValue: v,
        hoverRangedValue: g
      } = Oi(), b = G({}), [y, S] = Gt(null, {
        value: Je(e, "value"),
        defaultValue: e.defaultValue,
        postState: (D) => !D && (d != null && d.value) && e.picker === "time" ? d.value : D
      }), [w, C] = Gt(null, {
        value: Je(e, "pickerValue"),
        defaultValue: e.defaultPickerValue || y.value,
        postState: (D) => {
          const {
            generateConfig: A,
            showTime: H,
            defaultValue: j
          } = e, z = A.getNow();
          return D ? !y.value && e.showTime ? typeof H == "object" ? pl(A, Array.isArray(D) ? D[0] : D, H.defaultValue || z) : j ? pl(A, Array.isArray(D) ? D[0] : D, j) : pl(A, Array.isArray(D) ? D[0] : D, z) : D : z;
        }
      }), $ = (D) => {
        C(D), e.onPickerValueChange && e.onPickerValueChange(D);
      }, O = (D) => {
        const A = y4[e.picker];
        return A ? A(D) : D;
      }, [x, M] = Gt(() => e.picker === "time" ? "time" : O("date"), {
        value: Je(e, "mode")
      });
      le(() => e.picker, () => {
        M(e.picker);
      });
      const _ = G(x.value), N = (D) => {
        _.value = D;
      }, I = (D, A) => {
        const {
          onPanelChange: H,
          generateConfig: j
        } = e, z = O(D || x.value);
        N(x.value), M(z), H && (x.value !== z || ta(j, w.value, w.value)) && H(A, z);
      }, E = function(D, A) {
        let H = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
        const {
          picker: j,
          generateConfig: z,
          onSelect: F,
          onChange: U,
          disabledDate: Q
        } = e;
        (x.value === j || H) && (S(D), F && F(D), s && s(D, A), U && !ta(z, D, y.value) && !(Q != null && Q(D)) && U(D));
      }, B = (D) => b.value && b.value.onKeydown ? ([ee.LEFT, ee.RIGHT, ee.UP, ee.DOWN, ee.PAGE_UP, ee.PAGE_DOWN, ee.ENTER].includes(D.which) && D.preventDefault(), b.value.onKeydown(D)) : (lt(!1, "Panel not correct handle keyDown event. Please help to fire issue about this."), !1), k = (D) => {
        b.value && b.value.onBlur && b.value.onBlur(D);
      }, P = () => {
        const {
          generateConfig: D,
          hourStep: A,
          minuteStep: H,
          secondStep: j
        } = e, z = D.getNow(), F = c4(D.getHour(z), D.getMinute(z), D.getSecond(z), r.value ? A : 1, a.value ? H : 1, i.value ? j : 1), U = IS(
          D,
          z,
          F[0],
          // hour
          F[1],
          // minute
          F[2]
        );
        E(U, "submit");
      }, R = T(() => {
        const {
          prefixCls: D,
          direction: A
        } = e;
        return ae(`${D}-panel`, {
          [`${D}-panel-has-range`]: v && v.value && v.value[0] && v.value[1],
          [`${D}-panel-has-range-hover`]: g && g.value && g.value[0] && g.value[1],
          [`${D}-panel-rtl`]: A === "rtl"
        });
      });
      return Df(h(h({}, l), {
        mode: x,
        hideHeader: T(() => {
          var D;
          return e.hideHeader !== void 0 ? e.hideHeader : (D = l.hideHeader) === null || D === void 0 ? void 0 : D.value;
        }),
        hidePrevBtn: T(() => f.value && p.value === "right"),
        hideNextBtn: T(() => f.value && p.value === "left")
      })), le(() => e.value, () => {
        e.value && C(e.value);
      }), () => {
        const {
          prefixCls: D = "ant-picker",
          locale: A,
          generateConfig: H,
          disabledDate: j,
          picker: z = "date",
          tabindex: F = 0,
          showNow: U,
          showTime: Q,
          showToday: q,
          renderExtraFooter: oe,
          onMousedown: Z,
          onOk: ne,
          components: Y
        } = e;
        u && p.value !== "right" && (u.value = {
          onKeydown: B,
          onClose: () => {
            b.value && b.value.onClose && b.value.onClose();
          }
        });
        let V;
        const X = h(h(h({}, n), e), {
          operationRef: b,
          prefixCls: D,
          viewDate: w.value,
          value: y.value,
          onViewDateChange: $,
          sourceMode: _.value,
          onPanelChange: I,
          disabledDate: j
        });
        switch (delete X.onChange, delete X.onSelect, x.value) {
          case "decade":
            V = m(Rf, L(L({}, X), {}, {
              onSelect: (ge, we) => {
                $(ge), E(ge, we);
              }
            }), null);
            break;
          case "year":
            V = m(Xf, L(L({}, X), {}, {
              onSelect: (ge, we) => {
                $(ge), E(ge, we);
              }
            }), null);
            break;
          case "month":
            V = m(Vf, L(L({}, X), {}, {
              onSelect: (ge, we) => {
                $(ge), E(ge, we);
              }
            }), null);
            break;
          case "quarter":
            V = m(Uf, L(L({}, X), {}, {
              onSelect: (ge, we) => {
                $(ge), E(ge, we);
              }
            }), null);
            break;
          case "week":
            V = m(Hf, L(L({}, X), {}, {
              onSelect: (ge, we) => {
                $(ge), E(ge, we);
              }
            }), null);
            break;
          case "time":
            delete X.showTime, V = m(Rs, L(L(L({}, X), typeof Q == "object" ? Q : null), {}, {
              onSelect: (ge, we) => {
                $(ge), E(ge, we);
              }
            }), null);
            break;
          default:
            Q ? V = m(Lf, L(L({}, X), {}, {
              onSelect: (ge, we) => {
                $(ge), E(ge, we);
              }
            }), null) : V = m(Pi, L(L({}, X), {}, {
              onSelect: (ge, we) => {
                $(ge), E(ge, we);
              }
            }), null);
        }
        let re, ie;
        c != null && c.value || (re = LS(D, x.value, oe), ie = HS({
          prefixCls: D,
          components: Y,
          needConfirmButton: o.value,
          okDisabled: !y.value || j && j(y.value),
          locale: A,
          showNow: U,
          onNow: o.value && P,
          onOk: () => {
            y.value && (E(y.value, "submit", !0), ne && ne(y.value));
          }
        }));
        let he;
        if (q && x.value === "date" && z === "date" && !Q) {
          const ge = H.getNow(), we = `${D}-today-btn`, Le = j && j(ge);
          he = m("a", {
            class: ae(we, Le && `${we}-disabled`),
            "aria-disabled": Le,
            onClick: () => {
              Le || E(ge, "mouse", !0);
            }
          }, [A.today]);
        }
        return m("div", {
          tabindex: F,
          class: ae(R.value, n.class),
          style: n.style,
          onKeydown: B,
          onBlur: k,
          onMousedown: Z
        }, [V, re || ie || he ? m("div", {
          class: `${D}-footer`
        }, [re, ie, he]) : null]);
      };
    }
  });
}
const A4 = D4(), zS = (e) => m(A4, e), N4 = {
  bottomLeft: {
    points: ["tl", "bl"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  bottomRight: {
    points: ["tr", "br"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  topLeft: {
    points: ["bl", "tl"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  topRight: {
    points: ["br", "tr"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  }
};
function jS(e, t) {
  let {
    slots: n
  } = t;
  const {
    prefixCls: o,
    popupStyle: r,
    visible: a,
    dropdownClassName: i,
    dropdownAlign: l,
    transitionName: u,
    getPopupContainer: s,
    range: c,
    popupPlacement: d,
    direction: f
  } = Mt(e), p = `${o}-dropdown`;
  return m(wa, {
    showAction: [],
    hideAction: [],
    popupPlacement: d !== void 0 ? d : f === "rtl" ? "bottomRight" : "bottomLeft",
    builtinPlacements: N4,
    prefixCls: p,
    popupTransitionName: u,
    popupAlign: l,
    popupVisible: a,
    popupClassName: ae(i, {
      [`${p}-range`]: c,
      [`${p}-rtl`]: f === "rtl"
    }),
    popupStyle: r,
    getPopupContainer: s
  }, {
    default: n.default,
    popup: n.popupElement
  });
}
const VS = J({
  name: "PresetPanel",
  props: {
    prefixCls: String,
    presets: {
      type: Array,
      default: () => []
    },
    onClick: Function,
    onHover: Function
  },
  setup(e) {
    return () => e.presets.length ? m("div", {
      class: `${e.prefixCls}-presets`
    }, [m("ul", null, [e.presets.map((t, n) => {
      let {
        label: o,
        value: r
      } = t;
      return m("li", {
        key: n,
        onClick: () => {
          e.onClick(r);
        },
        onMouseenter: () => {
          var a;
          (a = e.onHover) === null || a === void 0 || a.call(e, r);
        },
        onMouseleave: () => {
          var a;
          (a = e.onHover) === null || a === void 0 || a.call(e, null);
        }
      }, [o]);
    })])]) : null;
  }
});
function Uc(e) {
  let {
    open: t,
    value: n,
    isClickOutside: o,
    triggerOpen: r,
    forwardKeydown: a,
    onKeydown: i,
    blurToCancel: l,
    onSubmit: u,
    onCancel: s,
    onFocus: c,
    onBlur: d
  } = e;
  const f = K(!1), p = K(!1), v = K(!1), g = K(!1), b = K(!1), y = T(() => ({
    onMousedown: () => {
      f.value = !0, r(!0);
    },
    onKeydown: (w) => {
      if (i(w, () => {
        b.value = !0;
      }), !b.value) {
        switch (w.which) {
          case ee.ENTER: {
            t.value ? u() !== !1 && (f.value = !0) : r(!0), w.preventDefault();
            return;
          }
          case ee.TAB: {
            f.value && t.value && !w.shiftKey ? (f.value = !1, w.preventDefault()) : !f.value && t.value && !a(w) && w.shiftKey && (f.value = !0, w.preventDefault());
            return;
          }
          case ee.ESC: {
            f.value = !0, s();
            return;
          }
        }
        !t.value && ![ee.SHIFT].includes(w.which) ? r(!0) : f.value || a(w);
      }
    },
    onFocus: (w) => {
      f.value = !0, p.value = !0, c && c(w);
    },
    onBlur: (w) => {
      if (v.value || !o(document.activeElement)) {
        v.value = !1;
        return;
      }
      l.value ? setTimeout(() => {
        let {
          activeElement: C
        } = document;
        for (; C && C.shadowRoot; )
          C = C.shadowRoot.activeElement;
        o(C) && s();
      }, 0) : t.value && (r(!1), g.value && u()), p.value = !1, d && d(w);
    }
  }));
  le(t, () => {
    g.value = !1;
  }), le(n, () => {
    g.value = !0;
  });
  const S = K();
  return ze(() => {
    S.value = p4((w) => {
      const C = v4(w);
      if (t.value) {
        const $ = o(C);
        $ ? (!p.value || $) && r(!1) : (v.value = !0, Ue(() => {
          v.value = !1;
        }));
      }
    });
  }), at(() => {
    S.value && S.value();
  }), [y, {
    focused: p,
    typing: f
  }];
}
function Gc(e) {
  let {
    valueTexts: t,
    onTextChange: n
  } = e;
  const o = G("");
  function r(i) {
    o.value = i, n(i);
  }
  function a() {
    o.value = t.value[0];
  }
  return le(() => [...t.value], function(i) {
    let l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    i.join("||") !== l.join("||") && t.value.every((u) => u !== o.value) && a();
  }, {
    immediate: !0
  }), [o, r, a];
}
function Xl(e, t) {
  let {
    formatList: n,
    generateConfig: o,
    locale: r
  } = t;
  const a = Jd(() => {
    if (!e.value)
      return [[""], ""];
    let u = "";
    const s = [];
    for (let c = 0; c < n.value.length; c += 1) {
      const d = n.value[c], f = Yt(e.value, {
        generateConfig: o.value,
        locale: r.value,
        format: d
      });
      s.push(f), c === 0 && (u = f);
    }
    return [s, u];
  }, [e, n], (u, s) => s[0] !== u[0] || !Kr(s[1], u[1])), i = T(() => a.value[0]), l = T(() => a.value[1]);
  return [i, l];
}
function Yc(e, t) {
  let {
    formatList: n,
    generateConfig: o,
    locale: r
  } = t;
  const a = G(null);
  let i;
  function l(d) {
    let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (Ue.cancel(i), f) {
      a.value = d;
      return;
    }
    i = Ue(() => {
      a.value = d;
    });
  }
  const [, u] = Xl(a, {
    formatList: n,
    generateConfig: o,
    locale: r
  });
  function s(d) {
    l(d);
  }
  function c() {
    let d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    l(null, d);
  }
  return le(e, () => {
    c(!0);
  }), at(() => {
    Ue.cancel(i);
  }), [u, s, c];
}
function WS(e, t) {
  return T(() => e != null && e.value ? e.value : t != null && t.value ? (yn(!1, "`ranges` is deprecated. Please use `presets` instead."), Object.keys(t.value).map((o) => {
    const r = t.value[o], a = typeof r == "function" ? r() : r;
    return {
      label: o,
      value: a
    };
  })) : []);
}
function KS(e) {
  const {
    picker: t,
    disabledHours: n,
    disabledMinutes: o,
    disabledSeconds: r
  } = e;
  t === "time" && (n || o || r) && lt(!1, "'disabledHours', 'disabledMinutes', 'disabledSeconds' will be removed in the next major version, please use 'disabledTime' instead.");
}
function R4() {
  return J({
    name: "Picker",
    inheritAttrs: !1,
    props: ["prefixCls", "id", "tabindex", "dropdownClassName", "dropdownAlign", "popupStyle", "transitionName", "generateConfig", "locale", "inputReadOnly", "allowClear", "autofocus", "showTime", "showNow", "showHour", "showMinute", "showSecond", "picker", "format", "use12Hours", "value", "defaultValue", "open", "defaultOpen", "defaultOpenValue", "suffixIcon", "presets", "clearIcon", "disabled", "disabledDate", "placeholder", "getPopupContainer", "panelRender", "inputRender", "onChange", "onOpenChange", "onPanelChange", "onFocus", "onBlur", "onMousedown", "onMouseup", "onMouseenter", "onMouseleave", "onContextmenu", "onClick", "onKeydown", "onSelect", "direction", "autocomplete", "showToday", "renderExtraFooter", "dateRender", "minuteStep", "hourStep", "secondStep", "hideDisabledOptions"],
    setup(e, t) {
      let {
        attrs: n,
        expose: o
      } = t;
      const r = G(null), a = T(() => e.presets), i = WS(a), l = T(() => {
        var j;
        return (j = e.picker) !== null && j !== void 0 ? j : "date";
      }), u = T(() => l.value === "date" && !!e.showTime || l.value === "time");
      process.env.NODE_ENV !== "production" && KS(e);
      const s = T(() => RS(TS(e.format, l.value, e.showTime, e.use12Hours))), c = G(null), d = G(null), f = G(null), [p, v] = Gt(null, {
        value: Je(e, "value"),
        defaultValue: e.defaultValue
      }), g = G(p.value), b = (j) => {
        g.value = j;
      }, y = G(null), [S, w] = Gt(!1, {
        value: Je(e, "open"),
        defaultValue: e.defaultOpen,
        postState: (j) => e.disabled ? !1 : j,
        onChange: (j) => {
          e.onOpenChange && e.onOpenChange(j), !j && y.value && y.value.onClose && y.value.onClose();
        }
      }), [C, $] = Xl(g, {
        formatList: s,
        generateConfig: Je(e, "generateConfig"),
        locale: Je(e, "locale")
      }), [O, x, M] = Gc({
        valueTexts: C,
        onTextChange: (j) => {
          const z = AS(j, {
            locale: e.locale,
            formatList: s.value,
            generateConfig: e.generateConfig
          });
          z && (!e.disabledDate || !e.disabledDate(z)) && b(z);
        }
      }), _ = (j) => {
        const {
          onChange: z,
          generateConfig: F,
          locale: U
        } = e;
        b(j), v(j), z && !ta(F, p.value, j) && z(j, j ? Yt(j, {
          generateConfig: F,
          locale: U,
          format: s.value[0]
        }) : "");
      }, N = (j) => {
        e.disabled && j || w(j);
      }, I = (j) => S.value && y.value && y.value.onKeydown ? y.value.onKeydown(j) : (lt(!1, "Picker not correct forward Keydown operation. Please help to fire issue about this."), !1), E = function() {
        e.onMouseup && e.onMouseup(...arguments), r.value && (r.value.focus(), N(!0));
      }, [B, {
        focused: k,
        typing: P
      }] = Uc({
        blurToCancel: u,
        open: S,
        value: O,
        triggerOpen: N,
        forwardKeydown: I,
        isClickOutside: (j) => !MS([c.value, d.value, f.value], j),
        onSubmit: () => (
          // When user typing disabledDate with keyboard and enter, this value will be empty
          !g.value || // Normal disabled check
          e.disabledDate && e.disabledDate(g.value) ? !1 : (_(g.value), N(!1), M(), !0)
        ),
        onCancel: () => {
          N(!1), b(p.value), M();
        },
        onKeydown: (j, z) => {
          var F;
          (F = e.onKeydown) === null || F === void 0 || F.call(e, j, z);
        },
        onFocus: (j) => {
          var z;
          (z = e.onFocus) === null || z === void 0 || z.call(e, j);
        },
        onBlur: (j) => {
          var z;
          (z = e.onBlur) === null || z === void 0 || z.call(e, j);
        }
      });
      le([S, C], () => {
        S.value || (b(p.value), !C.value.length || C.value[0] === "" ? x("") : $.value !== O.value && M());
      }), le(l, () => {
        S.value || M();
      }), le(p, () => {
        b(p.value);
      });
      const [R, D, A] = Yc(O, {
        formatList: s,
        generateConfig: Je(e, "generateConfig"),
        locale: Je(e, "locale")
      }), H = (j, z) => {
        (z === "submit" || z !== "key" && !u.value) && (_(j), N(!1));
      };
      return Df({
        operationRef: y,
        hideHeader: T(() => l.value === "time"),
        onSelect: H,
        open: S,
        defaultOpenValue: Je(e, "defaultOpenValue"),
        onDateMouseenter: D,
        onDateMouseleave: A
      }), o({
        focus: () => {
          r.value && r.value.focus();
        },
        blur: () => {
          r.value && r.value.blur();
        }
      }), () => {
        const {
          prefixCls: j = "rc-picker",
          id: z,
          tabindex: F,
          dropdownClassName: U,
          dropdownAlign: Q,
          popupStyle: q,
          transitionName: oe,
          generateConfig: Z,
          locale: ne,
          inputReadOnly: Y,
          allowClear: V,
          autofocus: X,
          picker: re = "date",
          defaultOpenValue: ie,
          suffixIcon: he,
          clearIcon: ge,
          disabled: we,
          placeholder: Le,
          getPopupContainer: be,
          panelRender: pe,
          onMousedown: xe,
          onMouseenter: Ne,
          onMouseleave: ye,
          onContextmenu: Ce,
          onClick: Te,
          onSelect: te,
          direction: se,
          autocomplete: Pe = "off"
        } = e, _e = h(h(h({}, e), n), {
          class: ae({
            [`${j}-panel-focused`]: !P.value
          }),
          style: void 0,
          pickerValue: void 0,
          onPickerValueChange: void 0,
          onChange: null
        });
        let Ee = m("div", {
          class: `${j}-panel-layout`
        }, [m(VS, {
          prefixCls: j,
          presets: i.value,
          onClick: (Oe) => {
            _(Oe), N(!1);
          }
        }, null), m(zS, L(L({}, _e), {}, {
          generateConfig: Z,
          value: g.value,
          locale: ne,
          tabindex: -1,
          onSelect: (Oe) => {
            te == null || te(Oe), b(Oe);
          },
          direction: se,
          onPanelChange: (Oe, De) => {
            const {
              onPanelChange: je
            } = e;
            A(!0), je == null || je(Oe, De);
          }
        }), null)]);
        pe && (Ee = pe(Ee));
        const Be = m("div", {
          class: `${j}-panel-container`,
          ref: c,
          onMousedown: (Oe) => {
            Oe.preventDefault();
          }
        }, [Ee]);
        let ue;
        he && (ue = m("span", {
          class: `${j}-suffix`
        }, [he]));
        let fe;
        V && p.value && !we && (fe = m("span", {
          onMousedown: (Oe) => {
            Oe.preventDefault(), Oe.stopPropagation();
          },
          onMouseup: (Oe) => {
            Oe.preventDefault(), Oe.stopPropagation(), _(null), N(!1);
          },
          class: `${j}-clear`,
          role: "button"
        }, [ge || m("span", {
          class: `${j}-clear-btn`
        }, null)]));
        const ve = h(h(h(h({
          id: z,
          tabindex: F,
          disabled: we,
          readonly: Y || typeof s.value[0] == "function" || !P.value,
          value: R.value || O.value,
          onInput: (Oe) => {
            x(Oe.target.value);
          },
          autofocus: X,
          placeholder: Le,
          ref: r,
          title: O.value
        }, B.value), {
          size: ES(re, s.value[0], Z)
        }), FS(e)), {
          autocomplete: Pe
        }), Ie = e.inputRender ? e.inputRender(ve) : m("input", ve, null);
        process.env.NODE_ENV !== "production" && lt(!ie, "`defaultOpenValue` may confuse user for the current value status. Please use `defaultValue` instead.");
        const Fe = se === "rtl" ? "bottomRight" : "bottomLeft";
        return m("div", {
          ref: f,
          class: ae(j, n.class, {
            [`${j}-disabled`]: we,
            [`${j}-focused`]: k.value,
            [`${j}-rtl`]: se === "rtl"
          }),
          style: n.style,
          onMousedown: xe,
          onMouseup: E,
          onMouseenter: Ne,
          onMouseleave: ye,
          onContextmenu: Ce,
          onClick: Te
        }, [m("div", {
          class: ae(`${j}-input`, {
            [`${j}-input-placeholder`]: !!R.value
          }),
          ref: d
        }, [Ie, ue, fe]), m(jS, {
          visible: S.value,
          popupStyle: q,
          prefixCls: j,
          dropdownClassName: U,
          dropdownAlign: Q,
          getPopupContainer: be,
          transitionName: oe,
          popupPlacement: Fe,
          direction: se
        }, {
          default: () => [m("div", {
            style: {
              pointerEvents: "none",
              position: "absolute",
              top: 0,
              bottom: 0,
              left: 0,
              right: 0
            }
          }, null)],
          popupElement: () => Be
        })]);
      };
    }
  });
}
const F4 = R4();
function B4(e, t) {
  let {
    picker: n,
    locale: o,
    selectedValue: r,
    disabledDate: a,
    disabled: i,
    generateConfig: l
  } = e;
  const u = T(() => rt(r.value, 0)), s = T(() => rt(r.value, 1));
  function c(g) {
    return l.value.locale.getWeekFirstDate(o.value.locale, g);
  }
  function d(g) {
    const b = l.value.getYear(g), y = l.value.getMonth(g);
    return b * 100 + y;
  }
  function f(g) {
    const b = l.value.getYear(g), y = Vc(l.value, g);
    return b * 10 + y;
  }
  return [(g) => {
    var b;
    if (a && (!((b = a == null ? void 0 : a.value) === null || b === void 0) && b.call(a, g)))
      return !0;
    if (i[1] && s)
      return !vo(l.value, g, s.value) && l.value.isAfter(g, s.value);
    if (t.value[1] && s.value)
      switch (n.value) {
        case "quarter":
          return f(g) > f(s.value);
        case "month":
          return d(g) > d(s.value);
        case "week":
          return c(g) > c(s.value);
        default:
          return !vo(l.value, g, s.value) && l.value.isAfter(g, s.value);
      }
    return !1;
  }, (g) => {
    var b;
    if (!((b = a.value) === null || b === void 0) && b.call(a, g))
      return !0;
    if (i[0] && u)
      return !vo(l.value, g, s.value) && l.value.isAfter(u.value, g);
    if (t.value[0] && u.value)
      switch (n.value) {
        case "quarter":
          return f(g) < f(u.value);
        case "month":
          return d(g) < d(u.value);
        case "week":
          return c(g) < c(u.value);
        default:
          return !vo(l.value, g, u.value) && l.value.isAfter(u.value, g);
      }
    return !1;
  }];
}
function k4(e, t, n, o) {
  const r = qa(e, n, o, 1);
  function a(i) {
    return i(e, t) ? "same" : i(r, t) ? "closing" : "far";
  }
  switch (n) {
    case "year":
      return a((i, l) => S4(o, i, l));
    case "quarter":
    case "month":
      return a((i, l) => Ns(o, i, l));
    default:
      return a((i, l) => Ff(o, i, l));
  }
}
function L4(e, t, n, o) {
  const r = rt(e, 0), a = rt(e, 1);
  if (t === 0)
    return r;
  if (r && a)
    switch (k4(r, a, n, o)) {
      case "same":
        return r;
      case "closing":
        return r;
      default:
        return qa(a, n, o, -1);
    }
  return r;
}
function H4(e) {
  let {
    values: t,
    picker: n,
    defaultDates: o,
    generateConfig: r
  } = e;
  const a = G([rt(o, 0), rt(o, 1)]), i = G(null), l = T(() => rt(t.value, 0)), u = T(() => rt(t.value, 1)), s = (p) => a.value[p] ? a.value[p] : rt(i.value, p) || L4(t.value, p, n.value, r.value) || l.value || u.value || r.value.getNow(), c = G(null), d = G(null);
  Ve(() => {
    c.value = s(0), d.value = s(1);
  });
  function f(p, v) {
    if (p) {
      let g = _n(i.value, p, v);
      a.value = _n(a.value, null, v) || [null, null];
      const b = (v + 1) % 2;
      rt(t.value, b) || (g = _n(g, p, b)), i.value = g;
    } else
      (l.value || u.value) && (i.value = null);
  }
  return [c, d, f];
}
function z4(e) {
  return cw() ? (dw(e), !0) : !1;
}
function j4(e) {
  return typeof e == "function" ? e() : Ye(e);
}
function US(e) {
  var t;
  const n = j4(e);
  return (t = n == null ? void 0 : n.$el) !== null && t !== void 0 ? t : n;
}
function V4(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  On() ? ze(e) : t ? e() : mt(e);
}
function W4(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  const n = K(), o = () => n.value = !!e();
  return o(), V4(o, t), n;
}
var Eu;
const GS = typeof window < "u";
GS && (!((Eu = window == null ? void 0 : window.navigator) === null || Eu === void 0) && Eu.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
const K4 = GS ? window : void 0;
var U4 = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function G4(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    window: o = K4
  } = n, r = U4(n, ["window"]);
  let a;
  const i = W4(() => o && "ResizeObserver" in o), l = () => {
    a && (a.disconnect(), a = void 0);
  }, u = le(() => US(e), (c) => {
    l(), i.value && o && c && (a = new ResizeObserver(t), a.observe(c, r));
  }, {
    immediate: !0,
    flush: "post"
  }), s = () => {
    l(), u();
  };
  return z4(s), {
    isSupported: i,
    stop: s
  };
}
function ka(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    width: 0,
    height: 0
  }, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    box: o = "content-box"
  } = n, r = K(t.width), a = K(t.height);
  return G4(e, (i) => {
    let [l] = i;
    const u = o === "border-box" ? l.borderBoxSize : o === "content-box" ? l.contentBoxSize : l.devicePixelContentBoxSize;
    u ? (r.value = u.reduce((s, c) => {
      let {
        inlineSize: d
      } = c;
      return s + d;
    }, 0), a.value = u.reduce((s, c) => {
      let {
        blockSize: d
      } = c;
      return s + d;
    }, 0)) : (r.value = l.contentRect.width, a.value = l.contentRect.height);
  }, n), le(() => US(e), (i) => {
    r.value = i ? t.width : 0, a.value = i ? t.height : 0;
  }), {
    width: r,
    height: a
  };
}
function bg(e, t) {
  return e && e[0] && e[1] && t.isAfter(e[0], e[1]) ? [e[1], e[0]] : e;
}
function yg(e, t, n, o) {
  return !!(e || o && o[t] || n[(t + 1) % 2]);
}
function Y4() {
  return J({
    name: "RangerPicker",
    inheritAttrs: !1,
    props: ["prefixCls", "id", "popupStyle", "dropdownClassName", "transitionName", "dropdownAlign", "getPopupContainer", "generateConfig", "locale", "placeholder", "autofocus", "disabled", "format", "picker", "showTime", "showNow", "showHour", "showMinute", "showSecond", "use12Hours", "separator", "value", "defaultValue", "defaultPickerValue", "open", "defaultOpen", "disabledDate", "disabledTime", "dateRender", "panelRender", "ranges", "allowEmpty", "allowClear", "suffixIcon", "clearIcon", "pickerRef", "inputReadOnly", "mode", "renderExtraFooter", "onChange", "onOpenChange", "onPanelChange", "onCalendarChange", "onFocus", "onBlur", "onMousedown", "onMouseup", "onMouseenter", "onMouseleave", "onClick", "onOk", "onKeydown", "components", "order", "direction", "activePickerIndex", "autocomplete", "minuteStep", "hourStep", "secondStep", "hideDisabledOptions", "disabledMinutes", "presets", "prevIcon", "nextIcon", "superPrevIcon", "superNextIcon"],
    setup(e, t) {
      let {
        attrs: n,
        expose: o
      } = t;
      const r = T(() => e.picker === "date" && !!e.showTime || e.picker === "time"), a = T(() => e.presets), i = T(() => e.ranges), l = WS(a, i), u = G({}), s = G(null), c = G(null), d = G(null), f = G(null), p = G(null), v = G(null), g = G(null), b = G(null);
      process.env.NODE_ENV !== "production" && KS(e);
      const y = T(() => RS(TS(e.format, e.picker, e.showTime, e.use12Hours))), [S, w] = Gt(0, {
        value: Je(e, "activePickerIndex")
      }), C = G(null), $ = T(() => {
        const {
          disabled: me
        } = e;
        return Array.isArray(me) ? me : [me || !1, me || !1];
      }), [O, x] = Gt(null, {
        value: Je(e, "value"),
        defaultValue: e.defaultValue,
        postState: (me) => e.picker === "time" && !e.order ? me : bg(me, e.generateConfig)
      }), [M, _, N] = H4({
        values: O,
        picker: Je(e, "picker"),
        defaultDates: e.defaultPickerValue,
        generateConfig: Je(e, "generateConfig")
      }), [I, E] = Gt(O.value, {
        postState: (me) => {
          let Re = me;
          if ($.value[0] && $.value[1])
            return Re;
          for (let Ae = 0; Ae < 2; Ae += 1)
            $.value[Ae] && !rt(Re, Ae) && !rt(e.allowEmpty, Ae) && (Re = _n(Re, e.generateConfig.getNow(), Ae));
          return Re;
        }
      }), [B, k] = Gt([e.picker, e.picker], {
        value: Je(e, "mode")
      });
      le(() => e.picker, () => {
        k([e.picker, e.picker]);
      });
      const P = (me, Re) => {
        var Ae;
        k(me), (Ae = e.onPanelChange) === null || Ae === void 0 || Ae.call(e, Re, me);
      }, [R, D] = B4({
        picker: Je(e, "picker"),
        selectedValue: I,
        locale: Je(e, "locale"),
        disabled: $,
        disabledDate: Je(e, "disabledDate"),
        generateConfig: Je(e, "generateConfig")
      }, u), [A, H] = Gt(!1, {
        value: Je(e, "open"),
        defaultValue: e.defaultOpen,
        postState: (me) => $.value[S.value] ? !1 : me,
        onChange: (me) => {
          var Re;
          (Re = e.onOpenChange) === null || Re === void 0 || Re.call(e, me), !me && C.value && C.value.onClose && C.value.onClose();
        }
      }), j = T(() => A.value && S.value === 0), z = T(() => A.value && S.value === 1), F = G(0), U = G(0), Q = G(0), {
        width: q
      } = ka(s);
      le([A, q], () => {
        !A.value && s.value && (Q.value = q.value);
      });
      const {
        width: oe
      } = ka(c), {
        width: Z
      } = ka(b), {
        width: ne
      } = ka(d), {
        width: Y
      } = ka(p);
      le([S, A, oe, Z, ne, Y, () => e.direction], () => {
        U.value = 0, S.value ? d.value && p.value && (U.value = ne.value + Y.value, oe.value && Z.value && U.value > oe.value - Z.value - (e.direction === "rtl" || b.value.offsetLeft > U.value ? 0 : b.value.offsetLeft) && (F.value = U.value)) : S.value === 0 && (F.value = 0);
      }, {
        immediate: !0
      });
      const V = G();
      function X(me, Re) {
        if (me)
          clearTimeout(V.value), u.value[Re] = !0, w(Re), H(me), A.value || N(null, Re);
        else if (S.value === Re) {
          H(me);
          const Ae = u.value;
          V.value = setTimeout(() => {
            Ae === u.value && (u.value = {});
          });
        }
      }
      function re(me) {
        X(!0, me), setTimeout(() => {
          const Re = [v, g][me];
          Re.value && Re.value.focus();
        }, 0);
      }
      function ie(me, Re) {
        let Ae = me, vt = rt(Ae, 0), _t = rt(Ae, 1);
        const {
          generateConfig: It,
          locale: ln,
          picker: jt,
          order: Zn,
          onCalendarChange: mn,
          allowEmpty: Pn,
          onChange: St,
          showTime: kn
        } = e;
        vt && _t && It.isAfter(vt, _t) && (// WeekPicker only compare week
        jt === "week" && !DS(It, ln.locale, vt, _t) || // QuotaPicker only compare week
        jt === "quarter" && !_S(It, vt, _t) || // Other non-TimePicker compare date
        jt !== "week" && jt !== "quarter" && jt !== "time" && !(kn ? ta(It, vt, _t) : vo(It, vt, _t)) ? (Re === 0 ? (Ae = [vt, null], _t = null) : (vt = null, Ae = [null, _t]), u.value = {
          [Re]: !0
        }) : (jt !== "time" || Zn !== !1) && (Ae = bg(Ae, It))), E(Ae);
        const In = Ae && Ae[0] ? Yt(Ae[0], {
          generateConfig: It,
          locale: ln,
          format: y.value[0]
        }) : "", _o = Ae && Ae[1] ? Yt(Ae[1], {
          generateConfig: It,
          locale: ln,
          format: y.value[0]
        }) : "";
        mn && mn(Ae, [In, _o], {
          range: Re === 0 ? "start" : "end"
        });
        const Do = yg(vt, 0, $.value, Pn), Ln = yg(_t, 1, $.value, Pn);
        (Ae === null || Do && Ln) && (x(Ae), St && (!ta(It, rt(O.value, 0), vt) || !ta(It, rt(O.value, 1), _t)) && St(Ae, [In, _o]));
        let Hn = null;
        Re === 0 && !$.value[1] ? Hn = 1 : Re === 1 && !$.value[0] && (Hn = 0), Hn !== null && Hn !== S.value && (!u.value[Hn] || !rt(Ae, Hn)) && rt(Ae, Re) ? re(Hn) : X(!1, Re);
      }
      const he = (me) => A && C.value && C.value.onKeydown ? C.value.onKeydown(me) : (lt(!1, "Picker not correct forward Keydown operation. Please help to fire issue about this."), !1), ge = {
        formatList: y,
        generateConfig: Je(e, "generateConfig"),
        locale: Je(e, "locale")
      }, [we, Le] = Xl(T(() => rt(I.value, 0)), ge), [be, pe] = Xl(T(() => rt(I.value, 1)), ge), xe = (me, Re) => {
        const Ae = AS(me, {
          locale: e.locale,
          formatList: y.value,
          generateConfig: e.generateConfig
        });
        Ae && !(Re === 0 ? R : D)(Ae) && (E(_n(I.value, Ae, Re)), N(Ae, Re));
      }, [Ne, ye, Ce] = Gc({
        valueTexts: we,
        onTextChange: (me) => xe(me, 0)
      }), [Te, te, se] = Gc({
        valueTexts: be,
        onTextChange: (me) => xe(me, 1)
      }), [Pe, _e] = yt(null), [Ee, Be] = yt(null), [ue, fe, ve] = Yc(Ne, ge), [Ie, Fe, Oe] = Yc(Te, ge), De = (me) => {
        Be(_n(I.value, me, S.value)), S.value === 0 ? fe(me) : Fe(me);
      }, je = () => {
        Be(_n(I.value, null, S.value)), S.value === 0 ? ve() : Oe();
      }, et = (me, Re) => ({
        forwardKeydown: he,
        onBlur: (Ae) => {
          var vt;
          (vt = e.onBlur) === null || vt === void 0 || vt.call(e, Ae);
        },
        isClickOutside: (Ae) => !MS([c.value, d.value, f.value, s.value], Ae),
        onFocus: (Ae) => {
          var vt;
          w(me), (vt = e.onFocus) === null || vt === void 0 || vt.call(e, Ae);
        },
        triggerOpen: (Ae) => {
          X(Ae, me);
        },
        onSubmit: () => {
          if (
            // When user typing disabledDate with keyboard and enter, this value will be empty
            !I.value || // Normal disabled check
            e.disabledDate && e.disabledDate(I.value[me])
          )
            return !1;
          ie(I.value, me), Re();
        },
        onCancel: () => {
          X(!1, me), E(O.value), Re();
        }
      }), [Ge, {
        focused: tt,
        typing: ut
      }] = Uc(h(h({}, et(0, Ce)), {
        blurToCancel: r,
        open: j,
        value: Ne,
        onKeydown: (me, Re) => {
          var Ae;
          (Ae = e.onKeydown) === null || Ae === void 0 || Ae.call(e, me, Re);
        }
      })), [Bt, {
        focused: Jt,
        typing: en
      }] = Uc(h(h({}, et(1, se)), {
        blurToCancel: r,
        open: z,
        value: Te,
        onKeydown: (me, Re) => {
          var Ae;
          (Ae = e.onKeydown) === null || Ae === void 0 || Ae.call(e, me, Re);
        }
      })), zt = (me) => {
        var Re;
        (Re = e.onClick) === null || Re === void 0 || Re.call(e, me), !A.value && !v.value.contains(me.target) && !g.value.contains(me.target) && ($.value[0] ? $.value[1] || re(1) : re(0));
      }, an = (me) => {
        var Re;
        (Re = e.onMousedown) === null || Re === void 0 || Re.call(e, me), A.value && (tt.value || Jt.value) && !v.value.contains(me.target) && !g.value.contains(me.target) && me.preventDefault();
      }, Bn = T(() => {
        var me;
        return !((me = O.value) === null || me === void 0) && me[0] ? Yt(O.value[0], {
          locale: e.locale,
          format: "YYYYMMDDHHmmss",
          generateConfig: e.generateConfig
        }) : "";
      }), Eo = T(() => {
        var me;
        return !((me = O.value) === null || me === void 0) && me[1] ? Yt(O.value[1], {
          locale: e.locale,
          format: "YYYYMMDDHHmmss",
          generateConfig: e.generateConfig
        }) : "";
      });
      le([A, we, be], () => {
        A.value || (E(O.value), !we.value.length || we.value[0] === "" ? ye("") : Le.value !== Ne.value && Ce(), !be.value.length || be.value[0] === "" ? te("") : pe.value !== Te.value && se());
      }), le([Bn, Eo], () => {
        E(O.value);
      }), process.env.NODE_ENV !== "production" && Ve(() => {
        const {
          value: me,
          disabled: Re
        } = e;
        me && Array.isArray(Re) && (rt(Re, 0) && !rt(me, 0) || rt(Re, 1) && !rt(me, 1)) && lt(!1, "`disabled` should not set with empty `value`. You should set `allowEmpty` or `value` instead.");
      }), o({
        focus: () => {
          v.value && v.value.focus();
        },
        blur: () => {
          v.value && v.value.blur(), g.value && g.value.blur();
        }
      });
      const Mo = T(() => A.value && Ee.value && Ee.value[0] && Ee.value[1] && e.generateConfig.isAfter(Ee.value[1], Ee.value[0]) ? Ee.value : null);
      function tr() {
        let me = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, Re = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          generateConfig: Ae,
          showTime: vt,
          dateRender: _t,
          direction: It,
          disabledTime: ln,
          prefixCls: jt,
          locale: Zn
        } = e;
        let mn = vt;
        if (vt && typeof vt == "object" && vt.defaultValue) {
          const St = vt.defaultValue;
          mn = h(h({}, vt), {
            defaultValue: rt(St, S.value) || void 0
          });
        }
        let Pn = null;
        return _t && (Pn = (St) => {
          let {
            current: kn,
            today: In
          } = St;
          return _t({
            current: kn,
            today: In,
            info: {
              range: S.value ? "end" : "start"
            }
          });
        }), m(I4, {
          value: {
            inRange: !0,
            panelPosition: me,
            rangedValue: Pe.value || I.value,
            hoverRangedValue: Mo.value
          }
        }, {
          default: () => [m(zS, L(L(L({}, e), Re), {}, {
            dateRender: Pn,
            showTime: mn,
            mode: B.value[S.value],
            generateConfig: Ae,
            style: void 0,
            direction: It,
            disabledDate: S.value === 0 ? R : D,
            disabledTime: (St) => ln ? ln(St, S.value === 0 ? "start" : "end") : !1,
            class: ae({
              [`${jt}-panel-focused`]: S.value === 0 ? !ut.value : !en.value
            }),
            value: rt(I.value, S.value),
            locale: Zn,
            tabIndex: -1,
            onPanelChange: (St, kn) => {
              S.value === 0 && ve(!0), S.value === 1 && Oe(!0), P(_n(B.value, kn, S.value), _n(I.value, St, S.value));
              let In = St;
              me === "right" && B.value[S.value] === kn && (In = qa(In, kn, Ae, -1)), N(In, S.value);
            },
            onOk: null,
            onSelect: void 0,
            onChange: void 0,
            defaultValue: S.value === 0 ? rt(I.value, 1) : rt(I.value, 0)
          }), null)]
        });
      }
      const Ma = (me, Re) => {
        const Ae = _n(I.value, me, S.value);
        Re === "submit" || Re !== "key" && !r.value ? (ie(Ae, S.value), S.value === 0 ? ve() : Oe()) : E(Ae);
      };
      return Df({
        operationRef: C,
        hideHeader: T(() => e.picker === "time"),
        onDateMouseenter: De,
        onDateMouseleave: je,
        hideRanges: T(() => !0),
        onSelect: Ma,
        open: A
      }), () => {
        const {
          prefixCls: me = "rc-picker",
          id: Re,
          popupStyle: Ae,
          dropdownClassName: vt,
          transitionName: _t,
          dropdownAlign: It,
          getPopupContainer: ln,
          generateConfig: jt,
          locale: Zn,
          placeholder: mn,
          autofocus: Pn,
          picker: St = "date",
          showTime: kn,
          separator: In = "~",
          disabledDate: _o,
          panelRender: Do,
          allowClear: Ln,
          suffixIcon: Br,
          clearIcon: Hn,
          inputReadOnly: Xs,
          renderExtraFooter: XC,
          onMouseenter: qC,
          onMouseleave: QC,
          onMouseup: ZC,
          onOk: Rp,
          components: JC,
          direction: _a,
          autocomplete: Fp = "off"
        } = e, ew = _a === "rtl" ? {
          right: `${U.value}px`
        } : {
          left: `${U.value}px`
        };
        function tw() {
          let sn;
          const Ao = LS(me, B.value[S.value], XC), Hp = HS({
            prefixCls: me,
            components: JC,
            needConfirmButton: r.value,
            okDisabled: !rt(I.value, S.value) || _o && _o(I.value[S.value]),
            locale: Zn,
            onOk: () => {
              rt(I.value, S.value) && (ie(I.value, S.value), Rp && Rp(I.value));
            }
          });
          if (St !== "time" && !kn) {
            const No = S.value === 0 ? M.value : _.value, rw = qa(No, St, jt), Js = B.value[S.value] === St, zp = tr(Js ? "left" : !1, {
              pickerValue: No,
              onPickerValueChange: (eu) => {
                N(eu, S.value);
              }
            }), jp = tr("right", {
              pickerValue: rw,
              onPickerValueChange: (eu) => {
                N(qa(eu, St, jt, -1), S.value);
              }
            });
            _a === "rtl" ? sn = m(We, null, [jp, Js && zp]) : sn = m(We, null, [zp, Js && jp]);
          } else
            sn = tr();
          let Zs = m("div", {
            class: `${me}-panel-layout`
          }, [m(VS, {
            prefixCls: me,
            presets: l.value,
            onClick: (No) => {
              ie(No, null), X(!1, S.value);
            },
            onHover: (No) => {
              _e(No);
            }
          }, null), m("div", null, [m("div", {
            class: `${me}-panels`
          }, [sn]), (Ao || Hp) && m("div", {
            class: `${me}-footer`
          }, [Ao, Hp])])]);
          return Do && (Zs = Do(Zs)), m("div", {
            class: `${me}-panel-container`,
            style: {
              marginLeft: `${F.value}px`
            },
            ref: c,
            onMousedown: (No) => {
              No.preventDefault();
            }
          }, [Zs]);
        }
        const nw = m("div", {
          class: ae(`${me}-range-wrapper`, `${me}-${St}-range-wrapper`),
          style: {
            minWidth: `${Q.value}px`
          }
        }, [m("div", {
          ref: b,
          class: `${me}-range-arrow`,
          style: ew
        }, null), tw()]);
        let Bp;
        Br && (Bp = m("span", {
          class: `${me}-suffix`
        }, [Br]));
        let kp;
        Ln && (rt(O.value, 0) && !$.value[0] || rt(O.value, 1) && !$.value[1]) && (kp = m("span", {
          onMousedown: (sn) => {
            sn.preventDefault(), sn.stopPropagation();
          },
          onMouseup: (sn) => {
            sn.preventDefault(), sn.stopPropagation();
            let Ao = O.value;
            $.value[0] || (Ao = _n(Ao, null, 0)), $.value[1] || (Ao = _n(Ao, null, 1)), ie(Ao, null), X(!1, S.value);
          },
          class: `${me}-clear`
        }, [Hn || m("span", {
          class: `${me}-clear-btn`
        }, null)]));
        const Lp = {
          size: ES(St, y.value[0], jt)
        };
        let qs = 0, Qs = 0;
        d.value && f.value && p.value && (S.value === 0 ? Qs = d.value.offsetWidth : (qs = U.value, Qs = f.value.offsetWidth));
        const ow = _a === "rtl" ? {
          right: `${qs}px`
        } : {
          left: `${qs}px`
        };
        return m("div", L({
          ref: s,
          class: ae(me, `${me}-range`, n.class, {
            [`${me}-disabled`]: $.value[0] && $.value[1],
            [`${me}-focused`]: S.value === 0 ? tt.value : Jt.value,
            [`${me}-rtl`]: _a === "rtl"
          }),
          style: n.style,
          onClick: zt,
          onMouseenter: qC,
          onMouseleave: QC,
          onMousedown: an,
          onMouseup: ZC
        }, FS(e)), [m("div", {
          class: ae(`${me}-input`, {
            [`${me}-input-active`]: S.value === 0,
            [`${me}-input-placeholder`]: !!ue.value
          }),
          ref: d
        }, [m("input", L(L(L({
          id: Re,
          disabled: $.value[0],
          readonly: Xs || typeof y.value[0] == "function" || !ut.value,
          value: ue.value || Ne.value,
          onInput: (sn) => {
            ye(sn.target.value);
          },
          autofocus: Pn,
          placeholder: rt(mn, 0) || "",
          ref: v
        }, Ge.value), Lp), {}, {
          autocomplete: Fp
        }), null)]), m("div", {
          class: `${me}-range-separator`,
          ref: p
        }, [In]), m("div", {
          class: ae(`${me}-input`, {
            [`${me}-input-active`]: S.value === 1,
            [`${me}-input-placeholder`]: !!Ie.value
          }),
          ref: f
        }, [m("input", L(L(L({
          disabled: $.value[1],
          readonly: Xs || typeof y.value[0] == "function" || !en.value,
          value: Ie.value || Te.value,
          onInput: (sn) => {
            te(sn.target.value);
          },
          placeholder: rt(mn, 1) || "",
          ref: g
        }, Bt.value), Lp), {}, {
          autocomplete: Fp
        }), null)]), m("div", {
          class: `${me}-active-bar`,
          style: h(h({}, ow), {
            width: `${Qs}px`,
            position: "absolute"
          })
        }, null), Bp, kp, m(jS, {
          visible: A.value,
          popupStyle: Ae,
          prefixCls: me,
          dropdownClassName: vt,
          dropdownAlign: It,
          getPopupContainer: ln,
          transitionName: _t,
          range: !0,
          direction: _a
        }, {
          default: () => [m("div", {
            style: {
              pointerEvents: "none",
              position: "absolute",
              top: 0,
              bottom: 0,
              left: 0,
              right: 0
            }
          }, null)],
          popupElement: () => nw
        })]);
      };
    }
  });
}
const X4 = Y4();
var q4 = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const Q4 = {
  prefixCls: String,
  name: String,
  id: String,
  type: String,
  defaultChecked: {
    type: [Boolean, Number],
    default: void 0
  },
  checked: {
    type: [Boolean, Number],
    default: void 0
  },
  disabled: Boolean,
  tabindex: {
    type: [Number, String]
  },
  readonly: Boolean,
  autofocus: Boolean,
  value: W.any,
  required: Boolean
}, YS = J({
  compatConfig: {
    MODE: 3
  },
  name: "Checkbox",
  inheritAttrs: !1,
  props: bt(Q4, {
    prefixCls: "rc-checkbox",
    type: "checkbox",
    defaultChecked: !1
  }),
  emits: ["click", "change"],
  setup(e, t) {
    let {
      attrs: n,
      emit: o,
      expose: r
    } = t;
    const a = G(e.checked === void 0 ? e.defaultChecked : e.checked), i = G();
    le(() => e.checked, () => {
      a.value = e.checked;
    }), r({
      focus() {
        var c;
        (c = i.value) === null || c === void 0 || c.focus();
      },
      blur() {
        var c;
        (c = i.value) === null || c === void 0 || c.blur();
      }
    });
    const l = G(), u = (c) => {
      if (e.disabled)
        return;
      e.checked === void 0 && (a.value = c.target.checked), c.shiftKey = l.value;
      const d = {
        target: h(h({}, e), {
          checked: c.target.checked
        }),
        stopPropagation() {
          c.stopPropagation();
        },
        preventDefault() {
          c.preventDefault();
        },
        nativeEvent: c
      };
      e.checked !== void 0 && (i.value.checked = !!e.checked), o("change", d), l.value = !1;
    }, s = (c) => {
      o("click", c), l.value = c.shiftKey;
    };
    return () => {
      const {
        prefixCls: c,
        name: d,
        id: f,
        type: p,
        disabled: v,
        readonly: g,
        tabindex: b,
        autofocus: y,
        value: S,
        required: w
      } = e, C = q4(e, ["prefixCls", "name", "id", "type", "disabled", "readonly", "tabindex", "autofocus", "value", "required"]), {
        class: $,
        onFocus: O,
        onBlur: x,
        onKeydown: M,
        onKeypress: _,
        onKeyup: N
      } = n, I = h(h({}, C), n), E = Object.keys(I).reduce((P, R) => ((R.startsWith("data-") || R.startsWith("aria-") || R === "role") && (P[R] = I[R]), P), {}), B = ae(c, $, {
        [`${c}-checked`]: a.value,
        [`${c}-disabled`]: v
      }), k = h(h({
        name: d,
        id: f,
        type: p,
        readonly: g,
        disabled: v,
        tabindex: b,
        class: `${c}-input`,
        checked: !!a.value,
        autofocus: y,
        value: S
      }, E), {
        onChange: u,
        onClick: s,
        onFocus: O,
        onBlur: x,
        onKeydown: M,
        onKeypress: _,
        onKeyup: N,
        required: w
      });
      return m("span", {
        class: B
      }, [m("input", L({
        ref: i
      }, k), null), m("span", {
        class: `${c}-inner`
      }, null)]);
    };
  }
}), XS = Symbol("radioGroupContextKey"), Z4 = (e) => {
  ot(XS, e);
}, J4 = () => nt(XS, void 0), qS = Symbol("radioOptionTypeContextKey"), e3 = (e) => {
  ot(qS, e);
}, t3 = () => nt(qS, void 0), n3 = new Xe("antRadioEffect", {
  "0%": {
    transform: "scale(1)",
    opacity: 0.5
  },
  "100%": {
    transform: "scale(1.6)",
    opacity: 0
  }
}), o3 = (e) => {
  const {
    componentCls: t,
    antCls: n
  } = e, o = `${t}-group`;
  return {
    [o]: h(h({}, st(e)), {
      display: "inline-block",
      fontSize: 0,
      // RTL
      [`&${o}-rtl`]: {
        direction: "rtl"
      },
      [`${n}-badge ${n}-badge-count`]: {
        zIndex: 1
      },
      [`> ${n}-badge:not(:first-child) > ${n}-button-wrapper`]: {
        borderInlineStart: "none"
      }
    })
  };
}, r3 = (e) => {
  const {
    componentCls: t,
    radioWrapperMarginRight: n,
    radioCheckedColor: o,
    radioSize: r,
    motionDurationSlow: a,
    motionDurationMid: i,
    motionEaseInOut: l,
    motionEaseInOutCirc: u,
    radioButtonBg: s,
    colorBorder: c,
    lineWidth: d,
    radioDotSize: f,
    colorBgContainerDisabled: p,
    colorTextDisabled: v,
    paddingXS: g,
    radioDotDisabledColor: b,
    lineType: y,
    radioDotDisabledSize: S,
    wireframe: w,
    colorWhite: C
  } = e, $ = `${t}-inner`;
  return {
    [`${t}-wrapper`]: h(h({}, st(e)), {
      position: "relative",
      display: "inline-flex",
      alignItems: "baseline",
      marginInlineStart: 0,
      marginInlineEnd: n,
      cursor: "pointer",
      // RTL
      [`&${t}-wrapper-rtl`]: {
        direction: "rtl"
      },
      "&-disabled": {
        cursor: "not-allowed",
        color: e.colorTextDisabled
      },
      "&::after": {
        display: "inline-block",
        width: 0,
        overflow: "hidden",
        content: '"\\a0"'
      },
      // hashId 在 wrapper 上，只能铺平
      [`${t}-checked::after`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        width: "100%",
        height: "100%",
        border: `${d}px ${y} ${o}`,
        borderRadius: "50%",
        visibility: "hidden",
        animationName: n3,
        animationDuration: a,
        animationTimingFunction: l,
        animationFillMode: "both",
        content: '""'
      },
      [t]: h(h({}, st(e)), {
        position: "relative",
        display: "inline-block",
        outline: "none",
        cursor: "pointer",
        alignSelf: "center"
      }),
      [`${t}-wrapper:hover &,
        &:hover ${$}`]: {
        borderColor: o
      },
      [`${t}-input:focus-visible + ${$}`]: h({}, Sr(e)),
      [`${t}:hover::after, ${t}-wrapper:hover &::after`]: {
        visibility: "visible"
      },
      [`${t}-inner`]: {
        "&::after": {
          boxSizing: "border-box",
          position: "absolute",
          insetBlockStart: "50%",
          insetInlineStart: "50%",
          display: "block",
          width: r,
          height: r,
          marginBlockStart: r / -2,
          marginInlineStart: r / -2,
          backgroundColor: w ? o : C,
          borderBlockStart: 0,
          borderInlineStart: 0,
          borderRadius: r,
          transform: "scale(0)",
          opacity: 0,
          transition: `all ${a} ${u}`,
          content: '""'
        },
        boxSizing: "border-box",
        position: "relative",
        insetBlockStart: 0,
        insetInlineStart: 0,
        display: "block",
        width: r,
        height: r,
        backgroundColor: s,
        borderColor: c,
        borderStyle: "solid",
        borderWidth: d,
        borderRadius: "50%",
        transition: `all ${i}`
      },
      [`${t}-input`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineEnd: 0,
        insetBlockEnd: 0,
        insetInlineStart: 0,
        zIndex: 1,
        cursor: "pointer",
        opacity: 0
      },
      // 选中状态
      [`${t}-checked`]: {
        [$]: {
          borderColor: o,
          backgroundColor: w ? s : o,
          "&::after": {
            transform: `scale(${f / r})`,
            opacity: 1,
            transition: `all ${a} ${u}`
          }
        }
      },
      [`${t}-disabled`]: {
        cursor: "not-allowed",
        [$]: {
          backgroundColor: p,
          borderColor: c,
          cursor: "not-allowed",
          "&::after": {
            backgroundColor: b
          }
        },
        [`${t}-input`]: {
          cursor: "not-allowed"
        },
        [`${t}-disabled + span`]: {
          color: v,
          cursor: "not-allowed"
        },
        [`&${t}-checked`]: {
          [$]: {
            "&::after": {
              transform: `scale(${S / r})`
            }
          }
        }
      },
      [`span${t} + *`]: {
        paddingInlineStart: g,
        paddingInlineEnd: g
      }
    })
  };
}, a3 = (e) => {
  const {
    radioButtonColor: t,
    controlHeight: n,
    componentCls: o,
    lineWidth: r,
    lineType: a,
    colorBorder: i,
    motionDurationSlow: l,
    motionDurationMid: u,
    radioButtonPaddingHorizontal: s,
    fontSize: c,
    radioButtonBg: d,
    fontSizeLG: f,
    controlHeightLG: p,
    controlHeightSM: v,
    paddingXS: g,
    borderRadius: b,
    borderRadiusSM: y,
    borderRadiusLG: S,
    radioCheckedColor: w,
    radioButtonCheckedBg: C,
    radioButtonHoverColor: $,
    radioButtonActiveColor: O,
    radioSolidCheckedColor: x,
    colorTextDisabled: M,
    colorBgContainerDisabled: _,
    radioDisabledButtonCheckedColor: N,
    radioDisabledButtonCheckedBg: I
  } = e;
  return {
    [`${o}-button-wrapper`]: {
      position: "relative",
      display: "inline-block",
      height: n,
      margin: 0,
      paddingInline: s,
      paddingBlock: 0,
      color: t,
      fontSize: c,
      lineHeight: `${n - r * 2}px`,
      background: d,
      border: `${r}px ${a} ${i}`,
      // strange align fix for chrome but works
      // https://gw.alipayobjects.com/zos/rmsportal/VFTfKXJuogBAXcvfAUWJ.gif
      borderBlockStartWidth: r + 0.02,
      borderInlineStartWidth: 0,
      borderInlineEndWidth: r,
      cursor: "pointer",
      transition: [`color ${u}`, `background ${u}`, `border-color ${u}`, `box-shadow ${u}`].join(","),
      a: {
        color: t
      },
      [`> ${o}-button`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        zIndex: -1,
        width: "100%",
        height: "100%"
      },
      "&:not(:first-child)": {
        "&::before": {
          position: "absolute",
          insetBlockStart: -r,
          insetInlineStart: -r,
          display: "block",
          boxSizing: "content-box",
          width: 1,
          height: "100%",
          paddingBlock: r,
          paddingInline: 0,
          backgroundColor: i,
          transition: `background-color ${l}`,
          content: '""'
        }
      },
      "&:first-child": {
        borderInlineStart: `${r}px ${a} ${i}`,
        borderStartStartRadius: b,
        borderEndStartRadius: b
      },
      "&:last-child": {
        borderStartEndRadius: b,
        borderEndEndRadius: b
      },
      "&:first-child:last-child": {
        borderRadius: b
      },
      [`${o}-group-large &`]: {
        height: p,
        fontSize: f,
        lineHeight: `${p - r * 2}px`,
        "&:first-child": {
          borderStartStartRadius: S,
          borderEndStartRadius: S
        },
        "&:last-child": {
          borderStartEndRadius: S,
          borderEndEndRadius: S
        }
      },
      [`${o}-group-small &`]: {
        height: v,
        paddingInline: g - r,
        paddingBlock: 0,
        lineHeight: `${v - r * 2}px`,
        "&:first-child": {
          borderStartStartRadius: y,
          borderEndStartRadius: y
        },
        "&:last-child": {
          borderStartEndRadius: y,
          borderEndEndRadius: y
        }
      },
      "&:hover": {
        position: "relative",
        color: w
      },
      "&:has(:focus-visible)": h({}, Sr(e)),
      [`${o}-inner, input[type='checkbox'], input[type='radio']`]: {
        width: 0,
        height: 0,
        opacity: 0,
        pointerEvents: "none"
      },
      [`&-checked:not(${o}-button-wrapper-disabled)`]: {
        zIndex: 1,
        color: w,
        background: C,
        borderColor: w,
        "&::before": {
          backgroundColor: w
        },
        "&:first-child": {
          borderColor: w
        },
        "&:hover": {
          color: $,
          borderColor: $,
          "&::before": {
            backgroundColor: $
          }
        },
        "&:active": {
          color: O,
          borderColor: O,
          "&::before": {
            backgroundColor: O
          }
        }
      },
      [`${o}-group-solid &-checked:not(${o}-button-wrapper-disabled)`]: {
        color: x,
        background: w,
        borderColor: w,
        "&:hover": {
          color: x,
          background: $,
          borderColor: $
        },
        "&:active": {
          color: x,
          background: O,
          borderColor: O
        }
      },
      "&-disabled": {
        color: M,
        backgroundColor: _,
        borderColor: i,
        cursor: "not-allowed",
        "&:first-child, &:hover": {
          color: M,
          backgroundColor: _,
          borderColor: i
        }
      },
      [`&-disabled${o}-button-wrapper-checked`]: {
        color: N,
        backgroundColor: I,
        borderColor: i,
        boxShadow: "none"
      }
    }
  };
}, QS = ht("Radio", (e) => {
  const {
    padding: t,
    lineWidth: n,
    controlItemBgActiveDisabled: o,
    colorTextDisabled: r,
    colorBgContainer: a,
    fontSizeLG: i,
    controlOutline: l,
    colorPrimaryHover: u,
    colorPrimaryActive: s,
    colorText: c,
    colorPrimary: d,
    marginXS: f,
    controlOutlineWidth: p,
    colorTextLightSolid: v,
    wireframe: g
  } = e, b = `0 0 0 ${p}px ${l}`, y = b, S = i, w = 4, C = S - w * 2, $ = g ? C : S - (w + n) * 2, O = d, x = c, M = u, _ = s, N = t - n, B = qe(e, {
    radioFocusShadow: b,
    radioButtonFocusShadow: y,
    radioSize: S,
    radioDotSize: $,
    radioDotDisabledSize: C,
    radioCheckedColor: O,
    radioDotDisabledColor: r,
    radioSolidCheckedColor: v,
    radioButtonBg: a,
    radioButtonCheckedBg: a,
    radioButtonColor: x,
    radioButtonHoverColor: M,
    radioButtonActiveColor: _,
    radioButtonPaddingHorizontal: N,
    radioDisabledButtonCheckedBg: o,
    radioDisabledButtonCheckedColor: r,
    radioWrapperMarginRight: f
  });
  return [o3(B), r3(B), a3(B)];
});
var i3 = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const ZS = () => ({
  prefixCls: String,
  checked: Me(),
  disabled: Me(),
  isGroup: Me(),
  value: W.any,
  name: String,
  id: String,
  autofocus: Me(),
  onChange: de(),
  onFocus: de(),
  onBlur: de(),
  onClick: de(),
  "onUpdate:checked": de(),
  "onUpdate:value": de()
}), un = J({
  compatConfig: {
    MODE: 3
  },
  name: "ARadio",
  inheritAttrs: !1,
  props: ZS(),
  setup(e, t) {
    let {
      emit: n,
      expose: o,
      slots: r,
      attrs: a
    } = t;
    const i = Lt(), l = rn.useInject(), u = t3(), s = J4(), c = Cn(), d = T(() => {
      var M;
      return (M = g.value) !== null && M !== void 0 ? M : c.value;
    }), f = G(), {
      prefixCls: p,
      direction: v,
      disabled: g
    } = Ke("radio", e), b = T(() => (s == null ? void 0 : s.optionType.value) === "button" || u === "button" ? `${p.value}-button` : p.value), y = Cn(), [S, w] = QS(p);
    o({
      focus: () => {
        f.value.focus();
      },
      blur: () => {
        f.value.blur();
      }
    });
    const O = (M) => {
      const _ = M.target.checked;
      n("update:checked", _), n("update:value", _), n("change", M), i.onFieldChange();
    }, x = (M) => {
      n("change", M), s && s.onChange && s.onChange(M);
    };
    return () => {
      var M;
      const _ = s, {
        prefixCls: N,
        id: I = i.id.value
      } = e, E = i3(e, ["prefixCls", "id"]), B = h(h({
        prefixCls: b.value,
        id: I
      }, pt(E, ["onUpdate:checked", "onUpdate:value"])), {
        disabled: (M = g.value) !== null && M !== void 0 ? M : y.value
      });
      _ ? (B.name = _.name.value, B.onChange = x, B.checked = e.value === _.value.value, B.disabled = d.value || _.disabled.value) : B.onChange = O;
      const k = ae({
        [`${b.value}-wrapper`]: !0,
        [`${b.value}-wrapper-checked`]: B.checked,
        [`${b.value}-wrapper-disabled`]: B.disabled,
        [`${b.value}-wrapper-rtl`]: v.value === "rtl",
        [`${b.value}-wrapper-in-form-item`]: l.isFormItemInput
      }, a.class, w.value);
      return S(m("label", L(L({}, a), {}, {
        class: k
      }), [m(YS, L(L({}, B), {}, {
        type: "radio",
        ref: f
      }), null), r.default && m("span", null, [r.default()])]));
    };
  }
}), l3 = () => ({
  prefixCls: String,
  value: W.any,
  size: Ze(),
  options: Nt(),
  disabled: Me(),
  name: String,
  buttonStyle: Ze("outline"),
  id: String,
  optionType: Ze("default"),
  onChange: de(),
  "onUpdate:value": de()
}), qf = J({
  compatConfig: {
    MODE: 3
  },
  name: "ARadioGroup",
  inheritAttrs: !1,
  props: l3(),
  // emits: ['update:value', 'change'],
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: r
    } = t;
    const a = Lt(), {
      prefixCls: i,
      direction: l,
      size: u
    } = Ke("radio", e), [s, c] = QS(i), d = G(e.value), f = G(!1);
    return le(() => e.value, (v) => {
      d.value = v, f.value = !1;
    }), Z4({
      onChange: (v) => {
        const g = d.value, {
          value: b
        } = v.target;
        "value" in e || (d.value = b), !f.value && b !== g && (f.value = !0, o("update:value", b), o("change", v), a.onFieldChange()), mt(() => {
          f.value = !1;
        });
      },
      value: d,
      disabled: T(() => e.disabled),
      name: T(() => e.name),
      optionType: T(() => e.optionType)
    }), () => {
      var v;
      const {
        options: g,
        buttonStyle: b,
        id: y = a.id.value
      } = e, S = `${i.value}-group`, w = ae(S, `${S}-${b}`, {
        [`${S}-${u.value}`]: u.value,
        [`${S}-rtl`]: l.value === "rtl"
      }, r.class, c.value);
      let C = null;
      return g && g.length > 0 ? C = g.map(($) => {
        if (typeof $ == "string" || typeof $ == "number")
          return m(un, {
            key: $,
            prefixCls: i.value,
            disabled: e.disabled,
            value: $,
            checked: d.value === $
          }, {
            default: () => [$]
          });
        const {
          value: O,
          disabled: x,
          label: M
        } = $;
        return m(un, {
          key: `radio-group-value-options-${O}`,
          prefixCls: i.value,
          disabled: x || e.disabled,
          value: O,
          checked: d.value === O
        }, {
          default: () => [M]
        });
      }) : C = (v = n.default) === null || v === void 0 ? void 0 : v.call(n), s(m("div", L(L({}, r), {}, {
        class: w,
        id: y
      }), [C]));
    };
  }
}), s3 = J({
  compatConfig: {
    MODE: 3
  },
  name: "ARadioButton",
  inheritAttrs: !1,
  props: ZS(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r
    } = Ke("radio", e);
    return e3("button"), () => {
      var a;
      return m(un, L(L(L({}, o), e), {}, {
        prefixCls: r.value
      }), {
        default: () => [(a = n.default) === null || a === void 0 ? void 0 : a.call(n)]
      });
    };
  }
});
un.Group = qf;
un.Button = s3;
un.install = function(e) {
  return e.component(un.name, un), e.component(un.Group.name, un.Group), e.component(un.Button.name, un.Button), e;
};
const Qf = (e) => ({
  // Firefox
  "&::-moz-placeholder": {
    opacity: 1
  },
  "&::placeholder": {
    color: e,
    userSelect: "none"
    // https://github.com/ant-design/ant-design/pull/32639
  },
  "&:placeholder-shown": {
    textOverflow: "ellipsis"
  }
}), Ia = (e) => ({
  borderColor: e.inputBorderHoverColor,
  borderInlineEndWidth: e.lineWidth
}), Yo = (e) => ({
  borderColor: e.inputBorderHoverColor,
  boxShadow: `0 0 0 ${e.controlOutlineWidth}px ${e.controlOutline}`,
  borderInlineEndWidth: e.lineWidth,
  outline: 0
}), Zf = (e) => ({
  color: e.colorTextDisabled,
  backgroundColor: e.colorBgContainerDisabled,
  borderColor: e.colorBorder,
  boxShadow: "none",
  cursor: "not-allowed",
  opacity: 1,
  "&:hover": h({}, Ia(qe(e, {
    inputBorderHoverColor: e.colorBorder
  })))
}), JS = (e) => {
  const {
    inputPaddingVerticalLG: t,
    fontSizeLG: n,
    lineHeightLG: o,
    borderRadiusLG: r,
    inputPaddingHorizontalLG: a
  } = e;
  return {
    padding: `${t}px ${a}px`,
    fontSize: n,
    lineHeight: o,
    borderRadius: r
  };
}, e$ = (e) => ({
  padding: `${e.inputPaddingVerticalSM}px ${e.controlPaddingHorizontalSM - 1}px`,
  borderRadius: e.borderRadiusSM
}), Ii = (e, t) => {
  const {
    componentCls: n,
    colorError: o,
    colorWarning: r,
    colorErrorOutline: a,
    colorWarningOutline: i,
    colorErrorBorderHover: l,
    colorWarningBorderHover: u
  } = e;
  return {
    [`&-status-error:not(${t}-disabled):not(${t}-borderless)${t}`]: {
      borderColor: o,
      "&:hover": {
        borderColor: l
      },
      "&:focus, &-focused": h({}, Yo(qe(e, {
        inputBorderActiveColor: o,
        inputBorderHoverColor: o,
        controlOutline: a
      }))),
      [`${n}-prefix`]: {
        color: o
      }
    },
    [`&-status-warning:not(${t}-disabled):not(${t}-borderless)${t}`]: {
      borderColor: r,
      "&:hover": {
        borderColor: u
      },
      "&:focus, &-focused": h({}, Yo(qe(e, {
        inputBorderActiveColor: r,
        inputBorderHoverColor: r,
        controlOutline: i
      }))),
      [`${n}-prefix`]: {
        color: r
      }
    }
  };
}, Ta = (e) => h(h({
  position: "relative",
  display: "inline-block",
  width: "100%",
  minWidth: 0,
  padding: `${e.inputPaddingVertical}px ${e.inputPaddingHorizontal}px`,
  color: e.colorText,
  fontSize: e.fontSize,
  lineHeight: e.lineHeight,
  backgroundColor: e.colorBgContainer,
  backgroundImage: "none",
  borderWidth: e.lineWidth,
  borderStyle: e.lineType,
  borderColor: e.colorBorder,
  borderRadius: e.borderRadius,
  transition: `all ${e.motionDurationMid}`
}, Qf(e.colorTextPlaceholder)), {
  "&:hover": h({}, Ia(e)),
  "&:focus, &-focused": h({}, Yo(e)),
  "&-disabled, &[disabled]": h({}, Zf(e)),
  "&-borderless": {
    "&, &:hover, &:focus, &-focused, &-disabled, &[disabled]": {
      backgroundColor: "transparent",
      border: "none",
      boxShadow: "none"
    }
  },
  // Reset height for `textarea`s
  "textarea&": {
    maxWidth: "100%",
    height: "auto",
    minHeight: e.controlHeight,
    lineHeight: e.lineHeight,
    verticalAlign: "bottom",
    transition: `all ${e.motionDurationSlow}, height 0s`,
    resize: "vertical"
  },
  // Size
  "&-lg": h({}, JS(e)),
  "&-sm": h({}, e$(e)),
  // RTL
  "&-rtl": {
    direction: "rtl"
  },
  "&-textarea-rtl": {
    direction: "rtl"
  }
}), t$ = (e) => {
  const {
    componentCls: t,
    antCls: n
  } = e;
  return {
    position: "relative",
    display: "table",
    width: "100%",
    borderCollapse: "separate",
    borderSpacing: 0,
    // Undo padding and float of grid classes
    "&[class*='col-']": {
      paddingInlineEnd: e.paddingXS,
      "&:last-child": {
        paddingInlineEnd: 0
      }
    },
    // Sizing options
    [`&-lg ${t}, &-lg > ${t}-group-addon`]: h({}, JS(e)),
    [`&-sm ${t}, &-sm > ${t}-group-addon`]: h({}, e$(e)),
    [`> ${t}`]: {
      display: "table-cell",
      "&:not(:first-child):not(:last-child)": {
        borderRadius: 0
      }
    },
    [`${t}-group`]: {
      "&-addon, &-wrap": {
        display: "table-cell",
        width: 1,
        whiteSpace: "nowrap",
        verticalAlign: "middle",
        "&:not(:first-child):not(:last-child)": {
          borderRadius: 0
        }
      },
      "&-wrap > *": {
        display: "block !important"
      },
      "&-addon": {
        position: "relative",
        padding: `0 ${e.inputPaddingHorizontal}px`,
        color: e.colorText,
        fontWeight: "normal",
        fontSize: e.fontSize,
        textAlign: "center",
        backgroundColor: e.colorFillAlter,
        border: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`,
        borderRadius: e.borderRadius,
        transition: `all ${e.motionDurationSlow}`,
        lineHeight: 1,
        // Reset Select's style in addon
        [`${n}-select`]: {
          margin: `-${e.inputPaddingVertical + 1}px -${e.inputPaddingHorizontal}px`,
          [`&${n}-select-single:not(${n}-select-customize-input)`]: {
            [`${n}-select-selector`]: {
              backgroundColor: "inherit",
              border: `${e.lineWidth}px ${e.lineType} transparent`,
              boxShadow: "none"
            }
          },
          "&-open, &-focused": {
            [`${n}-select-selector`]: {
              color: e.colorPrimary
            }
          }
        },
        // https://github.com/ant-design/ant-design/issues/31333
        [`${n}-cascader-picker`]: {
          margin: `-9px -${e.inputPaddingHorizontal}px`,
          backgroundColor: "transparent",
          [`${n}-cascader-input`]: {
            textAlign: "start",
            border: 0,
            boxShadow: "none"
          }
        }
      },
      "&-addon:first-child": {
        borderInlineEnd: 0
      },
      "&-addon:last-child": {
        borderInlineStart: 0
      }
    },
    [`${t}`]: {
      float: "inline-start",
      width: "100%",
      marginBottom: 0,
      textAlign: "inherit",
      "&:focus": {
        zIndex: 1,
        borderInlineEndWidth: 1
      },
      "&:hover": {
        zIndex: 1,
        borderInlineEndWidth: 1,
        [`${t}-search-with-button &`]: {
          zIndex: 0
        }
      }
    },
    // Reset rounded corners
    [`> ${t}:first-child, ${t}-group-addon:first-child`]: {
      borderStartEndRadius: 0,
      borderEndEndRadius: 0,
      // Reset Select's style in addon
      [`${n}-select ${n}-select-selector`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${t}-affix-wrapper`]: {
      [`&:not(:first-child) ${t}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      },
      [`&:not(:last-child) ${t}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${t}:last-child, ${t}-group-addon:last-child`]: {
      borderStartStartRadius: 0,
      borderEndStartRadius: 0,
      // Reset Select's style in addon
      [`${n}-select ${n}-select-selector`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`${t}-affix-wrapper`]: {
      "&:not(:last-child)": {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
        [`${t}-search &`]: {
          borderStartStartRadius: e.borderRadius,
          borderEndStartRadius: e.borderRadius
        }
      },
      [`&:not(:first-child), ${t}-search &:not(:first-child)`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&${t}-group-compact`]: h(h({
      display: "block"
    }, ca()), {
      [`${t}-group-addon, ${t}-group-wrap, > ${t}`]: {
        "&:not(:first-child):not(:last-child)": {
          borderInlineEndWidth: e.lineWidth,
          "&:hover": {
            zIndex: 1
          },
          "&:focus": {
            zIndex: 1
          }
        }
      },
      "& > *": {
        display: "inline-block",
        float: "none",
        verticalAlign: "top",
        borderRadius: 0
      },
      [`& > ${t}-affix-wrapper`]: {
        display: "inline-flex"
      },
      [`& > ${n}-picker-range`]: {
        display: "inline-flex"
      },
      "& > *:not(:last-child)": {
        marginInlineEnd: -e.lineWidth,
        borderInlineEndWidth: e.lineWidth
      },
      // Undo float for .ant-input-group .ant-input
      [`${t}`]: {
        float: "none"
      },
      // reset border for Select, DatePicker, AutoComplete, Cascader, Mention, TimePicker, Input
      [`& > ${n}-select > ${n}-select-selector,
      & > ${n}-select-auto-complete ${t},
      & > ${n}-cascader-picker ${t},
      & > ${t}-group-wrapper ${t}`]: {
        borderInlineEndWidth: e.lineWidth,
        borderRadius: 0,
        "&:hover": {
          zIndex: 1
        },
        "&:focus": {
          zIndex: 1
        }
      },
      [`& > ${n}-select-focused`]: {
        zIndex: 1
      },
      // update z-index for arrow icon
      [`& > ${n}-select > ${n}-select-arrow`]: {
        zIndex: 1
        // https://github.com/ant-design/ant-design/issues/20371
      },
      [`& > *:first-child,
      & > ${n}-select:first-child > ${n}-select-selector,
      & > ${n}-select-auto-complete:first-child ${t},
      & > ${n}-cascader-picker:first-child ${t}`]: {
        borderStartStartRadius: e.borderRadius,
        borderEndStartRadius: e.borderRadius
      },
      [`& > *:last-child,
      & > ${n}-select:last-child > ${n}-select-selector,
      & > ${n}-cascader-picker:last-child ${t},
      & > ${n}-cascader-picker-focused:last-child ${t}`]: {
        borderInlineEndWidth: e.lineWidth,
        borderStartEndRadius: e.borderRadius,
        borderEndEndRadius: e.borderRadius
      },
      // https://github.com/ant-design/ant-design/issues/12493
      [`& > ${n}-select-auto-complete ${t}`]: {
        verticalAlign: "top"
      },
      [`${t}-group-wrapper + ${t}-group-wrapper`]: {
        marginInlineStart: -e.lineWidth,
        [`${t}-affix-wrapper`]: {
          borderRadius: 0
        }
      },
      [`${t}-group-wrapper:not(:last-child)`]: {
        [`&${t}-search > ${t}-group`]: {
          [`& > ${t}-group-addon > ${t}-search-button`]: {
            borderRadius: 0
          },
          [`& > ${t}`]: {
            borderStartStartRadius: e.borderRadius,
            borderStartEndRadius: 0,
            borderEndEndRadius: 0,
            borderEndStartRadius: e.borderRadius
          }
        }
      }
    }),
    [`&&-sm ${n}-btn`]: {
      fontSize: e.fontSizeSM,
      height: e.controlHeightSM,
      lineHeight: "normal"
    },
    [`&&-lg ${n}-btn`]: {
      fontSize: e.fontSizeLG,
      height: e.controlHeightLG,
      lineHeight: "normal"
    },
    // Fix https://github.com/ant-design/ant-design/issues/5754
    [`&&-lg ${n}-select-single ${n}-select-selector`]: {
      height: `${e.controlHeightLG}px`,
      [`${n}-select-selection-item, ${n}-select-selection-placeholder`]: {
        // -2 is for the border size & override default
        lineHeight: `${e.controlHeightLG - 2}px`
      },
      [`${n}-select-selection-search-input`]: {
        height: `${e.controlHeightLG}px`
      }
    },
    [`&&-sm ${n}-select-single ${n}-select-selector`]: {
      height: `${e.controlHeightSM}px`,
      [`${n}-select-selection-item, ${n}-select-selection-placeholder`]: {
        // -2 is for the border size & override default
        lineHeight: `${e.controlHeightSM - 2}px`
      },
      [`${n}-select-selection-search-input`]: {
        height: `${e.controlHeightSM}px`
      }
    }
  };
}, u3 = (e) => {
  const {
    componentCls: t,
    controlHeightSM: n,
    lineWidth: o
  } = e, a = (n - o * 2 - 16) / 2;
  return {
    [t]: h(h(h(h({}, st(e)), Ta(e)), Ii(e, t)), {
      '&[type="color"]': {
        height: e.controlHeight,
        [`&${t}-lg`]: {
          height: e.controlHeightLG
        },
        [`&${t}-sm`]: {
          height: n,
          paddingTop: a,
          paddingBottom: a
        }
      }
    })
  };
}, c3 = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    // ========================= Input =========================
    [`${t}-clear-icon`]: {
      margin: 0,
      color: e.colorTextQuaternary,
      fontSize: e.fontSizeIcon,
      verticalAlign: -1,
      // https://github.com/ant-design/ant-design/pull/18151
      // https://codesandbox.io/s/wizardly-sun-u10br
      cursor: "pointer",
      transition: `color ${e.motionDurationSlow}`,
      "&:hover": {
        color: e.colorTextTertiary
      },
      "&:active": {
        color: e.colorText
      },
      "&-hidden": {
        visibility: "hidden"
      },
      "&-has-suffix": {
        margin: `0 ${e.inputAffixPadding}px`
      }
    },
    // ======================= TextArea ========================
    "&-textarea-with-clear-btn": {
      padding: "0 !important",
      border: "0 !important",
      [`${t}-clear-icon`]: {
        position: "absolute",
        insetBlockStart: e.paddingXS,
        insetInlineEnd: e.paddingXS,
        zIndex: 1
      }
    }
  };
}, d3 = (e) => {
  const {
    componentCls: t,
    inputAffixPadding: n,
    colorTextDescription: o,
    motionDurationSlow: r,
    colorIcon: a,
    colorIconHover: i,
    iconCls: l
  } = e;
  return {
    [`${t}-affix-wrapper`]: h(h(h(h(h({}, Ta(e)), {
      display: "inline-flex",
      [`&:not(${t}-affix-wrapper-disabled):hover`]: h(h({}, Ia(e)), {
        zIndex: 1,
        [`${t}-search-with-button &`]: {
          zIndex: 0
        }
      }),
      "&-focused, &:focus": {
        zIndex: 1
      },
      "&-disabled": {
        [`${t}[disabled]`]: {
          background: "transparent"
        }
      },
      [`> input${t}`]: {
        padding: 0,
        fontSize: "inherit",
        border: "none",
        borderRadius: 0,
        outline: "none",
        "&:focus": {
          boxShadow: "none !important"
        }
      },
      "&::before": {
        width: 0,
        visibility: "hidden",
        content: '"\\a0"'
      },
      [`${t}`]: {
        "&-prefix, &-suffix": {
          display: "flex",
          flex: "none",
          alignItems: "center",
          "> *:not(:last-child)": {
            marginInlineEnd: e.paddingXS
          }
        },
        "&-show-count-suffix": {
          color: o
        },
        "&-show-count-has-suffix": {
          marginInlineEnd: e.paddingXXS
        },
        "&-prefix": {
          marginInlineEnd: n
        },
        "&-suffix": {
          marginInlineStart: n
        }
      }
    }), c3(e)), {
      // password
      [`${l}${t}-password-icon`]: {
        color: a,
        cursor: "pointer",
        transition: `all ${r}`,
        "&:hover": {
          color: i
        }
      }
    }), Ii(e, `${t}-affix-wrapper`))
  };
}, f3 = (e) => {
  const {
    componentCls: t,
    colorError: n,
    colorSuccess: o,
    borderRadiusLG: r,
    borderRadiusSM: a
  } = e;
  return {
    [`${t}-group`]: h(h(h({}, st(e)), t$(e)), {
      "&-rtl": {
        direction: "rtl"
      },
      "&-wrapper": {
        display: "inline-block",
        width: "100%",
        textAlign: "start",
        verticalAlign: "top",
        "&-rtl": {
          direction: "rtl"
        },
        // Size
        "&-lg": {
          [`${t}-group-addon`]: {
            borderRadius: r
          }
        },
        "&-sm": {
          [`${t}-group-addon`]: {
            borderRadius: a
          }
        },
        // Status
        "&-status-error": {
          [`${t}-group-addon`]: {
            color: n,
            borderColor: n
          }
        },
        "&-status-warning": {
          [`${t}-group-addon:last-child`]: {
            color: o,
            borderColor: o
          }
        }
      }
    })
  };
}, p3 = (e) => {
  const {
    componentCls: t,
    antCls: n
  } = e, o = `${t}-search`;
  return {
    [o]: {
      [`${t}`]: {
        "&:hover, &:focus": {
          borderColor: e.colorPrimaryHover,
          [`+ ${t}-group-addon ${o}-button:not(${n}-btn-primary)`]: {
            borderInlineStartColor: e.colorPrimaryHover
          }
        }
      },
      [`${t}-affix-wrapper`]: {
        borderRadius: 0
      },
      // fix slight height diff in Firefox:
      // https://ant.design/components/auto-complete-cn/#components-auto-complete-demo-certain-category
      [`${t}-lg`]: {
        lineHeight: e.lineHeightLG - 2e-4
      },
      [`> ${t}-group`]: {
        [`> ${t}-group-addon:last-child`]: {
          insetInlineStart: -1,
          padding: 0,
          border: 0,
          [`${o}-button`]: {
            paddingTop: 0,
            paddingBottom: 0,
            borderStartStartRadius: 0,
            borderStartEndRadius: e.borderRadius,
            borderEndEndRadius: e.borderRadius,
            borderEndStartRadius: 0
          },
          [`${o}-button:not(${n}-btn-primary)`]: {
            color: e.colorTextDescription,
            "&:hover": {
              color: e.colorPrimaryHover
            },
            "&:active": {
              color: e.colorPrimaryActive
            },
            [`&${n}-btn-loading::before`]: {
              insetInlineStart: 0,
              insetInlineEnd: 0,
              insetBlockStart: 0,
              insetBlockEnd: 0
            }
          }
        }
      },
      [`${o}-button`]: {
        height: e.controlHeight,
        "&:hover, &:focus": {
          zIndex: 1
        }
      },
      [`&-large ${o}-button`]: {
        height: e.controlHeightLG
      },
      [`&-small ${o}-button`]: {
        height: e.controlHeightSM
      },
      "&-rtl": {
        direction: "rtl"
      },
      // ===================== Compact Item Customized Styles =====================
      [`&${t}-compact-item`]: {
        [`&:not(${t}-compact-last-item)`]: {
          [`${t}-group-addon`]: {
            [`${t}-search-button`]: {
              marginInlineEnd: -e.lineWidth,
              borderRadius: 0
            }
          }
        },
        [`&:not(${t}-compact-first-item)`]: {
          [`${t},${t}-affix-wrapper`]: {
            borderRadius: 0
          }
        },
        [`> ${t}-group-addon ${t}-search-button,
        > ${t},
        ${t}-affix-wrapper`]: {
          "&:hover,&:focus,&:active": {
            zIndex: 2
          }
        },
        [`> ${t}-affix-wrapper-focused`]: {
          zIndex: 2
        }
      }
    }
  };
};
function ks(e) {
  return qe(e, {
    inputAffixPadding: e.paddingXXS,
    inputPaddingVertical: Math.max(Math.round((e.controlHeight - e.fontSize * e.lineHeight) / 2 * 10) / 10 - e.lineWidth, 3),
    inputPaddingVerticalLG: Math.ceil((e.controlHeightLG - e.fontSizeLG * e.lineHeightLG) / 2 * 10) / 10 - e.lineWidth,
    inputPaddingVerticalSM: Math.max(Math.round((e.controlHeightSM - e.fontSize * e.lineHeight) / 2 * 10) / 10 - e.lineWidth, 0),
    inputPaddingHorizontal: e.paddingSM - e.lineWidth,
    inputPaddingHorizontalSM: e.paddingXS - e.lineWidth,
    inputPaddingHorizontalLG: e.controlPaddingHorizontal - e.lineWidth,
    inputBorderHoverColor: e.colorPrimaryHover,
    inputBorderActiveColor: e.colorPrimaryHover
  });
}
const v3 = (e) => {
  const {
    componentCls: t,
    inputPaddingHorizontal: n,
    paddingLG: o
  } = e, r = `${t}-textarea`;
  return {
    [r]: {
      position: "relative",
      [`${r}-suffix`]: {
        position: "absolute",
        top: 0,
        insetInlineEnd: n,
        bottom: 0,
        zIndex: 1,
        display: "inline-flex",
        alignItems: "center",
        margin: "auto"
      },
      "&-status-error,\n        &-status-warning,\n        &-status-success,\n        &-status-validating": {
        [`&${r}-has-feedback`]: {
          [`${t}`]: {
            paddingInlineEnd: o
          }
        }
      },
      "&-show-count": {
        // https://github.com/ant-design/ant-design/issues/33049
        [`> ${t}`]: {
          height: "100%"
        },
        "&::after": {
          color: e.colorTextDescription,
          whiteSpace: "nowrap",
          content: "attr(data-count)",
          pointerEvents: "none",
          float: "right"
        }
      },
      "&-rtl": {
        "&::after": {
          float: "left"
        }
      }
    }
  };
}, Jf = ht("Input", (e) => {
  const t = ks(e);
  return [
    u3(t),
    v3(t),
    d3(t),
    f3(t),
    p3(t),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    xi(t)
  ];
}), Mu = (e, t, n, o) => {
  const {
    lineHeight: r
  } = e, a = Math.floor(n * r) + 2, i = Math.max((t - a) / 2, 0), l = Math.max(t - a - i, 0);
  return {
    padding: `${i}px ${o}px ${l}px`
  };
}, m3 = (e) => {
  const {
    componentCls: t,
    pickerCellCls: n,
    pickerCellInnerCls: o,
    pickerPanelCellHeight: r,
    motionDurationSlow: a,
    borderRadiusSM: i,
    motionDurationMid: l,
    controlItemBgHover: u,
    lineWidth: s,
    lineType: c,
    colorPrimary: d,
    controlItemBgActive: f,
    colorTextLightSolid: p,
    controlHeightSM: v,
    pickerDateHoverRangeBorderColor: g,
    pickerCellBorderGap: b,
    pickerBasicCellHoverWithRangeColor: y,
    pickerPanelCellWidth: S,
    colorTextDisabled: w,
    colorBgContainerDisabled: C
  } = e;
  return {
    "&::before": {
      position: "absolute",
      top: "50%",
      insetInlineStart: 0,
      insetInlineEnd: 0,
      zIndex: 1,
      height: r,
      transform: "translateY(-50%)",
      transition: `all ${a}`,
      content: '""'
    },
    // >>> Default
    [o]: {
      position: "relative",
      zIndex: 2,
      display: "inline-block",
      minWidth: r,
      height: r,
      lineHeight: `${r}px`,
      borderRadius: i,
      transition: `background ${l}, border ${l}`
    },
    // >>> Hover
    [`&:hover:not(${n}-in-view),
    &:hover:not(${n}-selected):not(${n}-range-start):not(${n}-range-end):not(${n}-range-hover-start):not(${n}-range-hover-end)`]: {
      [o]: {
        background: u
      }
    },
    // >>> Today
    [`&-in-view${n}-today ${o}`]: {
      "&::before": {
        position: "absolute",
        top: 0,
        insetInlineEnd: 0,
        bottom: 0,
        insetInlineStart: 0,
        zIndex: 1,
        border: `${s}px ${c} ${d}`,
        borderRadius: i,
        content: '""'
      }
    },
    // >>> In Range
    [`&-in-view${n}-in-range`]: {
      position: "relative",
      "&::before": {
        background: f
      }
    },
    // >>> Selected
    [`&-in-view${n}-selected ${o},
      &-in-view${n}-range-start ${o},
      &-in-view${n}-range-end ${o}`]: {
      color: p,
      background: d
    },
    [`&-in-view${n}-range-start:not(${n}-range-start-single),
      &-in-view${n}-range-end:not(${n}-range-end-single)`]: {
      "&::before": {
        background: f
      }
    },
    [`&-in-view${n}-range-start::before`]: {
      insetInlineStart: "50%"
    },
    [`&-in-view${n}-range-end::before`]: {
      insetInlineEnd: "50%"
    },
    // >>> Range Hover
    [`&-in-view${n}-range-hover-start:not(${n}-in-range):not(${n}-range-start):not(${n}-range-end),
      &-in-view${n}-range-hover-end:not(${n}-in-range):not(${n}-range-start):not(${n}-range-end),
      &-in-view${n}-range-hover-start${n}-range-start-single,
      &-in-view${n}-range-hover-start${n}-range-start${n}-range-end${n}-range-end-near-hover,
      &-in-view${n}-range-hover-end${n}-range-start${n}-range-end${n}-range-start-near-hover,
      &-in-view${n}-range-hover-end${n}-range-end-single,
      &-in-view${n}-range-hover:not(${n}-in-range)`]: {
      "&::after": {
        position: "absolute",
        top: "50%",
        zIndex: 0,
        height: v,
        borderTop: `${s}px dashed ${g}`,
        borderBottom: `${s}px dashed ${g}`,
        transform: "translateY(-50%)",
        transition: `all ${a}`,
        content: '""'
      }
    },
    // Add space for stash
    "&-range-hover-start::after,\n      &-range-hover-end::after,\n      &-range-hover::after": {
      insetInlineEnd: 0,
      insetInlineStart: b
    },
    // Hover with in range
    [`&-in-view${n}-in-range${n}-range-hover::before,
      &-in-view${n}-range-start${n}-range-hover::before,
      &-in-view${n}-range-end${n}-range-hover::before,
      &-in-view${n}-range-start:not(${n}-range-start-single)${n}-range-hover-start::before,
      &-in-view${n}-range-end:not(${n}-range-end-single)${n}-range-hover-end::before,
      ${t}-panel
      > :not(${t}-date-panel)
      &-in-view${n}-in-range${n}-range-hover-start::before,
      ${t}-panel
      > :not(${t}-date-panel)
      &-in-view${n}-in-range${n}-range-hover-end::before`]: {
      background: y
    },
    // range start border-radius
    [`&-in-view${n}-range-start:not(${n}-range-start-single):not(${n}-range-end) ${o}`]: {
      borderStartStartRadius: i,
      borderEndStartRadius: i,
      borderStartEndRadius: 0,
      borderEndEndRadius: 0
    },
    // range end border-radius
    [`&-in-view${n}-range-end:not(${n}-range-end-single):not(${n}-range-start) ${o}`]: {
      borderStartStartRadius: 0,
      borderEndStartRadius: 0,
      borderStartEndRadius: i,
      borderEndEndRadius: i
    },
    [`&-range-hover${n}-range-end::after`]: {
      insetInlineStart: "50%"
    },
    // Edge start
    [`tr > &-in-view${n}-range-hover:first-child::after,
      tr > &-in-view${n}-range-hover-end:first-child::after,
      &-in-view${n}-start${n}-range-hover-edge-start${n}-range-hover-edge-start-near-range::after,
      &-in-view${n}-range-hover-edge-start:not(${n}-range-hover-edge-start-near-range)::after,
      &-in-view${n}-range-hover-start::after`]: {
      insetInlineStart: (S - r) / 2,
      borderInlineStart: `${s}px dashed ${g}`,
      borderStartStartRadius: s,
      borderEndStartRadius: s
    },
    // Edge end
    [`tr > &-in-view${n}-range-hover:last-child::after,
      tr > &-in-view${n}-range-hover-start:last-child::after,
      &-in-view${n}-end${n}-range-hover-edge-end${n}-range-hover-edge-end-near-range::after,
      &-in-view${n}-range-hover-edge-end:not(${n}-range-hover-edge-end-near-range)::after,
      &-in-view${n}-range-hover-end::after`]: {
      insetInlineEnd: (S - r) / 2,
      borderInlineEnd: `${s}px dashed ${g}`,
      borderStartEndRadius: s,
      borderEndEndRadius: s
    },
    // >>> Disabled
    "&-disabled": {
      color: w,
      pointerEvents: "none",
      [o]: {
        background: "transparent"
      },
      "&::before": {
        background: C
      }
    },
    [`&-disabled${n}-today ${o}::before`]: {
      borderColor: w
    }
  };
}, g3 = (e) => {
  const {
    componentCls: t,
    pickerCellInnerCls: n,
    pickerYearMonthCellWidth: o,
    pickerControlIconSize: r,
    pickerPanelCellWidth: a,
    paddingSM: i,
    paddingXS: l,
    paddingXXS: u,
    colorBgContainer: s,
    lineWidth: c,
    lineType: d,
    borderRadiusLG: f,
    colorPrimary: p,
    colorTextHeading: v,
    colorSplit: g,
    pickerControlIconBorderWidth: b,
    colorIcon: y,
    pickerTextHeight: S,
    motionDurationMid: w,
    colorIconHover: C,
    fontWeightStrong: $,
    pickerPanelCellHeight: O,
    pickerCellPaddingVertical: x,
    colorTextDisabled: M,
    colorText: _,
    fontSize: N,
    pickerBasicCellHoverWithRangeColor: I,
    motionDurationSlow: E,
    pickerPanelWithoutTimeCellHeight: B,
    pickerQuarterPanelContentHeight: k,
    colorLink: P,
    colorLinkActive: R,
    colorLinkHover: D,
    pickerDateHoverRangeBorderColor: A,
    borderRadiusSM: H,
    colorTextLightSolid: j,
    borderRadius: z,
    controlItemBgHover: F,
    pickerTimePanelColumnHeight: U,
    pickerTimePanelColumnWidth: Q,
    pickerTimePanelCellHeight: q,
    controlItemBgActive: oe,
    marginXXS: Z
  } = e, ne = a * 7 + i * 2 + 4, Y = (ne - l * 2) / 3 - o - i;
  return {
    [t]: {
      "&-panel": {
        display: "inline-flex",
        flexDirection: "column",
        textAlign: "center",
        background: s,
        border: `${c}px ${d} ${g}`,
        borderRadius: f,
        outline: "none",
        "&-focused": {
          borderColor: p
        },
        "&-rtl": {
          direction: "rtl",
          [`${t}-prev-icon,
              ${t}-super-prev-icon`]: {
            transform: "rotate(45deg)"
          },
          [`${t}-next-icon,
              ${t}-super-next-icon`]: {
            transform: "rotate(-135deg)"
          }
        }
      },
      // ========================================================
      // =                     Shared Panel                     =
      // ========================================================
      "&-decade-panel,\n        &-year-panel,\n        &-quarter-panel,\n        &-month-panel,\n        &-week-panel,\n        &-date-panel,\n        &-time-panel": {
        display: "flex",
        flexDirection: "column",
        width: ne
      },
      // ======================= Header =======================
      "&-header": {
        display: "flex",
        padding: `0 ${l}px`,
        color: v,
        borderBottom: `${c}px ${d} ${g}`,
        "> *": {
          flex: "none"
        },
        button: {
          padding: 0,
          color: y,
          lineHeight: `${S}px`,
          background: "transparent",
          border: 0,
          cursor: "pointer",
          transition: `color ${w}`
        },
        "> button": {
          minWidth: "1.6em",
          fontSize: N,
          "&:hover": {
            color: C
          }
        },
        "&-view": {
          flex: "auto",
          fontWeight: $,
          lineHeight: `${S}px`,
          button: {
            color: "inherit",
            fontWeight: "inherit",
            verticalAlign: "top",
            "&:not(:first-child)": {
              marginInlineStart: l
            },
            "&:hover": {
              color: p
            }
          }
        }
      },
      // Arrow button
      "&-prev-icon,\n        &-next-icon,\n        &-super-prev-icon,\n        &-super-next-icon": {
        position: "relative",
        display: "inline-block",
        width: r,
        height: r,
        "&::before": {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          display: "inline-block",
          width: r,
          height: r,
          border: "0 solid currentcolor",
          borderBlockStartWidth: b,
          borderBlockEndWidth: 0,
          borderInlineStartWidth: b,
          borderInlineEndWidth: 0,
          content: '""'
        }
      },
      "&-super-prev-icon,\n        &-super-next-icon": {
        "&::after": {
          position: "absolute",
          top: Math.ceil(r / 2),
          insetInlineStart: Math.ceil(r / 2),
          display: "inline-block",
          width: r,
          height: r,
          border: "0 solid currentcolor",
          borderBlockStartWidth: b,
          borderBlockEndWidth: 0,
          borderInlineStartWidth: b,
          borderInlineEndWidth: 0,
          content: '""'
        }
      },
      "&-prev-icon,\n        &-super-prev-icon": {
        transform: "rotate(-45deg)"
      },
      "&-next-icon,\n        &-super-next-icon": {
        transform: "rotate(135deg)"
      },
      // ======================== Body ========================
      "&-content": {
        width: "100%",
        tableLayout: "fixed",
        borderCollapse: "collapse",
        "th, td": {
          position: "relative",
          minWidth: O,
          fontWeight: "normal"
        },
        th: {
          height: O + x * 2,
          color: _,
          verticalAlign: "middle"
        }
      },
      "&-cell": h({
        padding: `${x}px 0`,
        color: M,
        cursor: "pointer",
        // In view
        "&-in-view": {
          color: _
        }
      }, m3(e)),
      // DatePanel only
      [`&-date-panel ${t}-cell-in-view${t}-cell-in-range${t}-cell-range-hover-start ${n},
        &-date-panel ${t}-cell-in-view${t}-cell-in-range${t}-cell-range-hover-end ${n}`]: {
        "&::after": {
          position: "absolute",
          top: 0,
          bottom: 0,
          zIndex: -1,
          background: I,
          transition: `all ${E}`,
          content: '""'
        }
      },
      [`&-date-panel
        ${t}-cell-in-view${t}-cell-in-range${t}-cell-range-hover-start
        ${n}::after`]: {
        insetInlineEnd: -(a - O) / 2,
        insetInlineStart: 0
      },
      [`&-date-panel ${t}-cell-in-view${t}-cell-in-range${t}-cell-range-hover-end ${n}::after`]: {
        insetInlineEnd: 0,
        insetInlineStart: -(a - O) / 2
      },
      // Hover with range start & end
      [`&-range-hover${t}-range-start::after`]: {
        insetInlineEnd: "50%"
      },
      "&-decade-panel,\n        &-year-panel,\n        &-quarter-panel,\n        &-month-panel": {
        [`${t}-content`]: {
          height: B * 4
        },
        [n]: {
          padding: `0 ${l}px`
        }
      },
      "&-quarter-panel": {
        [`${t}-content`]: {
          height: k
        }
      },
      // ======================== Footer ========================
      [`&-panel ${t}-footer`]: {
        borderTop: `${c}px ${d} ${g}`
      },
      "&-footer": {
        width: "min-content",
        minWidth: "100%",
        lineHeight: `${S - 2 * c}px`,
        textAlign: "center",
        "&-extra": {
          padding: `0 ${i}`,
          lineHeight: `${S - 2 * c}px`,
          textAlign: "start",
          "&:not(:last-child)": {
            borderBottom: `${c}px ${d} ${g}`
          }
        }
      },
      "&-now": {
        textAlign: "start"
      },
      "&-today-btn": {
        color: P,
        "&:hover": {
          color: D
        },
        "&:active": {
          color: R
        },
        [`&${t}-today-btn-disabled`]: {
          color: M,
          cursor: "not-allowed"
        }
      },
      // ========================================================
      // =                       Special                        =
      // ========================================================
      // ===================== Decade Panel =====================
      "&-decade-panel": {
        [n]: {
          padding: `0 ${l / 2}px`
        },
        [`${t}-cell::before`]: {
          display: "none"
        }
      },
      // ============= Year & Quarter & Month Panel =============
      "&-year-panel,\n        &-quarter-panel,\n        &-month-panel": {
        [`${t}-body`]: {
          padding: `0 ${l}px`
        },
        [n]: {
          width: o
        },
        [`${t}-cell-range-hover-start::after`]: {
          insetInlineStart: Y,
          borderInlineStart: `${c}px dashed ${A}`,
          borderStartStartRadius: H,
          borderBottomStartRadius: H,
          borderStartEndRadius: 0,
          borderBottomEndRadius: 0,
          [`${t}-panel-rtl &`]: {
            insetInlineEnd: Y,
            borderInlineEnd: `${c}px dashed ${A}`,
            borderStartStartRadius: 0,
            borderBottomStartRadius: 0,
            borderStartEndRadius: H,
            borderBottomEndRadius: H
          }
        },
        [`${t}-cell-range-hover-end::after`]: {
          insetInlineEnd: Y,
          borderInlineEnd: `${c}px dashed ${A}`,
          borderStartStartRadius: 0,
          borderEndStartRadius: 0,
          borderStartEndRadius: z,
          borderEndEndRadius: z,
          [`${t}-panel-rtl &`]: {
            insetInlineStart: Y,
            borderInlineStart: `${c}px dashed ${A}`,
            borderStartStartRadius: z,
            borderEndStartRadius: z,
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        }
      },
      // ====================== Week Panel ======================
      "&-week-panel": {
        [`${t}-body`]: {
          padding: `${l}px ${i}px`
        },
        // Clear cell style
        [`${t}-cell`]: {
          [`&:hover ${n},
            &-selected ${n},
            ${n}`]: {
            background: "transparent !important"
          }
        },
        "&-row": {
          td: {
            transition: `background ${w}`,
            "&:first-child": {
              borderStartStartRadius: H,
              borderEndStartRadius: H
            },
            "&:last-child": {
              borderStartEndRadius: H,
              borderEndEndRadius: H
            }
          },
          "&:hover td": {
            background: F
          },
          "&-selected td,\n            &-selected:hover td": {
            background: p,
            [`&${t}-cell-week`]: {
              color: new Ct(j).setAlpha(0.5).toHexString()
            },
            [`&${t}-cell-today ${n}::before`]: {
              borderColor: j
            },
            [n]: {
              color: j
            }
          }
        }
      },
      // ====================== Date Panel ======================
      "&-date-panel": {
        [`${t}-body`]: {
          padding: `${l}px ${i}px`
        },
        [`${t}-content`]: {
          width: a * 7,
          th: {
            width: a
          }
        }
      },
      // ==================== Datetime Panel ====================
      "&-datetime-panel": {
        display: "flex",
        [`${t}-time-panel`]: {
          borderInlineStart: `${c}px ${d} ${g}`
        },
        [`${t}-date-panel,
          ${t}-time-panel`]: {
          transition: `opacity ${E}`
        },
        // Keyboard
        "&-active": {
          [`${t}-date-panel,
            ${t}-time-panel`]: {
            opacity: 0.3,
            "&-active": {
              opacity: 1
            }
          }
        }
      },
      // ====================== Time Panel ======================
      "&-time-panel": {
        width: "auto",
        minWidth: "auto",
        direction: "ltr",
        [`${t}-content`]: {
          display: "flex",
          flex: "auto",
          height: U
        },
        "&-column": {
          flex: "1 0 auto",
          width: Q,
          margin: `${u}px 0`,
          padding: 0,
          overflowY: "hidden",
          textAlign: "start",
          listStyle: "none",
          transition: `background ${w}`,
          overflowX: "hidden",
          "&::after": {
            display: "block",
            height: U - q,
            content: '""'
          },
          "&:not(:first-child)": {
            borderInlineStart: `${c}px ${d} ${g}`
          },
          "&-active": {
            background: new Ct(oe).setAlpha(0.2).toHexString()
          },
          "&:hover": {
            overflowY: "auto"
          },
          "> li": {
            margin: 0,
            padding: 0,
            [`&${t}-time-panel-cell`]: {
              marginInline: Z,
              [`${t}-time-panel-cell-inner`]: {
                display: "block",
                width: Q - 2 * Z,
                height: q,
                margin: 0,
                paddingBlock: 0,
                paddingInlineEnd: 0,
                paddingInlineStart: (Q - q) / 2,
                color: _,
                lineHeight: `${q}px`,
                borderRadius: H,
                cursor: "pointer",
                transition: `background ${w}`,
                "&:hover": {
                  background: F
                }
              },
              "&-selected": {
                [`${t}-time-panel-cell-inner`]: {
                  background: oe
                }
              },
              "&-disabled": {
                [`${t}-time-panel-cell-inner`]: {
                  color: M,
                  background: "transparent",
                  cursor: "not-allowed"
                }
              }
            }
          }
        }
      },
      // https://github.com/ant-design/ant-design/issues/39227
      [`&-datetime-panel ${t}-time-panel-column:after`]: {
        height: U - q + u * 2
      }
    }
  };
}, h3 = (e) => {
  const {
    componentCls: t,
    colorBgContainer: n,
    colorError: o,
    colorErrorOutline: r,
    colorWarning: a,
    colorWarningOutline: i
  } = e;
  return {
    [t]: {
      [`&-status-error${t}`]: {
        "&, &:not([disabled]):hover": {
          backgroundColor: n,
          borderColor: o
        },
        "&-focused, &:focus": h({}, Yo(qe(e, {
          inputBorderActiveColor: o,
          inputBorderHoverColor: o,
          controlOutline: r
        }))),
        [`${t}-active-bar`]: {
          background: o
        }
      },
      [`&-status-warning${t}`]: {
        "&, &:not([disabled]):hover": {
          backgroundColor: n,
          borderColor: a
        },
        "&-focused, &:focus": h({}, Yo(qe(e, {
          inputBorderActiveColor: a,
          inputBorderHoverColor: a,
          controlOutline: i
        }))),
        [`${t}-active-bar`]: {
          background: a
        }
      }
    }
  };
}, b3 = (e) => {
  const {
    componentCls: t,
    antCls: n,
    boxShadowPopoverArrow: o,
    controlHeight: r,
    fontSize: a,
    inputPaddingHorizontal: i,
    colorBgContainer: l,
    lineWidth: u,
    lineType: s,
    colorBorder: c,
    borderRadius: d,
    motionDurationMid: f,
    colorBgContainerDisabled: p,
    colorTextDisabled: v,
    colorTextPlaceholder: g,
    controlHeightLG: b,
    fontSizeLG: y,
    controlHeightSM: S,
    inputPaddingHorizontalSM: w,
    paddingXS: C,
    marginXS: $,
    colorTextDescription: O,
    lineWidthBold: x,
    lineHeight: M,
    colorPrimary: _,
    motionDurationSlow: N,
    zIndexPopup: I,
    paddingXXS: E,
    paddingSM: B,
    pickerTextHeight: k,
    controlItemBgActive: P,
    colorPrimaryBorder: R,
    sizePopupArrow: D,
    borderRadiusXS: A,
    borderRadiusOuter: H,
    colorBgElevated: j,
    borderRadiusLG: z,
    boxShadowSecondary: F,
    borderRadiusSM: U,
    colorSplit: Q,
    controlItemBgHover: q,
    presetsWidth: oe,
    presetsMaxWidth: Z
  } = e;
  return [
    {
      [t]: h(h(h({}, st(e)), Mu(e, r, a, i)), {
        position: "relative",
        display: "inline-flex",
        alignItems: "center",
        background: l,
        lineHeight: 1,
        border: `${u}px ${s} ${c}`,
        borderRadius: d,
        transition: `border ${f}, box-shadow ${f}`,
        "&:hover, &-focused": h({}, Ia(e)),
        "&-focused": h({}, Yo(e)),
        [`&${t}-disabled`]: {
          background: p,
          borderColor: c,
          cursor: "not-allowed",
          [`${t}-suffix`]: {
            color: v
          }
        },
        [`&${t}-borderless`]: {
          backgroundColor: "transparent !important",
          borderColor: "transparent !important",
          boxShadow: "none !important"
        },
        // ======================== Input =========================
        [`${t}-input`]: {
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          width: "100%",
          "> input": h(h({}, Ta(e)), {
            flex: "auto",
            // Fix Firefox flex not correct:
            // https://github.com/ant-design/ant-design/pull/20023#issuecomment-564389553
            minWidth: 1,
            height: "auto",
            padding: 0,
            background: "transparent",
            border: 0,
            "&:focus": {
              boxShadow: "none"
            },
            "&[disabled]": {
              background: "transparent"
            }
          }),
          "&:hover": {
            [`${t}-clear`]: {
              opacity: 1
            }
          },
          "&-placeholder": {
            "> input": {
              color: g
            }
          }
        },
        // Size
        "&-large": h(h({}, Mu(e, b, y, i)), {
          [`${t}-input > input`]: {
            fontSize: y
          }
        }),
        "&-small": h({}, Mu(e, S, a, w)),
        [`${t}-suffix`]: {
          display: "flex",
          flex: "none",
          alignSelf: "center",
          marginInlineStart: C / 2,
          color: v,
          lineHeight: 1,
          pointerEvents: "none",
          "> *": {
            verticalAlign: "top",
            "&:not(:last-child)": {
              marginInlineEnd: $
            }
          }
        },
        [`${t}-clear`]: {
          position: "absolute",
          top: "50%",
          insetInlineEnd: 0,
          color: v,
          lineHeight: 1,
          background: l,
          transform: "translateY(-50%)",
          cursor: "pointer",
          opacity: 0,
          transition: `opacity ${f}, color ${f}`,
          "> *": {
            verticalAlign: "top"
          },
          "&:hover": {
            color: O
          }
        },
        [`${t}-separator`]: {
          position: "relative",
          display: "inline-block",
          width: "1em",
          height: y,
          color: v,
          fontSize: y,
          verticalAlign: "top",
          cursor: "default",
          [`${t}-focused &`]: {
            color: O
          },
          [`${t}-range-separator &`]: {
            [`${t}-disabled &`]: {
              cursor: "not-allowed"
            }
          }
        },
        // ======================== Range =========================
        "&-range": {
          position: "relative",
          display: "inline-flex",
          // Clear
          [`${t}-clear`]: {
            insetInlineEnd: i
          },
          "&:hover": {
            [`${t}-clear`]: {
              opacity: 1
            }
          },
          // Active bar
          [`${t}-active-bar`]: {
            bottom: -u,
            height: x,
            marginInlineStart: i,
            background: _,
            opacity: 0,
            transition: `all ${N} ease-out`,
            pointerEvents: "none"
          },
          [`&${t}-focused`]: {
            [`${t}-active-bar`]: {
              opacity: 1
            }
          },
          [`${t}-range-separator`]: {
            alignItems: "center",
            padding: `0 ${C}px`,
            lineHeight: 1
          },
          [`&${t}-small`]: {
            [`${t}-clear`]: {
              insetInlineEnd: w
            },
            [`${t}-active-bar`]: {
              marginInlineStart: w
            }
          }
        },
        // ======================= Dropdown =======================
        "&-dropdown": h(h(h({}, st(e)), g3(e)), {
          position: "absolute",
          // Fix incorrect position of picker popup
          // https://github.com/ant-design/ant-design/issues/35590
          top: -9999,
          left: {
            _skip_check_: !0,
            value: -9999
          },
          zIndex: I,
          [`&${t}-dropdown-hidden`]: {
            display: "none"
          },
          [`&${t}-dropdown-placement-bottomLeft`]: {
            [`${t}-range-arrow`]: {
              top: 0,
              display: "block",
              transform: "translateY(-100%)"
            }
          },
          [`&${t}-dropdown-placement-topLeft`]: {
            [`${t}-range-arrow`]: {
              bottom: 0,
              display: "block",
              transform: "translateY(100%) rotate(180deg)"
            }
          },
          [`&${n}-slide-up-enter${n}-slide-up-enter-active${t}-dropdown-placement-topLeft,
          &${n}-slide-up-enter${n}-slide-up-enter-active${t}-dropdown-placement-topRight,
          &${n}-slide-up-appear${n}-slide-up-appear-active${t}-dropdown-placement-topLeft,
          &${n}-slide-up-appear${n}-slide-up-appear-active${t}-dropdown-placement-topRight`]: {
            animationName: bf
          },
          [`&${n}-slide-up-enter${n}-slide-up-enter-active${t}-dropdown-placement-bottomLeft,
          &${n}-slide-up-enter${n}-slide-up-enter-active${t}-dropdown-placement-bottomRight,
          &${n}-slide-up-appear${n}-slide-up-appear-active${t}-dropdown-placement-bottomLeft,
          &${n}-slide-up-appear${n}-slide-up-appear-active${t}-dropdown-placement-bottomRight`]: {
            animationName: gf
          },
          [`&${n}-slide-up-leave${n}-slide-up-leave-active${t}-dropdown-placement-topLeft,
          &${n}-slide-up-leave${n}-slide-up-leave-active${t}-dropdown-placement-topRight`]: {
            animationName: yf
          },
          [`&${n}-slide-up-leave${n}-slide-up-leave-active${t}-dropdown-placement-bottomLeft,
          &${n}-slide-up-leave${n}-slide-up-leave-active${t}-dropdown-placement-bottomRight`]: {
            animationName: hf
          },
          // Time picker with additional style
          [`${t}-panel > ${t}-time-panel`]: {
            paddingTop: E
          },
          // ======================== Ranges ========================
          [`${t}-ranges`]: {
            marginBottom: 0,
            padding: `${E}px ${B}px`,
            overflow: "hidden",
            lineHeight: `${k - 2 * u - C / 2}px`,
            textAlign: "start",
            listStyle: "none",
            display: "flex",
            justifyContent: "space-between",
            "> li": {
              display: "inline-block"
            },
            // https://github.com/ant-design/ant-design/issues/23687
            [`${t}-preset > ${n}-tag-blue`]: {
              color: _,
              background: P,
              borderColor: R,
              cursor: "pointer"
            },
            [`${t}-ok`]: {
              marginInlineStart: "auto"
            }
          },
          [`${t}-range-wrapper`]: {
            display: "flex",
            position: "relative"
          },
          [`${t}-range-arrow`]: h({
            position: "absolute",
            zIndex: 1,
            display: "none",
            marginInlineStart: i * 1.5,
            transition: `left ${N} ease-out`
          }, oy(D, A, H, j, o)),
          [`${t}-panel-container`]: {
            overflow: "hidden",
            verticalAlign: "top",
            background: j,
            borderRadius: z,
            boxShadow: F,
            transition: `margin ${N}`,
            // ======================== Layout ========================
            [`${t}-panel-layout`]: {
              display: "flex",
              flexWrap: "nowrap",
              alignItems: "stretch"
            },
            // ======================== Preset ========================
            [`${t}-presets`]: {
              display: "flex",
              flexDirection: "column",
              minWidth: oe,
              maxWidth: Z,
              ul: {
                height: 0,
                flex: "auto",
                listStyle: "none",
                overflow: "auto",
                margin: 0,
                padding: C,
                borderInlineEnd: `${u}px ${s} ${Q}`,
                li: h(h({}, So), {
                  borderRadius: U,
                  paddingInline: C,
                  paddingBlock: (S - Math.round(a * M)) / 2,
                  cursor: "pointer",
                  transition: `all ${N}`,
                  "+ li": {
                    marginTop: $
                  },
                  "&:hover": {
                    background: q
                  }
                })
              }
            },
            // ======================== Panels ========================
            [`${t}-panels`]: {
              display: "inline-flex",
              flexWrap: "nowrap",
              direction: "ltr",
              [`${t}-panel`]: {
                borderWidth: `0 0 ${u}px`
              },
              "&:last-child": {
                [`${t}-panel`]: {
                  borderWidth: 0
                }
              }
            },
            [`${t}-panel`]: {
              verticalAlign: "top",
              background: "transparent",
              borderRadius: 0,
              borderWidth: 0,
              [`${t}-content,
            table`]: {
                textAlign: "center"
              },
              "&-focused": {
                borderColor: c
              }
            }
          }
        }),
        "&-dropdown-range": {
          padding: `${D * 2 / 3}px 0`,
          "&-hidden": {
            display: "none"
          }
        },
        "&-rtl": {
          direction: "rtl",
          [`${t}-separator`]: {
            transform: "rotate(180deg)"
          },
          [`${t}-footer`]: {
            "&-extra": {
              direction: "rtl"
            }
          }
        }
      })
    },
    // Follow code may reuse in other components
    Go(e, "slide-up"),
    Go(e, "slide-down"),
    jl(e, "move-up"),
    jl(e, "move-down")
  ];
}, y3 = (e) => {
  const {
    componentCls: n,
    controlHeightLG: o,
    controlHeightSM: r,
    colorPrimary: a,
    paddingXXS: i
  } = e;
  return {
    pickerCellCls: `${n}-cell`,
    pickerCellInnerCls: `${n}-cell-inner`,
    pickerTextHeight: o,
    pickerPanelCellWidth: r * 1.5,
    pickerPanelCellHeight: r,
    pickerDateHoverRangeBorderColor: new Ct(a).lighten(20).toHexString(),
    pickerBasicCellHoverWithRangeColor: new Ct(a).lighten(35).toHexString(),
    pickerPanelWithoutTimeCellHeight: o * 1.65,
    pickerYearMonthCellWidth: o * 1.5,
    pickerTimePanelColumnHeight: 28 * 8,
    pickerTimePanelColumnWidth: o * 1.4,
    pickerTimePanelCellHeight: 28,
    pickerQuarterPanelContentHeight: o * 1.4,
    pickerCellPaddingVertical: i,
    pickerCellBorderGap: 2,
    pickerControlIconSize: 7,
    pickerControlIconBorderWidth: 1.5
  };
}, n$ = ht("DatePicker", (e) => {
  const t = qe(ks(e), y3(e));
  return [
    b3(t),
    h3(t),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    xi(e, {
      focusElCls: `${e.componentCls}-focused`
    })
  ];
}, (e) => ({
  presetsWidth: 120,
  presetsMaxWidth: 200,
  zIndexPopup: e.zIndexPopupBase + 50
}));
function S3(e) {
  const t = K(), n = K(!1);
  function o() {
    for (var r = arguments.length, a = new Array(r), i = 0; i < r; i++)
      a[i] = arguments[i];
    n.value || (Ue.cancel(t.value), t.value = Ue(() => {
      e(...a);
    }));
  }
  return at(() => {
    n.value = !0, Ue.cancel(t.value);
  }), o;
}
function $3(e) {
  const t = K([]), n = K(typeof e == "function" ? e() : e), o = S3(() => {
    let a = n.value;
    t.value.forEach((i) => {
      a = i(a);
    }), t.value = [], n.value = a;
  });
  function r(a) {
    t.value.push(a), o();
  }
  return [n, r];
}
const C3 = J({
  compatConfig: {
    MODE: 3
  },
  name: "TabNode",
  props: {
    id: {
      type: String
    },
    prefixCls: {
      type: String
    },
    tab: {
      type: Object
    },
    active: {
      type: Boolean
    },
    closable: {
      type: Boolean
    },
    editable: {
      type: Object
    },
    onClick: {
      type: Function
    },
    onResize: {
      type: Function
    },
    renderWrapper: {
      type: Function
    },
    removeAriaLabel: {
      type: String
    },
    // onRemove: { type: Function as PropType<() => void> },
    onFocus: {
      type: Function
    }
  },
  emits: ["click", "resize", "remove", "focus"],
  setup(e, t) {
    let {
      expose: n,
      attrs: o
    } = t;
    const r = G();
    function a(u) {
      var s;
      !((s = e.tab) === null || s === void 0) && s.disabled || e.onClick(u);
    }
    n({
      domRef: r
    });
    function i(u) {
      var s;
      u.preventDefault(), u.stopPropagation(), e.editable.onEdit("remove", {
        key: (s = e.tab) === null || s === void 0 ? void 0 : s.key,
        event: u
      });
    }
    const l = T(() => {
      var u;
      return e.editable && e.closable !== !1 && !(!((u = e.tab) === null || u === void 0) && u.disabled);
    });
    return () => {
      var u;
      const {
        prefixCls: s,
        id: c,
        active: d,
        tab: {
          key: f,
          tab: p,
          disabled: v,
          closeIcon: g
        },
        renderWrapper: b,
        removeAriaLabel: y,
        editable: S,
        onFocus: w
      } = e, C = `${s}-tab`, $ = m("div", {
        key: f,
        ref: r,
        class: ae(C, {
          [`${C}-with-remove`]: l.value,
          [`${C}-active`]: d,
          [`${C}-disabled`]: v
        }),
        style: o.style,
        onClick: a
      }, [m("div", {
        role: "tab",
        "aria-selected": d,
        id: c && `${c}-tab-${f}`,
        class: `${C}-btn`,
        "aria-controls": c && `${c}-panel-${f}`,
        "aria-disabled": v,
        tabindex: v ? null : 0,
        onClick: (O) => {
          O.stopPropagation(), a(O);
        },
        onKeydown: (O) => {
          [ee.SPACE, ee.ENTER].includes(O.which) && (O.preventDefault(), a(O));
        },
        onFocus: w
      }, [typeof p == "function" ? p() : p]), l.value && m("button", {
        type: "button",
        "aria-label": y || "remove",
        tabindex: 0,
        class: `${C}-remove`,
        onClick: (O) => {
          O.stopPropagation(), i(O);
        }
      }, [(g == null ? void 0 : g()) || ((u = S.removeIcon) === null || u === void 0 ? void 0 : u.call(S)) || "×"])]);
      return b ? b($) : $;
    };
  }
}), Sg = {
  width: 0,
  height: 0,
  left: 0,
  top: 0
};
function w3(e, t) {
  const n = G(/* @__PURE__ */ new Map());
  return Ve(() => {
    var o, r;
    const a = /* @__PURE__ */ new Map(), i = e.value, l = t.value.get((o = i[0]) === null || o === void 0 ? void 0 : o.key) || Sg, u = l.left + l.width;
    for (let s = 0; s < i.length; s += 1) {
      const {
        key: c
      } = i[s];
      let d = t.value.get(c);
      d || (d = t.value.get((r = i[s - 1]) === null || r === void 0 ? void 0 : r.key) || Sg);
      const f = a.get(c) || h({}, d);
      f.right = u - f.left - f.width, a.set(c, f);
    }
    n.value = new Map(a);
  }), n;
}
const o$ = J({
  compatConfig: {
    MODE: 3
  },
  name: "AddButton",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    editable: {
      type: Object
    },
    locale: {
      type: Object,
      default: void 0
    }
  },
  setup(e, t) {
    let {
      expose: n,
      attrs: o
    } = t;
    const r = G();
    return n({
      domRef: r
    }), () => {
      const {
        prefixCls: a,
        editable: i,
        locale: l
      } = e;
      return !i || i.showAdd === !1 ? null : m("button", {
        ref: r,
        type: "button",
        class: `${a}-nav-add`,
        style: o.style,
        "aria-label": (l == null ? void 0 : l.addAriaLabel) || "Add tab",
        onClick: (u) => {
          i.onEdit("add", {
            event: u
          });
        }
      }, [i.addIcon ? i.addIcon() : "+"]);
    };
  }
}), x3 = {
  prefixCls: {
    type: String
  },
  id: {
    type: String
  },
  tabs: {
    type: Object
  },
  rtl: {
    type: Boolean
  },
  tabBarGutter: {
    type: Number
  },
  activeKey: {
    type: [String, Number]
  },
  mobile: {
    type: Boolean
  },
  moreIcon: W.any,
  moreTransitionName: {
    type: String
  },
  editable: {
    type: Object
  },
  locale: {
    type: Object,
    default: void 0
  },
  removeAriaLabel: String,
  onTabClick: {
    type: Function
  },
  popupClassName: String,
  getPopupContainer: de()
}, O3 = J({
  compatConfig: {
    MODE: 3
  },
  name: "OperationNode",
  inheritAttrs: !1,
  props: x3,
  emits: ["tabClick"],
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const [r, a] = yt(!1), [i, l] = yt(null), u = (p) => {
      const v = e.tabs.filter((y) => !y.disabled);
      let g = v.findIndex((y) => y.key === i.value) || 0;
      const b = v.length;
      for (let y = 0; y < b; y += 1) {
        g = (g + p + b) % b;
        const S = v[g];
        if (!S.disabled) {
          l(S.key);
          return;
        }
      }
    }, s = (p) => {
      const {
        which: v
      } = p;
      if (!r.value) {
        [ee.DOWN, ee.SPACE, ee.ENTER].includes(v) && (a(!0), p.preventDefault());
        return;
      }
      switch (v) {
        case ee.UP:
          u(-1), p.preventDefault();
          break;
        case ee.DOWN:
          u(1), p.preventDefault();
          break;
        case ee.ESC:
          a(!1);
          break;
        case ee.SPACE:
        case ee.ENTER:
          i.value !== null && e.onTabClick(i.value, p);
          break;
      }
    }, c = T(() => `${e.id}-more-popup`), d = T(() => i.value !== null ? `${c.value}-${i.value}` : null), f = (p, v) => {
      p.preventDefault(), p.stopPropagation(), e.editable.onEdit("remove", {
        key: v,
        event: p
      });
    };
    return ze(() => {
      le(i, () => {
        const p = document.getElementById(d.value);
        p && p.scrollIntoView && p.scrollIntoView(!1);
      }, {
        flush: "post",
        immediate: !0
      });
    }), le(r, () => {
      r.value || l(null);
    }), iS({}), () => {
      var p;
      const {
        prefixCls: v,
        id: g,
        tabs: b,
        locale: y,
        mobile: S,
        moreIcon: w = ((p = o.moreIcon) === null || p === void 0 ? void 0 : p.call(o)) || m(Ds, null, null),
        moreTransitionName: C,
        editable: $,
        tabBarGutter: O,
        rtl: x,
        onTabClick: M,
        popupClassName: _
      } = e;
      if (!b.length)
        return null;
      const N = `${v}-dropdown`, I = y == null ? void 0 : y.dropdownAriaLabel, E = {
        [x ? "marginRight" : "marginLeft"]: O
      };
      b.length || (E.visibility = "hidden", E.order = 1);
      const B = ae({
        [`${N}-rtl`]: x,
        [`${_}`]: !0
      }), k = S ? null : m(UN, {
        prefixCls: N,
        trigger: ["hover"],
        visible: r.value,
        transitionName: C,
        onVisibleChange: a,
        overlayClassName: B,
        mouseEnterDelay: 0.1,
        mouseLeaveDelay: 0.1,
        getPopupContainer: e.getPopupContainer
      }, {
        overlay: () => m(ho, {
          onClick: (P) => {
            let {
              key: R,
              domEvent: D
            } = P;
            M(R, D), a(!1);
          },
          id: c.value,
          tabindex: -1,
          role: "listbox",
          "aria-activedescendant": d.value,
          selectedKeys: [i.value],
          "aria-label": I !== void 0 ? I : "expanded dropdown"
        }, {
          default: () => [b.map((P) => {
            var R, D;
            const A = $ && P.closable !== !1 && !P.disabled;
            return m(go, {
              key: P.key,
              id: `${c.value}-${P.key}`,
              role: "option",
              "aria-controls": g && `${g}-panel-${P.key}`,
              disabled: P.disabled
            }, {
              default: () => [m("span", null, [typeof P.tab == "function" ? P.tab() : P.tab]), A && m("button", {
                type: "button",
                "aria-label": e.removeAriaLabel || "remove",
                tabindex: 0,
                class: `${N}-menu-item-remove`,
                onClick: (H) => {
                  H.stopPropagation(), f(H, P.key);
                }
              }, [((R = P.closeIcon) === null || R === void 0 ? void 0 : R.call(P)) || ((D = $.removeIcon) === null || D === void 0 ? void 0 : D.call($)) || "×"])]
            });
          })]
        }),
        default: () => m("button", {
          type: "button",
          class: `${v}-nav-more`,
          style: E,
          tabindex: -1,
          "aria-hidden": "true",
          "aria-haspopup": "listbox",
          "aria-controls": c.value,
          id: `${g}-more`,
          "aria-expanded": r.value,
          onKeydown: s
        }, [w])
      });
      return m("div", {
        class: ae(`${v}-nav-operations`, n.class),
        style: n.style
      }, [k, m(o$, {
        prefixCls: v,
        locale: y,
        editable: $
      }, null)]);
    };
  }
}), r$ = Symbol("tabsContextKey"), a$ = (e) => {
  ot(r$, e);
}, i$ = () => nt(r$, {
  tabs: G([]),
  prefixCls: G()
});
J({
  compatConfig: {
    MODE: 3
  },
  name: "TabsContextProvider",
  inheritAttrs: !1,
  props: {
    tabs: {
      type: Object,
      default: void 0
    },
    prefixCls: {
      type: String,
      default: void 0
    }
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    return a$(bd(e)), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
});
const P3 = 0.1, $g = 0.01, ml = 20, Cg = Math.pow(0.995, ml);
function I3(e, t) {
  const [n, o] = yt(), [r, a] = yt(0), [i, l] = yt(0), [u, s] = yt(), c = G();
  function d($) {
    const {
      screenX: O,
      screenY: x
    } = $.touches[0];
    o({
      x: O,
      y: x
    }), clearInterval(c.value);
  }
  function f($) {
    if (!n.value)
      return;
    $.preventDefault();
    const {
      screenX: O,
      screenY: x
    } = $.touches[0], M = O - n.value.x, _ = x - n.value.y;
    t(M, _), o({
      x: O,
      y: x
    });
    const N = Date.now();
    l(N - r.value), a(N), s({
      x: M,
      y: _
    });
  }
  function p() {
    if (!n.value)
      return;
    const $ = u.value;
    if (o(null), s(null), $) {
      const O = $.x / i.value, x = $.y / i.value, M = Math.abs(O), _ = Math.abs(x);
      if (Math.max(M, _) < P3)
        return;
      let N = O, I = x;
      c.value = setInterval(() => {
        if (Math.abs(N) < $g && Math.abs(I) < $g) {
          clearInterval(c.value);
          return;
        }
        N *= Cg, I *= Cg, t(N * ml, I * ml);
      }, ml);
    }
  }
  const v = G();
  function g($) {
    const {
      deltaX: O,
      deltaY: x
    } = $;
    let M = 0;
    const _ = Math.abs(O), N = Math.abs(x);
    _ === N ? M = v.value === "x" ? O : x : _ > N ? (M = O, v.value = "x") : (M = x, v.value = "y"), t(-M, -M) && $.preventDefault();
  }
  const b = G({
    onTouchStart: d,
    onTouchMove: f,
    onTouchEnd: p,
    onWheel: g
  });
  function y($) {
    b.value.onTouchStart($);
  }
  function S($) {
    b.value.onTouchMove($);
  }
  function w($) {
    b.value.onTouchEnd($);
  }
  function C($) {
    b.value.onWheel($);
  }
  ze(() => {
    var $, O;
    document.addEventListener("touchmove", S, {
      passive: !1
    }), document.addEventListener("touchend", w, {
      passive: !1
    }), ($ = e.value) === null || $ === void 0 || $.addEventListener("touchstart", y, {
      passive: !1
    }), (O = e.value) === null || O === void 0 || O.addEventListener("wheel", C, {
      passive: !1
    });
  }), at(() => {
    document.removeEventListener("touchmove", S), document.removeEventListener("touchend", w);
  });
}
function wg(e, t) {
  const n = G(e);
  function o(r) {
    const a = typeof r == "function" ? r(n.value) : r;
    a !== n.value && t(a, n.value), n.value = a;
  }
  return [n, o];
}
const ep = () => {
  const e = G(/* @__PURE__ */ new Map()), t = (n) => (o) => {
    e.value.set(n, o);
  };
  return yd(() => {
    e.value = /* @__PURE__ */ new Map();
  }), [t, e];
}, xg = {
  width: 0,
  height: 0,
  left: 0,
  top: 0,
  right: 0
}, T3 = () => ({
  id: {
    type: String
  },
  tabPosition: {
    type: String
  },
  activeKey: {
    type: [String, Number]
  },
  rtl: {
    type: Boolean
  },
  animated: He(),
  editable: He(),
  moreIcon: W.any,
  moreTransitionName: {
    type: String
  },
  mobile: {
    type: Boolean
  },
  tabBarGutter: {
    type: Number
  },
  renderTabBar: {
    type: Function
  },
  locale: He(),
  popupClassName: String,
  getPopupContainer: de(),
  onTabClick: {
    type: Function
  },
  onTabScroll: {
    type: Function
  }
}), E3 = (e, t) => {
  const {
    offsetWidth: n,
    offsetHeight: o,
    offsetTop: r,
    offsetLeft: a
  } = e, {
    width: i,
    height: l,
    x: u,
    y: s
  } = e.getBoundingClientRect();
  return Math.abs(i - n) < 1 ? [i, l, u - t.x, s - t.y] : [n, o, a, r];
}, Og = J({
  compatConfig: {
    MODE: 3
  },
  name: "TabNavList",
  inheritAttrs: !1,
  props: T3(),
  slots: Object,
  emits: ["tabClick", "tabScroll"],
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const {
      tabs: r,
      prefixCls: a
    } = i$(), i = K(), l = K(), u = K(), s = K(), [c, d] = ep(), f = T(() => e.tabPosition === "top" || e.tabPosition === "bottom"), [p, v] = wg(0, (be, pe) => {
      f.value && e.onTabScroll && e.onTabScroll({
        direction: be > pe ? "left" : "right"
      });
    }), [g, b] = wg(0, (be, pe) => {
      !f.value && e.onTabScroll && e.onTabScroll({
        direction: be > pe ? "top" : "bottom"
      });
    }), [y, S] = yt(0), [w, C] = yt(0), [$, O] = yt(null), [x, M] = yt(null), [_, N] = yt(0), [I, E] = yt(0), [B, k] = $3(/* @__PURE__ */ new Map()), P = w3(r, B), R = T(() => `${a.value}-nav-operations-hidden`), D = K(0), A = K(0);
    Ve(() => {
      f.value ? e.rtl ? (D.value = 0, A.value = Math.max(0, y.value - $.value)) : (D.value = Math.min(0, $.value - y.value), A.value = 0) : (D.value = Math.min(0, x.value - w.value), A.value = 0);
    });
    const H = (be) => be < D.value ? D.value : be > A.value ? A.value : be, j = K(), [z, F] = yt(), U = () => {
      F(Date.now());
    }, Q = () => {
      clearTimeout(j.value);
    }, q = (be, pe) => {
      be((xe) => H(xe + pe));
    };
    I3(i, (be, pe) => {
      if (f.value) {
        if ($.value >= y.value)
          return !1;
        q(v, be);
      } else {
        if (x.value >= w.value)
          return !1;
        q(b, pe);
      }
      return Q(), U(), !0;
    }), le(z, () => {
      Q(), z.value && (j.value = setTimeout(() => {
        F(0);
      }, 100));
    });
    const oe = function() {
      let be = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : e.activeKey;
      const pe = P.value.get(be) || {
        width: 0,
        height: 0,
        left: 0,
        right: 0,
        top: 0
      };
      if (f.value) {
        let xe = p.value;
        e.rtl ? pe.right < p.value ? xe = pe.right : pe.right + pe.width > p.value + $.value && (xe = pe.right + pe.width - $.value) : pe.left < -p.value ? xe = -pe.left : pe.left + pe.width > -p.value + $.value && (xe = -(pe.left + pe.width - $.value)), b(0), v(H(xe));
      } else {
        let xe = g.value;
        pe.top < -g.value ? xe = -pe.top : pe.top + pe.height > -g.value + x.value && (xe = -(pe.top + pe.height - x.value)), v(0), b(H(xe));
      }
    }, Z = K(0), ne = K(0);
    Ve(() => {
      let be, pe, xe, Ne, ye, Ce;
      const Te = P.value;
      ["top", "bottom"].includes(e.tabPosition) ? (be = "width", Ne = $.value, ye = y.value, Ce = _.value, pe = e.rtl ? "right" : "left", xe = Math.abs(p.value)) : (be = "height", Ne = x.value, ye = y.value, Ce = I.value, pe = "top", xe = -g.value);
      let te = Ne;
      ye + Ce > Ne && ye < Ne && (te = Ne - Ce);
      const se = r.value;
      if (!se.length)
        return [Z.value, ne.value] = [0, 0];
      const Pe = se.length;
      let _e = Pe;
      for (let Be = 0; Be < Pe; Be += 1) {
        const ue = Te.get(se[Be].key) || xg;
        if (ue[pe] + ue[be] > xe + te) {
          _e = Be - 1;
          break;
        }
      }
      let Ee = 0;
      for (let Be = Pe - 1; Be >= 0; Be -= 1)
        if ((Te.get(se[Be].key) || xg)[pe] < xe) {
          Ee = Be + 1;
          break;
        }
      return [Z.value, ne.value] = [Ee, _e];
    });
    const Y = () => {
      k(() => {
        var be;
        const pe = /* @__PURE__ */ new Map(), xe = (be = l.value) === null || be === void 0 ? void 0 : be.getBoundingClientRect();
        return r.value.forEach((Ne) => {
          let {
            key: ye
          } = Ne;
          const Ce = d.value.get(ye), Te = (Ce == null ? void 0 : Ce.$el) || Ce;
          if (Te) {
            const [te, se, Pe, _e] = E3(Te, xe);
            pe.set(ye, {
              width: te,
              height: se,
              left: Pe,
              top: _e
            });
          }
        }), pe;
      });
    };
    le(() => r.value.map((be) => be.key).join("%%"), () => {
      Y();
    }, {
      flush: "post"
    });
    const V = () => {
      var be, pe, xe, Ne, ye;
      const Ce = ((be = i.value) === null || be === void 0 ? void 0 : be.offsetWidth) || 0, Te = ((pe = i.value) === null || pe === void 0 ? void 0 : pe.offsetHeight) || 0, te = ((xe = s.value) === null || xe === void 0 ? void 0 : xe.$el) || {}, se = te.offsetWidth || 0, Pe = te.offsetHeight || 0;
      O(Ce), M(Te), N(se), E(Pe);
      const _e = (((Ne = l.value) === null || Ne === void 0 ? void 0 : Ne.offsetWidth) || 0) - se, Ee = (((ye = l.value) === null || ye === void 0 ? void 0 : ye.offsetHeight) || 0) - Pe;
      S(_e), C(Ee), Y();
    }, X = T(() => [...r.value.slice(0, Z.value), ...r.value.slice(ne.value + 1)]), [re, ie] = yt(), he = T(() => P.value.get(e.activeKey)), ge = K(), we = () => {
      Ue.cancel(ge.value);
    };
    le([he, f, () => e.rtl], () => {
      const be = {};
      he.value && (f.value ? (e.rtl ? be.right = Da(he.value.right) : be.left = Da(he.value.left), be.width = Da(he.value.width)) : (be.top = Da(he.value.top), be.height = Da(he.value.height))), we(), ge.value = Ue(() => {
        ie(be);
      });
    }), le([() => e.activeKey, he, P, f], () => {
      oe();
    }, {
      flush: "post"
    }), le([() => e.rtl, () => e.tabBarGutter, () => e.activeKey, () => r.value], () => {
      V();
    }, {
      flush: "post"
    });
    const Le = (be) => {
      let {
        position: pe,
        prefixCls: xe,
        extra: Ne
      } = be;
      if (!Ne)
        return null;
      const ye = Ne == null ? void 0 : Ne({
        position: pe
      });
      return ye ? m("div", {
        class: `${xe}-extra-content`
      }, [ye]) : null;
    };
    return at(() => {
      Q(), we();
    }), () => {
      const {
        id: be,
        animated: pe,
        activeKey: xe,
        rtl: Ne,
        editable: ye,
        locale: Ce,
        tabPosition: Te,
        tabBarGutter: te,
        onTabClick: se
      } = e, {
        class: Pe,
        style: _e
      } = n, Ee = a.value, Be = !!X.value.length, ue = `${Ee}-nav-wrap`;
      let fe, ve, Ie, Fe;
      f.value ? Ne ? (ve = p.value > 0, fe = p.value + $.value < y.value) : (fe = p.value < 0, ve = -p.value + $.value < y.value) : (Ie = g.value < 0, Fe = -g.value + x.value < w.value);
      const Oe = {};
      Te === "top" || Te === "bottom" ? Oe[Ne ? "marginRight" : "marginLeft"] = typeof te == "number" ? `${te}px` : te : Oe.marginTop = typeof te == "number" ? `${te}px` : te;
      const De = r.value.map((je, et) => {
        const {
          key: Ge
        } = je;
        return m(C3, {
          id: be,
          prefixCls: Ee,
          key: Ge,
          tab: je,
          style: et === 0 ? void 0 : Oe,
          closable: je.closable,
          editable: ye,
          active: Ge === xe,
          removeAriaLabel: Ce == null ? void 0 : Ce.removeAriaLabel,
          ref: c(Ge),
          onClick: (tt) => {
            se(Ge, tt);
          },
          onFocus: () => {
            oe(Ge), U(), i.value && (Ne || (i.value.scrollLeft = 0), i.value.scrollTop = 0);
          }
        }, o);
      });
      return m("div", {
        role: "tablist",
        class: ae(`${Ee}-nav`, Pe),
        style: _e,
        onKeydown: () => {
          U();
        }
      }, [m(Le, {
        position: "left",
        prefixCls: Ee,
        extra: o.leftExtra
      }, null), m(br, {
        onResize: V
      }, {
        default: () => [m("div", {
          class: ae(ue, {
            [`${ue}-ping-left`]: fe,
            [`${ue}-ping-right`]: ve,
            [`${ue}-ping-top`]: Ie,
            [`${ue}-ping-bottom`]: Fe
          }),
          ref: i
        }, [m(br, {
          onResize: V
        }, {
          default: () => [m("div", {
            ref: l,
            class: `${Ee}-nav-list`,
            style: {
              transform: `translate(${p.value}px, ${g.value}px)`,
              transition: z.value ? "none" : void 0
            }
          }, [De, m(o$, {
            ref: s,
            prefixCls: Ee,
            locale: Ce,
            editable: ye,
            style: h(h({}, De.length === 0 ? void 0 : Oe), {
              visibility: Be ? "hidden" : null
            })
          }, null), m("div", {
            class: ae(`${Ee}-ink-bar`, {
              [`${Ee}-ink-bar-animated`]: pe.inkBar
            }),
            style: re.value
          }, null)])]
        })])]
      }), m(O3, L(L({}, e), {}, {
        removeAriaLabel: Ce == null ? void 0 : Ce.removeAriaLabel,
        ref: u,
        prefixCls: Ee,
        tabs: X.value,
        class: !Be && R.value
      }), z0(o, ["moreIcon"])), m(Le, {
        position: "right",
        prefixCls: Ee,
        extra: o.rightExtra
      }, null), m(Le, {
        position: "right",
        prefixCls: Ee,
        extra: o.tabBarExtraContent
      }, null)]);
    };
  }
}), M3 = J({
  compatConfig: {
    MODE: 3
  },
  name: "TabPanelList",
  inheritAttrs: !1,
  props: {
    activeKey: {
      type: [String, Number]
    },
    id: {
      type: String
    },
    rtl: {
      type: Boolean
    },
    animated: {
      type: Object,
      default: void 0
    },
    tabPosition: {
      type: String
    },
    destroyInactiveTabPane: {
      type: Boolean
    }
  },
  setup(e) {
    const {
      tabs: t,
      prefixCls: n
    } = i$();
    return () => {
      const {
        id: o,
        activeKey: r,
        animated: a,
        tabPosition: i,
        rtl: l,
        destroyInactiveTabPane: u
      } = e, s = a.tabPane, c = n.value, d = t.value.findIndex((f) => f.key === r);
      return m("div", {
        class: `${c}-content-holder`
      }, [m("div", {
        class: [`${c}-content`, `${c}-content-${i}`, {
          [`${c}-content-animated`]: s
        }],
        style: d && s ? {
          [l ? "marginRight" : "marginLeft"]: `-${d}00%`
        } : null
      }, [t.value.map((f) => Tt(f.node, {
        key: f.key,
        prefixCls: c,
        tabKey: f.key,
        id: o,
        animated: s,
        active: f.key === r,
        destroyInactiveTabPane: u
      }))])]);
    };
  }
});
var _3 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z" } }, { tag: "path", attrs: { d: "M192 474h672q8 0 8 8v60q0 8-8 8H160q-8 0-8-8v-60q0-8 8-8z" } }] }, name: "plus", theme: "outlined" };
function Pg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      D3(e, r, n[r]);
    });
  }
  return e;
}
function D3(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Ls = function(t, n) {
  var o = Pg({}, t, n.attrs);
  return m(it, Pg({}, o, {
    icon: _3
  }), null);
};
Ls.displayName = "PlusOutlined";
Ls.inheritAttrs = !1;
const A3 = (e) => {
  const {
    componentCls: t,
    motionDurationSlow: n
  } = e;
  return [
    {
      [t]: {
        [`${t}-switch`]: {
          "&-appear, &-enter": {
            transition: "none",
            "&-start": {
              opacity: 0
            },
            "&-active": {
              opacity: 1,
              transition: `opacity ${n}`
            }
          },
          "&-leave": {
            position: "absolute",
            transition: "none",
            inset: 0,
            "&-start": {
              opacity: 1
            },
            "&-active": {
              opacity: 0,
              transition: `opacity ${n}`
            }
          }
        }
      }
    },
    // Follow code may reuse in other components
    [Go(e, "slide-up"), Go(e, "slide-down")]
  ];
}, N3 = (e) => {
  const {
    componentCls: t,
    tabsCardHorizontalPadding: n,
    tabsCardHeadBackground: o,
    tabsCardGutter: r,
    colorSplit: a
  } = e;
  return {
    [`${t}-card`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        [`${t}-tab`]: {
          margin: 0,
          padding: n,
          background: o,
          border: `${e.lineWidth}px ${e.lineType} ${a}`,
          transition: `all ${e.motionDurationSlow} ${e.motionEaseInOut}`
        },
        [`${t}-tab-active`]: {
          color: e.colorPrimary,
          background: e.colorBgContainer
        },
        [`${t}-ink-bar`]: {
          visibility: "hidden"
        }
      },
      // ========================== Top & Bottom ==========================
      [`&${t}-top, &${t}-bottom`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab + ${t}-tab`]: {
            marginLeft: {
              _skip_check_: !0,
              value: `${r}px`
            }
          }
        }
      },
      [`&${t}-top`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab`]: {
            borderRadius: `${e.borderRadiusLG}px ${e.borderRadiusLG}px 0 0`
          },
          [`${t}-tab-active`]: {
            borderBottomColor: e.colorBgContainer
          }
        }
      },
      [`&${t}-bottom`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab`]: {
            borderRadius: `0 0 ${e.borderRadiusLG}px ${e.borderRadiusLG}px`
          },
          [`${t}-tab-active`]: {
            borderTopColor: e.colorBgContainer
          }
        }
      },
      // ========================== Left & Right ==========================
      [`&${t}-left, &${t}-right`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab + ${t}-tab`]: {
            marginTop: `${r}px`
          }
        }
      },
      [`&${t}-left`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `${e.borderRadiusLG}px 0 0 ${e.borderRadiusLG}px`
            }
          },
          [`${t}-tab-active`]: {
            borderRightColor: {
              _skip_check_: !0,
              value: e.colorBgContainer
            }
          }
        }
      },
      [`&${t}-right`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `0 ${e.borderRadiusLG}px ${e.borderRadiusLG}px 0`
            }
          },
          [`${t}-tab-active`]: {
            borderLeftColor: {
              _skip_check_: !0,
              value: e.colorBgContainer
            }
          }
        }
      }
    }
  };
}, R3 = (e) => {
  const {
    componentCls: t,
    tabsHoverColor: n,
    dropdownEdgeChildVerticalPadding: o
  } = e;
  return {
    [`${t}-dropdown`]: h(h({}, st(e)), {
      position: "absolute",
      top: -9999,
      left: {
        _skip_check_: !0,
        value: -9999
      },
      zIndex: e.zIndexPopup,
      display: "block",
      "&-hidden": {
        display: "none"
      },
      [`${t}-dropdown-menu`]: {
        maxHeight: e.tabsDropdownHeight,
        margin: 0,
        padding: `${o}px 0`,
        overflowX: "hidden",
        overflowY: "auto",
        textAlign: {
          _skip_check_: !0,
          value: "left"
        },
        listStyleType: "none",
        backgroundColor: e.colorBgContainer,
        backgroundClip: "padding-box",
        borderRadius: e.borderRadiusLG,
        outline: "none",
        boxShadow: e.boxShadowSecondary,
        "&-item": h(h({}, So), {
          display: "flex",
          alignItems: "center",
          minWidth: e.tabsDropdownWidth,
          margin: 0,
          padding: `${e.paddingXXS}px ${e.paddingSM}px`,
          color: e.colorText,
          fontWeight: "normal",
          fontSize: e.fontSize,
          lineHeight: e.lineHeight,
          cursor: "pointer",
          transition: `all ${e.motionDurationSlow}`,
          "> span": {
            flex: 1,
            whiteSpace: "nowrap"
          },
          "&-remove": {
            flex: "none",
            marginLeft: {
              _skip_check_: !0,
              value: e.marginSM
            },
            color: e.colorTextDescription,
            fontSize: e.fontSizeSM,
            background: "transparent",
            border: 0,
            cursor: "pointer",
            "&:hover": {
              color: n
            }
          },
          "&:hover": {
            background: e.controlItemBgHover
          },
          "&-disabled": {
            "&, &:hover": {
              color: e.colorTextDisabled,
              background: "transparent",
              cursor: "not-allowed"
            }
          }
        })
      }
    })
  };
}, F3 = (e) => {
  const {
    componentCls: t,
    margin: n,
    colorSplit: o
  } = e;
  return {
    // ========================== Top & Bottom ==========================
    [`${t}-top, ${t}-bottom`]: {
      flexDirection: "column",
      [`> ${t}-nav, > div > ${t}-nav`]: {
        margin: `0 0 ${n}px 0`,
        "&::before": {
          position: "absolute",
          right: {
            _skip_check_: !0,
            value: 0
          },
          left: {
            _skip_check_: !0,
            value: 0
          },
          borderBottom: `${e.lineWidth}px ${e.lineType} ${o}`,
          content: "''"
        },
        [`${t}-ink-bar`]: {
          height: e.lineWidthBold,
          "&-animated": {
            transition: `width ${e.motionDurationSlow}, left ${e.motionDurationSlow},
            right ${e.motionDurationSlow}`
          }
        },
        [`${t}-nav-wrap`]: {
          "&::before, &::after": {
            top: 0,
            bottom: 0,
            width: e.controlHeight
          },
          "&::before": {
            left: {
              _skip_check_: !0,
              value: 0
            },
            boxShadow: e.boxShadowTabsOverflowLeft
          },
          "&::after": {
            right: {
              _skip_check_: !0,
              value: 0
            },
            boxShadow: e.boxShadowTabsOverflowRight
          },
          [`&${t}-nav-wrap-ping-left::before`]: {
            opacity: 1
          },
          [`&${t}-nav-wrap-ping-right::after`]: {
            opacity: 1
          }
        }
      }
    },
    [`${t}-top`]: {
      [`> ${t}-nav,
        > div > ${t}-nav`]: {
        "&::before": {
          bottom: 0
        },
        [`${t}-ink-bar`]: {
          bottom: 0
        }
      }
    },
    [`${t}-bottom`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        order: 1,
        marginTop: `${n}px`,
        marginBottom: 0,
        "&::before": {
          top: 0
        },
        [`${t}-ink-bar`]: {
          top: 0
        }
      },
      [`> ${t}-content-holder, > div > ${t}-content-holder`]: {
        order: 0
      }
    },
    // ========================== Left & Right ==========================
    [`${t}-left, ${t}-right`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        flexDirection: "column",
        minWidth: e.controlHeight * 1.25,
        // >>>>>>>>>>> Tab
        [`${t}-tab`]: {
          padding: `${e.paddingXS}px ${e.paddingLG}px`,
          textAlign: "center"
        },
        [`${t}-tab + ${t}-tab`]: {
          margin: `${e.margin}px 0 0 0`
        },
        // >>>>>>>>>>> Nav
        [`${t}-nav-wrap`]: {
          flexDirection: "column",
          "&::before, &::after": {
            right: {
              _skip_check_: !0,
              value: 0
            },
            left: {
              _skip_check_: !0,
              value: 0
            },
            height: e.controlHeight
          },
          "&::before": {
            top: 0,
            boxShadow: e.boxShadowTabsOverflowTop
          },
          "&::after": {
            bottom: 0,
            boxShadow: e.boxShadowTabsOverflowBottom
          },
          [`&${t}-nav-wrap-ping-top::before`]: {
            opacity: 1
          },
          [`&${t}-nav-wrap-ping-bottom::after`]: {
            opacity: 1
          }
        },
        // >>>>>>>>>>> Ink Bar
        [`${t}-ink-bar`]: {
          width: e.lineWidthBold,
          "&-animated": {
            transition: `height ${e.motionDurationSlow}, top ${e.motionDurationSlow}`
          }
        },
        [`${t}-nav-list, ${t}-nav-operations`]: {
          flex: "1 0 auto",
          flexDirection: "column"
        }
      }
    },
    [`${t}-left`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        [`${t}-ink-bar`]: {
          right: {
            _skip_check_: !0,
            value: 0
          }
        }
      },
      [`> ${t}-content-holder, > div > ${t}-content-holder`]: {
        marginLeft: {
          _skip_check_: !0,
          value: `-${e.lineWidth}px`
        },
        borderLeft: {
          _skip_check_: !0,
          value: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`
        },
        [`> ${t}-content > ${t}-tabpane`]: {
          paddingLeft: {
            _skip_check_: !0,
            value: e.paddingLG
          }
        }
      }
    },
    [`${t}-right`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        order: 1,
        [`${t}-ink-bar`]: {
          left: {
            _skip_check_: !0,
            value: 0
          }
        }
      },
      [`> ${t}-content-holder, > div > ${t}-content-holder`]: {
        order: 0,
        marginRight: {
          _skip_check_: !0,
          value: -e.lineWidth
        },
        borderRight: {
          _skip_check_: !0,
          value: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`
        },
        [`> ${t}-content > ${t}-tabpane`]: {
          paddingRight: {
            _skip_check_: !0,
            value: e.paddingLG
          }
        }
      }
    }
  };
}, B3 = (e) => {
  const {
    componentCls: t,
    padding: n
  } = e;
  return {
    [t]: {
      "&-small": {
        [`> ${t}-nav`]: {
          [`${t}-tab`]: {
            padding: `${e.paddingXS}px 0`,
            fontSize: e.fontSize
          }
        }
      },
      "&-large": {
        [`> ${t}-nav`]: {
          [`${t}-tab`]: {
            padding: `${n}px 0`,
            fontSize: e.fontSizeLG
          }
        }
      }
    },
    [`${t}-card`]: {
      [`&${t}-small`]: {
        [`> ${t}-nav`]: {
          [`${t}-tab`]: {
            padding: `${e.paddingXXS * 1.5}px ${n}px`
          }
        },
        [`&${t}-bottom`]: {
          [`> ${t}-nav ${t}-tab`]: {
            borderRadius: `0 0 ${e.borderRadius}px ${e.borderRadius}px`
          }
        },
        [`&${t}-top`]: {
          [`> ${t}-nav ${t}-tab`]: {
            borderRadius: `${e.borderRadius}px ${e.borderRadius}px 0 0`
          }
        },
        [`&${t}-right`]: {
          [`> ${t}-nav ${t}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `0 ${e.borderRadius}px ${e.borderRadius}px 0`
            }
          }
        },
        [`&${t}-left`]: {
          [`> ${t}-nav ${t}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `${e.borderRadius}px 0 0 ${e.borderRadius}px`
            }
          }
        }
      },
      [`&${t}-large`]: {
        [`> ${t}-nav`]: {
          [`${t}-tab`]: {
            padding: `${e.paddingXS}px ${n}px ${e.paddingXXS * 1.5}px`
          }
        }
      }
    }
  };
}, k3 = (e) => {
  const {
    componentCls: t,
    tabsActiveColor: n,
    tabsHoverColor: o,
    iconCls: r,
    tabsHorizontalGutter: a
  } = e, i = `${t}-tab`;
  return {
    [i]: {
      position: "relative",
      display: "inline-flex",
      alignItems: "center",
      padding: `${e.paddingSM}px 0`,
      fontSize: `${e.fontSize}px`,
      background: "transparent",
      border: 0,
      outline: "none",
      cursor: "pointer",
      "&-btn, &-remove": h({
        "&:focus:not(:focus-visible), &:active": {
          color: n
        }
      }, $i(e)),
      "&-btn": {
        outline: "none",
        transition: "all 0.3s"
      },
      "&-remove": {
        flex: "none",
        marginRight: {
          _skip_check_: !0,
          value: -e.marginXXS
        },
        marginLeft: {
          _skip_check_: !0,
          value: e.marginXS
        },
        color: e.colorTextDescription,
        fontSize: e.fontSizeSM,
        background: "transparent",
        border: "none",
        outline: "none",
        cursor: "pointer",
        transition: `all ${e.motionDurationSlow}`,
        "&:hover": {
          color: e.colorTextHeading
        }
      },
      "&:hover": {
        color: o
      },
      [`&${i}-active ${i}-btn`]: {
        color: e.colorPrimary,
        textShadow: e.tabsActiveTextShadow
      },
      [`&${i}-disabled`]: {
        color: e.colorTextDisabled,
        cursor: "not-allowed"
      },
      [`&${i}-disabled ${i}-btn, &${i}-disabled ${t}-remove`]: {
        "&:focus, &:active": {
          color: e.colorTextDisabled
        }
      },
      [`& ${i}-remove ${r}`]: {
        margin: 0
      },
      [r]: {
        marginRight: {
          _skip_check_: !0,
          value: e.marginSM
        }
      }
    },
    [`${i} + ${i}`]: {
      margin: {
        _skip_check_: !0,
        value: `0 0 0 ${a}px`
      }
    }
  };
}, L3 = (e) => {
  const {
    componentCls: t,
    tabsHorizontalGutter: n,
    iconCls: o,
    tabsCardGutter: r
  } = e;
  return {
    [`${t}-rtl`]: {
      direction: "rtl",
      [`${t}-nav`]: {
        [`${t}-tab`]: {
          margin: {
            _skip_check_: !0,
            value: `0 0 0 ${n}px`
          },
          [`${t}-tab:last-of-type`]: {
            marginLeft: {
              _skip_check_: !0,
              value: 0
            }
          },
          [o]: {
            marginRight: {
              _skip_check_: !0,
              value: 0
            },
            marginLeft: {
              _skip_check_: !0,
              value: `${e.marginSM}px`
            }
          },
          [`${t}-tab-remove`]: {
            marginRight: {
              _skip_check_: !0,
              value: `${e.marginXS}px`
            },
            marginLeft: {
              _skip_check_: !0,
              value: `-${e.marginXXS}px`
            },
            [o]: {
              margin: 0
            }
          }
        }
      },
      [`&${t}-left`]: {
        [`> ${t}-nav`]: {
          order: 1
        },
        [`> ${t}-content-holder`]: {
          order: 0
        }
      },
      [`&${t}-right`]: {
        [`> ${t}-nav`]: {
          order: 0
        },
        [`> ${t}-content-holder`]: {
          order: 1
        }
      },
      // ====================== Card ======================
      [`&${t}-card${t}-top, &${t}-card${t}-bottom`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab + ${t}-tab`]: {
            marginRight: {
              _skip_check_: !0,
              value: `${r}px`
            },
            marginLeft: {
              _skip_check_: !0,
              value: 0
            }
          }
        }
      }
    },
    [`${t}-dropdown-rtl`]: {
      direction: "rtl"
    },
    [`${t}-menu-item`]: {
      [`${t}-dropdown-rtl`]: {
        textAlign: {
          _skip_check_: !0,
          value: "right"
        }
      }
    }
  };
}, H3 = (e) => {
  const {
    componentCls: t,
    tabsCardHorizontalPadding: n,
    tabsCardHeight: o,
    tabsCardGutter: r,
    tabsHoverColor: a,
    tabsActiveColor: i,
    colorSplit: l
  } = e;
  return {
    [t]: h(h(h(h({}, st(e)), {
      display: "flex",
      // ========================== Navigation ==========================
      [`> ${t}-nav, > div > ${t}-nav`]: {
        position: "relative",
        display: "flex",
        flex: "none",
        alignItems: "center",
        [`${t}-nav-wrap`]: {
          position: "relative",
          display: "flex",
          flex: "auto",
          alignSelf: "stretch",
          overflow: "hidden",
          whiteSpace: "nowrap",
          transform: "translate(0)",
          // >>>>> Ping shadow
          "&::before, &::after": {
            position: "absolute",
            zIndex: 1,
            opacity: 0,
            transition: `opacity ${e.motionDurationSlow}`,
            content: "''",
            pointerEvents: "none"
          }
        },
        [`${t}-nav-list`]: {
          position: "relative",
          display: "flex",
          transition: `opacity ${e.motionDurationSlow}`
        },
        // >>>>>>>> Operations
        [`${t}-nav-operations`]: {
          display: "flex",
          alignSelf: "stretch"
        },
        [`${t}-nav-operations-hidden`]: {
          position: "absolute",
          visibility: "hidden",
          pointerEvents: "none"
        },
        [`${t}-nav-more`]: {
          position: "relative",
          padding: n,
          background: "transparent",
          border: 0,
          "&::after": {
            position: "absolute",
            right: {
              _skip_check_: !0,
              value: 0
            },
            bottom: 0,
            left: {
              _skip_check_: !0,
              value: 0
            },
            height: e.controlHeightLG / 8,
            transform: "translateY(100%)",
            content: "''"
          }
        },
        [`${t}-nav-add`]: h({
          minWidth: `${o}px`,
          marginLeft: {
            _skip_check_: !0,
            value: `${r}px`
          },
          padding: `0 ${e.paddingXS}px`,
          background: "transparent",
          border: `${e.lineWidth}px ${e.lineType} ${l}`,
          borderRadius: `${e.borderRadiusLG}px ${e.borderRadiusLG}px 0 0`,
          outline: "none",
          cursor: "pointer",
          color: e.colorText,
          transition: `all ${e.motionDurationSlow} ${e.motionEaseInOut}`,
          "&:hover": {
            color: a
          },
          "&:active, &:focus:not(:focus-visible)": {
            color: i
          }
        }, $i(e))
      },
      [`${t}-extra-content`]: {
        flex: "none"
      },
      // ============================ InkBar ============================
      [`${t}-ink-bar`]: {
        position: "absolute",
        background: e.colorPrimary,
        pointerEvents: "none"
      }
    }), k3(e)), {
      // =========================== TabPanes ===========================
      [`${t}-content`]: {
        position: "relative",
        display: "flex",
        width: "100%",
        "&-animated": {
          transition: "margin 0.3s"
        }
      },
      [`${t}-content-holder`]: {
        flex: "auto",
        minWidth: 0,
        minHeight: 0
      },
      [`${t}-tabpane`]: {
        outline: "none",
        flex: "none",
        width: "100%"
      }
    }),
    [`${t}-centered`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        [`${t}-nav-wrap`]: {
          [`&:not([class*='${t}-nav-wrap-ping'])`]: {
            justifyContent: "center"
          }
        }
      }
    }
  };
}, z3 = ht("Tabs", (e) => {
  const t = e.controlHeightLG, n = qe(e, {
    tabsHoverColor: e.colorPrimaryHover,
    tabsActiveColor: e.colorPrimaryActive,
    tabsCardHorizontalPadding: `${(t - Math.round(e.fontSize * e.lineHeight)) / 2 - e.lineWidth}px ${e.padding}px`,
    tabsCardHeight: t,
    tabsCardGutter: e.marginXXS / 2,
    tabsHorizontalGutter: 32,
    tabsCardHeadBackground: e.colorFillAlter,
    dropdownEdgeChildVerticalPadding: e.paddingXXS,
    tabsActiveTextShadow: "0 0 0.25px currentcolor",
    tabsDropdownHeight: 200,
    tabsDropdownWidth: 120
  });
  return [B3(n), L3(n), F3(n), R3(n), N3(n), H3(n), A3(n)];
}, (e) => ({
  zIndexPopup: e.zIndexPopupBase + 50
}));
let Ig = 0;
const l$ = () => ({
  prefixCls: {
    type: String
  },
  id: {
    type: String
  },
  popupClassName: String,
  getPopupContainer: de(),
  activeKey: {
    type: [String, Number]
  },
  defaultActiveKey: {
    type: [String, Number]
  },
  direction: Ze(),
  animated: dt([Boolean, Object]),
  renderTabBar: de(),
  tabBarGutter: {
    type: Number
  },
  tabBarStyle: He(),
  tabPosition: Ze(),
  destroyInactiveTabPane: Me(),
  hideAdd: Boolean,
  type: Ze(),
  size: Ze(),
  centered: Boolean,
  onEdit: de(),
  onChange: de(),
  onTabClick: de(),
  onTabScroll: de(),
  "onUpdate:activeKey": de(),
  // Accessibility
  locale: He(),
  onPrevClick: de(),
  onNextClick: de(),
  tabBarExtraContent: W.any
});
function j3(e) {
  return e.map((t) => {
    if (on(t)) {
      const n = h({}, t.props || {});
      for (const [f, p] of Object.entries(n))
        delete n[f], n[yi(f)] = p;
      const o = t.children || {}, r = t.key !== void 0 ? t.key : void 0, {
        tab: a = o.tab,
        disabled: i,
        forceRender: l,
        closable: u,
        animated: s,
        active: c,
        destroyInactiveTabPane: d
      } = n;
      return h(h({
        key: r
      }, n), {
        node: t,
        closeIcon: o.closeIcon,
        tab: a,
        disabled: i === "" || i,
        forceRender: l === "" || l,
        closable: u === "" || u,
        animated: s === "" || s,
        active: c === "" || c,
        destroyInactiveTabPane: d === "" || d
      });
    }
    return null;
  }).filter((t) => t);
}
const V3 = J({
  compatConfig: {
    MODE: 3
  },
  name: "InternalTabs",
  inheritAttrs: !1,
  props: h(h({}, bt(l$(), {
    tabPosition: "top",
    animated: {
      inkBar: !0,
      tabPane: !1
    }
  })), {
    tabs: Nt()
  }),
  slots: Object,
  // emits: ['tabClick', 'tabScroll', 'change', 'update:activeKey'],
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    gt(e.onPrevClick === void 0 && e.onNextClick === void 0, "Tabs", "`onPrevClick / @prevClick` and `onNextClick / @nextClick` has been removed. Please use `onTabScroll / @tabScroll` instead."), gt(e.tabBarExtraContent === void 0, "Tabs", "`tabBarExtraContent` prop has been removed. Please use `rightExtra` slot instead."), gt(o.tabBarExtraContent === void 0, "Tabs", "`tabBarExtraContent` slot is deprecated. Please use `rightExtra` slot instead.");
    const {
      prefixCls: r,
      direction: a,
      size: i,
      rootPrefixCls: l,
      getPopupContainer: u
    } = Ke("tabs", e), [s, c] = z3(r), d = T(() => a.value === "rtl"), f = T(() => {
      const {
        animated: x,
        tabPosition: M
      } = e;
      return x === !1 || ["left", "right"].includes(M) ? {
        inkBar: !1,
        tabPane: !1
      } : x === !0 ? {
        inkBar: !0,
        tabPane: !0
      } : h({
        inkBar: !0,
        tabPane: !1
      }, typeof x == "object" ? x : {});
    }), [p, v] = yt(!1);
    ze(() => {
      v(qd());
    });
    const [g, b] = Gt(() => {
      var x;
      return (x = e.tabs[0]) === null || x === void 0 ? void 0 : x.key;
    }, {
      value: T(() => e.activeKey),
      defaultValue: e.defaultActiveKey
    }), [y, S] = yt(() => e.tabs.findIndex((x) => x.key === g.value));
    Ve(() => {
      var x;
      let M = e.tabs.findIndex((_) => _.key === g.value);
      M === -1 && (M = Math.max(0, Math.min(y.value, e.tabs.length - 1)), b((x = e.tabs[M]) === null || x === void 0 ? void 0 : x.key)), S(M);
    });
    const [w, C] = Gt(null, {
      value: T(() => e.id)
    }), $ = T(() => p.value && !["left", "right"].includes(e.tabPosition) ? "top" : e.tabPosition);
    ze(() => {
      e.id || (C(`rc-tabs-${process.env.NODE_ENV === "test" ? "test" : Ig}`), Ig += 1);
    });
    const O = (x, M) => {
      var _, N;
      (_ = e.onTabClick) === null || _ === void 0 || _.call(e, x, M);
      const I = x !== g.value;
      b(x), I && ((N = e.onChange) === null || N === void 0 || N.call(e, x));
    };
    return a$({
      tabs: T(() => e.tabs),
      prefixCls: r
    }), () => {
      const {
        id: x,
        type: M,
        tabBarGutter: _,
        tabBarStyle: N,
        locale: I,
        destroyInactiveTabPane: E,
        renderTabBar: B = o.renderTabBar,
        onTabScroll: k,
        hideAdd: P,
        centered: R
      } = e, D = {
        id: w.value,
        activeKey: g.value,
        animated: f.value,
        tabPosition: $.value,
        rtl: d.value,
        mobile: p.value
      };
      let A;
      M === "editable-card" && (A = {
        onEdit: (F, U) => {
          let {
            key: Q,
            event: q
          } = U;
          var oe;
          (oe = e.onEdit) === null || oe === void 0 || oe.call(e, F === "add" ? q : Q, F);
        },
        removeIcon: () => m(Qn, null, null),
        addIcon: o.addIcon ? o.addIcon : () => m(Ls, null, null),
        showAdd: P !== !0
      });
      let H;
      const j = h(h({}, D), {
        moreTransitionName: `${l.value}-slide-up`,
        editable: A,
        locale: I,
        tabBarGutter: _,
        onTabClick: O,
        onTabScroll: k,
        style: N,
        getPopupContainer: u.value,
        popupClassName: ae(e.popupClassName, c.value)
      });
      B ? H = B(h(h({}, j), {
        DefaultTabBar: Og
      })) : H = m(Og, j, z0(o, ["moreIcon", "leftExtra", "rightExtra", "tabBarExtraContent"]));
      const z = r.value;
      return s(m("div", L(L({}, n), {}, {
        id: x,
        class: ae(z, `${z}-${$.value}`, {
          [c.value]: !0,
          [`${z}-${i.value}`]: i.value,
          [`${z}-card`]: ["card", "editable-card"].includes(M),
          [`${z}-editable-card`]: M === "editable-card",
          [`${z}-centered`]: R,
          [`${z}-mobile`]: p.value,
          [`${z}-editable`]: M === "editable-card",
          [`${z}-rtl`]: d.value
        }, n.class)
      }), [H, m(M3, L(L({
        destroyInactiveTabPane: E
      }, D), {}, {
        animated: f.value
      }), null)]));
    };
  }
}), Qa = J({
  compatConfig: {
    MODE: 3
  },
  name: "ATabs",
  inheritAttrs: !1,
  props: bt(l$(), {
    tabPosition: "top",
    animated: {
      inkBar: !0,
      tabPane: !1
    }
  }),
  slots: Object,
  // emits: ['tabClick', 'tabScroll', 'change', 'update:activeKey'],
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      emit: r
    } = t;
    const a = (i) => {
      r("update:activeKey", i), r("change", i);
    };
    return () => {
      var i;
      const l = j3(xt((i = o.default) === null || i === void 0 ? void 0 : i.call(o)));
      return m(V3, L(L(L({}, pt(e, ["onUpdate:activeKey"])), n), {}, {
        onChange: a,
        tabs: l
      }), o);
    };
  }
}), W3 = () => ({
  tab: W.any,
  disabled: {
    type: Boolean
  },
  forceRender: {
    type: Boolean
  },
  closable: {
    type: Boolean
  },
  animated: {
    type: Boolean
  },
  active: {
    type: Boolean
  },
  destroyInactiveTabPane: {
    type: Boolean
  },
  // Pass by TabPaneList
  prefixCls: {
    type: String
  },
  tabKey: {
    type: [String, Number]
  },
  id: {
    type: String
  }
  // closeIcon: PropTypes.any,
}), ql = J({
  compatConfig: {
    MODE: 3
  },
  name: "ATabPane",
  inheritAttrs: !1,
  __ANT_TAB_PANE: !0,
  props: W3(),
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const r = G(e.forceRender);
    le([() => e.active, () => e.destroyInactiveTabPane], () => {
      e.active ? r.value = !0 : e.destroyInactiveTabPane && (r.value = !1);
    }, {
      immediate: !0
    });
    const a = T(() => e.active ? {} : e.animated ? {
      visibility: "hidden",
      height: 0,
      overflowY: "hidden"
    } : {
      display: "none"
    });
    return () => {
      var i;
      const {
        prefixCls: l,
        forceRender: u,
        id: s,
        active: c,
        tabKey: d
      } = e;
      return m("div", {
        id: s && `${s}-panel-${d}`,
        role: "tabpanel",
        tabindex: c ? 0 : -1,
        "aria-labelledby": s && `${s}-tab-${d}`,
        "aria-hidden": !c,
        style: [a.value, n.style],
        class: [`${l}-tabpane`, c && `${l}-tabpane-active`, n.class]
      }, [(c || r.value || u) && ((i = o.default) === null || i === void 0 ? void 0 : i.call(o))]);
    };
  }
});
Qa.TabPane = ql;
Qa.install = function(e) {
  return e.component(Qa.name, Qa), e.component(ql.name, ql), e;
};
const s$ = Symbol("TreeContextKey"), K3 = J({
  compatConfig: {
    MODE: 3
  },
  name: "TreeContext",
  props: {
    value: {
      type: Object
    }
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ot(s$, T(() => e.value)), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
}), tp = () => nt(s$, T(() => ({}))), u$ = Symbol("KeysStateKey"), U3 = (e) => {
  ot(u$, e);
}, c$ = () => nt(u$, {
  expandedKeys: K([]),
  selectedKeys: K([]),
  loadedKeys: K([]),
  loadingKeys: K([]),
  checkedKeys: K([]),
  halfCheckedKeys: K([]),
  expandedKeysSet: T(() => /* @__PURE__ */ new Set()),
  selectedKeysSet: T(() => /* @__PURE__ */ new Set()),
  loadedKeysSet: T(() => /* @__PURE__ */ new Set()),
  loadingKeysSet: T(() => /* @__PURE__ */ new Set()),
  checkedKeysSet: T(() => /* @__PURE__ */ new Set()),
  halfCheckedKeysSet: T(() => /* @__PURE__ */ new Set()),
  flattenNodes: K([])
}), G3 = (e) => {
  let {
    prefixCls: t,
    level: n,
    isStart: o,
    isEnd: r
  } = e;
  const a = `${t}-indent-unit`, i = [];
  for (let l = 0; l < n; l += 1)
    i.push(m("span", {
      key: l,
      class: {
        [a]: !0,
        [`${a}-start`]: o[l],
        [`${a}-end`]: r[l]
      }
    }, null));
  return m("span", {
    "aria-hidden": "true",
    class: `${t}-indent`
  }, [i]);
}, d$ = {
  eventKey: [String, Number],
  prefixCls: String,
  // By parent
  // expanded: { type: Boolean, default: undefined },
  // selected: { type: Boolean, default: undefined },
  // checked: { type: Boolean, default: undefined },
  // loaded: { type: Boolean, default: undefined },
  // loading: { type: Boolean, default: undefined },
  // halfChecked: { type: Boolean, default: undefined },
  // dragOver: { type: Boolean, default: undefined },
  // dragOverGapTop: { type: Boolean, default: undefined },
  // dragOverGapBottom: { type: Boolean, default: undefined },
  // pos: String,
  title: W.any,
  /** New added in Tree for easy data access */
  data: {
    type: Object,
    default: void 0
  },
  parent: {
    type: Object,
    default: void 0
  },
  isStart: {
    type: Array
  },
  isEnd: {
    type: Array
  },
  active: {
    type: Boolean,
    default: void 0
  },
  onMousemove: {
    type: Function
  },
  // By user
  isLeaf: {
    type: Boolean,
    default: void 0
  },
  checkable: {
    type: Boolean,
    default: void 0
  },
  selectable: {
    type: Boolean,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  disableCheckbox: {
    type: Boolean,
    default: void 0
  },
  icon: W.any,
  switcherIcon: W.any,
  domRef: {
    type: Function
  }
}, Y3 = {
  prefixCls: {
    type: String
  },
  // data: { type: Array as PropType<FlattenNode[]> },
  motion: {
    type: Object
  },
  focusable: {
    type: Boolean
  },
  activeItem: {
    type: Object
  },
  focused: {
    type: Boolean
  },
  tabindex: {
    type: Number
  },
  checkable: {
    type: Boolean
  },
  selectable: {
    type: Boolean
  },
  disabled: {
    type: Boolean
  },
  // expandedKeys: { type: Array as PropType<Key[]> },
  // selectedKeys: { type: Array as PropType<Key[]> },
  // checkedKeys: { type: Array as PropType<Key[]> },
  // loadedKeys: { type: Array as PropType<Key[]> },
  // loadingKeys: { type: Array as PropType<Key[]> },
  // halfCheckedKeys: { type: Array as PropType<Key[]> },
  // keyEntities: { type: Object as PropType<Record<Key, DataEntity<DataNode>>> },
  // dragging: { type: Boolean as PropType<boolean> },
  // dragOverNodeKey: { type: [String, Number] as PropType<Key> },
  // dropPosition: { type: Number as PropType<number> },
  // Virtual list
  height: {
    type: Number
  },
  itemHeight: {
    type: Number
  },
  virtual: {
    type: Boolean
  },
  onScroll: {
    type: Function
  },
  onKeydown: {
    type: Function
  },
  onFocus: {
    type: Function
  },
  onBlur: {
    type: Function
  },
  onActiveChange: {
    type: Function
  },
  onContextmenu: {
    type: Function
  },
  onListChangeStart: {
    type: Function
  },
  onListChangeEnd: {
    type: Function
  }
}, X3 = () => ({
  prefixCls: String,
  focusable: {
    type: Boolean,
    default: void 0
  },
  activeKey: [Number, String],
  tabindex: Number,
  children: W.any,
  treeData: {
    type: Array
  },
  fieldNames: {
    type: Object
  },
  showLine: {
    type: [Boolean, Object],
    default: void 0
  },
  showIcon: {
    type: Boolean,
    default: void 0
  },
  icon: W.any,
  selectable: {
    type: Boolean,
    default: void 0
  },
  expandAction: [String, Boolean],
  disabled: {
    type: Boolean,
    default: void 0
  },
  multiple: {
    type: Boolean,
    default: void 0
  },
  checkable: {
    type: Boolean,
    default: void 0
  },
  checkStrictly: {
    type: Boolean,
    default: void 0
  },
  draggable: {
    type: [Function, Boolean]
  },
  defaultExpandParent: {
    type: Boolean,
    default: void 0
  },
  autoExpandParent: {
    type: Boolean,
    default: void 0
  },
  defaultExpandAll: {
    type: Boolean,
    default: void 0
  },
  defaultExpandedKeys: {
    type: Array
  },
  expandedKeys: {
    type: Array
  },
  defaultCheckedKeys: {
    type: Array
  },
  checkedKeys: {
    type: [Object, Array]
  },
  defaultSelectedKeys: {
    type: Array
  },
  selectedKeys: {
    type: Array
  },
  allowDrop: {
    type: Function
  },
  dropIndicatorRender: {
    type: Function
  },
  onFocus: {
    type: Function
  },
  onBlur: {
    type: Function
  },
  onKeydown: {
    type: Function
  },
  onContextmenu: {
    type: Function
  },
  onClick: {
    type: Function
  },
  onDblclick: {
    type: Function
  },
  onScroll: {
    type: Function
  },
  onExpand: {
    type: Function
  },
  onCheck: {
    type: Function
  },
  onSelect: {
    type: Function
  },
  onLoad: {
    type: Function
  },
  loadData: {
    type: Function
  },
  loadedKeys: {
    type: Array
  },
  onMouseenter: {
    type: Function
  },
  onMouseleave: {
    type: Function
  },
  onRightClick: {
    type: Function
  },
  onDragstart: {
    type: Function
  },
  onDragenter: {
    type: Function
  },
  onDragover: {
    type: Function
  },
  onDragleave: {
    type: Function
  },
  onDragend: {
    type: Function
  },
  onDrop: {
    type: Function
  },
  /**
   * Used for `rc-tree-select` only.
   * Do not use in your production code directly since this will be refactor.
   */
  onActiveChange: {
    type: Function
  },
  filterTreeNode: {
    type: Function
  },
  motion: W.any,
  switcherIcon: W.any,
  // Virtual List
  height: Number,
  itemHeight: Number,
  virtual: {
    type: Boolean,
    default: void 0
  },
  // direction for drag logic
  direction: {
    type: String
  },
  rootClassName: String,
  rootStyle: Object
});
var q3 = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const Tg = "open", Eg = "close", Q3 = "---", Mg = J({
  compatConfig: {
    MODE: 3
  },
  name: "ATreeNode",
  inheritAttrs: !1,
  props: d$,
  isTreeNode: 1,
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      expose: r
    } = t;
    lt(!("slots" in e.data), `treeData slots is deprecated, please use ${Object.keys(e.data.slots || {}).map((te) => "`v-slot:" + te + "` ")}instead`);
    const a = K(!1), i = tp(), {
      expandedKeysSet: l,
      selectedKeysSet: u,
      loadedKeysSet: s,
      loadingKeysSet: c,
      checkedKeysSet: d,
      halfCheckedKeysSet: f
    } = c$(), {
      dragOverNodeKey: p,
      dropPosition: v,
      keyEntities: g
    } = i.value, b = T(() => gl(e.eventKey, {
      expandedKeysSet: l.value,
      selectedKeysSet: u.value,
      loadedKeysSet: s.value,
      loadingKeysSet: c.value,
      checkedKeysSet: d.value,
      halfCheckedKeysSet: f.value,
      dragOverNodeKey: p,
      dropPosition: v,
      keyEntities: g
    })), y = jn(() => b.value.expanded), S = jn(() => b.value.selected), w = jn(() => b.value.checked), C = jn(() => b.value.loaded), $ = jn(() => b.value.loading), O = jn(() => b.value.halfChecked), x = jn(() => b.value.dragOver), M = jn(() => b.value.dragOverGapTop), _ = jn(() => b.value.dragOverGapBottom), N = jn(() => b.value.pos), I = K(), E = T(() => {
      const {
        eventKey: te
      } = e, {
        keyEntities: se
      } = i.value, {
        children: Pe
      } = se[te] || {};
      return !!(Pe || []).length;
    }), B = T(() => {
      const {
        isLeaf: te
      } = e, {
        loadData: se
      } = i.value, Pe = E.value;
      return te === !1 ? !1 : te || !se && !Pe || se && C.value && !Pe;
    }), k = T(() => B.value ? null : y.value ? Tg : Eg), P = T(() => {
      const {
        disabled: te
      } = e, {
        disabled: se
      } = i.value;
      return !!(se || te);
    }), R = T(() => {
      const {
        checkable: te
      } = e, {
        checkable: se
      } = i.value;
      return !se || te === !1 ? !1 : se;
    }), D = T(() => {
      const {
        selectable: te
      } = e, {
        selectable: se
      } = i.value;
      return typeof te == "boolean" ? te : se;
    }), A = T(() => {
      const {
        data: te,
        active: se,
        checkable: Pe,
        disableCheckbox: _e,
        disabled: Ee,
        selectable: Be
      } = e;
      return h(h({
        active: se,
        checkable: Pe,
        disableCheckbox: _e,
        disabled: Ee,
        selectable: Be
      }, te), {
        dataRef: te,
        data: te,
        isLeaf: B.value,
        checked: w.value,
        expanded: y.value,
        loading: $.value,
        selected: S.value,
        halfChecked: O.value
      });
    }), H = On(), j = T(() => {
      const {
        eventKey: te
      } = e, {
        keyEntities: se
      } = i.value, {
        parent: Pe
      } = se[te] || {};
      return h(h({}, hl(h({}, e, b.value))), {
        parent: Pe
      });
    }), z = Et({
      eventData: j,
      eventKey: T(() => e.eventKey),
      selectHandle: I,
      pos: N,
      key: H.vnode.key
    });
    r(z);
    const F = (te) => {
      const {
        onNodeDoubleClick: se
      } = i.value;
      se(te, j.value);
    }, U = (te) => {
      if (P.value)
        return;
      const {
        onNodeSelect: se
      } = i.value;
      te.preventDefault(), se(te, j.value);
    }, Q = (te) => {
      if (P.value)
        return;
      const {
        disableCheckbox: se
      } = e, {
        onNodeCheck: Pe
      } = i.value;
      if (!R.value || se)
        return;
      te.preventDefault();
      const _e = !w.value;
      Pe(te, j.value, _e);
    }, q = (te) => {
      const {
        onNodeClick: se
      } = i.value;
      se(te, j.value), D.value ? U(te) : Q(te);
    }, oe = (te) => {
      const {
        onNodeMouseEnter: se
      } = i.value;
      se(te, j.value);
    }, Z = (te) => {
      const {
        onNodeMouseLeave: se
      } = i.value;
      se(te, j.value);
    }, ne = (te) => {
      const {
        onNodeContextMenu: se
      } = i.value;
      se(te, j.value);
    }, Y = (te) => {
      const {
        onNodeDragStart: se
      } = i.value;
      te.stopPropagation(), a.value = !0, se(te, z);
      try {
        te.dataTransfer.setData("text/plain", "");
      } catch {
      }
    }, V = (te) => {
      const {
        onNodeDragEnter: se
      } = i.value;
      te.preventDefault(), te.stopPropagation(), se(te, z);
    }, X = (te) => {
      const {
        onNodeDragOver: se
      } = i.value;
      te.preventDefault(), te.stopPropagation(), se(te, z);
    }, re = (te) => {
      const {
        onNodeDragLeave: se
      } = i.value;
      te.stopPropagation(), se(te, z);
    }, ie = (te) => {
      const {
        onNodeDragEnd: se
      } = i.value;
      te.stopPropagation(), a.value = !1, se(te, z);
    }, he = (te) => {
      const {
        onNodeDrop: se
      } = i.value;
      te.preventDefault(), te.stopPropagation(), a.value = !1, se(te, z);
    }, ge = (te) => {
      const {
        onNodeExpand: se
      } = i.value;
      $.value || se(te, j.value);
    }, we = () => {
      const {
        data: te
      } = e, {
        draggable: se
      } = i.value;
      return !!(se && (!se.nodeDraggable || se.nodeDraggable(te)));
    }, Le = () => {
      const {
        draggable: te,
        prefixCls: se
      } = i.value;
      return te && (te != null && te.icon) ? m("span", {
        class: `${se}-draggable-icon`
      }, [te.icon]) : null;
    }, be = () => {
      var te, se, Pe;
      const {
        switcherIcon: _e = o.switcherIcon || ((te = i.value.slots) === null || te === void 0 ? void 0 : te[(Pe = (se = e.data) === null || se === void 0 ? void 0 : se.slots) === null || Pe === void 0 ? void 0 : Pe.switcherIcon])
      } = e, {
        switcherIcon: Ee
      } = i.value, Be = _e || Ee;
      return typeof Be == "function" ? Be(A.value) : Be;
    }, pe = () => {
      const {
        loadData: te,
        onNodeLoad: se
      } = i.value;
      $.value || te && y.value && !B.value && !E.value && !C.value && se(j.value);
    };
    ze(() => {
      pe();
    }), Co(() => {
      pe();
    });
    const xe = () => {
      const {
        prefixCls: te
      } = i.value, se = be();
      if (B.value)
        return se !== !1 ? m("span", {
          class: ae(`${te}-switcher`, `${te}-switcher-noop`)
        }, [se]) : null;
      const Pe = ae(`${te}-switcher`, `${te}-switcher_${y.value ? Tg : Eg}`);
      return se !== !1 ? m("span", {
        onClick: ge,
        class: Pe
      }, [se]) : null;
    }, Ne = () => {
      var te, se;
      const {
        disableCheckbox: Pe
      } = e, {
        prefixCls: _e
      } = i.value, Ee = P.value;
      return R.value ? m("span", {
        class: ae(`${_e}-checkbox`, w.value && `${_e}-checkbox-checked`, !w.value && O.value && `${_e}-checkbox-indeterminate`, (Ee || Pe) && `${_e}-checkbox-disabled`),
        onClick: Q
      }, [(se = (te = i.value).customCheckable) === null || se === void 0 ? void 0 : se.call(te)]) : null;
    }, ye = () => {
      const {
        prefixCls: te
      } = i.value;
      return m("span", {
        class: ae(`${te}-iconEle`, `${te}-icon__${k.value || "docu"}`, $.value && `${te}-icon_loading`)
      }, null);
    }, Ce = () => {
      const {
        disabled: te,
        eventKey: se
      } = e, {
        draggable: Pe,
        dropLevelOffset: _e,
        dropPosition: Ee,
        prefixCls: Be,
        indent: ue,
        dropIndicatorRender: fe,
        dragOverNodeKey: ve,
        direction: Ie
      } = i.value;
      return !te && Pe !== !1 && ve === se ? fe({
        dropPosition: Ee,
        dropLevelOffset: _e,
        indent: ue,
        prefixCls: Be,
        direction: Ie
      }) : null;
    }, Te = () => {
      var te, se, Pe, _e, Ee, Be;
      const {
        // title = slots.title ||
        //   context.value.slots?.[props.data?.slots?.title] ||
        //   context.value.slots?.title,
        // selected,
        icon: ue = o.icon,
        // loading,
        data: fe
      } = e, ve = o.title || ((te = i.value.slots) === null || te === void 0 ? void 0 : te[(Pe = (se = e.data) === null || se === void 0 ? void 0 : se.slots) === null || Pe === void 0 ? void 0 : Pe.title]) || ((_e = i.value.slots) === null || _e === void 0 ? void 0 : _e.title) || e.title, {
        prefixCls: Ie,
        showIcon: Fe,
        icon: Oe,
        loadData: De
        // slots: contextSlots,
      } = i.value, je = P.value, et = `${Ie}-node-content-wrapper`;
      let Ge;
      if (Fe) {
        const Bt = ue || ((Ee = i.value.slots) === null || Ee === void 0 ? void 0 : Ee[(Be = fe == null ? void 0 : fe.slots) === null || Be === void 0 ? void 0 : Be.icon]) || Oe;
        Ge = Bt ? m("span", {
          class: ae(`${Ie}-iconEle`, `${Ie}-icon__customize`)
        }, [typeof Bt == "function" ? Bt(A.value) : Bt]) : ye();
      } else
        De && $.value && (Ge = ye());
      let tt;
      typeof ve == "function" ? tt = ve(A.value) : tt = ve, tt = tt === void 0 ? Q3 : tt;
      const ut = m("span", {
        class: `${Ie}-title`
      }, [tt]);
      return m("span", {
        ref: I,
        title: typeof ve == "string" ? ve : "",
        class: ae(`${et}`, `${et}-${k.value || "normal"}`, !je && (S.value || a.value) && `${Ie}-node-selected`),
        onMouseenter: oe,
        onMouseleave: Z,
        onContextmenu: ne,
        onClick: q,
        onDblclick: F
      }, [Ge, ut, Ce()]);
    };
    return () => {
      const te = h(h({}, e), n), {
        eventKey: se,
        isLeaf: Pe,
        isStart: _e,
        isEnd: Ee,
        domRef: Be,
        active: ue,
        data: fe,
        onMousemove: ve,
        selectable: Ie
      } = te, Fe = q3(te, ["eventKey", "isLeaf", "isStart", "isEnd", "domRef", "active", "data", "onMousemove", "selectable"]), {
        prefixCls: Oe,
        filterTreeNode: De,
        keyEntities: je,
        dropContainerKey: et,
        dropTargetKey: Ge,
        draggingNodeKey: tt
      } = i.value, ut = P.value, Bt = _r(Fe, {
        aria: !0,
        data: !0
      }), {
        level: Jt
      } = je[se] || {}, en = Ee[Ee.length - 1], zt = we(), an = !ut && zt, Bn = tt === se, Eo = Ie !== void 0 ? {
        "aria-selected": !!Ie
      } : void 0;
      return m("div", L(L({
        ref: Be,
        class: ae(n.class, `${Oe}-treenode`, {
          [`${Oe}-treenode-disabled`]: ut,
          [`${Oe}-treenode-switcher-${y.value ? "open" : "close"}`]: !Pe,
          [`${Oe}-treenode-checkbox-checked`]: w.value,
          [`${Oe}-treenode-checkbox-indeterminate`]: O.value,
          [`${Oe}-treenode-selected`]: S.value,
          [`${Oe}-treenode-loading`]: $.value,
          [`${Oe}-treenode-active`]: ue,
          [`${Oe}-treenode-leaf-last`]: en,
          [`${Oe}-treenode-draggable`]: an,
          dragging: Bn,
          "drop-target": Ge === se,
          "drop-container": et === se,
          "drag-over": !ut && x.value,
          "drag-over-gap-top": !ut && M.value,
          "drag-over-gap-bottom": !ut && _.value,
          "filter-node": De && De(j.value)
        }),
        style: n.style,
        draggable: an,
        "aria-grabbed": Bn,
        onDragstart: an ? Y : void 0,
        onDragenter: zt ? V : void 0,
        onDragover: zt ? X : void 0,
        onDragleave: zt ? re : void 0,
        onDrop: zt ? he : void 0,
        onDragend: zt ? ie : void 0,
        onMousemove: ve
      }, Eo), Bt), [m(G3, {
        prefixCls: Oe,
        level: Jt,
        isStart: _e,
        isEnd: Ee
      }, null), Le(), xe(), Ne(), Te()]);
    };
  }
});
function co(e, t) {
  if (!e)
    return [];
  const n = e.slice(), o = n.indexOf(t);
  return o >= 0 && n.splice(o, 1), n;
}
function Ro(e, t) {
  const n = (e || []).slice();
  return n.indexOf(t) === -1 && n.push(t), n;
}
function np(e) {
  return e.split("-");
}
function f$(e, t) {
  return `${e}-${t}`;
}
function Z3(e) {
  return e && e.type && e.type.isTreeNode;
}
function J3(e, t) {
  const n = [], o = t[e];
  function r() {
    (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).forEach((i) => {
      let {
        key: l,
        children: u
      } = i;
      n.push(l), r(u);
    });
  }
  return r(o.children), n;
}
function eF(e) {
  if (e.parent) {
    const t = np(e.pos);
    return Number(t[t.length - 1]) === e.parent.children.length - 1;
  }
  return !1;
}
function tF(e) {
  const t = np(e.pos);
  return Number(t[t.length - 1]) === 0;
}
function _g(e, t, n, o, r, a, i, l, u, s) {
  var c;
  const {
    clientX: d,
    clientY: f
  } = e, {
    top: p,
    height: v
  } = e.target.getBoundingClientRect(), b = ((s === "rtl" ? -1 : 1) * (((r == null ? void 0 : r.x) || 0) - d) - 12) / o;
  let y = l[n.eventKey];
  if (f < p + v / 2) {
    const N = i.findIndex((B) => B.key === y.key), I = N <= 0 ? 0 : N - 1, E = i[I].key;
    y = l[E];
  }
  const S = y.key, w = y, C = y.key;
  let $ = 0, O = 0;
  if (!u.has(S))
    for (let N = 0; N < b && eF(y); N += 1)
      y = y.parent, O += 1;
  const x = t.eventData, M = y.node;
  let _ = !0;
  return tF(y) && y.level === 0 && f < p + v / 2 && a({
    dragNode: x,
    dropNode: M,
    dropPosition: -1
  }) && y.key === n.eventKey ? $ = -1 : (w.children || []).length && u.has(C) ? a({
    dragNode: x,
    dropNode: M,
    dropPosition: 0
  }) ? $ = 0 : _ = !1 : O === 0 ? b > -1.5 ? a({
    dragNode: x,
    dropNode: M,
    dropPosition: 1
  }) ? $ = 1 : _ = !1 : a({
    dragNode: x,
    dropNode: M,
    dropPosition: 0
  }) ? $ = 0 : a({
    dragNode: x,
    dropNode: M,
    dropPosition: 1
  }) ? $ = 1 : _ = !1 : a({
    dragNode: x,
    dropNode: M,
    dropPosition: 1
  }) ? $ = 1 : _ = !1, {
    dropPosition: $,
    dropLevelOffset: O,
    dropTargetKey: y.key,
    dropTargetPos: y.pos,
    dragOverNodeKey: C,
    dropContainerKey: $ === 0 ? null : ((c = y.parent) === null || c === void 0 ? void 0 : c.key) || null,
    dropAllowed: _
  };
}
function Dg(e, t) {
  if (!e)
    return;
  const {
    multiple: n
  } = t;
  return n ? e.slice() : e.length ? [e[0]] : e;
}
function _u(e) {
  if (!e)
    return null;
  let t;
  if (Array.isArray(e))
    t = {
      checkedKeys: e,
      halfCheckedKeys: void 0
    };
  else if (typeof e == "object")
    t = {
      checkedKeys: e.checked || void 0,
      halfCheckedKeys: e.halfChecked || void 0
    };
  else
    return lt(!1, "`checkedKeys` is not an array or an object"), null;
  return t;
}
function Ag(e, t) {
  const n = /* @__PURE__ */ new Set();
  function o(r) {
    if (n.has(r))
      return;
    const a = t[r];
    if (!a)
      return;
    n.add(r);
    const {
      parent: i,
      node: l
    } = a;
    l.disabled || i && o(i.key);
  }
  return (e || []).forEach((r) => {
    o(r);
  }), [...n];
}
var nF = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function Ti(e, t) {
  return e ?? t;
}
function op(e) {
  const {
    title: t,
    _title: n,
    key: o,
    children: r
  } = e || {}, a = t || "title";
  return {
    title: a,
    _title: n || [a],
    key: o || "key",
    children: r || "children"
  };
}
function oF(e) {
  function t() {
    let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return nn(n).map((r) => {
      var a, i, l, u;
      if (!Z3(r))
        return lt(!r, "Tree/TreeNode can only accept TreeNode as children."), null;
      const s = r.children || {}, c = r.key, d = {};
      for (const [N, I] of Object.entries(r.props))
        d[yi(N)] = I;
      const {
        isLeaf: f,
        checkable: p,
        selectable: v,
        disabled: g,
        disableCheckbox: b
      } = d, y = {
        isLeaf: f || f === "" || void 0,
        checkable: p || p === "" || void 0,
        selectable: v || v === "" || void 0,
        disabled: g || g === "" || void 0,
        disableCheckbox: b || b === "" || void 0
      }, S = h(h({}, d), y), {
        title: w = (a = s.title) === null || a === void 0 ? void 0 : a.call(s, S),
        icon: C = (i = s.icon) === null || i === void 0 ? void 0 : i.call(s, S),
        switcherIcon: $ = (l = s.switcherIcon) === null || l === void 0 ? void 0 : l.call(s, S)
      } = d, O = nF(d, ["title", "icon", "switcherIcon"]), x = (u = s.default) === null || u === void 0 ? void 0 : u.call(s), M = h(h(h({}, O), {
        title: w,
        icon: C,
        switcherIcon: $,
        key: c,
        isLeaf: f
      }), y), _ = t(x);
      return _.length && (M.children = _), M;
    });
  }
  return t(e);
}
function rF(e, t, n) {
  const {
    _title: o,
    key: r,
    children: a
  } = op(n), i = new Set(t === !0 ? [] : t), l = [];
  function u(s) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    return s.map((d, f) => {
      const p = f$(c ? c.pos : "0", f), v = Ti(d[r], p);
      let g;
      for (let y = 0; y < o.length; y += 1) {
        const S = o[y];
        if (d[S] !== void 0) {
          g = d[S];
          break;
        }
      }
      const b = h(h({}, pt(d, [...o, r, a])), {
        title: g,
        key: v,
        parent: c,
        pos: p,
        children: null,
        data: d,
        isStart: [...c ? c.isStart : [], f === 0],
        isEnd: [...c ? c.isEnd : [], f === s.length - 1]
      });
      return l.push(b), t === !0 || i.has(v) ? b.children = u(d[a] || [], b) : b.children = [], b;
    });
  }
  return u(e), l;
}
function aF(e, t, n) {
  let o = {};
  typeof n == "object" ? o = n : o = {
    externalGetKey: n
  }, o = o || {};
  const {
    childrenPropName: r,
    externalGetKey: a,
    fieldNames: i
  } = o, {
    key: l,
    children: u
  } = op(i), s = r || u;
  let c;
  a ? typeof a == "string" ? c = (f) => f[a] : typeof a == "function" && (c = (f) => a(f)) : c = (f, p) => Ti(f[l], p);
  function d(f, p, v, g) {
    const b = f ? f[s] : e, y = f ? f$(v.pos, p) : "0", S = f ? [...g, f] : [];
    if (f) {
      const w = c(f, y), C = {
        node: f,
        index: p,
        pos: y,
        key: w,
        parentPos: v.node ? v.pos : null,
        level: v.level + 1,
        nodes: S
      };
      t(C);
    }
    b && b.forEach((w, C) => {
      d(w, C, {
        node: f,
        pos: y,
        level: v ? v.level + 1 : -1
      }, S);
    });
  }
  d(null);
}
function p$(e) {
  let {
    initWrapper: t,
    processEntity: n,
    onProcessFinished: o,
    externalGetKey: r,
    childrenPropName: a,
    fieldNames: i
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, l = arguments.length > 2 ? arguments[2] : void 0;
  const u = r || l, s = {}, c = {};
  let d = {
    posEntities: s,
    keyEntities: c
  };
  return t && (d = t(d) || d), aF(e, (f) => {
    const {
      node: p,
      index: v,
      pos: g,
      key: b,
      parentPos: y,
      level: S,
      nodes: w
    } = f, C = {
      node: p,
      nodes: w,
      index: v,
      key: b,
      pos: g,
      level: S
    }, $ = Ti(b, g);
    s[g] = C, c[$] = C, C.parent = s[y], C.parent && (C.parent.children = C.parent.children || [], C.parent.children.push(C)), n && n(C, d);
  }, {
    externalGetKey: u,
    childrenPropName: a,
    fieldNames: i
  }), o && o(d), d;
}
function gl(e, t) {
  let {
    expandedKeysSet: n,
    selectedKeysSet: o,
    loadedKeysSet: r,
    loadingKeysSet: a,
    checkedKeysSet: i,
    halfCheckedKeysSet: l,
    dragOverNodeKey: u,
    dropPosition: s,
    keyEntities: c
  } = t;
  const d = c[e];
  return {
    eventKey: e,
    expanded: n.has(e),
    selected: o.has(e),
    loaded: r.has(e),
    loading: a.has(e),
    checked: i.has(e),
    halfChecked: l.has(e),
    pos: String(d ? d.pos : ""),
    parent: d.parent,
    // [Legacy] Drag props
    // Since the interaction of drag is changed, the semantic of the props are
    // not accuracy, I think it should be finally removed
    dragOver: u === e && s === 0,
    dragOverGapTop: u === e && s === -1,
    dragOverGapBottom: u === e && s === 1
  };
}
function hl(e) {
  const {
    data: t,
    expanded: n,
    selected: o,
    checked: r,
    loaded: a,
    loading: i,
    halfChecked: l,
    dragOver: u,
    dragOverGapTop: s,
    dragOverGapBottom: c,
    pos: d,
    active: f,
    eventKey: p
  } = e, v = h(h({
    dataRef: t
  }, t), {
    expanded: n,
    selected: o,
    checked: r,
    loaded: a,
    loading: i,
    halfChecked: l,
    dragOver: u,
    dragOverGapTop: s,
    dragOverGapBottom: c,
    pos: d,
    active: f,
    eventKey: p,
    key: p
  });
  return "props" in v || Object.defineProperty(v, "props", {
    get() {
      return lt(!1, "Second param return from event is node data instead of TreeNode instance. Please read value directly instead of reading from `props`."), e;
    }
  }), v;
}
function v$(e, t) {
  const n = /* @__PURE__ */ new Set();
  return e.forEach((o) => {
    t.has(o) || n.add(o);
  }), n;
}
function iF(e) {
  const {
    disabled: t,
    disableCheckbox: n,
    checkable: o
  } = e || {};
  return !!(t || n) || o === !1;
}
function lF(e, t, n, o) {
  const r = new Set(e), a = /* @__PURE__ */ new Set();
  for (let l = 0; l <= n; l += 1)
    (t.get(l) || /* @__PURE__ */ new Set()).forEach((s) => {
      const {
        key: c,
        node: d,
        children: f = []
      } = s;
      r.has(c) && !o(d) && f.filter((p) => !o(p.node)).forEach((p) => {
        r.add(p.key);
      });
    });
  const i = /* @__PURE__ */ new Set();
  for (let l = n; l >= 0; l -= 1)
    (t.get(l) || /* @__PURE__ */ new Set()).forEach((s) => {
      const {
        parent: c,
        node: d
      } = s;
      if (o(d) || !s.parent || i.has(s.parent.key))
        return;
      if (o(s.parent.node)) {
        i.add(c.key);
        return;
      }
      let f = !0, p = !1;
      (c.children || []).filter((v) => !o(v.node)).forEach((v) => {
        let {
          key: g
        } = v;
        const b = r.has(g);
        f && !b && (f = !1), !p && (b || a.has(g)) && (p = !0);
      }), f && r.add(c.key), p && a.add(c.key), i.add(c.key);
    });
  return {
    checkedKeys: Array.from(r),
    halfCheckedKeys: Array.from(v$(a, r))
  };
}
function sF(e, t, n, o, r) {
  const a = new Set(e);
  let i = new Set(t);
  for (let u = 0; u <= o; u += 1)
    (n.get(u) || /* @__PURE__ */ new Set()).forEach((c) => {
      const {
        key: d,
        node: f,
        children: p = []
      } = c;
      !a.has(d) && !i.has(d) && !r(f) && p.filter((v) => !r(v.node)).forEach((v) => {
        a.delete(v.key);
      });
    });
  i = /* @__PURE__ */ new Set();
  const l = /* @__PURE__ */ new Set();
  for (let u = o; u >= 0; u -= 1)
    (n.get(u) || /* @__PURE__ */ new Set()).forEach((c) => {
      const {
        parent: d,
        node: f
      } = c;
      if (r(f) || !c.parent || l.has(c.parent.key))
        return;
      if (r(c.parent.node)) {
        l.add(d.key);
        return;
      }
      let p = !0, v = !1;
      (d.children || []).filter((g) => !r(g.node)).forEach((g) => {
        let {
          key: b
        } = g;
        const y = a.has(b);
        p && !y && (p = !1), !v && (y || i.has(b)) && (v = !0);
      }), p || a.delete(d.key), v && i.add(d.key), l.add(d.key);
    });
  return {
    checkedKeys: Array.from(a),
    halfCheckedKeys: Array.from(v$(i, a))
  };
}
function na(e, t, n, o, r, a) {
  const i = [];
  let l;
  l = iF;
  const u = new Set(e.filter((c) => {
    const d = !!n[c];
    return d || i.push(c), d;
  }));
  kb(!i.length, `Tree missing follow keys: ${i.slice(0, 100).map((c) => `'${c}'`).join(", ")}`);
  let s;
  return t === !0 ? s = lF(u, r, o, l) : s = sF(u, t.halfCheckedKeys, r, o, l), s;
}
function m$(e) {
  const t = G(0), n = K();
  return Ve(() => {
    const o = /* @__PURE__ */ new Map();
    let r = 0;
    const a = e.value || {};
    for (const i in a)
      if (Object.prototype.hasOwnProperty.call(a, i)) {
        const l = a[i], {
          level: u
        } = l;
        let s = o.get(u);
        s || (s = /* @__PURE__ */ new Set(), o.set(u, s)), s.add(l), r = Math.max(r, u);
      }
    t.value = r, n.value = o;
  }), {
    maxLevel: t,
    levelEntities: n
  };
}
const g$ = () => Nn() && window.document.documentElement;
let Zi;
const uF = () => {
  if (!g$())
    return !1;
  if (Zi !== void 0)
    return Zi;
  const e = document.createElement("div");
  return e.style.display = "flex", e.style.flexDirection = "column", e.style.rowGap = "1px", e.appendChild(document.createElement("div")), e.appendChild(document.createElement("div")), document.body.appendChild(e), Zi = e.scrollHeight === 1, document.body.removeChild(e), Zi;
}, cF = () => {
  const e = K(!1);
  return ze(() => {
    e.value = uF();
  }), e;
}, h$ = Symbol("rowContextKey"), dF = (e) => {
  ot(h$, e);
}, fF = () => nt(h$, {
  gutter: T(() => {
  }),
  wrap: T(() => {
  }),
  supportFlexGap: T(() => {
  })
}), pF = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    // Grid system
    [t]: {
      display: "flex",
      flexFlow: "row wrap",
      minWidth: 0,
      "&::before, &::after": {
        display: "flex"
      },
      "&-no-wrap": {
        flexWrap: "nowrap"
      },
      // The origin of the X-axis
      "&-start": {
        justifyContent: "flex-start"
      },
      // The center of the X-axis
      "&-center": {
        justifyContent: "center"
      },
      // The opposite of the X-axis
      "&-end": {
        justifyContent: "flex-end"
      },
      "&-space-between": {
        justifyContent: "space-between"
      },
      "&-space-around ": {
        justifyContent: "space-around"
      },
      // Align at the top
      "&-top": {
        alignItems: "flex-start"
      },
      // Align at the center
      "&-middle": {
        alignItems: "center"
      },
      "&-bottom": {
        alignItems: "flex-end"
      }
    }
  };
}, vF = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    // Grid system
    [t]: {
      position: "relative",
      maxWidth: "100%",
      // Prevent columns from collapsing when empty
      minHeight: 1
    }
  };
}, mF = (e, t) => {
  const {
    componentCls: n,
    gridColumns: o
  } = e, r = {};
  for (let a = o; a >= 0; a--)
    a === 0 ? (r[`${n}${t}-${a}`] = {
      display: "none"
    }, r[`${n}-push-${a}`] = {
      insetInlineStart: "auto"
    }, r[`${n}-pull-${a}`] = {
      insetInlineEnd: "auto"
    }, r[`${n}${t}-push-${a}`] = {
      insetInlineStart: "auto"
    }, r[`${n}${t}-pull-${a}`] = {
      insetInlineEnd: "auto"
    }, r[`${n}${t}-offset-${a}`] = {
      marginInlineEnd: 0
    }, r[`${n}${t}-order-${a}`] = {
      order: 0
    }) : (r[`${n}${t}-${a}`] = {
      display: "block",
      flex: `0 0 ${a / o * 100}%`,
      maxWidth: `${a / o * 100}%`
    }, r[`${n}${t}-push-${a}`] = {
      insetInlineStart: `${a / o * 100}%`
    }, r[`${n}${t}-pull-${a}`] = {
      insetInlineEnd: `${a / o * 100}%`
    }, r[`${n}${t}-offset-${a}`] = {
      marginInlineStart: `${a / o * 100}%`
    }, r[`${n}${t}-order-${a}`] = {
      order: a
    });
  return r;
}, Xc = (e, t) => mF(e, t), gF = (e, t, n) => ({
  [`@media (min-width: ${t}px)`]: h({}, Xc(e, n))
}), hF = ht("Grid", (e) => [pF(e)]), bF = ht("Grid", (e) => {
  const t = qe(e, {
    gridColumns: 24
    // Row is divided into 24 parts in Grid
  }), n = {
    "-sm": t.screenSMMin,
    "-md": t.screenMDMin,
    "-lg": t.screenLGMin,
    "-xl": t.screenXLMin,
    "-xxl": t.screenXXLMin
  };
  return [vF(t), Xc(t, ""), Xc(t, "-xs"), Object.keys(n).map((o) => gF(t, n[o], o)).reduce((o, r) => h(h({}, o), r), {})];
}), yF = () => ({
  align: dt([String, Object]),
  justify: dt([String, Object]),
  prefixCls: String,
  gutter: dt([Number, Array, Object], 0),
  wrap: {
    type: Boolean,
    default: void 0
  }
}), b$ = J({
  compatConfig: {
    MODE: 3
  },
  name: "ARow",
  inheritAttrs: !1,
  props: yF(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r,
      direction: a
    } = Ke("row", e), [i, l] = hF(r);
    let u;
    const s = K0(), c = G({
      xs: !0,
      sm: !0,
      md: !0,
      lg: !0,
      xl: !0,
      xxl: !0
    }), d = G({
      xs: !1,
      sm: !1,
      md: !1,
      lg: !1,
      xl: !1,
      xxl: !1
    }), f = (w) => T(() => {
      if (typeof e[w] == "string")
        return e[w];
      if (typeof e[w] != "object")
        return "";
      for (let C = 0; C < ja.length; C++) {
        const $ = ja[C];
        if (!d.value[$])
          continue;
        const O = e[w][$];
        if (O !== void 0)
          return O;
      }
      return "";
    }), p = f("align"), v = f("justify"), g = cF();
    ze(() => {
      u = s.value.subscribe((w) => {
        d.value = w;
        const C = e.gutter || 0;
        (!Array.isArray(C) && typeof C == "object" || Array.isArray(C) && (typeof C[0] == "object" || typeof C[1] == "object")) && (c.value = w);
      });
    }), at(() => {
      s.value.unsubscribe(u);
    });
    const b = T(() => {
      const w = [void 0, void 0], {
        gutter: C = 0
      } = e;
      return (Array.isArray(C) ? C : [C, void 0]).forEach((O, x) => {
        if (typeof O == "object")
          for (let M = 0; M < ja.length; M++) {
            const _ = ja[M];
            if (c.value[_] && O[_] !== void 0) {
              w[x] = O[_];
              break;
            }
          }
        else
          w[x] = O;
      }), w;
    });
    dF({
      gutter: b,
      supportFlexGap: g,
      wrap: T(() => e.wrap)
    });
    const y = T(() => ae(r.value, {
      [`${r.value}-no-wrap`]: e.wrap === !1,
      [`${r.value}-${v.value}`]: v.value,
      [`${r.value}-${p.value}`]: p.value,
      [`${r.value}-rtl`]: a.value === "rtl"
    }, o.class, l.value)), S = T(() => {
      const w = b.value, C = {}, $ = w[0] != null && w[0] > 0 ? `${w[0] / -2}px` : void 0, O = w[1] != null && w[1] > 0 ? `${w[1] / -2}px` : void 0;
      return $ && (C.marginLeft = $, C.marginRight = $), g.value ? C.rowGap = `${w[1]}px` : O && (C.marginTop = O, C.marginBottom = O), C;
    });
    return () => {
      var w;
      return i(m("div", L(L({}, o), {}, {
        class: y.value,
        style: h(h({}, S.value), o.style)
      }), [(w = n.default) === null || w === void 0 ? void 0 : w.call(n)]));
    };
  }
});
function cr() {
  return cr = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, cr.apply(this, arguments);
}
function SF(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, hi(e, t);
}
function qc(e) {
  return qc = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, qc(e);
}
function hi(e, t) {
  return hi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, r) {
    return o.__proto__ = r, o;
  }, hi(e, t);
}
function $F() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function bl(e, t, n) {
  return $F() ? bl = Reflect.construct.bind() : bl = function(r, a, i) {
    var l = [null];
    l.push.apply(l, a);
    var u = Function.bind.apply(r, l), s = new u();
    return i && hi(s, i.prototype), s;
  }, bl.apply(null, arguments);
}
function CF(e) {
  return Function.toString.call(e).indexOf("[native code]") !== -1;
}
function Qc(e) {
  var t = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return Qc = function(o) {
    if (o === null || !CF(o))
      return o;
    if (typeof o != "function")
      throw new TypeError("Super expression must either be null or a function");
    if (typeof t < "u") {
      if (t.has(o))
        return t.get(o);
      t.set(o, r);
    }
    function r() {
      return bl(o, arguments, qc(this).constructor);
    }
    return r.prototype = Object.create(o.prototype, {
      constructor: {
        value: r,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), hi(r, o);
  }, Qc(e);
}
var wF = /%[sdj%]/g, y$ = function() {
};
typeof process < "u" && process.env && process.env.NODE_ENV !== "production" && typeof window < "u" && typeof document < "u" && (y$ = function(t, n) {
  typeof console < "u" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING > "u" && n.every(function(o) {
    return typeof o == "string";
  }) && console.warn(t, n);
});
function Zc(e) {
  if (!e || !e.length)
    return null;
  var t = {};
  return e.forEach(function(n) {
    var o = n.field;
    t[o] = t[o] || [], t[o].push(n);
  }), t;
}
function $n(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++)
    n[o - 1] = arguments[o];
  var r = 0, a = n.length;
  if (typeof e == "function")
    return e.apply(null, n);
  if (typeof e == "string") {
    var i = e.replace(wF, function(l) {
      if (l === "%%")
        return "%";
      if (r >= a)
        return l;
      switch (l) {
        case "%s":
          return String(n[r++]);
        case "%d":
          return Number(n[r++]);
        case "%j":
          try {
            return JSON.stringify(n[r++]);
          } catch {
            return "[Circular]";
          }
          break;
        default:
          return l;
      }
    });
    return i;
  }
  return e;
}
function xF(e) {
  return e === "string" || e === "url" || e === "hex" || e === "email" || e === "date" || e === "pattern";
}
function Ht(e, t) {
  return !!(e == null || t === "array" && Array.isArray(e) && !e.length || xF(t) && typeof e == "string" && !e);
}
function OF(e, t, n) {
  var o = [], r = 0, a = e.length;
  function i(l) {
    o.push.apply(o, l || []), r++, r === a && n(o);
  }
  e.forEach(function(l) {
    t(l, i);
  });
}
function Ng(e, t, n) {
  var o = 0, r = e.length;
  function a(i) {
    if (i && i.length) {
      n(i);
      return;
    }
    var l = o;
    o = o + 1, l < r ? t(e[l], a) : n([]);
  }
  a([]);
}
function PF(e) {
  var t = [];
  return Object.keys(e).forEach(function(n) {
    t.push.apply(t, e[n] || []);
  }), t;
}
var Rg = /* @__PURE__ */ function(e) {
  SF(t, e);
  function t(n, o) {
    var r;
    return r = e.call(this, "Async Validation Error") || this, r.errors = n, r.fields = o, r;
  }
  return t;
}(/* @__PURE__ */ Qc(Error));
function IF(e, t, n, o, r) {
  if (t.first) {
    var a = new Promise(function(f, p) {
      var v = function(y) {
        return o(y), y.length ? p(new Rg(y, Zc(y))) : f(r);
      }, g = PF(e);
      Ng(g, n, v);
    });
    return a.catch(function(f) {
      return f;
    }), a;
  }
  var i = t.firstFields === !0 ? Object.keys(e) : t.firstFields || [], l = Object.keys(e), u = l.length, s = 0, c = [], d = new Promise(function(f, p) {
    var v = function(b) {
      if (c.push.apply(c, b), s++, s === u)
        return o(c), c.length ? p(new Rg(c, Zc(c))) : f(r);
    };
    l.length || (o(c), f(r)), l.forEach(function(g) {
      var b = e[g];
      i.indexOf(g) !== -1 ? Ng(b, n, v) : OF(b, n, v);
    });
  });
  return d.catch(function(f) {
    return f;
  }), d;
}
function TF(e) {
  return !!(e && e.message !== void 0);
}
function EF(e, t) {
  for (var n = e, o = 0; o < t.length; o++) {
    if (n == null)
      return n;
    n = n[t[o]];
  }
  return n;
}
function Fg(e, t) {
  return function(n) {
    var o;
    return e.fullFields ? o = EF(t, e.fullFields) : o = t[n.field || e.fullField], TF(n) ? (n.field = n.field || e.fullField, n.fieldValue = o, n) : {
      message: typeof n == "function" ? n() : n,
      fieldValue: o,
      field: n.field || e.fullField
    };
  };
}
function Bg(e, t) {
  if (t) {
    for (var n in t)
      if (t.hasOwnProperty(n)) {
        var o = t[n];
        typeof o == "object" && typeof e[n] == "object" ? e[n] = cr({}, e[n], o) : e[n] = o;
      }
  }
  return e;
}
var S$ = function(t, n, o, r, a, i) {
  t.required && (!o.hasOwnProperty(t.field) || Ht(n, i || t.type)) && r.push($n(a.messages.required, t.fullField));
}, MF = function(t, n, o, r, a) {
  (/^\s+$/.test(n) || n === "") && r.push($n(a.messages.whitespace, t.fullField));
}, Ji, _F = function() {
  if (Ji)
    return Ji;
  var e = "[a-fA-F\\d:]", t = function(C) {
    return C && C.includeBoundaries ? "(?:(?<=\\s|^)(?=" + e + ")|(?<=" + e + ")(?=\\s|$))" : "";
  }, n = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", o = "[a-fA-F\\d]{1,4}", r = (`
(?:
(?:` + o + ":){7}(?:" + o + `|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:` + o + ":){6}(?:" + n + "|:" + o + `|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:` + o + ":){5}(?::" + n + "|(?::" + o + `){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:` + o + ":){4}(?:(?::" + o + "){0,1}:" + n + "|(?::" + o + `){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:` + o + ":){3}(?:(?::" + o + "){0,2}:" + n + "|(?::" + o + `){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:` + o + ":){2}(?:(?::" + o + "){0,3}:" + n + "|(?::" + o + `){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:` + o + ":){1}(?:(?::" + o + "){0,4}:" + n + "|(?::" + o + `){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::` + o + "){0,5}:" + n + "|(?::" + o + `){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`).replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), a = new RegExp("(?:^" + n + "$)|(?:^" + r + "$)"), i = new RegExp("^" + n + "$"), l = new RegExp("^" + r + "$"), u = function(C) {
    return C && C.exact ? a : new RegExp("(?:" + t(C) + n + t(C) + ")|(?:" + t(C) + r + t(C) + ")", "g");
  };
  u.v4 = function(w) {
    return w && w.exact ? i : new RegExp("" + t(w) + n + t(w), "g");
  }, u.v6 = function(w) {
    return w && w.exact ? l : new RegExp("" + t(w) + r + t(w), "g");
  };
  var s = "(?:(?:[a-z]+:)?//)", c = "(?:\\S+(?::\\S*)?@)?", d = u.v4().source, f = u.v6().source, p = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)", v = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*", g = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", b = "(?::\\d{2,5})?", y = '(?:[/?#][^\\s"]*)?', S = "(?:" + s + "|www\\.)" + c + "(?:localhost|" + d + "|" + f + "|" + p + v + g + ")" + b + y;
  return Ji = new RegExp("(?:^" + S + "$)", "i"), Ji;
}, kg = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  // url: new RegExp(
  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
  //   'i',
  // ),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
}, Va = {
  integer: function(t) {
    return Va.number(t) && parseInt(t, 10) === t;
  },
  float: function(t) {
    return Va.number(t) && !Va.integer(t);
  },
  array: function(t) {
    return Array.isArray(t);
  },
  regexp: function(t) {
    if (t instanceof RegExp)
      return !0;
    try {
      return !!new RegExp(t);
    } catch {
      return !1;
    }
  },
  date: function(t) {
    return typeof t.getTime == "function" && typeof t.getMonth == "function" && typeof t.getYear == "function" && !isNaN(t.getTime());
  },
  number: function(t) {
    return isNaN(t) ? !1 : typeof t == "number";
  },
  object: function(t) {
    return typeof t == "object" && !Va.array(t);
  },
  method: function(t) {
    return typeof t == "function";
  },
  email: function(t) {
    return typeof t == "string" && t.length <= 320 && !!t.match(kg.email);
  },
  url: function(t) {
    return typeof t == "string" && t.length <= 2048 && !!t.match(_F());
  },
  hex: function(t) {
    return typeof t == "string" && !!t.match(kg.hex);
  }
}, DF = function(t, n, o, r, a) {
  if (t.required && n === void 0) {
    S$(t, n, o, r, a);
    return;
  }
  var i = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], l = t.type;
  i.indexOf(l) > -1 ? Va[l](n) || r.push($n(a.messages.types[l], t.fullField, t.type)) : l && typeof n !== t.type && r.push($n(a.messages.types[l], t.fullField, t.type));
}, AF = function(t, n, o, r, a) {
  var i = typeof t.len == "number", l = typeof t.min == "number", u = typeof t.max == "number", s = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, c = n, d = null, f = typeof n == "number", p = typeof n == "string", v = Array.isArray(n);
  if (f ? d = "number" : p ? d = "string" : v && (d = "array"), !d)
    return !1;
  v && (c = n.length), p && (c = n.replace(s, "_").length), i ? c !== t.len && r.push($n(a.messages[d].len, t.fullField, t.len)) : l && !u && c < t.min ? r.push($n(a.messages[d].min, t.fullField, t.min)) : u && !l && c > t.max ? r.push($n(a.messages[d].max, t.fullField, t.max)) : l && u && (c < t.min || c > t.max) && r.push($n(a.messages[d].range, t.fullField, t.min, t.max));
}, jr = "enum", NF = function(t, n, o, r, a) {
  t[jr] = Array.isArray(t[jr]) ? t[jr] : [], t[jr].indexOf(n) === -1 && r.push($n(a.messages[jr], t.fullField, t[jr].join(", ")));
}, RF = function(t, n, o, r, a) {
  if (t.pattern) {
    if (t.pattern instanceof RegExp)
      t.pattern.lastIndex = 0, t.pattern.test(n) || r.push($n(a.messages.pattern.mismatch, t.fullField, n, t.pattern));
    else if (typeof t.pattern == "string") {
      var i = new RegExp(t.pattern);
      i.test(n) || r.push($n(a.messages.pattern.mismatch, t.fullField, n, t.pattern));
    }
  }
}, ft = {
  required: S$,
  whitespace: MF,
  type: DF,
  range: AF,
  enum: NF,
  pattern: RF
}, FF = function(t, n, o, r, a) {
  var i = [], l = t.required || !t.required && r.hasOwnProperty(t.field);
  if (l) {
    if (Ht(n, "string") && !t.required)
      return o();
    ft.required(t, n, r, i, a, "string"), Ht(n, "string") || (ft.type(t, n, r, i, a), ft.range(t, n, r, i, a), ft.pattern(t, n, r, i, a), t.whitespace === !0 && ft.whitespace(t, n, r, i, a));
  }
  o(i);
}, BF = function(t, n, o, r, a) {
  var i = [], l = t.required || !t.required && r.hasOwnProperty(t.field);
  if (l) {
    if (Ht(n) && !t.required)
      return o();
    ft.required(t, n, r, i, a), n !== void 0 && ft.type(t, n, r, i, a);
  }
  o(i);
}, kF = function(t, n, o, r, a) {
  var i = [], l = t.required || !t.required && r.hasOwnProperty(t.field);
  if (l) {
    if (n === "" && (n = void 0), Ht(n) && !t.required)
      return o();
    ft.required(t, n, r, i, a), n !== void 0 && (ft.type(t, n, r, i, a), ft.range(t, n, r, i, a));
  }
  o(i);
}, LF = function(t, n, o, r, a) {
  var i = [], l = t.required || !t.required && r.hasOwnProperty(t.field);
  if (l) {
    if (Ht(n) && !t.required)
      return o();
    ft.required(t, n, r, i, a), n !== void 0 && ft.type(t, n, r, i, a);
  }
  o(i);
}, HF = function(t, n, o, r, a) {
  var i = [], l = t.required || !t.required && r.hasOwnProperty(t.field);
  if (l) {
    if (Ht(n) && !t.required)
      return o();
    ft.required(t, n, r, i, a), Ht(n) || ft.type(t, n, r, i, a);
  }
  o(i);
}, zF = function(t, n, o, r, a) {
  var i = [], l = t.required || !t.required && r.hasOwnProperty(t.field);
  if (l) {
    if (Ht(n) && !t.required)
      return o();
    ft.required(t, n, r, i, a), n !== void 0 && (ft.type(t, n, r, i, a), ft.range(t, n, r, i, a));
  }
  o(i);
}, jF = function(t, n, o, r, a) {
  var i = [], l = t.required || !t.required && r.hasOwnProperty(t.field);
  if (l) {
    if (Ht(n) && !t.required)
      return o();
    ft.required(t, n, r, i, a), n !== void 0 && (ft.type(t, n, r, i, a), ft.range(t, n, r, i, a));
  }
  o(i);
}, VF = function(t, n, o, r, a) {
  var i = [], l = t.required || !t.required && r.hasOwnProperty(t.field);
  if (l) {
    if (n == null && !t.required)
      return o();
    ft.required(t, n, r, i, a, "array"), n != null && (ft.type(t, n, r, i, a), ft.range(t, n, r, i, a));
  }
  o(i);
}, WF = function(t, n, o, r, a) {
  var i = [], l = t.required || !t.required && r.hasOwnProperty(t.field);
  if (l) {
    if (Ht(n) && !t.required)
      return o();
    ft.required(t, n, r, i, a), n !== void 0 && ft.type(t, n, r, i, a);
  }
  o(i);
}, KF = "enum", UF = function(t, n, o, r, a) {
  var i = [], l = t.required || !t.required && r.hasOwnProperty(t.field);
  if (l) {
    if (Ht(n) && !t.required)
      return o();
    ft.required(t, n, r, i, a), n !== void 0 && ft[KF](t, n, r, i, a);
  }
  o(i);
}, GF = function(t, n, o, r, a) {
  var i = [], l = t.required || !t.required && r.hasOwnProperty(t.field);
  if (l) {
    if (Ht(n, "string") && !t.required)
      return o();
    ft.required(t, n, r, i, a), Ht(n, "string") || ft.pattern(t, n, r, i, a);
  }
  o(i);
}, YF = function(t, n, o, r, a) {
  var i = [], l = t.required || !t.required && r.hasOwnProperty(t.field);
  if (l) {
    if (Ht(n, "date") && !t.required)
      return o();
    if (ft.required(t, n, r, i, a), !Ht(n, "date")) {
      var u;
      n instanceof Date ? u = n : u = new Date(n), ft.type(t, u, r, i, a), u && ft.range(t, u.getTime(), r, i, a);
    }
  }
  o(i);
}, XF = function(t, n, o, r, a) {
  var i = [], l = Array.isArray(n) ? "array" : typeof n;
  ft.required(t, n, r, i, a, l), o(i);
}, Du = function(t, n, o, r, a) {
  var i = t.type, l = [], u = t.required || !t.required && r.hasOwnProperty(t.field);
  if (u) {
    if (Ht(n, i) && !t.required)
      return o();
    ft.required(t, n, r, l, a, i), Ht(n, i) || ft.type(t, n, r, l, a);
  }
  o(l);
}, qF = function(t, n, o, r, a) {
  var i = [], l = t.required || !t.required && r.hasOwnProperty(t.field);
  if (l) {
    if (Ht(n) && !t.required)
      return o();
    ft.required(t, n, r, i, a);
  }
  o(i);
}, Za = {
  string: FF,
  method: BF,
  number: kF,
  boolean: LF,
  regexp: HF,
  integer: zF,
  float: jF,
  array: VF,
  object: WF,
  enum: UF,
  pattern: GF,
  date: YF,
  url: Du,
  hex: Du,
  email: Du,
  required: XF,
  any: qF
};
function Jc() {
  return {
    default: "Validation error on field %s",
    required: "%s is required",
    enum: "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      boolean: "%s is not a %s",
      integer: "%s is not an %s",
      float: "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function() {
      var t = JSON.parse(JSON.stringify(this));
      return t.clone = this.clone, t;
    }
  };
}
var ed = Jc(), Ei = /* @__PURE__ */ function() {
  function e(n) {
    this.rules = null, this._messages = ed, this.define(n);
  }
  var t = e.prototype;
  return t.define = function(o) {
    var r = this;
    if (!o)
      throw new Error("Cannot configure a schema with no rules");
    if (typeof o != "object" || Array.isArray(o))
      throw new Error("Rules must be an object");
    this.rules = {}, Object.keys(o).forEach(function(a) {
      var i = o[a];
      r.rules[a] = Array.isArray(i) ? i : [i];
    });
  }, t.messages = function(o) {
    return o && (this._messages = Bg(Jc(), o)), this._messages;
  }, t.validate = function(o, r, a) {
    var i = this;
    r === void 0 && (r = {}), a === void 0 && (a = function() {
    });
    var l = o, u = r, s = a;
    if (typeof u == "function" && (s = u, u = {}), !this.rules || Object.keys(this.rules).length === 0)
      return s && s(null, l), Promise.resolve(l);
    function c(g) {
      var b = [], y = {};
      function S(C) {
        if (Array.isArray(C)) {
          var $;
          b = ($ = b).concat.apply($, C);
        } else
          b.push(C);
      }
      for (var w = 0; w < g.length; w++)
        S(g[w]);
      b.length ? (y = Zc(b), s(b, y)) : s(null, l);
    }
    if (u.messages) {
      var d = this.messages();
      d === ed && (d = Jc()), Bg(d, u.messages), u.messages = d;
    } else
      u.messages = this.messages();
    var f = {}, p = u.keys || Object.keys(this.rules);
    p.forEach(function(g) {
      var b = i.rules[g], y = l[g];
      b.forEach(function(S) {
        var w = S;
        typeof w.transform == "function" && (l === o && (l = cr({}, l)), y = l[g] = w.transform(y)), typeof w == "function" ? w = {
          validator: w
        } : w = cr({}, w), w.validator = i.getValidationMethod(w), w.validator && (w.field = g, w.fullField = w.fullField || g, w.type = i.getType(w), f[g] = f[g] || [], f[g].push({
          rule: w,
          value: y,
          source: l,
          field: g
        }));
      });
    });
    var v = {};
    return IF(f, u, function(g, b) {
      var y = g.rule, S = (y.type === "object" || y.type === "array") && (typeof y.fields == "object" || typeof y.defaultField == "object");
      S = S && (y.required || !y.required && g.value), y.field = g.field;
      function w(O, x) {
        return cr({}, x, {
          fullField: y.fullField + "." + O,
          fullFields: y.fullFields ? [].concat(y.fullFields, [O]) : [O]
        });
      }
      function C(O) {
        O === void 0 && (O = []);
        var x = Array.isArray(O) ? O : [O];
        !u.suppressWarning && x.length && e.warning("async-validator:", x), x.length && y.message !== void 0 && (x = [].concat(y.message));
        var M = x.map(Fg(y, l));
        if (u.first && M.length)
          return v[y.field] = 1, b(M);
        if (!S)
          b(M);
        else {
          if (y.required && !g.value)
            return y.message !== void 0 ? M = [].concat(y.message).map(Fg(y, l)) : u.error && (M = [u.error(y, $n(u.messages.required, y.field))]), b(M);
          var _ = {};
          y.defaultField && Object.keys(g.value).map(function(E) {
            _[E] = y.defaultField;
          }), _ = cr({}, _, g.rule.fields);
          var N = {};
          Object.keys(_).forEach(function(E) {
            var B = _[E], k = Array.isArray(B) ? B : [B];
            N[E] = k.map(w.bind(null, E));
          });
          var I = new e(N);
          I.messages(u.messages), g.rule.options && (g.rule.options.messages = u.messages, g.rule.options.error = u.error), I.validate(g.value, g.rule.options || u, function(E) {
            var B = [];
            M && M.length && B.push.apply(B, M), E && E.length && B.push.apply(B, E), b(B.length ? B : null);
          });
        }
      }
      var $;
      if (y.asyncValidator)
        $ = y.asyncValidator(y, g.value, C, g.source, u);
      else if (y.validator) {
        try {
          $ = y.validator(y, g.value, C, g.source, u);
        } catch (O) {
          console.error == null || console.error(O), u.suppressValidatorError || setTimeout(function() {
            throw O;
          }, 0), C(O.message);
        }
        $ === !0 ? C() : $ === !1 ? C(typeof y.message == "function" ? y.message(y.fullField || y.field) : y.message || (y.fullField || y.field) + " fails") : $ instanceof Array ? C($) : $ instanceof Error && C($.message);
      }
      $ && $.then && $.then(function() {
        return C();
      }, function(O) {
        return C(O);
      });
    }, function(g) {
      c(g);
    }, l);
  }, t.getType = function(o) {
    if (o.type === void 0 && o.pattern instanceof RegExp && (o.type = "pattern"), typeof o.validator != "function" && o.type && !Za.hasOwnProperty(o.type))
      throw new Error($n("Unknown rule type %s", o.type));
    return o.type || "string";
  }, t.getValidationMethod = function(o) {
    if (typeof o.validator == "function")
      return o.validator;
    var r = Object.keys(o), a = r.indexOf("message");
    return a !== -1 && r.splice(a, 1), r.length === 1 && r[0] === "required" ? Za.required : Za[this.getType(o)] || void 0;
  }, e;
}();
Ei.register = function(t, n) {
  if (typeof n != "function")
    throw new Error("Cannot register a validator by type, validator is not a function");
  Za[t] = n;
};
Ei.warning = y$;
Ei.messages = ed;
Ei.validators = Za;
function Vo(e) {
  return e == null ? [] : Array.isArray(e) ? e : [e];
}
function $$(e, t) {
  let n = e;
  for (let o = 0; o < t.length; o += 1) {
    if (n == null)
      return;
    n = n[t[o]];
  }
  return n;
}
function C$(e, t, n, o) {
  if (!t.length)
    return n;
  const [r, ...a] = t;
  let i;
  return !e && typeof r == "number" ? i = [] : Array.isArray(e) ? i = [...e] : i = h({}, e), o && n === void 0 && a.length === 1 ? delete i[r][a[0]] : i[r] = C$(i[r], a, n, o), i;
}
function QF(e, t, n) {
  let o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  return t.length && o && n === void 0 && !$$(e, t.slice(0, -1)) ? e : C$(e, t, n, o);
}
function td(e) {
  return Vo(e);
}
function ZF(e, t) {
  return $$(e, t);
}
function JF(e, t, n) {
  let o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  return QF(e, t, n, o);
}
function eB(e, t) {
  return e && e.some((n) => nB(n, t));
}
function Lg(e) {
  return typeof e == "object" && e !== null && Object.getPrototypeOf(e) === Object.prototype;
}
function w$(e, t) {
  const n = Array.isArray(e) ? [...e] : h({}, e);
  return t && Object.keys(t).forEach((o) => {
    const r = n[o], a = t[o], i = Lg(r) && Lg(a);
    n[o] = i ? w$(r, a || {}) : a;
  }), n;
}
function tB(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++)
    n[o - 1] = arguments[o];
  return n.reduce((r, a) => w$(r, a), e);
}
function Hg(e, t) {
  let n = {};
  return t.forEach((o) => {
    const r = ZF(e, o);
    n = JF(n, o, r);
  }), n;
}
function nB(e, t) {
  return !e || !t || e.length !== t.length ? !1 : e.every((n, o) => t[o] === n);
}
const hn = "'${name}' is not a valid ${type}", Hs = {
  default: "Validation error on field '${name}'",
  required: "'${name}' is required",
  enum: "'${name}' must be one of [${enum}]",
  whitespace: "'${name}' cannot be empty",
  date: {
    format: "'${name}' is invalid for format date",
    parse: "'${name}' could not be parsed as date",
    invalid: "'${name}' is invalid date"
  },
  types: {
    string: hn,
    method: hn,
    array: hn,
    object: hn,
    number: hn,
    date: hn,
    boolean: hn,
    integer: hn,
    float: hn,
    regexp: hn,
    email: hn,
    url: hn,
    hex: hn
  },
  string: {
    len: "'${name}' must be exactly ${len} characters",
    min: "'${name}' must be at least ${min} characters",
    max: "'${name}' cannot be longer than ${max} characters",
    range: "'${name}' must be between ${min} and ${max} characters"
  },
  number: {
    len: "'${name}' must equal ${len}",
    min: "'${name}' cannot be less than ${min}",
    max: "'${name}' cannot be greater than ${max}",
    range: "'${name}' must be between ${min} and ${max}"
  },
  array: {
    len: "'${name}' must be exactly ${len} in length",
    min: "'${name}' cannot be less than ${min} in length",
    max: "'${name}' cannot be greater than ${max} in length",
    range: "'${name}' must be between ${min} and ${max} in length"
  },
  pattern: {
    mismatch: "'${name}' does not match pattern ${pattern}"
  }
};
var zs = function(e, t, n, o) {
  function r(a) {
    return a instanceof n ? a : new n(function(i) {
      i(a);
    });
  }
  return new (n || (n = Promise))(function(a, i) {
    function l(c) {
      try {
        s(o.next(c));
      } catch (d) {
        i(d);
      }
    }
    function u(c) {
      try {
        s(o.throw(c));
      } catch (d) {
        i(d);
      }
    }
    function s(c) {
      c.done ? a(c.value) : r(c.value).then(l, u);
    }
    s((o = o.apply(e, t || [])).next());
  });
};
const oB = Ei;
function rB(e, t) {
  return e.replace(/\$\{\w+\}/g, (n) => {
    const o = n.slice(2, -1);
    return t[o];
  });
}
function nd(e, t, n, o, r) {
  return zs(this, void 0, void 0, function* () {
    const a = h({}, n);
    delete a.ruleIndex, delete a.trigger;
    let i = null;
    a && a.type === "array" && a.defaultField && (i = a.defaultField, delete a.defaultField);
    const l = new oB({
      [e]: [a]
    }), u = tB({}, Hs, o.validateMessages);
    l.messages(u);
    let s = [];
    try {
      yield Promise.resolve(l.validate({
        [e]: t
      }, h({}, o)));
    } catch (f) {
      f.errors ? s = f.errors.map((p, v) => {
        let {
          message: g
        } = p;
        return (
          // Wrap VueNode with `key`
          on(g) ? Ko(g, {
            key: `error_${v}`
          }) : g
        );
      }) : (console.error(f), s = [u.default()]);
    }
    if (!s.length && i)
      return (yield Promise.all(t.map((p, v) => nd(`${e}.${v}`, p, i, o, r)))).reduce((p, v) => [...p, ...v], []);
    const c = h(h(h({}, n), {
      name: e,
      enum: (n.enum || []).join(", ")
    }), r);
    return s.map((f) => typeof f == "string" ? rB(f, c) : f);
  });
}
function x$(e, t, n, o, r, a) {
  const i = e.join("."), l = n.map((s, c) => {
    const d = s.validator, f = h(h({}, s), {
      ruleIndex: c
    });
    return d && (f.validator = (p, v, g) => {
      let b = !1;
      const S = d(p, v, function() {
        for (var w = arguments.length, C = new Array(w), $ = 0; $ < w; $++)
          C[$] = arguments[$];
        Promise.resolve().then(() => {
          lt(!b, "Your validator function has already return a promise. `callback` will be ignored."), b || g(...C);
        });
      });
      b = S && typeof S.then == "function" && typeof S.catch == "function", lt(b, "`callback` is deprecated. Please return a promise instead."), b && S.then(() => {
        g();
      }).catch((w) => {
        g(w || " ");
      });
    }), f;
  }).sort((s, c) => {
    let {
      warningOnly: d,
      ruleIndex: f
    } = s, {
      warningOnly: p,
      ruleIndex: v
    } = c;
    return !!d == !!p ? f - v : d ? 1 : -1;
  });
  let u;
  if (r === !0)
    u = new Promise((s, c) => zs(this, void 0, void 0, function* () {
      for (let d = 0; d < l.length; d += 1) {
        const f = l[d], p = yield nd(i, t, f, o, a);
        if (p.length) {
          c([{
            errors: p,
            rule: f
          }]);
          return;
        }
      }
      s([]);
    }));
  else {
    const s = l.map((c) => nd(i, t, c, o, a).then((d) => ({
      errors: d,
      rule: c
    })));
    u = (r ? iB(s) : aB(s)).then((c) => Promise.reject(c));
  }
  return u.catch((s) => s), u;
}
function aB(e) {
  return zs(this, void 0, void 0, function* () {
    return Promise.all(e).then((t) => [].concat(...t));
  });
}
function iB(e) {
  return zs(this, void 0, void 0, function* () {
    let t = 0;
    return new Promise((n) => {
      e.forEach((o) => {
        o.then((r) => {
          r.errors.length && n([r]), t += 1, t === e.length && n([]);
        });
      });
    });
  });
}
const O$ = Symbol("formContextKey"), P$ = (e) => {
  ot(O$, e);
}, rp = () => nt(O$, {
  name: T(() => {
  }),
  labelAlign: T(() => "right"),
  vertical: T(() => !1),
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  addField: (e, t) => {
  },
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  removeField: (e) => {
  },
  model: T(() => {
  }),
  rules: T(() => {
  }),
  colon: T(() => {
  }),
  labelWrap: T(() => {
  }),
  labelCol: T(() => {
  }),
  requiredMark: T(() => !1),
  validateTrigger: T(() => {
  }),
  onValidate: () => {
  },
  validateMessages: T(() => Hs)
}), I$ = Symbol("formItemPrefixContextKey"), lB = (e) => {
  ot(I$, e);
}, sB = () => nt(I$, {
  prefixCls: T(() => "")
});
function uB(e) {
  return typeof e == "number" ? `${e} ${e} auto` : /^\d+(\.\d+)?(px|em|rem|%)$/.test(e) ? `0 0 ${e}` : e;
}
const cB = () => ({
  span: [String, Number],
  order: [String, Number],
  offset: [String, Number],
  push: [String, Number],
  pull: [String, Number],
  xs: {
    type: [String, Number, Object],
    default: void 0
  },
  sm: {
    type: [String, Number, Object],
    default: void 0
  },
  md: {
    type: [String, Number, Object],
    default: void 0
  },
  lg: {
    type: [String, Number, Object],
    default: void 0
  },
  xl: {
    type: [String, Number, Object],
    default: void 0
  },
  xxl: {
    type: [String, Number, Object],
    default: void 0
  },
  prefixCls: String,
  flex: [String, Number]
}), dB = ["xs", "sm", "md", "lg", "xl", "xxl"], T$ = J({
  compatConfig: {
    MODE: 3
  },
  name: "ACol",
  inheritAttrs: !1,
  props: cB(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      gutter: r,
      supportFlexGap: a,
      wrap: i
    } = fF(), {
      prefixCls: l,
      direction: u
    } = Ke("col", e), [s, c] = bF(l), d = T(() => {
      const {
        span: p,
        order: v,
        offset: g,
        push: b,
        pull: y
      } = e, S = l.value;
      let w = {};
      return dB.forEach((C) => {
        let $ = {};
        const O = e[C];
        typeof O == "number" ? $.span = O : typeof O == "object" && ($ = O || {}), w = h(h({}, w), {
          [`${S}-${C}-${$.span}`]: $.span !== void 0,
          [`${S}-${C}-order-${$.order}`]: $.order || $.order === 0,
          [`${S}-${C}-offset-${$.offset}`]: $.offset || $.offset === 0,
          [`${S}-${C}-push-${$.push}`]: $.push || $.push === 0,
          [`${S}-${C}-pull-${$.pull}`]: $.pull || $.pull === 0,
          [`${S}-rtl`]: u.value === "rtl"
        });
      }), ae(S, {
        [`${S}-${p}`]: p !== void 0,
        [`${S}-order-${v}`]: v,
        [`${S}-offset-${g}`]: g,
        [`${S}-push-${b}`]: b,
        [`${S}-pull-${y}`]: y
      }, w, o.class, c.value);
    }), f = T(() => {
      const {
        flex: p
      } = e, v = r.value, g = {};
      if (v && v[0] > 0) {
        const b = `${v[0] / 2}px`;
        g.paddingLeft = b, g.paddingRight = b;
      }
      if (v && v[1] > 0 && !a.value) {
        const b = `${v[1] / 2}px`;
        g.paddingTop = b, g.paddingBottom = b;
      }
      return p && (g.flex = uB(p), i.value === !1 && !g.minWidth && (g.minWidth = 0)), g;
    });
    return () => {
      var p;
      return s(m("div", L(L({}, o), {}, {
        class: d.value,
        style: [f.value, o.style]
      }), [(p = n.default) === null || p === void 0 ? void 0 : p.call(n)]));
    };
  }
});
var fB = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { tag: "path", attrs: { d: "M623.6 316.7C593.6 290.4 554 276 512 276s-81.6 14.5-111.6 40.7C369.2 344 352 380.7 352 420v7.6c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V420c0-44.1 43.1-80 96-80s96 35.9 96 80c0 31.1-22 59.6-56.1 72.7-21.2 8.1-39.2 22.3-52.1 40.9-13.1 19-19.9 41.8-19.9 64.9V620c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-22.7a48.3 48.3 0 0130.9-44.8c59-22.7 97.1-74.7 97.1-132.5.1-39.3-17.1-76-48.3-103.3zM472 732a40 40 0 1080 0 40 40 0 10-80 0z" } }] }, name: "question-circle", theme: "outlined" };
function zg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      pB(e, r, n[r]);
    });
  }
  return e;
}
function pB(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var ap = function(t, n) {
  var o = zg({}, t, n.attrs);
  return m(it, zg({}, o, {
    icon: fB
  }), null);
};
ap.displayName = "QuestionCircleOutlined";
ap.inheritAttrs = !1;
const ip = (e, t) => {
  let {
    slots: n,
    emit: o,
    attrs: r
  } = t;
  var a, i, l, u, s;
  const {
    prefixCls: c,
    htmlFor: d,
    labelCol: f,
    labelAlign: p,
    colon: v,
    required: g,
    requiredMark: b
  } = h(h({}, e), r), [y] = Pr("Form"), S = (a = e.label) !== null && a !== void 0 ? a : (i = n.label) === null || i === void 0 ? void 0 : i.call(n);
  if (!S)
    return null;
  const {
    vertical: w,
    labelAlign: C,
    labelCol: $,
    labelWrap: O,
    colon: x
  } = rp(), M = f || ($ == null ? void 0 : $.value) || {}, _ = p || (C == null ? void 0 : C.value), N = `${c}-item-label`, I = ae(N, _ === "left" && `${N}-left`, M.class, {
    [`${N}-wrap`]: !!O.value
  });
  let E = S;
  const B = v === !0 || (x == null ? void 0 : x.value) !== !1 && v !== !1;
  if (B && !w.value && typeof S == "string" && S.trim() !== "" && (E = S.replace(/[:|：]\s*$/, "")), e.tooltip || n.tooltip) {
    const R = m("span", {
      class: `${c}-item-tooltip`
    }, [m(Nr, {
      title: e.tooltip
    }, {
      default: () => [m(ap, null, null)]
    })]);
    E = m(We, null, [E, n.tooltip ? (l = n.tooltip) === null || l === void 0 ? void 0 : l.call(n, {
      class: `${c}-item-tooltip`
    }) : R]);
  }
  b === "optional" && !g && (E = m(We, null, [E, m("span", {
    class: `${c}-item-optional`
  }, [((u = y.value) === null || u === void 0 ? void 0 : u.optional) || ((s = yo.Form) === null || s === void 0 ? void 0 : s.optional)])]));
  const P = ae({
    [`${c}-item-required`]: g,
    [`${c}-item-required-mark-optional`]: b === "optional",
    [`${c}-item-no-colon`]: !B
  });
  return m(T$, L(L({}, M), {}, {
    class: I
  }), {
    default: () => [m("label", {
      for: d,
      class: P,
      title: typeof S == "string" ? S : "",
      onClick: (R) => o("click", R)
    }, [E])]
  });
};
ip.displayName = "FormItemLabel";
ip.inheritAttrs = !1;
const vB = (e) => {
  const {
    componentCls: t
  } = e, n = `${t}-show-help`, o = `${t}-show-help-item`;
  return {
    [n]: {
      // Explain holder
      transition: `opacity ${e.motionDurationSlow} ${e.motionEaseInOut}`,
      "&-appear, &-enter": {
        opacity: 0,
        "&-active": {
          opacity: 1
        }
      },
      "&-leave": {
        opacity: 1,
        "&-active": {
          opacity: 0
        }
      },
      // Explain
      [o]: {
        overflow: "hidden",
        transition: `height ${e.motionDurationSlow} ${e.motionEaseInOut},
                     opacity ${e.motionDurationSlow} ${e.motionEaseInOut},
                     transform ${e.motionDurationSlow} ${e.motionEaseInOut} !important`,
        [`&${o}-appear, &${o}-enter`]: {
          transform: "translateY(-5px)",
          opacity: 0,
          "&-active": {
            transform: "translateY(0)",
            opacity: 1
          }
        },
        [`&${o}-leave-active`]: {
          transform: "translateY(-5px)"
        }
      }
    }
  };
}, mB = (e) => ({
  legend: {
    display: "block",
    width: "100%",
    marginBottom: e.marginLG,
    padding: 0,
    color: e.colorTextDescription,
    fontSize: e.fontSizeLG,
    lineHeight: "inherit",
    border: 0,
    borderBottom: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`
  },
  label: {
    fontSize: e.fontSize
  },
  'input[type="search"]': {
    boxSizing: "border-box"
  },
  // Position radios and checkboxes better
  'input[type="radio"], input[type="checkbox"]': {
    lineHeight: "normal"
  },
  'input[type="file"]': {
    display: "block"
  },
  // Make range inputs behave like textual form controls
  'input[type="range"]': {
    display: "block",
    width: "100%"
  },
  // Make multiple select elements height not fixed
  "select[multiple], select[size]": {
    height: "auto"
  },
  // Focus for file, radio, and checkbox
  "input[type='file']:focus,\n  input[type='radio']:focus,\n  input[type='checkbox']:focus": {
    outline: 0,
    boxShadow: `0 0 0 ${e.controlOutlineWidth}px ${e.controlOutline}`
  },
  // Adjust output element
  output: {
    display: "block",
    paddingTop: 15,
    color: e.colorText,
    fontSize: e.fontSize,
    lineHeight: e.lineHeight
  }
}), jg = (e, t) => {
  const {
    formItemCls: n
  } = e;
  return {
    [n]: {
      [`${n}-label > label`]: {
        height: t
      },
      [`${n}-control-input`]: {
        minHeight: t
      }
    }
  };
}, gB = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [e.componentCls]: h(h(h({}, st(e)), mB(e)), {
      [`${t}-text`]: {
        display: "inline-block",
        paddingInlineEnd: e.paddingSM
      },
      // ================================================================
      // =                             Size                             =
      // ================================================================
      "&-small": h({}, jg(e, e.controlHeightSM)),
      "&-large": h({}, jg(e, e.controlHeightLG))
    })
  };
}, hB = (e) => {
  const {
    formItemCls: t,
    iconCls: n,
    componentCls: o,
    rootPrefixCls: r
  } = e;
  return {
    [t]: h(h({}, st(e)), {
      marginBottom: e.marginLG,
      verticalAlign: "top",
      "&-with-help": {
        transition: "none"
      },
      [`&-hidden,
        &-hidden.${r}-row`]: {
        // https://github.com/ant-design/ant-design/issues/26141
        display: "none"
      },
      "&-has-warning": {
        [`${t}-split`]: {
          color: e.colorError
        }
      },
      "&-has-error": {
        [`${t}-split`]: {
          color: e.colorWarning
        }
      },
      // ==============================================================
      // =                            Label                           =
      // ==============================================================
      [`${t}-label`]: {
        display: "inline-block",
        flexGrow: 0,
        overflow: "hidden",
        whiteSpace: "nowrap",
        textAlign: "end",
        verticalAlign: "middle",
        "&-left": {
          textAlign: "start"
        },
        "&-wrap": {
          overflow: "unset",
          lineHeight: `${e.lineHeight} - 0.25em`,
          whiteSpace: "unset"
        },
        "> label": {
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          maxWidth: "100%",
          height: e.controlHeight,
          color: e.colorTextHeading,
          fontSize: e.fontSize,
          [`> ${n}`]: {
            fontSize: e.fontSize,
            verticalAlign: "top"
          },
          // Required mark
          [`&${t}-required:not(${t}-required-mark-optional)::before`]: {
            display: "inline-block",
            marginInlineEnd: e.marginXXS,
            color: e.colorError,
            fontSize: e.fontSize,
            fontFamily: "SimSun, sans-serif",
            lineHeight: 1,
            content: '"*"',
            [`${o}-hide-required-mark &`]: {
              display: "none"
            }
          },
          // Optional mark
          [`${t}-optional`]: {
            display: "inline-block",
            marginInlineStart: e.marginXXS,
            color: e.colorTextDescription,
            [`${o}-hide-required-mark &`]: {
              display: "none"
            }
          },
          // Optional mark
          [`${t}-tooltip`]: {
            color: e.colorTextDescription,
            cursor: "help",
            writingMode: "horizontal-tb",
            marginInlineStart: e.marginXXS
          },
          "&::after": {
            content: '":"',
            position: "relative",
            marginBlock: 0,
            marginInlineStart: e.marginXXS / 2,
            marginInlineEnd: e.marginXS
          },
          [`&${t}-no-colon::after`]: {
            content: '" "'
          }
        }
      },
      // ==============================================================
      // =                            Input                           =
      // ==============================================================
      [`${t}-control`]: {
        display: "flex",
        flexDirection: "column",
        flexGrow: 1,
        [`&:first-child:not([class^="'${r}-col-'"]):not([class*="' ${r}-col-'"])`]: {
          width: "100%"
        },
        "&-input": {
          position: "relative",
          display: "flex",
          alignItems: "center",
          minHeight: e.controlHeight,
          "&-content": {
            flex: "auto",
            maxWidth: "100%"
          }
        }
      },
      // ==============================================================
      // =                           Explain                          =
      // ==============================================================
      [t]: {
        "&-explain, &-extra": {
          clear: "both",
          color: e.colorTextDescription,
          fontSize: e.fontSize,
          lineHeight: e.lineHeight
        },
        "&-explain-connected": {
          width: "100%"
        },
        "&-extra": {
          minHeight: e.controlHeightSM,
          transition: `color ${e.motionDurationMid} ${e.motionEaseOut}`
          // sync input color transition
        },
        "&-explain": {
          "&-error": {
            color: e.colorError
          },
          "&-warning": {
            color: e.colorWarning
          }
        }
      },
      [`&-with-help ${t}-explain`]: {
        height: "auto",
        opacity: 1
      },
      // ==============================================================
      // =                        Feedback Icon                       =
      // ==============================================================
      [`${t}-feedback-icon`]: {
        fontSize: e.fontSize,
        textAlign: "center",
        visibility: "visible",
        animationName: Sf,
        animationDuration: e.motionDurationMid,
        animationTimingFunction: e.motionEaseOutBack,
        pointerEvents: "none",
        "&-success": {
          color: e.colorSuccess
        },
        "&-error": {
          color: e.colorError
        },
        "&-warning": {
          color: e.colorWarning
        },
        "&-validating": {
          color: e.colorPrimary
        }
      }
    })
  };
}, bB = (e) => {
  const {
    componentCls: t,
    formItemCls: n,
    rootPrefixCls: o
  } = e;
  return {
    [`${t}-horizontal`]: {
      [`${n}-label`]: {
        flexGrow: 0
      },
      [`${n}-control`]: {
        flex: "1 1 0",
        // https://github.com/ant-design/ant-design/issues/32777
        // https://github.com/ant-design/ant-design/issues/33773
        minWidth: 0
      },
      // https://github.com/ant-design/ant-design/issues/32980
      [`${n}-label.${o}-col-24 + ${n}-control`]: {
        minWidth: "unset"
      }
    }
  };
}, yB = (e) => {
  const {
    componentCls: t,
    formItemCls: n
  } = e;
  return {
    [`${t}-inline`]: {
      display: "flex",
      flexWrap: "wrap",
      [n]: {
        flex: "none",
        flexWrap: "nowrap",
        marginInlineEnd: e.margin,
        marginBottom: 0,
        "&-with-help": {
          marginBottom: e.marginLG
        },
        [`> ${n}-label,
        > ${n}-control`]: {
          display: "inline-block",
          verticalAlign: "top"
        },
        [`> ${n}-label`]: {
          flex: "none"
        },
        [`${t}-text`]: {
          display: "inline-block"
        },
        [`${n}-has-feedback`]: {
          display: "inline-block"
        }
      }
    }
  };
}, Ur = (e) => ({
  margin: 0,
  padding: `0 0 ${e.paddingXS}px`,
  whiteSpace: "initial",
  textAlign: "start",
  "> label": {
    margin: 0,
    "&::after": {
      display: "none"
    }
  }
}), SB = (e) => {
  const {
    componentCls: t,
    formItemCls: n
  } = e;
  return {
    [`${n} ${n}-label`]: Ur(e),
    [t]: {
      [n]: {
        flexWrap: "wrap",
        [`${n}-label,
          ${n}-control`]: {
          flex: "0 0 100%",
          maxWidth: "100%"
        }
      }
    }
  };
}, $B = (e) => {
  const {
    componentCls: t,
    formItemCls: n,
    rootPrefixCls: o
  } = e;
  return {
    [`${t}-vertical`]: {
      [n]: {
        "&-row": {
          flexDirection: "column"
        },
        "&-label > label": {
          height: "auto"
        },
        [`${t}-item-control`]: {
          width: "100%"
        }
      }
    },
    [`${t}-vertical ${n}-label,
      .${o}-col-24${n}-label,
      .${o}-col-xl-24${n}-label`]: Ur(e),
    [`@media (max-width: ${e.screenXSMax}px)`]: [SB(e), {
      [t]: {
        [`.${o}-col-xs-24${n}-label`]: Ur(e)
      }
    }],
    [`@media (max-width: ${e.screenSMMax}px)`]: {
      [t]: {
        [`.${o}-col-sm-24${n}-label`]: Ur(e)
      }
    },
    [`@media (max-width: ${e.screenMDMax}px)`]: {
      [t]: {
        [`.${o}-col-md-24${n}-label`]: Ur(e)
      }
    },
    [`@media (max-width: ${e.screenLGMax}px)`]: {
      [t]: {
        [`.${o}-col-lg-24${n}-label`]: Ur(e)
      }
    }
  };
}, lp = ht("Form", (e, t) => {
  let {
    rootPrefixCls: n
  } = t;
  const o = qe(e, {
    formItemCls: `${e.componentCls}-item`,
    rootPrefixCls: n
  });
  return [gB(o), hB(o), vB(o), bB(o), yB(o), $B(o), $f(o), Sf];
}), CB = J({
  compatConfig: {
    MODE: 3
  },
  name: "ErrorList",
  inheritAttrs: !1,
  props: ["errors", "help", "onErrorVisibleChanged", "helpStatus", "warnings"],
  setup(e, t) {
    let {
      attrs: n
    } = t;
    const {
      prefixCls: o,
      status: r
    } = sB(), a = T(() => `${o.value}-item-explain`), i = T(() => !!(e.errors && e.errors.length)), l = G(r.value), [, u] = lp(o);
    return le([i, r], () => {
      i.value && (l.value = r.value);
    }), () => {
      var s, c;
      const d = As(`${o.value}-show-help-item`), f = bs(`${o.value}-show-help-item`, d);
      return f.role = "alert", f.class = [u.value, a.value, n.class, `${o.value}-show-help`], m(Yn, L(L({}, Ca(`${o.value}-show-help`)), {}, {
        onAfterEnter: () => e.onErrorVisibleChanged(!0),
        onAfterLeave: () => e.onErrorVisibleChanged(!1)
      }), {
        default: () => [An(m(ns, L(L({}, f), {}, {
          tag: "div"
        }), {
          default: () => [(c = e.errors) === null || c === void 0 ? void 0 : c.map((p, v) => m("div", {
            key: v,
            class: l.value ? `${a.value}-${l.value}` : ""
          }, [p]))]
        }), [[wo, !!(!((s = e.errors) === null || s === void 0) && s.length)]])]
      });
    };
  }
}), wB = J({
  compatConfig: {
    MODE: 3
  },
  slots: Object,
  inheritAttrs: !1,
  props: ["prefixCls", "errors", "hasFeedback", "onDomErrorVisibleChange", "wrapperCol", "help", "extra", "status", "marginBottom", "onErrorVisibleChanged"],
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = rp(), {
      wrapperCol: r
    } = o, a = h({}, o);
    return delete a.labelCol, delete a.wrapperCol, P$(a), lB({
      prefixCls: T(() => e.prefixCls),
      status: T(() => e.status)
    }), () => {
      var i, l, u;
      const {
        prefixCls: s,
        wrapperCol: c,
        marginBottom: d,
        onErrorVisibleChanged: f,
        help: p = (i = n.help) === null || i === void 0 ? void 0 : i.call(n),
        errors: v = nn((l = n.errors) === null || l === void 0 ? void 0 : l.call(n)),
        // hasFeedback,
        // status,
        extra: g = (u = n.extra) === null || u === void 0 ? void 0 : u.call(n)
      } = e, b = `${s}-item`, y = c || (r == null ? void 0 : r.value) || {}, S = ae(`${b}-control`, y.class);
      return m(T$, L(L({}, y), {}, {
        class: S
      }), {
        default: () => {
          var w;
          return m(We, null, [m("div", {
            class: `${b}-control-input`
          }, [m("div", {
            class: `${b}-control-input-content`
          }, [(w = n.default) === null || w === void 0 ? void 0 : w.call(n)])]), d !== null || v.length ? m("div", {
            style: {
              display: "flex",
              flexWrap: "nowrap"
            }
          }, [m(CB, {
            errors: v,
            help: p,
            class: `${b}-explain-connected`,
            onErrorVisibleChanged: f
          }, null), !!d && m("div", {
            style: {
              width: 0,
              height: `${d}px`
            }
          }, null)]) : null, g ? m("div", {
            class: `${b}-extra`
          }, [g]) : null]);
        }
      });
    };
  }
});
function xB(e) {
  const t = K(e.value.slice());
  let n = null;
  return Ve(() => {
    clearTimeout(n), n = setTimeout(() => {
      t.value = e.value;
    }, e.value.length ? 0 : 10);
  }), t;
}
ro("success", "warning", "error", "validating", "");
const OB = {
  success: Io,
  warning: Qo,
  error: vn,
  validating: pn
};
function Au(e, t, n) {
  let o = e;
  const r = t;
  let a = 0;
  try {
    for (let i = r.length; a < i - 1 && !(!o && !n); ++a) {
      const l = r[a];
      if (l in o)
        o = o[l];
      else {
        if (n)
          throw Error("please transfer a valid name path to form item!");
        break;
      }
    }
    if (n && !o)
      throw Error("please transfer a valid name path to form item!");
  } catch {
    console.error("please transfer a valid name path to form item!");
  }
  return {
    o,
    k: r[a],
    v: o ? o[r[a]] : void 0
  };
}
const PB = () => ({
  htmlFor: String,
  prefixCls: String,
  label: W.any,
  help: W.any,
  extra: W.any,
  labelCol: {
    type: Object
  },
  wrapperCol: {
    type: Object
  },
  hasFeedback: {
    type: Boolean,
    default: !1
  },
  colon: {
    type: Boolean,
    default: void 0
  },
  labelAlign: String,
  prop: {
    type: [String, Number, Array]
  },
  name: {
    type: [String, Number, Array]
  },
  rules: [Array, Object],
  autoLink: {
    type: Boolean,
    default: !0
  },
  required: {
    type: Boolean,
    default: void 0
  },
  validateFirst: {
    type: Boolean,
    default: void 0
  },
  validateStatus: W.oneOf(ro("", "success", "warning", "error", "validating")),
  validateTrigger: {
    type: [String, Array]
  },
  messageVariables: {
    type: Object
  },
  hidden: Boolean,
  noStyle: Boolean,
  tooltip: String
});
let IB = 0;
const TB = "form_item", E$ = J({
  compatConfig: {
    MODE: 3
  },
  name: "AFormItem",
  inheritAttrs: !1,
  __ANT_NEW_FORM_ITEM: !0,
  props: PB(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: r
    } = t;
    lt(e.prop === void 0, "`prop` is deprecated. Please use `name` instead.");
    const a = `form-item-${++IB}`, {
      prefixCls: i
    } = Ke("form", e), [l, u] = lp(i), s = K(), c = rp(), d = T(() => e.name || e.prop), f = K([]), p = K(!1), v = K(), g = T(() => {
      const q = d.value;
      return td(q);
    }), b = T(() => {
      if (g.value.length) {
        const q = c.name.value, oe = g.value.join("_");
        return q ? `${q}_${oe}` : `${TB}_${oe}`;
      } else
        return;
    }), y = () => {
      const q = c.model.value;
      if (!(!q || !d.value))
        return Au(q, g.value, !0).v;
    }, S = T(() => y()), w = K(fl(S.value)), C = T(() => {
      let q = e.validateTrigger !== void 0 ? e.validateTrigger : c.validateTrigger.value;
      return q = q === void 0 ? "change" : q, Vo(q);
    }), $ = T(() => {
      let q = c.rules.value;
      const oe = e.rules, Z = e.required !== void 0 ? {
        required: !!e.required,
        trigger: C.value
      } : [], ne = Au(q, g.value);
      q = q ? ne.o[ne.k] || ne.v : [];
      const Y = [].concat(oe || q || []);
      return FD(Y, (V) => V.required) ? Y : Y.concat(Z);
    }), O = T(() => {
      const q = $.value;
      let oe = !1;
      return q && q.length && q.every((Z) => Z.required ? (oe = !0, !1) : !0), oe || e.required;
    }), x = K();
    Ve(() => {
      x.value = e.validateStatus;
    });
    const M = T(() => {
      let q = {};
      return typeof e.label == "string" ? q.label = e.label : e.name && (q.label = String(e.name)), e.messageVariables && (q = h(h({}, q), e.messageVariables)), q;
    }), _ = (q) => {
      if (g.value.length === 0)
        return;
      const {
        validateFirst: oe = !1
      } = e, {
        triggerName: Z
      } = q || {};
      let ne = $.value;
      if (Z && (ne = ne.filter((V) => {
        const {
          trigger: X
        } = V;
        return !X && !C.value.length ? !0 : Vo(X || C.value).includes(Z);
      })), !ne.length)
        return Promise.resolve();
      const Y = x$(g.value, S.value, ne, h({
        validateMessages: c.validateMessages.value
      }, q), oe, M.value);
      return x.value = "validating", f.value = [], Y.catch((V) => V).then(function() {
        let V = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        if (x.value === "validating") {
          const X = V.filter((re) => re && re.errors.length);
          x.value = X.length ? "error" : "success", f.value = X.map((re) => re.errors), c.onValidate(d.value, !f.value.length, f.value.length ? Ft(f.value[0]) : null);
        }
      }), Y;
    }, N = () => {
      _({
        triggerName: "blur"
      });
    }, I = () => {
      if (p.value) {
        p.value = !1;
        return;
      }
      _({
        triggerName: "change"
      });
    }, E = () => {
      x.value = e.validateStatus, p.value = !1, f.value = [];
    }, B = () => {
      var q;
      x.value = e.validateStatus, p.value = !0, f.value = [];
      const oe = c.model.value || {}, Z = S.value, ne = Au(oe, g.value, !0);
      Array.isArray(Z) ? ne.o[ne.k] = [].concat((q = w.value) !== null && q !== void 0 ? q : []) : ne.o[ne.k] = w.value, mt(() => {
        p.value = !1;
      });
    }, k = T(() => e.htmlFor === void 0 ? b.value : e.htmlFor), P = () => {
      const q = k.value;
      if (!q || !v.value)
        return;
      const oe = v.value.$el.querySelector(`[id="${q}"]`);
      oe && oe.focus && oe.focus();
    };
    r({
      onFieldBlur: N,
      onFieldChange: I,
      clearValidate: E,
      resetField: B
    }), H2({
      id: b,
      onFieldBlur: () => {
        e.autoLink && N();
      },
      onFieldChange: () => {
        e.autoLink && I();
      },
      clearValidate: E
    }, T(() => !!(e.autoLink && c.model.value && d.value)));
    let R = !1;
    le(d, (q) => {
      q ? R || (R = !0, c.addField(a, {
        fieldValue: S,
        fieldId: b,
        fieldName: d,
        resetField: B,
        clearValidate: E,
        namePath: g,
        validateRules: _,
        rules: $
      })) : (R = !1, c.removeField(a));
    }, {
      immediate: !0
    }), at(() => {
      c.removeField(a);
    });
    const D = xB(f), A = T(() => e.validateStatus !== void 0 ? e.validateStatus : D.value.length ? "error" : x.value), H = T(() => ({
      [`${i.value}-item`]: !0,
      [u.value]: !0,
      // Status
      [`${i.value}-item-has-feedback`]: A.value && e.hasFeedback,
      [`${i.value}-item-has-success`]: A.value === "success",
      [`${i.value}-item-has-warning`]: A.value === "warning",
      [`${i.value}-item-has-error`]: A.value === "error",
      [`${i.value}-item-is-validating`]: A.value === "validating",
      [`${i.value}-item-hidden`]: e.hidden
    })), j = Et({});
    rn.useProvide(j), Ve(() => {
      let q;
      if (e.hasFeedback) {
        const oe = A.value && OB[A.value];
        q = oe ? m("span", {
          class: ae(`${i.value}-item-feedback-icon`, `${i.value}-item-feedback-icon-${A.value}`)
        }, [m(oe, null, null)]) : null;
      }
      h(j, {
        status: A.value,
        hasFeedback: e.hasFeedback,
        feedbackIcon: q,
        isFormItemInput: !0
      });
    });
    const z = K(null), F = K(!1), U = () => {
      if (s.value) {
        const q = getComputedStyle(s.value);
        z.value = parseInt(q.marginBottom, 10);
      }
    };
    ze(() => {
      le(F, () => {
        F.value && U();
      }, {
        flush: "post",
        immediate: !0
      });
    });
    const Q = (q) => {
      q || (z.value = null);
    };
    return () => {
      var q, oe;
      if (e.noStyle)
        return (q = n.default) === null || q === void 0 ? void 0 : q.call(n);
      const Z = (oe = e.help) !== null && oe !== void 0 ? oe : n.help ? nn(n.help()) : null, ne = !!(Z != null && Array.isArray(Z) && Z.length || D.value.length);
      return F.value = ne, l(m("div", {
        class: [H.value, ne ? `${i.value}-item-with-help` : "", o.class],
        ref: s
      }, [m(b$, L(L({}, o), {}, {
        class: `${i.value}-row`,
        key: "row"
      }), {
        default: () => {
          var Y, V;
          return m(We, null, [m(ip, L(L({}, e), {}, {
            htmlFor: k.value,
            required: O.value,
            requiredMark: c.requiredMark.value,
            prefixCls: i.value,
            onClick: P,
            label: e.label
          }), {
            label: n.label,
            tooltip: n.tooltip
          }), m(wB, L(L({}, e), {}, {
            errors: Z != null ? Vo(Z) : D.value,
            marginBottom: z.value,
            prefixCls: i.value,
            status: A.value,
            ref: v,
            help: Z,
            extra: (Y = e.extra) !== null && Y !== void 0 ? Y : (V = n.extra) === null || V === void 0 ? void 0 : V.call(n),
            onErrorVisibleChanged: Q
          }), {
            default: n.default
          })]);
        }
      }), !!z.value && m("div", {
        class: `${i.value}-margin-offset`,
        style: {
          marginBottom: `-${z.value}px`
        }
      }, null)]));
    };
  }
});
function M$(e) {
  let t = !1, n = e.length;
  const o = [];
  return e.length ? new Promise((r, a) => {
    e.forEach((i, l) => {
      i.catch((u) => (t = !0, u)).then((u) => {
        n -= 1, o[l] = u, !(n > 0) && (t && a(o), r(o));
      });
    });
  }) : Promise.resolve([]);
}
function Vg(e) {
  let t = !1;
  return e && e.length && e.every((n) => n.required ? (t = !0, !1) : !0), t;
}
function Wg(e) {
  return e == null ? [] : Array.isArray(e) ? e : [e];
}
function Nu(e, t, n) {
  let o = e;
  t = t.replace(/\[(\w+)\]/g, ".$1"), t = t.replace(/^\./, "");
  const r = t.split(".");
  let a = 0;
  for (let i = r.length; a < i - 1 && !(!o && !n); ++a) {
    const l = r[a];
    if (l in o)
      o = o[l];
    else {
      if (n)
        throw new Error("please transfer a valid name path to validate!");
      break;
    }
  }
  return {
    o,
    k: r[a],
    v: o ? o[r[a]] : null,
    isValid: o && r[a] in o
  };
}
function EB(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : G({}), n = arguments.length > 2 ? arguments[2] : void 0;
  const o = fl(Ye(e)), r = Et({}), a = K([]), i = (w) => {
    h(Ye(e), h(h({}, fl(o)), w)), mt(() => {
      Object.keys(r).forEach((C) => {
        r[C] = {
          autoLink: !1,
          required: Vg(Ye(t)[C])
        };
      });
    });
  }, l = function() {
    let w = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], C = arguments.length > 1 ? arguments[1] : void 0;
    return C.length ? w.filter(($) => {
      const O = Wg($.trigger || "change");
      return HD(O, C).length;
    }) : w;
  };
  let u = null;
  const s = function(w) {
    let C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, $ = arguments.length > 2 ? arguments[2] : void 0;
    const O = [], x = {};
    for (let N = 0; N < w.length; N++) {
      const I = w[N], E = Nu(Ye(e), I, $);
      if (!E.isValid)
        continue;
      x[I] = E.v;
      const B = l(Ye(t)[I], Wg(C && C.trigger));
      B.length && O.push(c(I, E.v, B, C || {}).then(() => ({
        name: I,
        errors: [],
        warnings: []
      })).catch((k) => {
        const P = [], R = [];
        return k.forEach((D) => {
          let {
            rule: {
              warningOnly: A
            },
            errors: H
          } = D;
          A ? R.push(...H) : P.push(...H);
        }), P.length ? Promise.reject({
          name: I,
          errors: P,
          warnings: R
        }) : {
          name: I,
          errors: P,
          warnings: R
        };
      }));
    }
    const M = M$(O);
    u = M;
    const _ = M.then(() => u === M ? Promise.resolve(x) : Promise.reject([])).catch((N) => {
      const I = N.filter((E) => E && E.errors.length);
      return I.length ? Promise.reject({
        values: x,
        errorFields: I,
        outOfDate: u !== M
      }) : Promise.resolve(x);
    });
    return _.catch((N) => N), _;
  }, c = function(w, C, $) {
    let O = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const x = x$([w], C, $, h({
      validateMessages: Hs
    }, O), !!O.validateFirst);
    return r[w] ? (r[w].validateStatus = "validating", x.catch((M) => M).then(function() {
      let M = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var _;
      if (r[w].validateStatus === "validating") {
        const N = M.filter((I) => I && I.errors.length);
        r[w].validateStatus = N.length ? "error" : "success", r[w].help = N.length ? N.map((I) => I.errors) : null, (_ = n == null ? void 0 : n.onValidate) === null || _ === void 0 || _.call(n, w, !N.length, N.length ? Ft(r[w].help[0]) : null);
      }
    }), x) : x.catch((M) => M);
  }, d = (w, C) => {
    let $ = [], O = !0;
    w ? Array.isArray(w) ? $ = w : $ = [w] : (O = !1, $ = a.value);
    const x = s($, C || {}, O);
    return x.catch((M) => M), x;
  }, f = (w) => {
    let C = [];
    w ? Array.isArray(w) ? C = w : C = [w] : C = a.value, C.forEach(($) => {
      r[$] && h(r[$], {
        validateStatus: "",
        help: null
      });
    });
  }, p = (w) => {
    const C = {
      autoLink: !1
    }, $ = [], O = Array.isArray(w) ? w : [w];
    for (let x = 0; x < O.length; x++) {
      const M = O[x];
      (M == null ? void 0 : M.validateStatus) === "error" && (C.validateStatus = "error", M.help && $.push(M.help)), C.required = C.required || (M == null ? void 0 : M.required);
    }
    return C.help = $, C;
  };
  let v = o, g = !0;
  const b = (w) => {
    const C = [];
    a.value.forEach(($) => {
      const O = Nu(w, $, !1), x = Nu(v, $, !1);
      (g && (n == null ? void 0 : n.immediate) && O.isValid || !Gd(O.v, x.v)) && C.push($);
    }), d(C, {
      trigger: "change"
    }), g = !1, v = fl(Ft(w));
  }, y = n == null ? void 0 : n.debounce;
  let S = !0;
  return le(t, () => {
    a.value = t ? Object.keys(Ye(t)) : [], !S && n && n.validateOnRuleChange && d(), S = !1;
  }, {
    deep: !0,
    immediate: !0
  }), le(a, () => {
    const w = {};
    a.value.forEach((C) => {
      w[C] = h({}, r[C], {
        autoLink: !1,
        required: Vg(Ye(t)[C])
      }), delete r[C];
    });
    for (const C in r)
      Object.prototype.hasOwnProperty.call(r, C) && delete r[C];
    h(r, w);
  }, {
    immediate: !0
  }), le(e, y && y.wait ? MD(b, y.wait, QD(y, ["wait"])) : b, {
    immediate: n && !!n.immediate,
    deep: !0
  }), {
    modelRef: e,
    rulesRef: t,
    initialModel: o,
    validateInfos: r,
    resetFields: i,
    validate: d,
    validateField: c,
    mergeValidateInfo: p,
    clearValidate: f
  };
}
const MB = () => ({
  layout: W.oneOf(ro("horizontal", "inline", "vertical")),
  labelCol: He(),
  wrapperCol: He(),
  colon: Me(),
  labelAlign: Ze(),
  labelWrap: Me(),
  prefixCls: String,
  requiredMark: dt([String, Boolean]),
  /** @deprecated Will warning in future branch. Pls use `requiredMark` instead. */
  hideRequiredMark: Me(),
  model: W.object,
  rules: He(),
  validateMessages: He(),
  validateOnRuleChange: Me(),
  // 提交失败自动滚动到第一个错误字段
  scrollToFirstError: Wt(),
  onSubmit: de(),
  name: String,
  validateTrigger: dt([String, Array]),
  size: Ze(),
  disabled: Me(),
  onValuesChange: de(),
  onFieldsChange: de(),
  onFinish: de(),
  onFinishFailed: de(),
  onValidate: de()
});
function _B(e, t) {
  return Gd(Vo(e), Vo(t));
}
const Lo = J({
  compatConfig: {
    MODE: 3
  },
  name: "AForm",
  inheritAttrs: !1,
  props: bt(MB(), {
    layout: "horizontal",
    hideRequiredMark: !1,
    colon: !0
  }),
  Item: E$,
  useForm: EB,
  // emits: ['finishFailed', 'submit', 'finish', 'validate'],
  setup(e, t) {
    let {
      emit: n,
      slots: o,
      expose: r,
      attrs: a
    } = t;
    const {
      prefixCls: i,
      direction: l,
      form: u,
      size: s,
      disabled: c
    } = Ke("form", e), d = T(() => e.requiredMark === "" || e.requiredMark), f = T(() => {
      var D;
      return d.value !== void 0 ? d.value : u && ((D = u.value) === null || D === void 0 ? void 0 : D.requiredMark) !== void 0 ? u.value.requiredMark : !e.hideRequiredMark;
    });
    vy(s), Ib(c);
    const p = T(() => {
      var D, A;
      return (D = e.colon) !== null && D !== void 0 ? D : (A = u.value) === null || A === void 0 ? void 0 : A.colon;
    }), {
      validateMessages: v
    } = ox(), g = T(() => h(h(h({}, Hs), v.value), e.validateMessages)), [b, y] = lp(i), S = T(() => ae(i.value, {
      [`${i.value}-${e.layout}`]: !0,
      [`${i.value}-hide-required-mark`]: f.value === !1,
      [`${i.value}-rtl`]: l.value === "rtl",
      [`${i.value}-${s.value}`]: s.value
    }, y.value)), w = G(), C = {}, $ = (D, A) => {
      C[D] = A;
    }, O = (D) => {
      delete C[D];
    }, x = (D) => {
      const A = !!D, H = A ? Vo(D).map(td) : [];
      return A ? Object.values(C).filter((j) => H.findIndex((z) => _B(z, j.fieldName.value)) > -1) : Object.values(C);
    }, M = (D) => {
      if (!e.model) {
        Pt(!1, "Form", "model is required for resetFields to work.");
        return;
      }
      x(D).forEach((A) => {
        A.resetField();
      });
    }, _ = (D) => {
      x(D).forEach((A) => {
        A.clearValidate();
      });
    }, N = (D) => {
      const {
        scrollToFirstError: A
      } = e;
      if (n("finishFailed", D), A && D.errorFields.length) {
        let H = {};
        typeof A == "object" && (H = A), E(D.errorFields[0].name, H);
      }
    }, I = function() {
      return P(...arguments);
    }, E = function(D) {
      let A = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const H = x(D ? [D] : void 0);
      if (H.length) {
        const j = H[0].fieldId.value, z = j ? document.getElementById(j) : null;
        z && q1(z, h({
          scrollMode: "if-needed",
          block: "nearest"
        }, A));
      }
    }, B = function() {
      let D = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
      if (D === !0) {
        const A = [];
        return Object.values(C).forEach((H) => {
          let {
            namePath: j
          } = H;
          A.push(j.value);
        }), Hg(e.model, A);
      } else
        return Hg(e.model, D);
    }, k = (D, A) => {
      if (Pt(!(D instanceof Function), "Form", "validateFields/validateField/validate not support callback, please use promise instead"), !e.model)
        return Pt(!1, "Form", "model is required for validateFields to work."), Promise.reject("Form `model` is required for validateFields to work.");
      const H = !!D, j = H ? Vo(D).map(td) : [], z = [];
      Object.values(C).forEach((Q) => {
        var q;
        if (H || j.push(Q.namePath.value), !(!((q = Q.rules) === null || q === void 0) && q.value.length))
          return;
        const oe = Q.namePath.value;
        if (!H || eB(j, oe)) {
          const Z = Q.validateRules(h({
            validateMessages: g.value
          }, A));
          z.push(Z.then(() => ({
            name: oe,
            errors: [],
            warnings: []
          })).catch((ne) => {
            const Y = [], V = [];
            return ne.forEach((X) => {
              let {
                rule: {
                  warningOnly: re
                },
                errors: ie
              } = X;
              re ? V.push(...ie) : Y.push(...ie);
            }), Y.length ? Promise.reject({
              name: oe,
              errors: Y,
              warnings: V
            }) : {
              name: oe,
              errors: Y,
              warnings: V
            };
          }));
        }
      });
      const F = M$(z);
      w.value = F;
      const U = F.then(() => w.value === F ? Promise.resolve(B(j)) : Promise.reject([])).catch((Q) => {
        const q = Q.filter((oe) => oe && oe.errors.length);
        return Promise.reject({
          values: B(j),
          errorFields: q,
          outOfDate: w.value !== F
        });
      });
      return U.catch((Q) => Q), U;
    }, P = function() {
      return k(...arguments);
    }, R = (D) => {
      D.preventDefault(), D.stopPropagation(), n("submit", D), e.model && k().then((H) => {
        n("finish", H);
      }).catch((H) => {
        N(H);
      });
    };
    return r({
      resetFields: M,
      clearValidate: _,
      validateFields: k,
      getFieldsValue: B,
      validate: I,
      scrollToField: E
    }), P$({
      model: T(() => e.model),
      name: T(() => e.name),
      labelAlign: T(() => e.labelAlign),
      labelCol: T(() => e.labelCol),
      labelWrap: T(() => e.labelWrap),
      wrapperCol: T(() => e.wrapperCol),
      vertical: T(() => e.layout === "vertical"),
      colon: p,
      requiredMark: f,
      validateTrigger: T(() => e.validateTrigger),
      rules: T(() => e.rules),
      addField: $,
      removeField: O,
      onValidate: (D, A, H) => {
        n("validate", D, A, H);
      },
      validateMessages: g
    }), le(() => e.rules, () => {
      e.validateOnRuleChange && k();
    }), () => {
      var D;
      return b(m("form", L(L({}, a), {}, {
        onSubmit: R,
        class: [S.value, a.class]
      }), [(D = o.default) === null || D === void 0 ? void 0 : D.call(o)]));
    };
  }
});
Lo.useInjectFormItemContext = Lt;
Lo.ItemRest = Fc;
Lo.install = function(e) {
  return e.component(Lo.name, Lo), e.component(Lo.Item.name, Lo.Item), e.component(Fc.name, Fc), e;
};
const DB = new Xe("antCheckboxEffect", {
  "0%": {
    transform: "scale(1)",
    opacity: 0.5
  },
  "100%": {
    transform: "scale(1.6)",
    opacity: 0
  }
}), AB = (e) => {
  const {
    checkboxCls: t
  } = e, n = `${t}-wrapper`;
  return [
    // ===================== Basic =====================
    {
      // Group
      [`${t}-group`]: h(h({}, st(e)), {
        display: "inline-flex",
        flexWrap: "wrap",
        columnGap: e.marginXS,
        // Group > Grid
        [`> ${e.antCls}-row`]: {
          flex: 1
        }
      }),
      // Wrapper
      [n]: h(h({}, st(e)), {
        display: "inline-flex",
        alignItems: "baseline",
        cursor: "pointer",
        // Fix checkbox & radio in flex align #30260
        "&:after": {
          display: "inline-block",
          width: 0,
          overflow: "hidden",
          content: "'\\a0'"
        },
        // Checkbox near checkbox
        [`& + ${n}`]: {
          marginInlineStart: 0
        },
        [`&${n}-in-form-item`]: {
          'input[type="checkbox"]': {
            width: 14,
            height: 14
            // FIXME: magic
          }
        }
      }),
      // Wrapper > Checkbox
      [t]: h(h({}, st(e)), {
        position: "relative",
        whiteSpace: "nowrap",
        lineHeight: 1,
        cursor: "pointer",
        // To make alignment right when `controlHeight` is changed
        // Ref: https://github.com/ant-design/ant-design/issues/41564
        alignSelf: "center",
        // Wrapper > Checkbox > input
        [`${t}-input`]: {
          position: "absolute",
          // Since baseline align will get additional space offset,
          // we need to move input to top to make it align with text.
          // Ref: https://github.com/ant-design/ant-design/issues/38926#issuecomment-1486137799
          inset: 0,
          zIndex: 1,
          cursor: "pointer",
          opacity: 0,
          margin: 0,
          [`&:focus-visible + ${t}-inner`]: h({}, Sr(e))
        },
        // Wrapper > Checkbox > inner
        [`${t}-inner`]: {
          boxSizing: "border-box",
          position: "relative",
          top: 0,
          insetInlineStart: 0,
          display: "block",
          width: e.checkboxSize,
          height: e.checkboxSize,
          direction: "ltr",
          backgroundColor: e.colorBgContainer,
          border: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`,
          borderRadius: e.borderRadiusSM,
          borderCollapse: "separate",
          transition: `all ${e.motionDurationSlow}`,
          "&:after": {
            boxSizing: "border-box",
            position: "absolute",
            top: "50%",
            insetInlineStart: "21.5%",
            display: "table",
            width: e.checkboxSize / 14 * 5,
            height: e.checkboxSize / 14 * 8,
            border: `${e.lineWidthBold}px solid ${e.colorWhite}`,
            borderTop: 0,
            borderInlineStart: 0,
            transform: "rotate(45deg) scale(0) translate(-50%,-50%)",
            opacity: 0,
            content: '""',
            transition: `all ${e.motionDurationFast} ${e.motionEaseInBack}, opacity ${e.motionDurationFast}`
          }
        },
        // Wrapper > Checkbox + Text
        "& + span": {
          paddingInlineStart: e.paddingXS,
          paddingInlineEnd: e.paddingXS
        }
      })
    },
    // ================= Indeterminate =================
    {
      [t]: {
        "&-indeterminate": {
          // Wrapper > Checkbox > inner
          [`${t}-inner`]: {
            "&:after": {
              top: "50%",
              insetInlineStart: "50%",
              width: e.fontSizeLG / 2,
              height: e.fontSizeLG / 2,
              backgroundColor: e.colorPrimary,
              border: 0,
              transform: "translate(-50%, -50%) scale(1)",
              opacity: 1,
              content: '""'
            }
          }
        }
      }
    },
    // ===================== Hover =====================
    {
      // Wrapper
      [`${n}:hover ${t}:after`]: {
        visibility: "visible"
      },
      // Wrapper & Wrapper > Checkbox
      [`
        ${n}:not(${n}-disabled),
        ${t}:not(${t}-disabled)
      `]: {
        [`&:hover ${t}-inner`]: {
          borderColor: e.colorPrimary
        }
      },
      [`${n}:not(${n}-disabled)`]: {
        [`&:hover ${t}-checked:not(${t}-disabled) ${t}-inner`]: {
          backgroundColor: e.colorPrimaryHover,
          borderColor: "transparent"
        },
        [`&:hover ${t}-checked:not(${t}-disabled):after`]: {
          borderColor: e.colorPrimaryHover
        }
      }
    },
    // ==================== Checked ====================
    {
      // Wrapper > Checkbox
      [`${t}-checked`]: {
        [`${t}-inner`]: {
          backgroundColor: e.colorPrimary,
          borderColor: e.colorPrimary,
          "&:after": {
            opacity: 1,
            transform: "rotate(45deg) scale(1) translate(-50%,-50%)",
            transition: `all ${e.motionDurationMid} ${e.motionEaseOutBack} ${e.motionDurationFast}`
          }
        },
        // Checked Effect
        "&:after": {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          width: "100%",
          height: "100%",
          borderRadius: e.borderRadiusSM,
          visibility: "hidden",
          border: `${e.lineWidthBold}px solid ${e.colorPrimary}`,
          animationName: DB,
          animationDuration: e.motionDurationSlow,
          animationTimingFunction: "ease-in-out",
          animationFillMode: "backwards",
          content: '""',
          transition: `all ${e.motionDurationSlow}`
        }
      },
      [`
        ${n}-checked:not(${n}-disabled),
        ${t}-checked:not(${t}-disabled)
      `]: {
        [`&:hover ${t}-inner`]: {
          backgroundColor: e.colorPrimaryHover,
          borderColor: "transparent"
        },
        [`&:hover ${t}:after`]: {
          borderColor: e.colorPrimaryHover
        }
      }
    },
    // ==================== Disable ====================
    {
      // Wrapper
      [`${n}-disabled`]: {
        cursor: "not-allowed"
      },
      // Wrapper > Checkbox
      [`${t}-disabled`]: {
        // Wrapper > Checkbox > input
        [`&, ${t}-input`]: {
          cursor: "not-allowed",
          // Disabled for native input to enable Tooltip event handler
          // ref: https://github.com/ant-design/ant-design/issues/39822#issuecomment-1365075901
          pointerEvents: "none"
        },
        // Wrapper > Checkbox > inner
        [`${t}-inner`]: {
          background: e.colorBgContainerDisabled,
          borderColor: e.colorBorder,
          "&:after": {
            borderColor: e.colorTextDisabled
          }
        },
        "&:after": {
          display: "none"
        },
        "& + span": {
          color: e.colorTextDisabled
        },
        [`&${t}-indeterminate ${t}-inner::after`]: {
          background: e.colorTextDisabled
        }
      }
    }
  ];
};
function _$(e, t) {
  const n = qe(t, {
    checkboxCls: `.${e}`,
    checkboxSize: t.controlInteractiveSize
  });
  return [AB(n)];
}
const D$ = ht("Checkbox", (e, t) => {
  let {
    prefixCls: n
  } = t;
  return [_$(n, e)];
}), NB = () => ({
  name: String,
  prefixCls: String,
  options: Nt([]),
  disabled: Boolean,
  id: String
}), RB = () => h(h({}, NB()), {
  defaultValue: Nt(),
  value: Nt(),
  onChange: de(),
  "onUpdate:value": de()
}), FB = () => ({
  prefixCls: String,
  defaultChecked: Me(),
  checked: Me(),
  disabled: Me(),
  isGroup: Me(),
  value: W.any,
  name: String,
  id: String,
  indeterminate: Me(),
  type: Ze("checkbox"),
  autofocus: Me(),
  onChange: de(),
  "onUpdate:checked": de(),
  onClick: de(),
  skipGroup: Me(!1)
}), BB = () => h(h({}, FB()), {
  indeterminate: Me(!1)
}), A$ = Symbol("CheckboxGroupContext");
var Kg = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const oa = J({
  compatConfig: {
    MODE: 3
  },
  name: "ACheckbox",
  inheritAttrs: !1,
  __ANT_CHECKBOX: !0,
  props: BB(),
  // emits: ['change', 'update:checked'],
  setup(e, t) {
    let {
      emit: n,
      attrs: o,
      slots: r,
      expose: a
    } = t;
    const i = Lt(), l = rn.useInject(), {
      prefixCls: u,
      direction: s,
      disabled: c
    } = Ke("checkbox", e), d = Cn(), [f, p] = D$(u), v = nt(A$, void 0), g = Symbol("checkboxUniId"), b = T(() => (v == null ? void 0 : v.disabled.value) || c.value);
    Ve(() => {
      !e.skipGroup && v && v.registerValue(g, e.value);
    }), at(() => {
      v && v.cancelValue(g);
    }), ze(() => {
      Pt(!!(e.checked !== void 0 || v || e.value === void 0), "Checkbox", "`value` is not validate prop, do you mean `checked`?");
    });
    const y = ($) => {
      const O = $.target.checked;
      n("update:checked", O), n("change", $), i.onFieldChange();
    }, S = G();
    return a({
      focus: () => {
        var $;
        ($ = S.value) === null || $ === void 0 || $.focus();
      },
      blur: () => {
        var $;
        ($ = S.value) === null || $ === void 0 || $.blur();
      }
    }), () => {
      var $;
      const O = xt(($ = r.default) === null || $ === void 0 ? void 0 : $.call(r)), {
        indeterminate: x,
        skipGroup: M,
        id: _ = i.id.value
      } = e, N = Kg(e, ["indeterminate", "skipGroup", "id"]), {
        onMouseenter: I,
        onMouseleave: E,
        onInput: B,
        class: k,
        style: P
      } = o, R = Kg(o, ["onMouseenter", "onMouseleave", "onInput", "class", "style"]), D = h(h(h(h({}, N), {
        id: _,
        prefixCls: u.value
      }), R), {
        disabled: b.value
      });
      v && !M ? (D.onChange = function() {
        for (var z = arguments.length, F = new Array(z), U = 0; U < z; U++)
          F[U] = arguments[U];
        n("change", ...F), v.toggleOption({
          label: O,
          value: e.value
        });
      }, D.name = v.name.value, D.checked = v.mergedValue.value.includes(e.value), D.disabled = b.value || d.value, D.indeterminate = x) : D.onChange = y;
      const A = ae({
        [`${u.value}-wrapper`]: !0,
        [`${u.value}-rtl`]: s.value === "rtl",
        [`${u.value}-wrapper-checked`]: D.checked,
        [`${u.value}-wrapper-disabled`]: D.disabled,
        [`${u.value}-wrapper-in-form-item`]: l.isFormItemInput
      }, k, p.value), H = ae({
        [`${u.value}-indeterminate`]: x
      }, p.value);
      return f(m("label", {
        class: A,
        style: P,
        onMouseenter: I,
        onMouseleave: E
      }, [m(YS, L(L({
        "aria-checked": x ? "mixed" : void 0
      }, D), {}, {
        class: H,
        ref: S
      }), null), O.length ? m("span", null, [O]) : null]));
    };
  }
}), Ql = J({
  compatConfig: {
    MODE: 3
  },
  name: "ACheckboxGroup",
  inheritAttrs: !1,
  props: RB(),
  // emits: ['change', 'update:value'],
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      emit: r,
      expose: a
    } = t;
    const i = Lt(), {
      prefixCls: l,
      direction: u
    } = Ke("checkbox", e), s = T(() => `${l.value}-group`), [c, d] = D$(s), f = G((e.value === void 0 ? e.defaultValue : e.value) || []);
    le(() => e.value, () => {
      f.value = e.value || [];
    });
    const p = T(() => e.options.map((C) => typeof C == "string" || typeof C == "number" ? {
      label: C,
      value: C
    } : C)), v = G(Symbol()), g = G(/* @__PURE__ */ new Map()), b = (C) => {
      g.value.delete(C), v.value = Symbol();
    }, y = (C, $) => {
      g.value.set(C, $), v.value = Symbol();
    }, S = G(/* @__PURE__ */ new Map());
    return le(v, () => {
      const C = /* @__PURE__ */ new Map();
      for (const $ of g.value.values())
        C.set($, !0);
      S.value = C;
    }), ot(A$, {
      cancelValue: b,
      registerValue: y,
      toggleOption: (C) => {
        const $ = f.value.indexOf(C.value), O = [...f.value];
        $ === -1 ? O.push(C.value) : O.splice($, 1), e.value === void 0 && (f.value = O);
        const x = O.filter((M) => S.value.has(M)).sort((M, _) => {
          const N = p.value.findIndex((E) => E.value === M), I = p.value.findIndex((E) => E.value === _);
          return N - I;
        });
        r("update:value", x), r("change", x), i.onFieldChange();
      },
      mergedValue: f,
      name: T(() => e.name),
      disabled: T(() => e.disabled)
    }), a({
      mergedValue: f
    }), () => {
      var C;
      const {
        id: $ = i.id.value
      } = e;
      let O = null;
      return p.value && p.value.length > 0 && (O = p.value.map((x) => {
        var M;
        return m(oa, {
          prefixCls: l.value,
          key: x.value.toString(),
          disabled: "disabled" in x ? x.disabled : e.disabled,
          indeterminate: x.indeterminate,
          value: x.value,
          checked: f.value.indexOf(x.value) !== -1,
          onChange: x.onChange,
          class: `${s.value}-item`
        }, {
          default: () => [n.label !== void 0 ? (M = n.label) === null || M === void 0 ? void 0 : M.call(n, x) : x.label]
        });
      })), c(m("div", L(L({}, o), {}, {
        class: [s.value, {
          [`${s.value}-rtl`]: u.value === "rtl"
        }, o.class, d.value],
        id: $
      }), [O || ((C = n.default) === null || C === void 0 ? void 0 : C.call(n))]));
    };
  }
});
oa.Group = Ql;
oa.install = function(e) {
  return e.component(oa.name, oa), e.component(Ql.name, Ql), e;
};
let yl = h({}, yo.Modal);
function kB(e) {
  e ? yl = h(h({}, yl), e) : yl = h({}, yo.Modal);
}
function LB() {
  return yl;
}
const od = "internalMark", Sl = J({
  compatConfig: {
    MODE: 3
  },
  name: "ALocaleProvider",
  props: {
    locale: {
      type: Object
    },
    ANT_MARK__: String
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    Pt(e.ANT_MARK__ === od, "LocaleProvider", "`LocaleProvider` is deprecated. Please use `locale` with `ConfigProvider` instead");
    const o = Et({
      antLocale: h(h({}, e.locale), {
        exist: !0
      }),
      ANT_MARK__: od
    });
    return ot("localeData", o), le(() => e.locale, (r) => {
      kB(r && r.Modal), o.antLocale = h(h({}, r), {
        exist: !0
      });
    }, {
      immediate: !0
    }), () => {
      var r;
      return (r = n.default) === null || r === void 0 ? void 0 : r.call(n);
    };
  }
});
Sl.install = function(e) {
  return e.component(Sl.name, Sl), e;
};
const HB = Xn(Sl), js = J({
  name: "Notice",
  inheritAttrs: !1,
  props: ["prefixCls", "duration", "updateMark", "noticeKey", "closeIcon", "closable", "props", "onClick", "onClose", "holder", "visible"],
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t, r, a = !1;
    const i = T(() => e.duration === void 0 ? 4.5 : e.duration), l = () => {
      i.value && !a && (r = setTimeout(() => {
        s();
      }, i.value * 1e3));
    }, u = () => {
      r && (clearTimeout(r), r = null);
    }, s = (d) => {
      d && d.stopPropagation(), u();
      const {
        onClose: f,
        noticeKey: p
      } = e;
      f && f(p);
    }, c = () => {
      u(), l();
    };
    return ze(() => {
      l();
    }), Xo(() => {
      a = !0, u();
    }), le([i, () => e.updateMark, () => e.visible], (d, f) => {
      let [p, v, g] = d, [b, y, S] = f;
      (p !== b || v !== y || g !== S && S) && c();
    }, {
      flush: "post"
    }), () => {
      var d, f;
      const {
        prefixCls: p,
        closable: v,
        closeIcon: g = (d = o.closeIcon) === null || d === void 0 ? void 0 : d.call(o),
        onClick: b,
        holder: y
      } = e, {
        class: S,
        style: w
      } = n, C = `${p}-notice`, $ = Object.keys(n).reduce((x, M) => ((M.startsWith("data-") || M.startsWith("aria-") || M === "role") && (x[M] = n[M]), x), {}), O = m("div", L({
        class: ae(C, S, {
          [`${C}-closable`]: v
        }),
        style: w,
        onMouseenter: u,
        onMouseleave: l,
        onClick: b
      }, $), [m("div", {
        class: `${C}-content`
      }, [(f = o.default) === null || f === void 0 ? void 0 : f.call(o)]), v ? m("a", {
        tabindex: 0,
        onClick: s,
        class: `${C}-close`
      }, [g || m("span", {
        class: `${C}-close-x`
      }, null)]) : null]);
      return y ? m(hd, {
        to: y
      }, {
        default: () => O
      }) : O;
    };
  }
});
var zB = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
let Ug = 0;
const jB = Date.now();
function Gg() {
  const e = Ug;
  return Ug += 1, `rcNotification_${jB}_${e}`;
}
const Zl = J({
  name: "Notification",
  inheritAttrs: !1,
  props: ["prefixCls", "transitionName", "animation", "maxCount", "closeIcon", "hashId"],
  setup(e, t) {
    let {
      attrs: n,
      expose: o,
      slots: r
    } = t;
    const a = /* @__PURE__ */ new Map(), i = G([]), l = T(() => {
      const {
        prefixCls: c,
        animation: d = "fade"
      } = e;
      let f = e.transitionName;
      return !f && d && (f = `${c}-${d}`), bs(f);
    }), u = (c, d) => {
      const f = c.key || Gg(), p = h(h({}, c), {
        key: f
      }), {
        maxCount: v
      } = e, g = i.value.map((y) => y.notice.key).indexOf(f), b = i.value.concat();
      g !== -1 ? b.splice(g, 1, {
        notice: p,
        holderCallback: d
      }) : (v && i.value.length >= v && (p.key = b[0].notice.key, p.updateMark = Gg(), p.userPassKey = f, b.shift()), b.push({
        notice: p,
        holderCallback: d
      })), i.value = b;
    }, s = (c) => {
      i.value = i.value.filter((d) => {
        let {
          notice: {
            key: f,
            userPassKey: p
          }
        } = d;
        return (p || f) !== c;
      });
    };
    return o({
      add: u,
      remove: s,
      notices: i
    }), () => {
      var c;
      const {
        prefixCls: d,
        closeIcon: f = (c = r.closeIcon) === null || c === void 0 ? void 0 : c.call(r, {
          prefixCls: d
        })
      } = e, p = i.value.map((g, b) => {
        let {
          notice: y,
          holderCallback: S
        } = g;
        const w = b === i.value.length - 1 ? y.updateMark : void 0, {
          key: C,
          userPassKey: $
        } = y, {
          content: O
        } = y, x = h(h(h({
          prefixCls: d,
          closeIcon: typeof f == "function" ? f({
            prefixCls: d
          }) : f
        }, y), y.props), {
          key: C,
          noticeKey: $ || C,
          updateMark: w,
          onClose: (M) => {
            var _;
            s(M), (_ = y.onClose) === null || _ === void 0 || _.call(y);
          },
          onClick: y.onClick
        });
        return S ? m("div", {
          key: C,
          class: `${d}-hook-holder`,
          ref: (M) => {
            typeof C > "u" || (M ? (a.set(C, M), S(M, x)) : a.delete(C));
          }
        }, null) : m(js, L(L({}, x), {}, {
          class: ae(x.class, e.hashId)
        }), {
          default: () => [typeof O == "function" ? O({
            prefixCls: d
          }) : O]
        });
      }), v = {
        [d]: 1,
        [n.class]: !!n.class,
        [e.hashId]: !0
      };
      return m("div", {
        class: v,
        style: n.style || {
          top: "65px",
          left: "50%"
        }
      }, [m(ns, L({
        tag: "div"
      }, l.value), {
        default: () => [p]
      })]);
    };
  }
});
Zl.newInstance = function(t, n) {
  const o = t || {}, {
    name: r = "notification",
    getContainer: a,
    appContext: i,
    prefixCls: l,
    rootPrefixCls: u,
    transitionName: s,
    hasTransitionName: c,
    useStyle: d
  } = o, f = zB(o, ["name", "getContainer", "appContext", "prefixCls", "rootPrefixCls", "transitionName", "hasTransitionName", "useStyle"]), p = document.createElement("div");
  a ? a().appendChild(p) : document.body.appendChild(p);
  const v = J({
    compatConfig: {
      MODE: 3
    },
    name: "NotificationWrapper",
    setup(b, y) {
      let {
        attrs: S
      } = y;
      const w = K(), C = T(() => Vt.getPrefixCls(r, l)), [, $] = d(C);
      return ze(() => {
        n({
          notice(O) {
            var x;
            (x = w.value) === null || x === void 0 || x.add(O);
          },
          removeNotice(O) {
            var x;
            (x = w.value) === null || x === void 0 || x.remove(O);
          },
          destroy() {
            hr(null, p), p.parentNode && p.parentNode.removeChild(p);
          },
          component: w
        });
      }), () => {
        const O = Vt, x = O.getRootPrefixCls(u, C.value), M = c ? s : `${C.value}-${s}`;
        return m(nC, L(L({}, O), {}, {
          prefixCls: x
        }), {
          default: () => [m(Zl, L(L({
            ref: w
          }, S), {}, {
            prefixCls: C.value,
            transitionName: M,
            hashId: $.value
          }), null)]
        });
      };
    }
  }), g = m(v, f);
  g.appContext = i || g.appContext, hr(g, p);
};
let Yg = 0;
const VB = Date.now();
function Xg() {
  const e = Yg;
  return Yg += 1, `rcNotification_${VB}_${e}`;
}
const WB = J({
  name: "HookNotification",
  inheritAttrs: !1,
  props: ["prefixCls", "transitionName", "animation", "maxCount", "closeIcon", "hashId", "remove", "notices", "getStyles", "getClassName", "onAllRemoved", "getContainer"],
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const r = /* @__PURE__ */ new Map(), a = T(() => e.notices), i = T(() => {
      let c = e.transitionName;
      if (!c && e.animation)
        switch (typeof e.animation) {
          case "string":
            c = e.animation;
            break;
          case "function":
            c = e.animation().name;
            break;
          case "object":
            c = e.animation.name;
            break;
          default:
            c = `${e.prefixCls}-fade`;
            break;
        }
      return bs(c);
    }), l = (c) => e.remove(c), u = G({});
    le(a, () => {
      const c = {};
      Object.keys(u.value).forEach((d) => {
        c[d] = [];
      }), e.notices.forEach((d) => {
        const {
          placement: f = "topRight"
        } = d.notice;
        f && (c[f] = c[f] || [], c[f].push(d));
      }), u.value = c;
    });
    const s = T(() => Object.keys(u.value));
    return () => {
      var c;
      const {
        prefixCls: d,
        closeIcon: f = (c = o.closeIcon) === null || c === void 0 ? void 0 : c.call(o, {
          prefixCls: d
        })
      } = e, p = s.value.map((v) => {
        var g, b;
        const y = u.value[v], S = (g = e.getClassName) === null || g === void 0 ? void 0 : g.call(e, v), w = (b = e.getStyles) === null || b === void 0 ? void 0 : b.call(e, v), C = y.map((x, M) => {
          let {
            notice: _,
            holderCallback: N
          } = x;
          const I = M === a.value.length - 1 ? _.updateMark : void 0, {
            key: E,
            userPassKey: B
          } = _, {
            content: k
          } = _, P = h(h(h({
            prefixCls: d,
            closeIcon: typeof f == "function" ? f({
              prefixCls: d
            }) : f
          }, _), _.props), {
            key: E,
            noticeKey: B || E,
            updateMark: I,
            onClose: (R) => {
              var D;
              l(R), (D = _.onClose) === null || D === void 0 || D.call(_);
            },
            onClick: _.onClick
          });
          return N ? m("div", {
            key: E,
            class: `${d}-hook-holder`,
            ref: (R) => {
              typeof E > "u" || (R ? (r.set(E, R), N(R, P)) : r.delete(E));
            }
          }, null) : m(js, L(L({}, P), {}, {
            class: ae(P.class, e.hashId)
          }), {
            default: () => [typeof k == "function" ? k({
              prefixCls: d
            }) : k]
          });
        }), $ = {
          [d]: 1,
          [`${d}-${v}`]: 1,
          [n.class]: !!n.class,
          [e.hashId]: !0,
          [S]: !!S
        };
        function O() {
          var x;
          y.length > 0 || (Reflect.deleteProperty(u.value, v), (x = e.onAllRemoved) === null || x === void 0 || x.call(e));
        }
        return m("div", {
          key: v,
          class: $,
          style: n.style || w || {
            top: "65px",
            left: "50%"
          }
        }, [m(ns, L(L({
          tag: "div"
        }, i.value), {}, {
          onAfterLeave: O
        }), {
          default: () => [C]
        })]);
      });
      return m(qy, {
        getContainer: e.getContainer
      }, {
        default: () => [p]
      });
    };
  }
}), KB = WB;
var UB = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const GB = () => document.body;
let qg = 0;
function YB() {
  const e = {};
  for (var t = arguments.length, n = new Array(t), o = 0; o < t; o++)
    n[o] = arguments[o];
  return n.forEach((r) => {
    r && Object.keys(r).forEach((a) => {
      const i = r[a];
      i !== void 0 && (e[a] = i);
    });
  }), e;
}
function N$() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    getContainer: t = GB,
    motion: n,
    prefixCls: o,
    maxCount: r,
    getClassName: a,
    getStyles: i,
    onAllRemoved: l
  } = e, u = UB(e, ["getContainer", "motion", "prefixCls", "maxCount", "getClassName", "getStyles", "onAllRemoved"]), s = K([]), c = K(), d = (y, S) => {
    const w = y.key || Xg(), C = h(h({}, y), {
      key: w
    }), $ = s.value.map((x) => x.notice.key).indexOf(w), O = s.value.concat();
    $ !== -1 ? O.splice($, 1, {
      notice: C,
      holderCallback: S
    }) : (r && s.value.length >= r && (C.key = O[0].notice.key, C.updateMark = Xg(), C.userPassKey = w, O.shift()), O.push({
      notice: C,
      holderCallback: S
    })), s.value = O;
  }, f = (y) => {
    s.value = s.value.filter((S) => {
      let {
        notice: {
          key: w,
          userPassKey: C
        }
      } = S;
      return (C || w) !== y;
    });
  }, p = () => {
    s.value = [];
  }, v = () => m(KB, {
    ref: c,
    prefixCls: o,
    maxCount: r,
    notices: s.value,
    remove: f,
    getClassName: a,
    getStyles: i,
    animation: n,
    hashId: e.hashId,
    onAllRemoved: l,
    getContainer: t
  }, null), g = K([]), b = {
    open: (y) => {
      const S = YB(u, y);
      (S.key === null || S.key === void 0) && (S.key = `vc-notification-${qg}`, qg += 1), g.value = [...g.value, {
        type: "open",
        config: S
      }];
    },
    close: (y) => {
      g.value = [...g.value, {
        type: "close",
        key: y
      }];
    },
    destroy: () => {
      g.value = [...g.value, {
        type: "destroy"
      }];
    }
  };
  return le(g, () => {
    g.value.length && (g.value.forEach((y) => {
      switch (y.type) {
        case "open":
          d(y.config);
          break;
        case "close":
          f(y.key);
          break;
        case "destroy":
          p();
          break;
      }
    }), g.value = []);
  }), [b, v];
}
const XB = (e) => {
  const {
    componentCls: t,
    iconCls: n,
    boxShadowSecondary: o,
    colorBgElevated: r,
    colorSuccess: a,
    colorError: i,
    colorWarning: l,
    colorInfo: u,
    fontSizeLG: s,
    motionEaseInOutCirc: c,
    motionDurationSlow: d,
    marginXS: f,
    paddingXS: p,
    borderRadiusLG: v,
    zIndexPopup: g,
    // Custom token
    messageNoticeContentPadding: b
  } = e, y = new Xe("MessageMoveIn", {
    "0%": {
      padding: 0,
      transform: "translateY(-100%)",
      opacity: 0
    },
    "100%": {
      padding: p,
      transform: "translateY(0)",
      opacity: 1
    }
  }), S = new Xe("MessageMoveOut", {
    "0%": {
      maxHeight: e.height,
      padding: p,
      opacity: 1
    },
    "100%": {
      maxHeight: 0,
      padding: 0,
      opacity: 0
    }
  });
  return [
    // ============================ Holder ============================
    {
      [t]: h(h({}, st(e)), {
        position: "fixed",
        top: f,
        left: "50%",
        transform: "translateX(-50%)",
        width: "100%",
        pointerEvents: "none",
        zIndex: g,
        [`${t}-move-up`]: {
          animationFillMode: "forwards"
        },
        [`
        ${t}-move-up-appear,
        ${t}-move-up-enter
      `]: {
          animationName: y,
          animationDuration: d,
          animationPlayState: "paused",
          animationTimingFunction: c
        },
        [`
        ${t}-move-up-appear${t}-move-up-appear-active,
        ${t}-move-up-enter${t}-move-up-enter-active
      `]: {
          animationPlayState: "running"
        },
        [`${t}-move-up-leave`]: {
          animationName: S,
          animationDuration: d,
          animationPlayState: "paused",
          animationTimingFunction: c
        },
        [`${t}-move-up-leave${t}-move-up-leave-active`]: {
          animationPlayState: "running"
        },
        "&-rtl": {
          direction: "rtl",
          span: {
            direction: "rtl"
          }
        }
      })
    },
    // ============================ Notice ============================
    {
      [`${t}-notice`]: {
        padding: p,
        textAlign: "center",
        [n]: {
          verticalAlign: "text-bottom",
          marginInlineEnd: f,
          fontSize: s
        },
        [`${t}-notice-content`]: {
          display: "inline-block",
          padding: b,
          background: r,
          borderRadius: v,
          boxShadow: o,
          pointerEvents: "all"
        },
        [`${t}-success ${n}`]: {
          color: a
        },
        [`${t}-error ${n}`]: {
          color: i
        },
        [`${t}-warning ${n}`]: {
          color: l
        },
        [`
        ${t}-info ${n},
        ${t}-loading ${n}`]: {
          color: u
        }
      }
    },
    // ============================= Pure =============================
    {
      [`${t}-notice-pure-panel`]: {
        padding: 0,
        textAlign: "start"
      }
    }
  ];
}, sp = ht("Message", (e) => {
  const t = qe(e, {
    messageNoticeContentPadding: `${(e.controlHeightLG - e.fontSize * e.lineHeight) / 2}px ${e.paddingSM}px`
  });
  return [XB(t)];
}, (e) => ({
  height: 150,
  zIndexPopup: e.zIndexPopupBase + 10
})), qB = {
  info: m(Ar, null, null),
  success: m(Io, null, null),
  error: m(vn, null, null),
  warning: m(Qo, null, null),
  loading: m(pn, null, null)
}, R$ = J({
  name: "PureContent",
  inheritAttrs: !1,
  props: ["prefixCls", "type", "icon"],
  setup(e, t) {
    let {
      slots: n
    } = t;
    return () => {
      var o;
      return m("div", {
        class: ae(`${e.prefixCls}-custom-content`, `${e.prefixCls}-${e.type}`)
      }, [e.icon || qB[e.type], m("span", null, [(o = n.default) === null || o === void 0 ? void 0 : o.call(n)])]);
    };
  }
});
J({
  name: "PurePanel",
  inheritAttrs: !1,
  props: ["prefixCls", "class", "type", "icon", "content"],
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    var r;
    const {
      getPrefixCls: a
    } = rs(), i = T(() => e.prefixCls || a("message")), [, l] = sp(i);
    return m(js, L(L({}, o), {}, {
      prefixCls: i.value,
      class: ae(l.value, `${i.value}-notice-pure-panel`),
      noticeKey: "pure",
      duration: null
    }), {
      default: () => [m(R$, {
        prefixCls: i.value,
        type: e.type,
        icon: e.icon
      }, {
        default: () => [(r = n.default) === null || r === void 0 ? void 0 : r.call(n)]
      })]
    });
  }
});
var QB = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const ZB = 8, JB = 3, e6 = J({
  name: "Holder",
  inheritAttrs: !1,
  props: ["top", "prefixCls", "getContainer", "maxCount", "duration", "rtl", "transitionName", "onAllRemoved"],
  setup(e, t) {
    let {
      expose: n
    } = t;
    var o, r;
    const {
      getPrefixCls: a,
      getPopupContainer: i
    } = Ke("message", e), l = T(() => a("message", e.prefixCls)), [, u] = sp(l), s = () => {
      var g;
      const b = (g = e.top) !== null && g !== void 0 ? g : ZB;
      return {
        left: "50%",
        transform: "translateX(-50%)",
        top: typeof b == "number" ? `${b}px` : b
      };
    }, c = () => ae(u.value, e.rtl ? `${l.value}-rtl` : ""), d = () => {
      var g;
      return Ad({
        prefixCls: l.value,
        animation: (g = e.animation) !== null && g !== void 0 ? g : "move-up",
        transitionName: e.transitionName
      });
    }, f = m("span", {
      class: `${l.value}-close-x`
    }, [m(Qn, {
      class: `${l.value}-close-icon`
    }, null)]), [p, v] = N$({
      //@ts-ignore
      getStyles: s,
      prefixCls: l.value,
      getClassName: c,
      motion: d,
      closable: !1,
      closeIcon: f,
      duration: (o = e.duration) !== null && o !== void 0 ? o : JB,
      getContainer: (r = e.staticGetContainer) !== null && r !== void 0 ? r : i.value,
      maxCount: e.maxCount,
      onAllRemoved: e.onAllRemoved
    });
    return n(h(h({}, p), {
      prefixCls: l,
      hashId: u
    })), v;
  }
});
let Qg = 0;
function t6(e) {
  const t = K(null), n = Symbol("messageHolderKey"), o = (u) => {
    var s;
    (s = t.value) === null || s === void 0 || s.close(u);
  }, r = (u) => {
    if (!t.value) {
      const $ = () => {
      };
      return $.then = () => {
      }, $;
    }
    const {
      open: s,
      prefixCls: c,
      hashId: d
    } = t.value, f = `${c}-notice`, {
      content: p,
      icon: v,
      type: g,
      key: b,
      class: y,
      onClose: S
    } = u, w = QB(u, ["content", "icon", "type", "key", "class", "onClose"]);
    let C = b;
    return C == null && (Qg += 1, C = `antd-message-${Qg}`), Aw(($) => (s(h(h({}, w), {
      key: C,
      content: () => m(R$, {
        prefixCls: c,
        type: g,
        icon: typeof v == "function" ? v() : v
      }, {
        default: () => [typeof p == "function" ? p() : p]
      }),
      placement: "top",
      // @ts-ignore
      class: ae(g && `${f}-${g}`, d, y),
      onClose: () => {
        S == null || S(), $();
      }
    })), () => {
      o(C);
    }));
  }, i = {
    open: r,
    destroy: (u) => {
      var s;
      u !== void 0 ? o(u) : (s = t.value) === null || s === void 0 || s.destroy();
    }
  };
  return ["info", "success", "warning", "error", "loading"].forEach((u) => {
    const s = (c, d, f) => {
      let p;
      c && typeof c == "object" && "content" in c ? p = c : p = {
        content: c
      };
      let v, g;
      typeof d == "function" ? g = d : (v = d, g = f);
      const b = h(h({
        onClose: g,
        duration: v
      }, p), {
        type: u
      });
      return r(b);
    };
    i[u] = s;
  }), [i, () => m(e6, L(L({
    key: n
  }, e), {}, {
    ref: t
  }), null)];
}
function n6(e) {
  return t6(e);
}
let F$ = 3, B$, tn, o6 = 1, k$ = "", L$ = "move-up", H$ = !1, z$ = () => document.body, j$, V$ = !1;
function r6() {
  return o6++;
}
function a6(e) {
  e.top !== void 0 && (B$ = e.top, tn = null), e.duration !== void 0 && (F$ = e.duration), e.prefixCls !== void 0 && (k$ = e.prefixCls), e.getContainer !== void 0 && (z$ = e.getContainer, tn = null), e.transitionName !== void 0 && (L$ = e.transitionName, tn = null, H$ = !0), e.maxCount !== void 0 && (j$ = e.maxCount, tn = null), e.rtl !== void 0 && (V$ = e.rtl);
}
function i6(e, t) {
  if (tn) {
    t(tn);
    return;
  }
  Zl.newInstance({
    appContext: e.appContext,
    prefixCls: e.prefixCls || k$,
    rootPrefixCls: e.rootPrefixCls,
    transitionName: L$,
    hasTransitionName: H$,
    style: {
      top: B$
    },
    getContainer: z$ || e.getPopupContainer,
    maxCount: j$,
    name: "message",
    useStyle: sp
  }, (n) => {
    if (tn) {
      t(tn);
      return;
    }
    tn = n, t(n);
  });
}
const W$ = {
  info: Ar,
  success: Io,
  error: vn,
  warning: Qo,
  loading: pn
}, l6 = Object.keys(W$);
function s6(e) {
  const t = e.duration !== void 0 ? e.duration : F$, n = e.key || r6(), o = new Promise((a) => {
    const i = () => (typeof e.onClose == "function" && e.onClose(), a(!0));
    i6(e, (l) => {
      l.notice({
        key: n,
        duration: t,
        style: e.style || {},
        class: e.class,
        content: (u) => {
          let {
            prefixCls: s
          } = u;
          const c = W$[e.type], d = c ? m(c, null, null) : "", f = ae(`${s}-custom-content`, {
            [`${s}-${e.type}`]: e.type,
            [`${s}-rtl`]: V$ === !0
          });
          return m("div", {
            class: f
          }, [typeof e.icon == "function" ? e.icon() : e.icon || d, m("span", null, [typeof e.content == "function" ? e.content() : e.content])]);
        },
        onClose: i,
        onClick: e.onClick
      });
    });
  }), r = () => {
    tn && tn.removeNotice(n);
  };
  return r.then = (a, i) => o.then(a, i), r.promise = o, r;
}
function u6(e) {
  return Object.prototype.toString.call(e) === "[object Object]" && !!e.content;
}
const bo = {
  open: s6,
  config: a6,
  destroy(e) {
    if (tn)
      if (e) {
        const {
          removeNotice: t
        } = tn;
        t(e);
      } else {
        const {
          destroy: t
        } = tn;
        t(), tn = null;
      }
  }
};
function c6(e, t) {
  e[t] = (n, o, r) => u6(n) ? e.open(h(h({}, n), {
    type: t
  })) : (typeof o == "function" && (r = o, o = void 0), e.open({
    content: n,
    duration: o,
    type: t,
    onClose: r
  }));
}
l6.forEach((e) => c6(bo, e));
bo.warn = bo.warning;
bo.useMessage = n6;
const d6 = (e) => {
  const {
    componentCls: t,
    width: n,
    notificationMarginEdge: o
  } = e, r = new Xe("antNotificationTopFadeIn", {
    "0%": {
      marginTop: "-100%",
      opacity: 0
    },
    "100%": {
      marginTop: 0,
      opacity: 1
    }
  }), a = new Xe("antNotificationBottomFadeIn", {
    "0%": {
      marginBottom: "-100%",
      opacity: 0
    },
    "100%": {
      marginBottom: 0,
      opacity: 1
    }
  }), i = new Xe("antNotificationLeftFadeIn", {
    "0%": {
      right: {
        _skip_check_: !0,
        value: n
      },
      opacity: 0
    },
    "100%": {
      right: {
        _skip_check_: !0,
        value: 0
      },
      opacity: 1
    }
  });
  return {
    [`&${t}-top, &${t}-bottom`]: {
      marginInline: 0
    },
    [`&${t}-top`]: {
      [`${t}-fade-enter${t}-fade-enter-active, ${t}-fade-appear${t}-fade-appear-active`]: {
        animationName: r
      }
    },
    [`&${t}-bottom`]: {
      [`${t}-fade-enter${t}-fade-enter-active, ${t}-fade-appear${t}-fade-appear-active`]: {
        animationName: a
      }
    },
    [`&${t}-topLeft, &${t}-bottomLeft`]: {
      marginInlineEnd: 0,
      marginInlineStart: o,
      [`${t}-fade-enter${t}-fade-enter-active, ${t}-fade-appear${t}-fade-appear-active`]: {
        animationName: i
      }
    }
  };
}, f6 = (e) => {
  const {
    iconCls: t,
    componentCls: n,
    // .ant-notification
    boxShadowSecondary: o,
    fontSizeLG: r,
    notificationMarginBottom: a,
    borderRadiusLG: i,
    colorSuccess: l,
    colorInfo: u,
    colorWarning: s,
    colorError: c,
    colorTextHeading: d,
    notificationBg: f,
    notificationPadding: p,
    notificationMarginEdge: v,
    motionDurationMid: g,
    motionEaseInOut: b,
    fontSize: y,
    lineHeight: S,
    width: w,
    notificationIconSize: C
  } = e, $ = `${n}-notice`, O = new Xe("antNotificationFadeIn", {
    "0%": {
      left: {
        _skip_check_: !0,
        value: w
      },
      opacity: 0
    },
    "100%": {
      left: {
        _skip_check_: !0,
        value: 0
      },
      opacity: 1
    }
  }), x = new Xe("antNotificationFadeOut", {
    "0%": {
      maxHeight: e.animationMaxHeight,
      marginBottom: a,
      opacity: 1
    },
    "100%": {
      maxHeight: 0,
      marginBottom: 0,
      paddingTop: 0,
      paddingBottom: 0,
      opacity: 0
    }
  });
  return [
    // ============================ Holder ============================
    {
      [n]: h(h(h(h({}, st(e)), {
        position: "fixed",
        zIndex: e.zIndexPopup,
        marginInlineEnd: v,
        [`${n}-hook-holder`]: {
          position: "relative"
        },
        [`&${n}-top, &${n}-bottom`]: {
          [`${n}-notice`]: {
            marginInline: "auto auto"
          }
        },
        [`&${n}-topLeft, &${n}-bottomLeft`]: {
          [`${n}-notice`]: {
            marginInlineEnd: "auto",
            marginInlineStart: 0
          }
        },
        //  animation
        [`${n}-fade-enter, ${n}-fade-appear`]: {
          animationDuration: e.motionDurationMid,
          animationTimingFunction: b,
          animationFillMode: "both",
          opacity: 0,
          animationPlayState: "paused"
        },
        [`${n}-fade-leave`]: {
          animationTimingFunction: b,
          animationFillMode: "both",
          animationDuration: g,
          animationPlayState: "paused"
        },
        [`${n}-fade-enter${n}-fade-enter-active, ${n}-fade-appear${n}-fade-appear-active`]: {
          animationName: O,
          animationPlayState: "running"
        },
        [`${n}-fade-leave${n}-fade-leave-active`]: {
          animationName: x,
          animationPlayState: "running"
        }
      }), d6(e)), {
        // RTL
        "&-rtl": {
          direction: "rtl",
          [`${n}-notice-btn`]: {
            float: "left"
          }
        }
      })
    },
    // ============================ Notice ============================
    {
      [$]: {
        position: "relative",
        width: w,
        maxWidth: `calc(100vw - ${v * 2}px)`,
        marginBottom: a,
        marginInlineStart: "auto",
        padding: p,
        overflow: "hidden",
        lineHeight: S,
        wordWrap: "break-word",
        background: f,
        borderRadius: i,
        boxShadow: o,
        [`${n}-close-icon`]: {
          fontSize: y,
          cursor: "pointer"
        },
        [`${$}-message`]: {
          marginBottom: e.marginXS,
          color: d,
          fontSize: r,
          lineHeight: e.lineHeightLG
        },
        [`${$}-description`]: {
          fontSize: y
        },
        [`&${$}-closable ${$}-message`]: {
          paddingInlineEnd: e.paddingLG
        },
        [`${$}-with-icon ${$}-message`]: {
          marginBottom: e.marginXS,
          marginInlineStart: e.marginSM + C,
          fontSize: r
        },
        [`${$}-with-icon ${$}-description`]: {
          marginInlineStart: e.marginSM + C,
          fontSize: y
        },
        // Icon & color style in different selector level
        // https://github.com/ant-design/ant-design/issues/16503
        // https://github.com/ant-design/ant-design/issues/15512
        [`${$}-icon`]: {
          position: "absolute",
          fontSize: C,
          lineHeight: 0,
          // icon-font
          [`&-success${t}`]: {
            color: l
          },
          [`&-info${t}`]: {
            color: u
          },
          [`&-warning${t}`]: {
            color: s
          },
          [`&-error${t}`]: {
            color: c
          }
        },
        [`${$}-close`]: {
          position: "absolute",
          top: e.notificationPaddingVertical,
          insetInlineEnd: e.notificationPaddingHorizontal,
          color: e.colorIcon,
          outline: "none",
          width: e.notificationCloseButtonSize,
          height: e.notificationCloseButtonSize,
          borderRadius: e.borderRadiusSM,
          transition: `background-color ${e.motionDurationMid}, color ${e.motionDurationMid}`,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          "&:hover": {
            color: e.colorIconHover,
            backgroundColor: e.wireframe ? "transparent" : e.colorFillContent
          }
        },
        [`${$}-btn`]: {
          float: "right",
          marginTop: e.marginSM
        }
      }
    },
    // ============================= Pure =============================
    {
      [`${$}-pure-panel`]: {
        margin: 0
      }
    }
  ];
}, up = ht("Notification", (e) => {
  const t = e.paddingMD, n = e.paddingLG, o = qe(e, {
    // default.less variables
    notificationBg: e.colorBgElevated,
    notificationPaddingVertical: t,
    notificationPaddingHorizontal: n,
    // index.less variables
    notificationPadding: `${e.paddingMD}px ${e.paddingContentHorizontalLG}px`,
    notificationMarginBottom: e.margin,
    notificationMarginEdge: e.marginLG,
    animationMaxHeight: 150,
    notificationIconSize: e.fontSizeLG * e.lineHeightLG,
    notificationCloseButtonSize: e.controlHeightLG * 0.55
  });
  return [f6(o)];
}, (e) => ({
  zIndexPopup: e.zIndexPopupBase + 50,
  width: 384
}));
function K$(e, t) {
  return t || m("span", {
    class: `${e}-close-x`
  }, [m(Qn, {
    class: `${e}-close-icon`
  }, null)]);
}
m(Ar, null, null), m(Io, null, null), m(vn, null, null), m(Qo, null, null), m(pn, null, null);
const p6 = {
  success: Io,
  info: Ar,
  error: vn,
  warning: Qo
};
function U$(e) {
  let {
    prefixCls: t,
    icon: n,
    type: o,
    message: r,
    description: a,
    btn: i
  } = e, l = null;
  if (n)
    l = m("span", {
      class: `${t}-icon`
    }, [Gr(n)]);
  else if (o) {
    const u = p6[o];
    l = m(u, {
      class: `${t}-icon ${t}-icon-${o}`
    }, null);
  }
  return m("div", {
    class: ae({
      [`${t}-with-icon`]: l
    }),
    role: "alert"
  }, [l, m("div", {
    class: `${t}-message`
  }, [r]), m("div", {
    class: `${t}-description`
  }, [a]), i && m("div", {
    class: `${t}-btn`
  }, [i])]);
}
J({
  name: "PurePanel",
  inheritAttrs: !1,
  props: ["prefixCls", "icon", "type", "message", "description", "btn", "closeIcon"],
  setup(e) {
    const {
      getPrefixCls: t
    } = Ke("notification", e), n = T(() => e.prefixCls || t("notification")), o = T(() => `${n.value}-notice`), [, r] = up(n);
    return () => m(js, L(L({}, e), {}, {
      prefixCls: n.value,
      class: ae(r.value, `${o.value}-pure-panel`),
      noticeKey: "pure",
      duration: null,
      closable: e.closable,
      closeIcon: K$(n.value, e.closeIcon)
    }), {
      default: () => [m(U$, {
        prefixCls: o.value,
        icon: e.icon,
        type: e.type,
        message: e.message,
        description: e.description,
        btn: e.btn
      }, null)]
    });
  }
});
function G$(e, t, n) {
  let o;
  switch (t = typeof t == "number" ? `${t}px` : t, n = typeof n == "number" ? `${n}px` : n, e) {
    case "top":
      o = {
        left: "50%",
        transform: "translateX(-50%)",
        right: "auto",
        top: t,
        bottom: "auto"
      };
      break;
    case "topLeft":
      o = {
        left: 0,
        top: t,
        bottom: "auto"
      };
      break;
    case "topRight":
      o = {
        right: 0,
        top: t,
        bottom: "auto"
      };
      break;
    case "bottom":
      o = {
        left: "50%",
        transform: "translateX(-50%)",
        right: "auto",
        top: "auto",
        bottom: n
      };
      break;
    case "bottomLeft":
      o = {
        left: 0,
        top: "auto",
        bottom: n
      };
      break;
    default:
      o = {
        right: 0,
        top: "auto",
        bottom: n
      };
      break;
  }
  return o;
}
function v6(e) {
  return {
    name: `${e}-fade`
  };
}
var m6 = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const Zg = 24, g6 = 4.5, h6 = J({
  name: "Holder",
  inheritAttrs: !1,
  props: ["prefixCls", "class", "type", "icon", "content", "onAllRemoved"],
  setup(e, t) {
    let {
      expose: n
    } = t;
    const {
      getPrefixCls: o,
      getPopupContainer: r
    } = Ke("notification", e), a = T(() => e.prefixCls || o("notification")), i = (f) => {
      var p, v;
      return G$(f, (p = e.top) !== null && p !== void 0 ? p : Zg, (v = e.bottom) !== null && v !== void 0 ? v : Zg);
    }, [, l] = up(a), u = () => ae(l.value, {
      [`${a.value}-rtl`]: e.rtl
    }), s = () => v6(a.value), [c, d] = N$({
      prefixCls: a.value,
      getStyles: i,
      getClassName: u,
      motion: s,
      closable: !0,
      closeIcon: K$(a.value),
      duration: g6,
      getContainer: () => {
        var f, p;
        return ((f = e.getPopupContainer) === null || f === void 0 ? void 0 : f.call(e)) || ((p = r.value) === null || p === void 0 ? void 0 : p.call(r)) || document.body;
      },
      maxCount: e.maxCount,
      hashId: l.value,
      onAllRemoved: e.onAllRemoved
    });
    return n(h(h({}, c), {
      prefixCls: a.value,
      hashId: l
    })), d;
  }
});
function b6(e) {
  const t = K(null), n = Symbol("notificationHolderKey"), o = (l) => {
    if (!t.value)
      return;
    const {
      open: u,
      prefixCls: s,
      hashId: c
    } = t.value, d = `${s}-notice`, {
      message: f,
      description: p,
      icon: v,
      type: g,
      btn: b,
      class: y
    } = l, S = m6(l, ["message", "description", "icon", "type", "btn", "class"]);
    return u(h(h({
      placement: "topRight"
    }, S), {
      content: () => m(U$, {
        prefixCls: d,
        icon: typeof v == "function" ? v() : v,
        type: g,
        message: typeof f == "function" ? f() : f,
        description: typeof p == "function" ? p() : p,
        btn: typeof b == "function" ? b() : b
      }, null),
      // @ts-ignore
      class: ae(g && `${d}-${g}`, c, y)
    }));
  }, a = {
    open: o,
    destroy: (l) => {
      var u, s;
      l !== void 0 ? (u = t.value) === null || u === void 0 || u.close(l) : (s = t.value) === null || s === void 0 || s.destroy();
    }
  };
  return ["success", "info", "warning", "error"].forEach((l) => {
    a[l] = (u) => o(h(h({}, u), {
      type: l
    }));
  }), [a, () => m(h6, L(L({
    key: n
  }, e), {}, {
    ref: t
  }), null)];
}
function y6(e) {
  return b6(e);
}
const lr = {};
let Y$ = 4.5, X$ = "24px", q$ = "24px", rd = "", Q$ = "topRight", Z$ = () => document.body, J$ = null, ad = !1, eC;
function S6(e) {
  const {
    duration: t,
    placement: n,
    bottom: o,
    top: r,
    getContainer: a,
    closeIcon: i,
    prefixCls: l
  } = e;
  l !== void 0 && (rd = l), t !== void 0 && (Y$ = t), n !== void 0 && (Q$ = n), o !== void 0 && (q$ = typeof o == "number" ? `${o}px` : o), r !== void 0 && (X$ = typeof r == "number" ? `${r}px` : r), a !== void 0 && (Z$ = a), i !== void 0 && (J$ = i), e.rtl !== void 0 && (ad = e.rtl), e.maxCount !== void 0 && (eC = e.maxCount);
}
function $6(e, t) {
  let {
    prefixCls: n,
    placement: o = Q$,
    getContainer: r = Z$,
    top: a,
    bottom: i,
    closeIcon: l = J$,
    appContext: u
  } = e;
  const {
    getPrefixCls: s
  } = A6(), c = s("notification", n || rd), d = `${c}-${o}-${ad}`, f = lr[d];
  if (f) {
    Promise.resolve(f).then((v) => {
      t(v);
    });
    return;
  }
  const p = ae(`${c}-${o}`, {
    [`${c}-rtl`]: ad === !0
  });
  Zl.newInstance({
    name: "notification",
    prefixCls: n || rd,
    useStyle: up,
    class: p,
    style: G$(o, a ?? X$, i ?? q$),
    appContext: u,
    getContainer: r,
    closeIcon: (v) => {
      let {
        prefixCls: g
      } = v;
      return m("span", {
        class: `${g}-close-x`
      }, [Gr(l, {}, m(Qn, {
        class: `${g}-close-icon`
      }, null))]);
    },
    maxCount: eC,
    hasTransitionName: !0
  }, (v) => {
    lr[d] = v, t(v);
  });
}
const C6 = {
  success: Cf,
  info: xf,
  error: Of,
  warning: wf
};
function w6(e) {
  const {
    icon: t,
    type: n,
    description: o,
    message: r,
    btn: a
  } = e, i = e.duration === void 0 ? Y$ : e.duration;
  $6(e, (l) => {
    l.notice({
      content: (u) => {
        let {
          prefixCls: s
        } = u;
        const c = `${s}-notice`;
        let d = null;
        if (t)
          d = () => m("span", {
            class: `${c}-icon`
          }, [Gr(t)]);
        else if (n) {
          const f = C6[n];
          d = () => m(f, {
            class: `${c}-icon ${c}-icon-${n}`
          }, null);
        }
        return m("div", {
          class: d ? `${c}-with-icon` : ""
        }, [d && d(), m("div", {
          class: `${c}-message`
        }, [!o && d ? m("span", {
          class: `${c}-message-single-line-auto-margin`
        }, null) : null, Gr(r)]), m("div", {
          class: `${c}-description`
        }, [Gr(o)]), a ? m("span", {
          class: `${c}-btn`
        }, [Gr(a)]) : null]);
      },
      duration: i,
      closable: !0,
      onClose: e.onClose,
      onClick: e.onClick,
      key: e.key,
      style: e.style || {},
      class: e.class
    });
  });
}
const ga = {
  open: w6,
  close(e) {
    Object.keys(lr).forEach((t) => Promise.resolve(lr[t]).then((n) => {
      n.removeNotice(e);
    }));
  },
  config: S6,
  destroy() {
    Object.keys(lr).forEach((e) => {
      Promise.resolve(lr[e]).then((t) => {
        t.destroy();
      }), delete lr[e];
    });
  }
}, x6 = ["success", "info", "warning", "error"];
x6.forEach((e) => {
  ga[e] = (t) => ga.open(h(h({}, t), {
    type: e
  }));
});
ga.warn = ga.warning;
ga.useNotification = y6;
const O6 = `-ant-${Date.now()}-${Math.random()}`;
function P6(e, t) {
  const n = {}, o = (i, l) => {
    let u = i.clone();
    return u = (l == null ? void 0 : l(u)) || u, u.toRgbString();
  }, r = (i, l) => {
    const u = new Ct(i), s = yr(u.toRgbString());
    n[`${l}-color`] = o(u), n[`${l}-color-disabled`] = s[1], n[`${l}-color-hover`] = s[4], n[`${l}-color-active`] = s[6], n[`${l}-color-outline`] = u.clone().setAlpha(0.2).toRgbString(), n[`${l}-color-deprecated-bg`] = s[0], n[`${l}-color-deprecated-border`] = s[2];
  };
  if (t.primaryColor) {
    r(t.primaryColor, "primary");
    const i = new Ct(t.primaryColor), l = yr(i.toRgbString());
    l.forEach((s, c) => {
      n[`primary-${c + 1}`] = s;
    }), n["primary-color-deprecated-l-35"] = o(i, (s) => s.lighten(35)), n["primary-color-deprecated-l-20"] = o(i, (s) => s.lighten(20)), n["primary-color-deprecated-t-20"] = o(i, (s) => s.tint(20)), n["primary-color-deprecated-t-50"] = o(i, (s) => s.tint(50)), n["primary-color-deprecated-f-12"] = o(i, (s) => s.setAlpha(s.getAlpha() * 0.12));
    const u = new Ct(l[0]);
    n["primary-color-active-deprecated-f-30"] = o(u, (s) => s.setAlpha(s.getAlpha() * 0.3)), n["primary-color-active-deprecated-d-02"] = o(u, (s) => s.darken(2));
  }
  return t.successColor && r(t.successColor, "success"), t.warningColor && r(t.warningColor, "warning"), t.errorColor && r(t.errorColor, "error"), t.infoColor && r(t.infoColor, "info"), `
  :root {
    ${Object.keys(n).map((i) => `--${e}-${i}: ${n[i]};`).join(`
`)}
  }
  `.trim();
}
function I6(e, t) {
  const n = P6(e, t);
  Nn() ? li(n, `${O6}-dynamic-theme`) : Pt(!1, "ConfigProvider", "SSR do not support dynamic theme with css variables.");
}
const T6 = (e) => {
  const [t, n] = ya();
  return gc(T(() => ({
    theme: t.value,
    token: n.value,
    hashId: "",
    path: ["ant-design-icons", e.value]
  })), () => [{
    [`.${e.value}`]: h(h({}, Si()), {
      [`.${e.value} .${e.value}-icon`]: {
        display: "block"
      }
    })
  }]);
};
function E6(e, t) {
  const n = T(() => (e == null ? void 0 : e.value) || {}), o = T(() => n.value.inherit === !1 || !(t != null && t.value) ? iy : t.value);
  return T(() => {
    if (!(e != null && e.value))
      return t == null ? void 0 : t.value;
    const a = h({}, o.value.components);
    return Object.keys(e.value.components || {}).forEach((i) => {
      a[i] = h(h({}, a[i]), e.value.components[i]);
    }), h(h(h({}, o.value), n.value), {
      token: h(h({}, o.value.token), n.value.token),
      components: a
    });
  });
}
var M6 = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const _6 = "ant";
function ra() {
  return Vt.prefixCls || _6;
}
function tC() {
  return Vt.iconPrefixCls || xd;
}
const cp = Et({}), Vt = Et({});
Ve(() => {
  h(Vt, cp), Vt.prefixCls = ra(), Vt.iconPrefixCls = tC(), Vt.getPrefixCls = (e, t) => t || (e ? `${Vt.prefixCls}-${e}` : Vt.prefixCls), Vt.getRootPrefixCls = () => Vt.prefixCls ? Vt.prefixCls : ra();
});
let Ru;
const D6 = (e) => {
  Ru && Ru(), Ru = Ve(() => {
    h(cp, Et(e)), h(Vt, Et(e));
  }), e.theme && I6(ra(), e.theme);
}, A6 = () => ({
  getPrefixCls: (e, t) => t || (e ? `${ra()}-${e}` : ra()),
  getIconPrefixCls: tC,
  getRootPrefixCls: () => Vt.prefixCls ? Vt.prefixCls : ra()
}), Ja = J({
  compatConfig: {
    MODE: 3
  },
  name: "AConfigProvider",
  inheritAttrs: !1,
  props: rx(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = rs(), r = (P, R) => {
      const {
        prefixCls: D = "ant"
      } = e;
      if (R)
        return R;
      const A = D || o.getPrefixCls("");
      return P ? `${A}-${P}` : A;
    }, a = T(() => e.iconPrefixCls || o.iconPrefixCls.value || xd), i = T(() => a.value !== o.iconPrefixCls.value), l = T(() => {
      var P;
      return e.csp || ((P = o.csp) === null || P === void 0 ? void 0 : P.value);
    }), u = T6(a), s = E6(T(() => e.theme), T(() => {
      var P;
      return (P = o.theme) === null || P === void 0 ? void 0 : P.value;
    })), c = (P) => (e.renderEmpty || n.renderEmpty || o.renderEmpty || G1)(P), d = T(() => {
      var P, R;
      return (P = e.autoInsertSpaceInButton) !== null && P !== void 0 ? P : (R = o.autoInsertSpaceInButton) === null || R === void 0 ? void 0 : R.value;
    }), f = T(() => {
      var P;
      return e.locale || ((P = o.locale) === null || P === void 0 ? void 0 : P.value);
    });
    le(f, () => {
      cp.locale = f.value;
    }, {
      immediate: !0
    });
    const p = T(() => {
      var P;
      return e.direction || ((P = o.direction) === null || P === void 0 ? void 0 : P.value);
    }), v = T(() => {
      var P, R;
      return (P = e.space) !== null && P !== void 0 ? P : (R = o.space) === null || R === void 0 ? void 0 : R.value;
    }), g = T(() => {
      var P, R;
      return (P = e.virtual) !== null && P !== void 0 ? P : (R = o.virtual) === null || R === void 0 ? void 0 : R.value;
    }), b = T(() => {
      var P, R;
      return (P = e.dropdownMatchSelectWidth) !== null && P !== void 0 ? P : (R = o.dropdownMatchSelectWidth) === null || R === void 0 ? void 0 : R.value;
    }), y = T(() => {
      var P;
      return e.getTargetContainer !== void 0 ? e.getTargetContainer : (P = o.getTargetContainer) === null || P === void 0 ? void 0 : P.value;
    }), S = T(() => {
      var P;
      return e.getPopupContainer !== void 0 ? e.getPopupContainer : (P = o.getPopupContainer) === null || P === void 0 ? void 0 : P.value;
    }), w = T(() => {
      var P;
      return e.pageHeader !== void 0 ? e.pageHeader : (P = o.pageHeader) === null || P === void 0 ? void 0 : P.value;
    }), C = T(() => {
      var P;
      return e.input !== void 0 ? e.input : (P = o.input) === null || P === void 0 ? void 0 : P.value;
    }), $ = T(() => {
      var P;
      return e.pagination !== void 0 ? e.pagination : (P = o.pagination) === null || P === void 0 ? void 0 : P.value;
    }), O = T(() => {
      var P;
      return e.form !== void 0 ? e.form : (P = o.form) === null || P === void 0 ? void 0 : P.value;
    }), x = T(() => {
      var P;
      return e.select !== void 0 ? e.select : (P = o.select) === null || P === void 0 ? void 0 : P.value;
    }), M = T(() => e.componentSize), _ = T(() => e.componentDisabled), N = T(() => {
      var P, R;
      return (P = e.wave) !== null && P !== void 0 ? P : (R = o.wave) === null || R === void 0 ? void 0 : R.value;
    }), I = {
      csp: l,
      autoInsertSpaceInButton: d,
      locale: f,
      direction: p,
      space: v,
      virtual: g,
      dropdownMatchSelectWidth: b,
      getPrefixCls: r,
      iconPrefixCls: a,
      theme: T(() => {
        var P, R;
        return (P = s.value) !== null && P !== void 0 ? P : (R = o.theme) === null || R === void 0 ? void 0 : R.value;
      }),
      renderEmpty: c,
      getTargetContainer: y,
      getPopupContainer: S,
      pageHeader: w,
      input: C,
      pagination: $,
      form: O,
      select: x,
      componentSize: M,
      componentDisabled: _,
      transformCellText: T(() => e.transformCellText),
      wave: N
    }, E = T(() => {
      const P = s.value || {}, {
        algorithm: R,
        token: D
      } = P, A = M6(P, ["algorithm", "token"]), H = R && (!Array.isArray(R) || R.length > 0) ? zb(R) : void 0;
      return h(h({}, A), {
        theme: H,
        token: h(h({}, us), D)
      });
    }), B = T(() => {
      var P, R;
      let D = {};
      return f.value && (D = ((P = f.value.Form) === null || P === void 0 ? void 0 : P.defaultValidateMessages) || ((R = yo.Form) === null || R === void 0 ? void 0 : R.defaultValidateMessages) || {}), e.form && e.form.validateMessages && (D = h(h({}, D), e.form.validateMessages)), D;
    });
    ax(I), nx({
      validateMessages: B
    }), vy(M), Ib(_);
    const k = (P) => {
      var R, D;
      let A = i.value ? u((R = n.default) === null || R === void 0 ? void 0 : R.call(n)) : (D = n.default) === null || D === void 0 ? void 0 : D.call(n);
      if (e.theme) {
        const H = /* @__PURE__ */ function() {
          return A;
        }();
        A = m(j1, {
          value: E.value
        }, {
          default: () => [H]
        });
      }
      return m(HB, {
        locale: f.value || P,
        ANT_MARK__: od
      }, {
        default: () => [A]
      });
    };
    return Ve(() => {
      p.value && (bo.config({
        rtl: p.value === "rtl"
      }), ga.config({
        rtl: p.value === "rtl"
      }));
    }), () => m(Eb, {
      children: (P, R, D) => k(D)
    }, null);
  }
});
Ja.config = D6;
Ja.install = function(e) {
  e.component(Ja.name, Ja);
};
const nC = Ja, N6 = (e, t) => {
  let {
    attrs: n,
    slots: o
  } = t;
  return m(Zt, L(L({
    size: "small",
    type: "primary"
  }, e), n), o);
}, el = (e, t, n) => {
  const o = Mw(n);
  return {
    [`${e.componentCls}-${t}`]: {
      color: e[`color${n}`],
      background: e[`color${o}Bg`],
      borderColor: e[`color${o}Border`],
      [`&${e.componentCls}-borderless`]: {
        borderColor: "transparent"
      }
    }
  };
}, R6 = (e) => ry(e, (t, n) => {
  let {
    textColor: o,
    lightBorderColor: r,
    lightColor: a,
    darkColor: i
  } = n;
  return {
    [`${e.componentCls}-${t}`]: {
      color: o,
      background: a,
      borderColor: r,
      // Inverse color
      "&-inverse": {
        color: e.colorTextLightSolid,
        background: i,
        borderColor: i
      },
      [`&${e.componentCls}-borderless`]: {
        borderColor: "transparent"
      }
    }
  };
}), F6 = (e) => {
  const {
    paddingXXS: t,
    lineWidth: n,
    tagPaddingHorizontal: o,
    componentCls: r
  } = e, a = o - n, i = t - n;
  return {
    // Result
    [r]: h(h({}, st(e)), {
      display: "inline-block",
      height: "auto",
      marginInlineEnd: e.marginXS,
      paddingInline: a,
      fontSize: e.tagFontSize,
      lineHeight: `${e.tagLineHeight}px`,
      whiteSpace: "nowrap",
      background: e.tagDefaultBg,
      border: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`,
      borderRadius: e.borderRadiusSM,
      opacity: 1,
      transition: `all ${e.motionDurationMid}`,
      textAlign: "start",
      // RTL
      [`&${r}-rtl`]: {
        direction: "rtl"
      },
      "&, a, a:hover": {
        color: e.tagDefaultColor
      },
      [`${r}-close-icon`]: {
        marginInlineStart: i,
        color: e.colorTextDescription,
        fontSize: e.tagIconSize,
        cursor: "pointer",
        transition: `all ${e.motionDurationMid}`,
        "&:hover": {
          color: e.colorTextHeading
        }
      },
      [`&${r}-has-color`]: {
        borderColor: "transparent",
        [`&, a, a:hover, ${e.iconCls}-close, ${e.iconCls}-close:hover`]: {
          color: e.colorTextLightSolid
        }
      },
      "&-checkable": {
        backgroundColor: "transparent",
        borderColor: "transparent",
        cursor: "pointer",
        [`&:not(${r}-checkable-checked):hover`]: {
          color: e.colorPrimary,
          backgroundColor: e.colorFillSecondary
        },
        "&:active, &-checked": {
          color: e.colorTextLightSolid
        },
        "&-checked": {
          backgroundColor: e.colorPrimary,
          "&:hover": {
            backgroundColor: e.colorPrimaryHover
          }
        },
        "&:active": {
          backgroundColor: e.colorPrimaryActive
        }
      },
      "&-hidden": {
        display: "none"
      },
      // To ensure that a space will be placed between character and `Icon`.
      [`> ${e.iconCls} + span, > span + ${e.iconCls}`]: {
        marginInlineStart: a
      }
    }),
    [`${r}-borderless`]: {
      borderColor: "transparent",
      background: e.tagBorderlessBg
    }
  };
}, oC = ht("Tag", (e) => {
  const {
    fontSize: t,
    lineHeight: n,
    lineWidth: o,
    fontSizeIcon: r
  } = e, a = Math.round(t * n), i = e.fontSizeSM, l = a - o * 2, u = e.colorFillAlter, s = e.colorText, c = qe(e, {
    tagFontSize: i,
    tagLineHeight: l,
    tagDefaultBg: u,
    tagDefaultColor: s,
    tagIconSize: r - 2 * o,
    tagPaddingHorizontal: 8,
    tagBorderlessBg: e.colorFillTertiary
  });
  return [F6(c), R6(c), el(c, "success", "Success"), el(c, "processing", "Info"), el(c, "error", "Error"), el(c, "warning", "Warning")];
}), B6 = () => ({
  prefixCls: String,
  checked: {
    type: Boolean,
    default: void 0
  },
  onChange: {
    type: Function
  },
  onClick: {
    type: Function
  },
  "onUpdate:checked": Function
}), id = J({
  compatConfig: {
    MODE: 3
  },
  name: "ACheckableTag",
  inheritAttrs: !1,
  props: B6(),
  // emits: ['update:checked', 'change', 'click'],
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: r
    } = t;
    const {
      prefixCls: a
    } = Ke("tag", e), [i, l] = oC(a), u = (c) => {
      const {
        checked: d
      } = e;
      o("update:checked", !d), o("change", !d), o("click", c);
    }, s = T(() => ae(a.value, l.value, {
      [`${a.value}-checkable`]: !0,
      [`${a.value}-checkable-checked`]: e.checked
    }));
    return () => {
      var c;
      return i(m("span", L(L({}, r), {}, {
        class: [s.value, r.class],
        onClick: u
      }), [(c = n.default) === null || c === void 0 ? void 0 : c.call(n)]));
    };
  }
}), k6 = () => ({
  prefixCls: String,
  color: {
    type: String
  },
  closable: {
    type: Boolean,
    default: !1
  },
  closeIcon: W.any,
  /** @deprecated `visible` will be removed in next major version. */
  visible: {
    type: Boolean,
    default: void 0
  },
  onClose: {
    type: Function
  },
  onClick: ai(),
  "onUpdate:visible": Function,
  icon: W.any,
  bordered: {
    type: Boolean,
    default: !0
  }
}), aa = J({
  compatConfig: {
    MODE: 3
  },
  name: "ATag",
  inheritAttrs: !1,
  props: k6(),
  // emits: ['update:visible', 'close'],
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: r
    } = t;
    const {
      prefixCls: a,
      direction: i
    } = Ke("tag", e), [l, u] = oC(a), s = K(!0);
    process.env.NODE_ENV !== "production" && Pt(e.visible === void 0, "Tag", '`visible` is deprecated, please use `<Tag v-show="visible" />` instead.'), Ve(() => {
      e.visible !== void 0 && (s.value = e.visible);
    });
    const c = (v) => {
      v.stopPropagation(), o("update:visible", !1), o("close", v), !v.defaultPrevented && e.visible === void 0 && (s.value = !1);
    }, d = T(() => q0(e.color) || TN(e.color)), f = T(() => ae(a.value, u.value, {
      [`${a.value}-${e.color}`]: d.value,
      [`${a.value}-has-color`]: e.color && !d.value,
      [`${a.value}-hidden`]: !s.value,
      [`${a.value}-rtl`]: i.value === "rtl",
      [`${a.value}-borderless`]: !e.bordered
    })), p = (v) => {
      o("click", v);
    };
    return () => {
      var v, g, b;
      const {
        icon: y = (v = n.icon) === null || v === void 0 ? void 0 : v.call(n),
        color: S,
        closeIcon: w = (g = n.closeIcon) === null || g === void 0 ? void 0 : g.call(n),
        closable: C = !1
      } = e, $ = () => C ? w ? m("span", {
        class: `${a.value}-close-icon`,
        onClick: c
      }, [w]) : m(Qn, {
        class: `${a.value}-close-icon`,
        onClick: c
      }, null) : null, O = {
        backgroundColor: S && !d.value ? S : void 0
      }, x = y || null, M = (b = n.default) === null || b === void 0 ? void 0 : b.call(n), _ = x ? m(We, null, [x, m("span", null, [M])]) : M, N = e.onClick !== void 0, I = m("span", L(L({}, r), {}, {
        onClick: p,
        class: [f.value, r.class],
        style: [O, r.style]
      }), [_, $()]);
      return l(N ? m(Pf, null, {
        default: () => [I]
      }) : I);
    };
  }
});
aa.CheckableTag = id;
aa.install = function(e) {
  return e.component(aa.name, aa), e.component(id.name, id), e;
};
function L6(e, t) {
  let {
    slots: n,
    attrs: o
  } = t;
  return m(aa, L(L({
    color: "blue"
  }, e), o), n);
}
var H6 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M880 184H712v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H384v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H144c-17.7 0-32 14.3-32 32v664c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V216c0-17.7-14.3-32-32-32zm-40 656H184V460h656v380zM184 392V256h128v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h256v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h128v136H184z" } }] }, name: "calendar", theme: "outlined" };
function Jg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      z6(e, r, n[r]);
    });
  }
  return e;
}
function z6(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Vs = function(t, n) {
  var o = Jg({}, t, n.attrs);
  return m(it, Jg({}, o, {
    icon: H6
  }), null);
};
Vs.displayName = "CalendarOutlined";
Vs.inheritAttrs = !1;
var j6 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { tag: "path", attrs: { d: "M686.7 638.6L544.1 535.5V288c0-4.4-3.6-8-8-8H488c-4.4 0-8 3.6-8 8v275.4c0 2.6 1.2 5 3.3 6.5l165.4 120.6c3.6 2.6 8.6 1.8 11.2-1.7l28.6-39c2.6-3.7 1.8-8.7-1.8-11.2z" } }] }, name: "clock-circle", theme: "outlined" };
function eh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      V6(e, r, n[r]);
    });
  }
  return e;
}
function V6(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Ws = function(t, n) {
  var o = eh({}, t, n.attrs);
  return m(it, eh({}, o, {
    icon: j6
  }), null);
};
Ws.displayName = "ClockCircleOutlined";
Ws.inheritAttrs = !1;
function W6(e, t, n) {
  return n !== void 0 ? n : t === "year" && e.lang.yearPlaceholder ? e.lang.yearPlaceholder : t === "quarter" && e.lang.quarterPlaceholder ? e.lang.quarterPlaceholder : t === "month" && e.lang.monthPlaceholder ? e.lang.monthPlaceholder : t === "week" && e.lang.weekPlaceholder ? e.lang.weekPlaceholder : t === "time" && e.timePickerLocale.placeholder ? e.timePickerLocale.placeholder : e.lang.placeholder;
}
function K6(e, t, n) {
  return n !== void 0 ? n : t === "year" && e.lang.yearPlaceholder ? e.lang.rangeYearPlaceholder : t === "month" && e.lang.monthPlaceholder ? e.lang.rangeMonthPlaceholder : t === "week" && e.lang.weekPlaceholder ? e.lang.rangeWeekPlaceholder : t === "time" && e.timePickerLocale.placeholder ? e.timePickerLocale.rangePlaceholder : e.lang.rangePlaceholder;
}
function rC(e, t) {
  const n = {
    adjustX: 1,
    adjustY: 1
  };
  switch (t) {
    case "bottomLeft":
      return {
        points: ["tl", "bl"],
        offset: [0, 4],
        overflow: n
      };
    case "bottomRight":
      return {
        points: ["tr", "br"],
        offset: [0, 4],
        overflow: n
      };
    case "topLeft":
      return {
        points: ["bl", "tl"],
        offset: [0, -4],
        overflow: n
      };
    case "topRight":
      return {
        points: ["br", "tr"],
        offset: [0, -4],
        overflow: n
      };
    default:
      return {
        points: e === "rtl" ? ["tr", "br"] : ["tl", "bl"],
        offset: [0, 4],
        overflow: n
      };
  }
}
function Jl() {
  return {
    id: String,
    /**
     * @deprecated `dropdownClassName` is deprecated which will be removed in next major
     *   version.Please use `popupClassName` instead.
     */
    dropdownClassName: String,
    popupClassName: String,
    popupStyle: He(),
    transitionName: String,
    placeholder: String,
    allowClear: Me(),
    autofocus: Me(),
    disabled: Me(),
    tabindex: Number,
    open: Me(),
    defaultOpen: Me(),
    /** Make input readOnly to avoid popup keyboard in mobile */
    inputReadOnly: Me(),
    format: dt([String, Function, Array]),
    // Value
    // format:  string | CustomFormat<DateType> | (string | CustomFormat<DateType>)[];
    // Render
    // suffixIcon?: VueNode;
    // clearIcon?: VueNode;
    // prevIcon?: VueNode;
    // nextIcon?: VueNode;
    // superPrevIcon?: VueNode;
    // superNextIcon?: VueNode;
    getPopupContainer: de(),
    panelRender: de(),
    // // Events
    onChange: de(),
    "onUpdate:value": de(),
    onOk: de(),
    onOpenChange: de(),
    "onUpdate:open": de(),
    onFocus: de(),
    onBlur: de(),
    onMousedown: de(),
    onMouseup: de(),
    onMouseenter: de(),
    onMouseleave: de(),
    onClick: de(),
    onContextmenu: de(),
    onKeydown: de(),
    // WAI-ARIA
    role: String,
    name: String,
    autocomplete: String,
    direction: Ze(),
    showToday: Me(),
    showTime: dt([Boolean, Object]),
    locale: He(),
    size: Ze(),
    bordered: Me(),
    dateRender: de(),
    disabledDate: de(),
    mode: Ze(),
    picker: Ze(),
    valueFormat: String,
    placement: Ze(),
    status: Ze(),
    /** @deprecated Please use `disabledTime` instead. */
    disabledHours: de(),
    /** @deprecated Please use `disabledTime` instead. */
    disabledMinutes: de(),
    /** @deprecated Please use `disabledTime` instead. */
    disabledSeconds: de()
  };
}
function aC() {
  return {
    defaultPickerValue: dt([Object, String]),
    defaultValue: dt([Object, String]),
    value: dt([Object, String]),
    presets: Nt(),
    disabledTime: de(),
    renderExtraFooter: de(),
    showNow: Me(),
    monthCellRender: de(),
    // deprecated  Please use `monthCellRender"` instead.',
    monthCellContentRender: de()
  };
}
function iC() {
  return {
    allowEmpty: Nt(),
    dateRender: de(),
    defaultPickerValue: Nt(),
    defaultValue: Nt(),
    value: Nt(),
    presets: Nt(),
    disabledTime: de(),
    disabled: dt([Boolean, Array]),
    renderExtraFooter: de(),
    separator: {
      type: String
    },
    showTime: dt([Boolean, Object]),
    ranges: He(),
    placeholder: Nt(),
    mode: Nt(),
    onChange: de(),
    "onUpdate:value": de(),
    onCalendarChange: de(),
    onPanelChange: de(),
    onOk: de()
  };
}
var U6 = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function G6(e, t) {
  function n(s, c) {
    const d = h(h(h({}, Jl()), aC()), t);
    return J({
      compatConfig: {
        MODE: 3
      },
      name: c,
      inheritAttrs: !1,
      props: d,
      slots: Object,
      setup(f, p) {
        let {
          slots: v,
          expose: g,
          attrs: b,
          emit: y
        } = p;
        const S = f, w = Lt(), C = rn.useInject();
        process.env.NODE_ENV !== "production" && (gt(s !== "quarter", c || "DatePicker", `DatePicker.${c} is legacy usage. Please use DatePicker[picker='${s}'] directly.`), gt(!S.dropdownClassName, c || "DatePicker", "`dropdownClassName` is deprecated. Please use `popupClassName` instead."), gt(!(S.monthCellContentRender || v.monthCellContentRender), c || "DatePicker", '`monthCellContentRender` is deprecated. Please use `monthCellRender"` instead.'), gt(!b.getCalendarContainer, c || "DatePicker", '`getCalendarContainer` is deprecated. Please use `getPopupContainer"` instead.'));
        const {
          prefixCls: $,
          direction: O,
          getPopupContainer: x,
          size: M,
          rootPrefixCls: _,
          disabled: N
        } = Ke("picker", S), {
          compactSize: I,
          compactItemClassnames: E
        } = Dr($, O), B = T(() => I.value || M.value), [k, P] = n$($), R = G();
        g({
          focus: () => {
            var ne;
            (ne = R.value) === null || ne === void 0 || ne.focus();
          },
          blur: () => {
            var ne;
            (ne = R.value) === null || ne === void 0 || ne.blur();
          }
        });
        const D = (ne) => S.valueFormat ? e.toString(ne, S.valueFormat) : ne, A = (ne, Y) => {
          const V = D(ne);
          y("update:value", V), y("change", V, Y), w.onFieldChange();
        }, H = (ne) => {
          y("update:open", ne), y("openChange", ne);
        }, j = (ne) => {
          y("focus", ne);
        }, z = (ne) => {
          y("blur", ne), w.onFieldBlur();
        }, F = (ne, Y) => {
          const V = D(ne);
          y("panelChange", V, Y);
        }, U = (ne) => {
          const Y = D(ne);
          y("ok", Y);
        }, [Q] = Pr("DatePicker", El), q = T(() => S.value ? S.valueFormat ? e.toDate(S.value, S.valueFormat) : S.value : S.value === "" ? void 0 : S.value), oe = T(() => S.defaultValue ? S.valueFormat ? e.toDate(S.defaultValue, S.valueFormat) : S.defaultValue : S.defaultValue === "" ? void 0 : S.defaultValue), Z = T(() => S.defaultPickerValue ? S.valueFormat ? e.toDate(S.defaultPickerValue, S.valueFormat) : S.defaultPickerValue : S.defaultPickerValue === "" ? void 0 : S.defaultPickerValue);
        return () => {
          var ne, Y, V, X, re, ie;
          const he = h(h({}, Q.value), S.locale), ge = h(h({}, S), b), {
            bordered: we = !0,
            placeholder: Le,
            suffixIcon: be = (ne = v.suffixIcon) === null || ne === void 0 ? void 0 : ne.call(v),
            showToday: pe = !0,
            transitionName: xe,
            allowClear: Ne = !0,
            dateRender: ye = v.dateRender,
            renderExtraFooter: Ce = v.renderExtraFooter,
            monthCellRender: Te = v.monthCellRender || S.monthCellContentRender || v.monthCellContentRender,
            clearIcon: te = (Y = v.clearIcon) === null || Y === void 0 ? void 0 : Y.call(v),
            id: se = w.id.value
          } = ge, Pe = U6(ge, ["bordered", "placeholder", "suffixIcon", "showToday", "transitionName", "allowClear", "dateRender", "renderExtraFooter", "monthCellRender", "clearIcon", "id"]), _e = ge.showTime === "" ? !0 : ge.showTime, {
            format: Ee
          } = ge;
          let Be = {};
          s && (Be.picker = s);
          const ue = s || ge.picker || "date";
          Be = h(h(h({}, Be), _e ? es(h({
            format: Ee,
            picker: ue
          }, typeof _e == "object" ? _e : {})) : {}), ue === "time" ? es(h(h({
            format: Ee
          }, Pe), {
            picker: ue
          })) : {});
          const fe = $.value, ve = m(We, null, [be || (s === "time" ? m(Ws, null, null) : m(Vs, null, null)), C.hasFeedback && C.feedbackIcon]);
          return k(m(F4, L(L(L({
            monthCellRender: Te,
            dateRender: ye,
            renderExtraFooter: Ce,
            ref: R,
            placeholder: W6(he, ue, Le),
            suffixIcon: ve,
            dropdownAlign: rC(O.value, S.placement),
            clearIcon: te || m(vn, null, null),
            allowClear: Ne,
            transitionName: xe || `${_.value}-slide-up`
          }, Pe), Be), {}, {
            id: se,
            picker: ue,
            value: q.value,
            defaultValue: oe.value,
            defaultPickerValue: Z.value,
            showToday: pe,
            locale: he.lang,
            class: ae({
              [`${fe}-${B.value}`]: B.value,
              [`${fe}-borderless`]: !we
            }, dn(fe, Po(C.status, S.status), C.hasFeedback), b.class, P.value, E.value),
            disabled: N.value,
            prefixCls: fe,
            getPopupContainer: b.getCalendarContainer || x.value,
            generateConfig: e,
            prevIcon: ((V = v.prevIcon) === null || V === void 0 ? void 0 : V.call(v)) || m("span", {
              class: `${fe}-prev-icon`
            }, null),
            nextIcon: ((X = v.nextIcon) === null || X === void 0 ? void 0 : X.call(v)) || m("span", {
              class: `${fe}-next-icon`
            }, null),
            superPrevIcon: ((re = v.superPrevIcon) === null || re === void 0 ? void 0 : re.call(v)) || m("span", {
              class: `${fe}-super-prev-icon`
            }, null),
            superNextIcon: ((ie = v.superNextIcon) === null || ie === void 0 ? void 0 : ie.call(v)) || m("span", {
              class: `${fe}-super-next-icon`
            }, null),
            components: lC,
            direction: O.value,
            dropdownClassName: ae(P.value, S.popupClassName, S.dropdownClassName),
            onChange: A,
            onOpenChange: H,
            onFocus: j,
            onBlur: z,
            onPanelChange: F,
            onOk: U
          }), null));
        };
      }
    });
  }
  const o = n(void 0, "ADatePicker"), r = n("week", "AWeekPicker"), a = n("month", "AMonthPicker"), i = n("year", "AYearPicker"), l = n("time", "TimePicker"), u = n("quarter", "AQuarterPicker");
  return {
    DatePicker: o,
    WeekPicker: r,
    MonthPicker: a,
    YearPicker: i,
    TimePicker: l,
    QuarterPicker: u
  };
}
var Y6 = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M873.1 596.2l-164-208A32 32 0 00684 376h-64.8c-6.7 0-10.4 7.7-6.3 13l144.3 183H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h695.9c26.8 0 41.7-30.8 25.2-51.8z" } }] }, name: "swap-right", theme: "outlined" };
function th(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      X6(e, r, n[r]);
    });
  }
  return e;
}
function X6(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var dp = function(t, n) {
  var o = th({}, t, n.attrs);
  return m(it, th({}, o, {
    icon: Y6
  }), null);
};
dp.displayName = "SwapRightOutlined";
dp.inheritAttrs = !1;
var q6 = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function Q6(e, t) {
  return J({
    compatConfig: {
      MODE: 3
    },
    name: "ARangePicker",
    inheritAttrs: !1,
    props: h(h(h({}, Jl()), iC()), t),
    slots: Object,
    setup(o, r) {
      let {
        expose: a,
        slots: i,
        attrs: l,
        emit: u
      } = r;
      const s = o, c = Lt(), d = rn.useInject();
      process.env.NODE_ENV !== "production" && (gt(!s.dropdownClassName, "RangePicker", "`dropdownClassName` is deprecated. Please use `popupClassName` instead."), gt(!l.getCalendarContainer, "DatePicker", '`getCalendarContainer` is deprecated. Please use `getPopupContainer"` instead.'));
      const {
        prefixCls: f,
        direction: p,
        getPopupContainer: v,
        size: g,
        rootPrefixCls: b,
        disabled: y
      } = Ke("picker", s), {
        compactSize: S,
        compactItemClassnames: w
      } = Dr(f, p), C = T(() => S.value || g.value), [$, O] = n$(f), x = G();
      a({
        focus: () => {
          var j;
          (j = x.value) === null || j === void 0 || j.focus();
        },
        blur: () => {
          var j;
          (j = x.value) === null || j === void 0 || j.blur();
        }
      });
      const M = (j) => s.valueFormat ? e.toString(j, s.valueFormat) : j, _ = (j, z) => {
        const F = M(j);
        u("update:value", F), u("change", F, z), c.onFieldChange();
      }, N = (j) => {
        u("update:open", j), u("openChange", j);
      }, I = (j) => {
        u("focus", j);
      }, E = (j) => {
        u("blur", j), c.onFieldBlur();
      }, B = (j, z) => {
        const F = M(j);
        u("panelChange", F, z);
      }, k = (j) => {
        const z = M(j);
        u("ok", z);
      }, P = (j, z, F) => {
        const U = M(j);
        u("calendarChange", U, z, F);
      }, [R] = Pr("DatePicker", El), D = T(() => s.value && s.valueFormat ? e.toDate(s.value, s.valueFormat) : s.value), A = T(() => s.defaultValue && s.valueFormat ? e.toDate(s.defaultValue, s.valueFormat) : s.defaultValue), H = T(() => s.defaultPickerValue && s.valueFormat ? e.toDate(s.defaultPickerValue, s.valueFormat) : s.defaultPickerValue);
      return () => {
        var j, z, F, U, Q, q, oe;
        const Z = h(h({}, R.value), s.locale), ne = h(h({}, s), l), {
          prefixCls: Y,
          bordered: V = !0,
          placeholder: X,
          suffixIcon: re = (j = i.suffixIcon) === null || j === void 0 ? void 0 : j.call(i),
          picker: ie = "date",
          transitionName: he,
          allowClear: ge = !0,
          dateRender: we = i.dateRender,
          renderExtraFooter: Le = i.renderExtraFooter,
          separator: be = (z = i.separator) === null || z === void 0 ? void 0 : z.call(i),
          clearIcon: pe = (F = i.clearIcon) === null || F === void 0 ? void 0 : F.call(i),
          id: xe = c.id.value
        } = ne, Ne = q6(ne, ["prefixCls", "bordered", "placeholder", "suffixIcon", "picker", "transitionName", "allowClear", "dateRender", "renderExtraFooter", "separator", "clearIcon", "id"]);
        delete Ne["onUpdate:value"], delete Ne["onUpdate:open"];
        const {
          format: ye,
          showTime: Ce
        } = ne;
        let Te = {};
        Te = h(h(h({}, Te), Ce ? es(h({
          format: ye,
          picker: ie
        }, Ce)) : {}), ie === "time" ? es(h(h({
          format: ye
        }, pt(Ne, ["disabledTime"])), {
          picker: ie
        })) : {});
        const te = f.value, se = m(We, null, [re || (ie === "time" ? m(Ws, null, null) : m(Vs, null, null)), d.hasFeedback && d.feedbackIcon]);
        return $(m(X4, L(L(L({
          dateRender: we,
          renderExtraFooter: Le,
          separator: be || m("span", {
            "aria-label": "to",
            class: `${te}-separator`
          }, [m(dp, null, null)]),
          ref: x,
          dropdownAlign: rC(p.value, s.placement),
          placeholder: K6(Z, ie, X),
          suffixIcon: se,
          clearIcon: pe || m(vn, null, null),
          allowClear: ge,
          transitionName: he || `${b.value}-slide-up`
        }, Ne), Te), {}, {
          disabled: y.value,
          id: xe,
          value: D.value,
          defaultValue: A.value,
          defaultPickerValue: H.value,
          picker: ie,
          class: ae({
            [`${te}-${C.value}`]: C.value,
            [`${te}-borderless`]: !V
          }, dn(te, Po(d.status, s.status), d.hasFeedback), l.class, O.value, w.value),
          locale: Z.lang,
          prefixCls: te,
          getPopupContainer: l.getCalendarContainer || v.value,
          generateConfig: e,
          prevIcon: ((U = i.prevIcon) === null || U === void 0 ? void 0 : U.call(i)) || m("span", {
            class: `${te}-prev-icon`
          }, null),
          nextIcon: ((Q = i.nextIcon) === null || Q === void 0 ? void 0 : Q.call(i)) || m("span", {
            class: `${te}-next-icon`
          }, null),
          superPrevIcon: ((q = i.superPrevIcon) === null || q === void 0 ? void 0 : q.call(i)) || m("span", {
            class: `${te}-super-prev-icon`
          }, null),
          superNextIcon: ((oe = i.superNextIcon) === null || oe === void 0 ? void 0 : oe.call(i)) || m("span", {
            class: `${te}-super-next-icon`
          }, null),
          components: lC,
          direction: p.value,
          dropdownClassName: ae(O.value, s.popupClassName, s.dropdownClassName),
          onChange: _,
          onOpenChange: N,
          onFocus: I,
          onBlur: E,
          onPanelChange: B,
          onOk: k,
          onCalendarChange: P
        }), null));
      };
    }
  });
}
const lC = {
  button: N6,
  rangeItem: L6
};
function Z6(e) {
  return e ? Array.isArray(e) ? e : [e] : [];
}
function es(e) {
  const {
    format: t,
    picker: n,
    showHour: o,
    showMinute: r,
    showSecond: a,
    use12Hours: i
  } = e, l = Z6(t)[0], u = h({}, e);
  return l && typeof l == "string" && (!l.includes("s") && a === void 0 && (u.showSecond = !1), !l.includes("m") && r === void 0 && (u.showMinute = !1), !l.includes("H") && !l.includes("h") && o === void 0 && (u.showHour = !1), (l.includes("a") || l.includes("A")) && i === void 0 && (u.use12Hours = !0)), n === "time" ? u : (typeof l == "function" && delete u.format, {
    showTime: u
  });
}
function sC(e, t) {
  const {
    DatePicker: n,
    WeekPicker: o,
    MonthPicker: r,
    YearPicker: a,
    TimePicker: i,
    QuarterPicker: l
  } = G6(e, t), u = Q6(e, t);
  return {
    DatePicker: n,
    WeekPicker: o,
    MonthPicker: r,
    YearPicker: a,
    TimePicker: i,
    QuarterPicker: l,
    RangePicker: u
  };
}
const {
  DatePicker: Fu,
  WeekPicker: Bu,
  MonthPicker: ku,
  YearPicker: J6,
  TimePicker: ek,
  QuarterPicker: Lu,
  RangePicker: Hu
} = sC(OS), tk = h(Fu, {
  WeekPicker: Bu,
  MonthPicker: ku,
  YearPicker: J6,
  RangePicker: Hu,
  TimePicker: ek,
  QuarterPicker: Lu,
  install: (e) => (e.component(Fu.name, Fu), e.component(Hu.name, Hu), e.component(ku.name, ku), e.component(Bu.name, Bu), e.component(Lu.name, Lu), e)
}), nk = (e) => {
  const {
    componentCls: t,
    sizePaddingEdgeHorizontal: n,
    colorSplit: o,
    lineWidth: r
  } = e;
  return {
    [t]: h(h({}, st(e)), {
      borderBlockStart: `${r}px solid ${o}`,
      // vertical
      "&-vertical": {
        position: "relative",
        top: "-0.06em",
        display: "inline-block",
        height: "0.9em",
        margin: `0 ${e.dividerVerticalGutterMargin}px`,
        verticalAlign: "middle",
        borderTop: 0,
        borderInlineStart: `${r}px solid ${o}`
      },
      "&-horizontal": {
        display: "flex",
        clear: "both",
        width: "100%",
        minWidth: "100%",
        margin: `${e.dividerHorizontalGutterMargin}px 0`
      },
      [`&-horizontal${t}-with-text`]: {
        display: "flex",
        alignItems: "center",
        margin: `${e.dividerHorizontalWithTextGutterMargin}px 0`,
        color: e.colorTextHeading,
        fontWeight: 500,
        fontSize: e.fontSizeLG,
        whiteSpace: "nowrap",
        textAlign: "center",
        borderBlockStart: `0 ${o}`,
        "&::before, &::after": {
          position: "relative",
          width: "50%",
          borderBlockStart: `${r}px solid transparent`,
          // Chrome not accept `inherit` in `border-top`
          borderBlockStartColor: "inherit",
          borderBlockEnd: 0,
          transform: "translateY(50%)",
          content: "''"
        }
      },
      [`&-horizontal${t}-with-text-left`]: {
        "&::before": {
          width: "5%"
        },
        "&::after": {
          width: "95%"
        }
      },
      [`&-horizontal${t}-with-text-right`]: {
        "&::before": {
          width: "95%"
        },
        "&::after": {
          width: "5%"
        }
      },
      [`${t}-inner-text`]: {
        display: "inline-block",
        padding: "0 1em"
      },
      "&-dashed": {
        background: "none",
        borderColor: o,
        borderStyle: "dashed",
        borderWidth: `${r}px 0 0`
      },
      [`&-horizontal${t}-with-text${t}-dashed`]: {
        "&::before, &::after": {
          borderStyle: "dashed none none"
        }
      },
      [`&-vertical${t}-dashed`]: {
        borderInlineStartWidth: r,
        borderInlineEnd: 0,
        borderBlockStart: 0,
        borderBlockEnd: 0
      },
      [`&-plain${t}-with-text`]: {
        color: e.colorText,
        fontWeight: "normal",
        fontSize: e.fontSize
      },
      [`&-horizontal${t}-with-text-left${t}-no-default-orientation-margin-left`]: {
        "&::before": {
          width: 0
        },
        "&::after": {
          width: "100%"
        },
        [`${t}-inner-text`]: {
          paddingInlineStart: n
        }
      },
      [`&-horizontal${t}-with-text-right${t}-no-default-orientation-margin-right`]: {
        "&::before": {
          width: "100%"
        },
        "&::after": {
          width: 0
        },
        [`${t}-inner-text`]: {
          paddingInlineEnd: n
        }
      }
    })
  };
}, ok = ht("Divider", (e) => {
  const t = qe(e, {
    dividerVerticalGutterMargin: e.marginXS,
    dividerHorizontalWithTextGutterMargin: e.margin,
    dividerHorizontalGutterMargin: e.marginLG
  });
  return [nk(t)];
}, {
  sizePaddingEdgeHorizontal: 0
}), rk = () => ({
  prefixCls: String,
  type: {
    type: String,
    default: "horizontal"
  },
  dashed: {
    type: Boolean,
    default: !1
  },
  orientation: {
    type: String,
    default: "center"
  },
  plain: {
    type: Boolean,
    default: !1
  },
  orientationMargin: [String, Number]
}), ak = J({
  name: "ADivider",
  inheritAttrs: !1,
  compatConfig: {
    MODE: 3
  },
  props: rk(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r,
      direction: a
    } = Ke("divider", e), [i, l] = ok(r), u = T(() => e.orientation === "left" && e.orientationMargin != null), s = T(() => e.orientation === "right" && e.orientationMargin != null), c = T(() => {
      const {
        type: p,
        dashed: v,
        plain: g
      } = e, b = r.value;
      return {
        [b]: !0,
        [l.value]: !!l.value,
        [`${b}-${p}`]: !0,
        [`${b}-dashed`]: !!v,
        [`${b}-plain`]: !!g,
        [`${b}-rtl`]: a.value === "rtl",
        [`${b}-no-default-orientation-margin-left`]: u.value,
        [`${b}-no-default-orientation-margin-right`]: s.value
      };
    }), d = T(() => {
      const p = typeof e.orientationMargin == "number" ? `${e.orientationMargin}px` : e.orientationMargin;
      return h(h({}, u.value && {
        marginLeft: p
      }), s.value && {
        marginRight: p
      });
    }), f = T(() => e.orientation.length > 0 ? "-" + e.orientation : e.orientation);
    return () => {
      var p;
      const v = xt((p = n.default) === null || p === void 0 ? void 0 : p.call(n));
      return i(m("div", L(L({}, o), {}, {
        class: [c.value, v.length ? `${r.value}-with-text ${r.value}-with-text${f.value}` : "", o.class],
        role: "separator"
      }), [v.length ? m("span", {
        class: `${r.value}-inner-text`,
        style: d.value
      }, [v]) : null]));
    };
  }
}), ik = Xn(ak), ei = (e) => e != null && (Array.isArray(e) ? nn(e).length : !0);
function fp(e) {
  return ei(e.prefix) || ei(e.suffix) || ei(e.allowClear);
}
function $l(e) {
  return ei(e.addonBefore) || ei(e.addonAfter);
}
function ld(e) {
  return typeof e > "u" || e === null ? "" : String(e);
}
function ti(e, t, n, o) {
  if (!n)
    return;
  const r = t;
  if (t.type === "click") {
    Object.defineProperty(r, "target", {
      writable: !0
    }), Object.defineProperty(r, "currentTarget", {
      writable: !0
    });
    const a = e.cloneNode(!0);
    r.target = a, r.currentTarget = a, a.value = "", n(r);
    return;
  }
  if (o !== void 0) {
    Object.defineProperty(r, "target", {
      writable: !0
    }), Object.defineProperty(r, "currentTarget", {
      writable: !0
    }), r.target = e, r.currentTarget = e, e.value = o, n(r);
    return;
  }
  n(r);
}
function uC(e, t) {
  if (!e)
    return;
  e.focus(t);
  const {
    cursor: n
  } = t || {};
  if (n) {
    const o = e.value.length;
    switch (n) {
      case "start":
        e.setSelectionRange(0, 0);
        break;
      case "end":
        e.setSelectionRange(o, o);
        break;
      default:
        e.setSelectionRange(0, o);
    }
  }
}
const lk = () => ({
  addonBefore: W.any,
  addonAfter: W.any,
  prefix: W.any,
  suffix: W.any,
  clearIcon: W.any,
  affixWrapperClassName: String,
  groupClassName: String,
  wrapperClassName: String,
  inputClassName: String,
  allowClear: {
    type: Boolean,
    default: void 0
  }
}), cC = () => h(h({}, lk()), {
  value: {
    type: [String, Number, Symbol],
    default: void 0
  },
  defaultValue: {
    type: [String, Number, Symbol],
    default: void 0
  },
  inputElement: W.any,
  prefixCls: String,
  disabled: {
    type: Boolean,
    default: void 0
  },
  focused: {
    type: Boolean,
    default: void 0
  },
  triggerFocus: Function,
  readonly: {
    type: Boolean,
    default: void 0
  },
  handleReset: Function,
  hidden: {
    type: Boolean,
    default: void 0
  }
}), dC = () => h(h({}, cC()), {
  id: String,
  placeholder: {
    type: [String, Number]
  },
  autocomplete: String,
  type: Ze("text"),
  name: String,
  size: {
    type: String
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  lazy: {
    type: Boolean,
    default: !0
  },
  maxlength: Number,
  loading: {
    type: Boolean,
    default: void 0
  },
  bordered: {
    type: Boolean,
    default: void 0
  },
  showCount: {
    type: [Boolean, Object]
  },
  htmlSize: Number,
  onPressEnter: Function,
  onKeydown: Function,
  onKeyup: Function,
  onFocus: Function,
  onBlur: Function,
  onChange: Function,
  onInput: Function,
  "onUpdate:value": Function,
  onCompositionstart: Function,
  onCompositionend: Function,
  valueModifiers: Object,
  hidden: {
    type: Boolean,
    default: void 0
  },
  status: String
}), sk = J({
  name: "BaseInput",
  inheritAttrs: !1,
  props: cC(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const r = G(), a = (l) => {
      var u;
      if (!((u = r.value) === null || u === void 0) && u.contains(l.target)) {
        const {
          triggerFocus: s
        } = e;
        s == null || s();
      }
    }, i = () => {
      var l;
      const {
        allowClear: u,
        value: s,
        disabled: c,
        readonly: d,
        handleReset: f,
        suffix: p = n.suffix,
        prefixCls: v
      } = e;
      if (!u)
        return null;
      const g = !c && !d && s, b = `${v}-clear-icon`, y = ((l = n.clearIcon) === null || l === void 0 ? void 0 : l.call(n)) || "*";
      return m("span", {
        onClick: f,
        onMousedown: (S) => S.preventDefault(),
        class: ae({
          [`${b}-hidden`]: !g,
          [`${b}-has-suffix`]: !!p
        }, b),
        role: "button",
        tabindex: -1
      }, [y]);
    };
    return () => {
      var l, u;
      const {
        focused: s,
        value: c,
        disabled: d,
        allowClear: f,
        readonly: p,
        hidden: v,
        prefixCls: g,
        prefix: b = (l = n.prefix) === null || l === void 0 ? void 0 : l.call(n),
        suffix: y = (u = n.suffix) === null || u === void 0 ? void 0 : u.call(n),
        addonAfter: S = n.addonAfter,
        addonBefore: w = n.addonBefore,
        inputElement: C,
        affixWrapperClassName: $,
        wrapperClassName: O,
        groupClassName: x
      } = e;
      let M = Tt(C, {
        value: c,
        hidden: v
      });
      if (fp({
        prefix: b,
        suffix: y,
        allowClear: f
      })) {
        const _ = `${g}-affix-wrapper`, N = ae(_, {
          [`${_}-disabled`]: d,
          [`${_}-focused`]: s,
          [`${_}-readonly`]: p,
          [`${_}-input-with-clear-btn`]: y && f && c
        }, !$l({
          addonAfter: S,
          addonBefore: w
        }) && o.class, $), I = (y || f) && m("span", {
          class: `${g}-suffix`
        }, [i(), y]);
        M = m("span", {
          class: N,
          style: o.style,
          hidden: !$l({
            addonAfter: S,
            addonBefore: w
          }) && v,
          onMousedown: a,
          ref: r
        }, [b && m("span", {
          class: `${g}-prefix`
        }, [b]), Tt(C, {
          style: null,
          value: c,
          hidden: null
        }), I]);
      }
      if ($l({
        addonAfter: S,
        addonBefore: w
      })) {
        const _ = `${g}-group`, N = `${_}-addon`, I = ae(`${g}-wrapper`, _, O), E = ae(`${g}-group-wrapper`, o.class, x);
        return m("span", {
          class: E,
          style: o.style,
          hidden: v
        }, [m("span", {
          class: I
        }, [w && m("span", {
          class: N
        }, [w]), Tt(M, {
          style: null,
          hidden: null
        }), S && m("span", {
          class: N
        }, [S])])]);
      }
      return M;
    };
  }
});
var uk = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const ck = J({
  name: "VCInput",
  inheritAttrs: !1,
  props: dC(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: r,
      emit: a
    } = t;
    const i = K(e.value === void 0 ? e.defaultValue : e.value), l = K(!1), u = K(), s = K();
    le(() => e.value, () => {
      i.value = e.value;
    }), le(() => e.disabled, () => {
      e.disabled && (l.value = !1);
    });
    const c = (x) => {
      u.value && uC(u.value.input, x);
    }, d = () => {
      var x;
      (x = u.value.input) === null || x === void 0 || x.blur();
    }, f = (x, M, _) => {
      var N;
      (N = u.value.input) === null || N === void 0 || N.setSelectionRange(x, M, _);
    }, p = () => {
      var x;
      (x = u.value.input) === null || x === void 0 || x.select();
    };
    r({
      focus: c,
      blur: d,
      input: T(() => {
        var x;
        return (x = u.value.input) === null || x === void 0 ? void 0 : x.input;
      }),
      stateValue: i,
      setSelectionRange: f,
      select: p
    });
    const v = (x) => {
      a("change", x);
    }, g = (x, M) => {
      i.value !== x && (e.value === void 0 ? i.value = x : mt(() => {
        var _;
        u.value.input.value !== i.value && ((_ = s.value) === null || _ === void 0 || _.$forceUpdate());
      }), mt(() => {
        M && M();
      }));
    }, b = (x) => {
      const {
        value: M
      } = x.target;
      if (i.value === M)
        return;
      const _ = x.target.value;
      ti(u.value.input, x, v), g(_);
    }, y = (x) => {
      x.keyCode === 13 && a("pressEnter", x), a("keydown", x);
    }, S = (x) => {
      l.value = !0, a("focus", x);
    }, w = (x) => {
      l.value = !1, a("blur", x);
    }, C = (x) => {
      ti(u.value.input, x, v), g("", () => {
        c();
      });
    }, $ = () => {
      var x, M;
      const {
        addonBefore: _ = n.addonBefore,
        addonAfter: N = n.addonAfter,
        disabled: I,
        valueModifiers: E = {},
        htmlSize: B,
        autocomplete: k,
        prefixCls: P,
        inputClassName: R,
        prefix: D = (x = n.prefix) === null || x === void 0 ? void 0 : x.call(n),
        suffix: A = (M = n.suffix) === null || M === void 0 ? void 0 : M.call(n),
        allowClear: H,
        type: j = "text"
      } = e, z = pt(e, [
        "prefixCls",
        "onPressEnter",
        "addonBefore",
        "addonAfter",
        "prefix",
        "suffix",
        "allowClear",
        // Input elements must be either controlled or uncontrolled,
        // specify either the value prop, or the defaultValue prop, but not both.
        "defaultValue",
        "size",
        "bordered",
        "htmlSize",
        "lazy",
        "showCount",
        "valueModifiers",
        "showCount",
        "affixWrapperClassName",
        "groupClassName",
        "inputClassName",
        "wrapperClassName"
      ]), F = h(h(h({}, z), o), {
        autocomplete: k,
        onChange: b,
        onInput: b,
        onFocus: S,
        onBlur: w,
        onKeydown: y,
        class: ae(P, {
          [`${P}-disabled`]: I
        }, R, !$l({
          addonAfter: N,
          addonBefore: _
        }) && !fp({
          prefix: D,
          suffix: A,
          allowClear: H
        }) && o.class),
        ref: u,
        key: "ant-input",
        size: B,
        type: j,
        lazy: e.lazy
      });
      return E.lazy && delete F.onInput, F.autofocus || delete F.autofocus, m(Ss, pt(F, ["size"]), null);
    }, O = () => {
      var x;
      const {
        maxlength: M,
        suffix: _ = (x = n.suffix) === null || x === void 0 ? void 0 : x.call(n),
        showCount: N,
        prefixCls: I
      } = e, E = Number(M) > 0;
      if (_ || N) {
        const B = [...ld(i.value)].length, k = typeof N == "object" ? N.formatter({
          count: B,
          maxlength: M
        }) : `${B}${E ? ` / ${M}` : ""}`;
        return m(We, null, [!!N && m("span", {
          class: ae(`${I}-show-count-suffix`, {
            [`${I}-show-count-has-suffix`]: !!_
          })
        }, [k]), _]);
      }
      return null;
    };
    return ze(() => {
      process.env.NODE_ENV === "test" && e.autofocus && c();
    }), () => {
      const {
        prefixCls: x,
        disabled: M
      } = e, _ = uk(e, ["prefixCls", "disabled"]);
      return m(sk, L(L(L({}, _), o), {}, {
        ref: s,
        prefixCls: x,
        inputElement: $(),
        handleReset: C,
        value: ld(i.value),
        focused: l.value,
        triggerFocus: c,
        suffix: O(),
        disabled: M
      }), n);
    };
  }
}), Ks = () => pt(dC(), ["wrapperClassName", "groupClassName", "inputClassName", "affixWrapperClassName"]), fC = () => h(h({}, pt(Ks(), ["prefix", "addonBefore", "addonAfter", "suffix"])), {
  rows: Number,
  autosize: {
    type: [Boolean, Object],
    default: void 0
  },
  autoSize: {
    type: [Boolean, Object],
    default: void 0
  },
  onResize: {
    type: Function
  },
  onCompositionstart: ai(),
  onCompositionend: ai(),
  valueModifiers: Object
});
var dk = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const At = J({
  compatConfig: {
    MODE: 3
  },
  name: "AInput",
  inheritAttrs: !1,
  props: Ks(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: r,
      emit: a
    } = t;
    const i = G(), l = Lt(), u = rn.useInject(), s = T(() => Po(u.status, e.status)), {
      direction: c,
      prefixCls: d,
      size: f,
      autocomplete: p
    } = Ke("input", e), {
      compactSize: v,
      compactItemClassnames: g
    } = Dr(d, c), b = T(() => v.value || f.value), [y, S] = Jf(d), w = Cn();
    r({
      focus: (B) => {
        var k;
        (k = i.value) === null || k === void 0 || k.focus(B);
      },
      blur: () => {
        var B;
        (B = i.value) === null || B === void 0 || B.blur();
      },
      input: i,
      setSelectionRange: (B, k, P) => {
        var R;
        (R = i.value) === null || R === void 0 || R.setSelectionRange(B, k, P);
      },
      select: () => {
        var B;
        (B = i.value) === null || B === void 0 || B.select();
      }
    });
    const M = G([]), _ = () => {
      M.value.push(setTimeout(() => {
        var B, k, P, R;
        !((B = i.value) === null || B === void 0) && B.input && ((k = i.value) === null || k === void 0 ? void 0 : k.input.getAttribute("type")) === "password" && (!((P = i.value) === null || P === void 0) && P.input.hasAttribute("value")) && ((R = i.value) === null || R === void 0 || R.input.removeAttribute("value"));
      }));
    };
    ze(() => {
      _();
    }), yd(() => {
      M.value.forEach((B) => clearTimeout(B));
    }), at(() => {
      M.value.forEach((B) => clearTimeout(B));
    });
    const N = (B) => {
      _(), a("blur", B), l.onFieldBlur();
    }, I = (B) => {
      _(), a("focus", B);
    }, E = (B) => {
      a("update:value", B.target.value), a("change", B), a("input", B), l.onFieldChange();
    };
    return () => {
      var B, k, P, R, D, A;
      const {
        hasFeedback: H,
        feedbackIcon: j
      } = u, {
        allowClear: z,
        bordered: F = !0,
        prefix: U = (B = n.prefix) === null || B === void 0 ? void 0 : B.call(n),
        suffix: Q = (k = n.suffix) === null || k === void 0 ? void 0 : k.call(n),
        addonAfter: q = (P = n.addonAfter) === null || P === void 0 ? void 0 : P.call(n),
        addonBefore: oe = (R = n.addonBefore) === null || R === void 0 ? void 0 : R.call(n),
        id: Z = (D = l.id) === null || D === void 0 ? void 0 : D.value
      } = e, ne = dk(e, ["allowClear", "bordered", "prefix", "suffix", "addonAfter", "addonBefore", "id"]), Y = (H || Q) && m(We, null, [Q, H && j]), V = d.value, X = fp({
        prefix: U,
        suffix: Q
      }) || !!H, re = n.clearIcon || (() => m(vn, null, null));
      return y(m(ck, L(L(L({}, o), pt(ne, ["onUpdate:value", "onChange", "onInput"])), {}, {
        onChange: E,
        id: Z,
        disabled: (A = e.disabled) !== null && A !== void 0 ? A : w.value,
        ref: i,
        prefixCls: V,
        autocomplete: p.value,
        onBlur: N,
        onFocus: I,
        prefix: U,
        suffix: Y,
        allowClear: z,
        addonAfter: q && m(zl, null, {
          default: () => [m(Ll, null, {
            default: () => [q]
          })]
        }),
        addonBefore: oe && m(zl, null, {
          default: () => [m(Ll, null, {
            default: () => [oe]
          })]
        }),
        class: [o.class, g.value],
        inputClassName: ae({
          [`${V}-sm`]: b.value === "small",
          [`${V}-lg`]: b.value === "large",
          [`${V}-rtl`]: c.value === "rtl",
          [`${V}-borderless`]: !F
        }, !X && dn(V, s.value), S.value),
        affixWrapperClassName: ae({
          [`${V}-affix-wrapper-sm`]: b.value === "small",
          [`${V}-affix-wrapper-lg`]: b.value === "large",
          [`${V}-affix-wrapper-rtl`]: c.value === "rtl",
          [`${V}-affix-wrapper-borderless`]: !F
        }, dn(`${V}-affix-wrapper`, s.value, H), S.value),
        wrapperClassName: ae({
          [`${V}-group-rtl`]: c.value === "rtl"
        }, S.value),
        groupClassName: ae({
          [`${V}-group-wrapper-sm`]: b.value === "small",
          [`${V}-group-wrapper-lg`]: b.value === "large",
          [`${V}-group-wrapper-rtl`]: c.value === "rtl"
        }, dn(`${V}-group-wrapper`, s.value, H), S.value)
      }), h(h({}, n), {
        clearIcon: re
      })));
    };
  }
}), fk = J({
  compatConfig: {
    MODE: 3
  },
  name: "AInputGroup",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    size: {
      type: String
    },
    compact: {
      type: Boolean,
      default: void 0
    }
  },
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r,
      direction: a,
      getPrefixCls: i
    } = Ke("input-group", e), l = rn.useInject();
    rn.useProvide(l, {
      isFormItemInput: !1
    });
    const u = T(() => i("input")), [s, c] = Jf(u), d = T(() => {
      const f = r.value;
      return {
        [`${f}`]: !0,
        [c.value]: !0,
        [`${f}-lg`]: e.size === "large",
        [`${f}-sm`]: e.size === "small",
        [`${f}-compact`]: e.compact,
        [`${f}-rtl`]: a.value === "rtl"
      };
    });
    return () => {
      var f;
      return s(m("span", L(L({}, o), {}, {
        class: ae(d.value, o.class)
      }), [(f = n.default) === null || f === void 0 ? void 0 : f.call(n)]));
    };
  }
});
var pk = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const vk = J({
  compatConfig: {
    MODE: 3
  },
  name: "AInputSearch",
  inheritAttrs: !1,
  props: h(h({}, Ks()), {
    inputPrefixCls: String,
    // 不能设置默认值 https://github.com/vueComponent/ant-design-vue/issues/1916
    enterButton: W.any,
    onSearch: {
      type: Function
    }
  }),
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: r,
      emit: a
    } = t;
    const i = K(), l = K(!1);
    r({
      focus: () => {
        var $;
        ($ = i.value) === null || $ === void 0 || $.focus();
      },
      blur: () => {
        var $;
        ($ = i.value) === null || $ === void 0 || $.blur();
      }
    });
    const c = ($) => {
      a("update:value", $.target.value), $ && $.target && $.type === "click" && a("search", $.target.value, $), a("change", $);
    }, d = ($) => {
      var O;
      document.activeElement === ((O = i.value) === null || O === void 0 ? void 0 : O.input) && $.preventDefault();
    }, f = ($) => {
      var O, x;
      a("search", (x = (O = i.value) === null || O === void 0 ? void 0 : O.input) === null || x === void 0 ? void 0 : x.stateValue, $);
    }, p = ($) => {
      l.value || e.loading || f($);
    }, v = ($) => {
      l.value = !0, a("compositionstart", $);
    }, g = ($) => {
      l.value = !1, a("compositionend", $);
    }, {
      prefixCls: b,
      getPrefixCls: y,
      direction: S,
      size: w
    } = Ke("input-search", e), C = T(() => y("input", e.inputPrefixCls));
    return () => {
      var $, O, x, M;
      const {
        disabled: _,
        loading: N,
        addonAfter: I = ($ = n.addonAfter) === null || $ === void 0 ? void 0 : $.call(n),
        suffix: E = (O = n.suffix) === null || O === void 0 ? void 0 : O.call(n)
      } = e, B = pk(e, ["disabled", "loading", "addonAfter", "suffix"]);
      let {
        enterButton: k = (M = (x = n.enterButton) === null || x === void 0 ? void 0 : x.call(n)) !== null && M !== void 0 ? M : !1
      } = e;
      k = k || k === "";
      const P = typeof k == "boolean" ? m(Os, null, null) : null, R = `${b.value}-button`, D = Array.isArray(k) ? k[0] : k;
      let A;
      const H = D.type && M0(D.type) && D.type.__ANT_BUTTON;
      if (H || D.tagName === "button")
        A = Tt(D, h({
          onMousedown: d,
          onClick: f,
          key: "enterButton"
        }, H ? {
          class: R,
          size: w.value
        } : {}), !1);
      else {
        const z = P && !k;
        A = m(Zt, {
          class: R,
          type: k ? "primary" : void 0,
          size: w.value,
          disabled: _,
          key: "enterButton",
          onMousedown: d,
          onClick: f,
          loading: N,
          icon: z ? P : null
        }, {
          default: () => [z ? null : P || k]
        });
      }
      I && (A = [A, I]);
      const j = ae(b.value, {
        [`${b.value}-rtl`]: S.value === "rtl",
        [`${b.value}-${w.value}`]: !!w.value,
        [`${b.value}-with-button`]: !!k
      }, o.class);
      return m(At, L(L(L({
        ref: i
      }, pt(B, ["onUpdate:value", "onSearch", "enterButton"])), o), {}, {
        onPressEnter: p,
        onCompositionstart: v,
        onCompositionend: g,
        size: w.value,
        prefixCls: C.value,
        addonAfter: A,
        suffix: E,
        onChange: c,
        class: j,
        disabled: _
      }), n);
    };
  }
}), nh = (e) => e != null && (Array.isArray(e) ? nn(e).length : !0);
function mk(e) {
  return nh(e.addonBefore) || nh(e.addonAfter);
}
const gk = ["text", "input"], hk = J({
  compatConfig: {
    MODE: 3
  },
  name: "ClearableLabeledInput",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    inputType: W.oneOf(ro("text", "input")),
    value: Wt(),
    defaultValue: Wt(),
    allowClear: {
      type: Boolean,
      default: void 0
    },
    element: Wt(),
    handleReset: Function,
    disabled: {
      type: Boolean,
      default: void 0
    },
    direction: {
      type: String
    },
    size: {
      type: String
    },
    suffix: Wt(),
    prefix: Wt(),
    addonBefore: Wt(),
    addonAfter: Wt(),
    readonly: {
      type: Boolean,
      default: void 0
    },
    focused: {
      type: Boolean,
      default: void 0
    },
    bordered: {
      type: Boolean,
      default: !0
    },
    triggerFocus: {
      type: Function
    },
    hidden: Boolean,
    status: String,
    hashId: String
  },
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const r = rn.useInject(), a = (l) => {
      const {
        value: u,
        disabled: s,
        readonly: c,
        handleReset: d,
        suffix: f = n.suffix
      } = e, p = !s && !c && u, v = `${l}-clear-icon`;
      return m(vn, {
        onClick: d,
        onMousedown: (g) => g.preventDefault(),
        class: ae({
          [`${v}-hidden`]: !p,
          [`${v}-has-suffix`]: !!f
        }, v),
        role: "button"
      }, null);
    }, i = (l, u) => {
      const {
        value: s,
        allowClear: c,
        direction: d,
        bordered: f,
        hidden: p,
        status: v,
        addonAfter: g = n.addonAfter,
        addonBefore: b = n.addonBefore,
        hashId: y
      } = e, {
        status: S,
        hasFeedback: w
      } = r;
      if (!c)
        return Tt(u, {
          value: s,
          disabled: e.disabled
        });
      const C = ae(`${l}-affix-wrapper`, `${l}-affix-wrapper-textarea-with-clear-btn`, dn(`${l}-affix-wrapper`, Po(S, v), w), {
        [`${l}-affix-wrapper-rtl`]: d === "rtl",
        [`${l}-affix-wrapper-borderless`]: !f,
        // className will go to addon wrapper
        [`${o.class}`]: !mk({
          addonAfter: g,
          addonBefore: b
        }) && o.class
      }, y);
      return m("span", {
        class: C,
        style: o.style,
        hidden: p
      }, [Tt(u, {
        style: null,
        value: s,
        disabled: e.disabled
      }), a(l)]);
    };
    return () => {
      var l;
      const {
        prefixCls: u,
        inputType: s,
        element: c = (l = n.element) === null || l === void 0 ? void 0 : l.call(n)
      } = e;
      return s === gk[0] ? i(u, c) : null;
    };
  }
}), bk = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
  pointer-events: none !important;
`, yk = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break", "white-space"], zu = {};
let Mn;
function Sk(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  const n = e.getAttribute("id") || e.getAttribute("data-reactid") || e.getAttribute("name");
  if (t && zu[n])
    return zu[n];
  const o = window.getComputedStyle(e), r = o.getPropertyValue("box-sizing") || o.getPropertyValue("-moz-box-sizing") || o.getPropertyValue("-webkit-box-sizing"), a = parseFloat(o.getPropertyValue("padding-bottom")) + parseFloat(o.getPropertyValue("padding-top")), i = parseFloat(o.getPropertyValue("border-bottom-width")) + parseFloat(o.getPropertyValue("border-top-width")), u = {
    sizingStyle: yk.map((s) => `${s}:${o.getPropertyValue(s)}`).join(";"),
    paddingSize: a,
    borderSize: i,
    boxSizing: r
  };
  return t && n && (zu[n] = u), u;
}
function $k(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  Mn || (Mn = document.createElement("textarea"), Mn.setAttribute("tab-index", "-1"), Mn.setAttribute("aria-hidden", "true"), document.body.appendChild(Mn)), e.getAttribute("wrap") ? Mn.setAttribute("wrap", e.getAttribute("wrap")) : Mn.removeAttribute("wrap");
  const {
    paddingSize: r,
    borderSize: a,
    boxSizing: i,
    sizingStyle: l
  } = Sk(e, t);
  Mn.setAttribute("style", `${l};${bk}`), Mn.value = e.value || e.placeholder || "";
  let u, s, c, d = Mn.scrollHeight;
  if (i === "border-box" ? d += a : i === "content-box" && (d -= r), n !== null || o !== null) {
    Mn.value = " ";
    const p = Mn.scrollHeight - r;
    n !== null && (u = p * n, i === "border-box" && (u = u + r + a), d = Math.max(u, d)), o !== null && (s = p * o, i === "border-box" && (s = s + r + a), c = d > s ? "" : "hidden", d = Math.min(s, d));
  }
  const f = {
    height: `${d}px`,
    overflowY: c,
    resize: "none"
  };
  return u && (f.minHeight = `${u}px`), s && (f.maxHeight = `${s}px`), f;
}
const ju = 0, Vu = 1, Wu = 2, Ck = J({
  compatConfig: {
    MODE: 3
  },
  name: "ResizableTextArea",
  inheritAttrs: !1,
  props: fC(),
  setup(e, t) {
    let {
      attrs: n,
      emit: o,
      expose: r
    } = t, a, i;
    const l = G(), u = G({}), s = G(Wu);
    at(() => {
      Ue.cancel(a), Ue.cancel(i);
    });
    const c = () => {
      try {
        if (l.value && document.activeElement === l.value.input) {
          const O = l.value.getSelectionStart(), x = l.value.getSelectionEnd(), M = l.value.getScrollTop();
          l.value.setSelectionRange(O, x), l.value.setScrollTop(M);
        }
      } catch {
      }
    }, d = G(), f = G();
    Ve(() => {
      const O = e.autoSize || e.autosize;
      O ? (d.value = O.minRows, f.value = O.maxRows) : (d.value = void 0, f.value = void 0);
    });
    const p = T(() => !!(e.autoSize || e.autosize)), v = () => {
      s.value = ju;
    };
    le([() => e.value, d, f, p], () => {
      p.value && v();
    }, {
      immediate: !0
    });
    const g = G();
    le([s, l], () => {
      if (l.value)
        if (s.value === ju)
          s.value = Vu;
        else if (s.value === Vu) {
          const O = $k(l.value.input, !1, d.value, f.value);
          s.value = Wu, g.value = O;
        } else
          c();
    }, {
      immediate: !0,
      flush: "post"
    });
    const b = On(), y = G(), S = () => {
      Ue.cancel(y.value);
    }, w = (O) => {
      s.value === Wu && (o("resize", O), p.value && (S(), y.value = Ue(() => {
        v();
      })));
    };
    at(() => {
      S();
    }), r({
      resizeTextarea: () => {
        v();
      },
      textArea: T(() => {
        var O;
        return (O = l.value) === null || O === void 0 ? void 0 : O.input;
      }),
      instance: b
    }), Pt(e.autosize === void 0, "Input.TextArea", "autosize is deprecated, please use autoSize instead.");
    const $ = () => {
      const {
        prefixCls: O,
        disabled: x
      } = e, M = pt(e, ["prefixCls", "onPressEnter", "autoSize", "autosize", "defaultValue", "allowClear", "type", "maxlength", "valueModifiers"]), _ = ae(O, n.class, {
        [`${O}-disabled`]: x
      }), N = p.value ? g.value : null, I = [n.style, u.value, N], E = h(h(h({}, M), n), {
        style: I,
        class: _
      });
      return (s.value === ju || s.value === Vu) && I.push({
        overflowX: "hidden",
        overflowY: "hidden"
      }), E.autofocus || delete E.autofocus, E.rows === 0 && delete E.rows, m(br, {
        onResize: w,
        disabled: !p.value
      }, {
        default: () => [m(Ss, L(L({}, E), {}, {
          ref: l,
          tag: "textarea"
        }), null)]
      });
    };
    return () => $();
  }
});
function pC(e, t) {
  return [...e || ""].slice(0, t).join("");
}
function oh(e, t, n, o) {
  let r = n;
  return e ? r = pC(n, o) : [...t || ""].length < n.length && [...n || ""].length > o && (r = t), r;
}
const vC = J({
  compatConfig: {
    MODE: 3
  },
  name: "ATextarea",
  inheritAttrs: !1,
  props: fC(),
  setup(e, t) {
    let {
      attrs: n,
      expose: o,
      emit: r
    } = t;
    const a = Lt(), i = rn.useInject(), l = T(() => Po(i.status, e.status)), u = K(e.value === void 0 ? e.defaultValue : e.value), s = K(), c = K(""), {
      prefixCls: d,
      size: f,
      direction: p
    } = Ke("input", e), [v, g] = Jf(d), b = Cn(), y = T(() => e.showCount === "" || e.showCount || !1), S = T(() => Number(e.maxlength) > 0), w = K(!1), C = K(), $ = K(0), O = (A) => {
      w.value = !0, C.value = c.value, $.value = A.currentTarget.selectionStart, r("compositionstart", A);
    }, x = (A) => {
      var H;
      w.value = !1;
      let j = A.currentTarget.value;
      if (S.value) {
        const z = $.value >= e.maxlength + 1 || $.value === ((H = C.value) === null || H === void 0 ? void 0 : H.length);
        j = oh(z, C.value, j, e.maxlength);
      }
      j !== c.value && (I(j), ti(A.currentTarget, A, k, j)), r("compositionend", A);
    }, M = On();
    le(() => e.value, () => {
      var A;
      "value" in M.vnode.props, u.value = (A = e.value) !== null && A !== void 0 ? A : "";
    });
    const _ = (A) => {
      var H;
      uC((H = s.value) === null || H === void 0 ? void 0 : H.textArea, A);
    }, N = () => {
      var A, H;
      (H = (A = s.value) === null || A === void 0 ? void 0 : A.textArea) === null || H === void 0 || H.blur();
    }, I = (A, H) => {
      u.value !== A && (e.value === void 0 ? u.value = A : mt(() => {
        var j, z, F;
        s.value.textArea.value !== c.value && ((F = (j = s.value) === null || j === void 0 ? void 0 : (z = j.instance).update) === null || F === void 0 || F.call(z));
      }), mt(() => {
        H && H();
      }));
    }, E = (A) => {
      A.keyCode === 13 && r("pressEnter", A), r("keydown", A);
    }, B = (A) => {
      const {
        onBlur: H
      } = e;
      H == null || H(A), a.onFieldBlur();
    }, k = (A) => {
      r("update:value", A.target.value), r("change", A), r("input", A), a.onFieldChange();
    }, P = (A) => {
      ti(s.value.textArea, A, k), I("", () => {
        _();
      });
    }, R = (A) => {
      let H = A.target.value;
      if (u.value !== H) {
        if (S.value) {
          const j = A.target, z = j.selectionStart >= e.maxlength + 1 || j.selectionStart === H.length || !j.selectionStart;
          H = oh(z, c.value, H, e.maxlength);
        }
        ti(A.currentTarget, A, k, H), I(H);
      }
    }, D = () => {
      var A, H;
      const {
        class: j
      } = n, {
        bordered: z = !0
      } = e, F = h(h(h({}, pt(e, ["allowClear"])), n), {
        class: [{
          [`${d.value}-borderless`]: !z,
          [`${j}`]: j && !y.value,
          [`${d.value}-sm`]: f.value === "small",
          [`${d.value}-lg`]: f.value === "large"
        }, dn(d.value, l.value), g.value],
        disabled: b.value,
        showCount: null,
        prefixCls: d.value,
        onInput: R,
        onChange: R,
        onBlur: B,
        onKeydown: E,
        onCompositionstart: O,
        onCompositionend: x
      });
      return !((A = e.valueModifiers) === null || A === void 0) && A.lazy && delete F.onInput, m(Ck, L(L({}, F), {}, {
        id: (H = F == null ? void 0 : F.id) !== null && H !== void 0 ? H : a.id.value,
        ref: s,
        maxlength: e.maxlength,
        lazy: e.lazy
      }), null);
    };
    return o({
      focus: _,
      blur: N,
      resizableTextArea: s
    }), Ve(() => {
      let A = ld(u.value);
      !w.value && S.value && (e.value === null || e.value === void 0) && (A = pC(A, e.maxlength)), c.value = A;
    }), () => {
      var A;
      const {
        maxlength: H,
        bordered: j = !0,
        hidden: z
      } = e, {
        style: F,
        class: U
      } = n, Q = h(h(h({}, e), n), {
        prefixCls: d.value,
        inputType: "text",
        handleReset: P,
        direction: p.value,
        bordered: j,
        style: y.value ? void 0 : F,
        hashId: g.value,
        disabled: (A = e.disabled) !== null && A !== void 0 ? A : b.value
      });
      let q = m(hk, L(L({}, Q), {}, {
        value: c.value,
        status: e.status
      }), {
        element: D
      });
      if (y.value || i.hasFeedback) {
        const oe = [...c.value].length;
        let Z = "";
        typeof y.value == "object" ? Z = y.value.formatter({
          value: c.value,
          count: oe,
          maxlength: H
        }) : Z = `${oe}${S.value ? ` / ${H}` : ""}`, q = m("div", {
          hidden: z,
          class: ae(`${d.value}-textarea`, {
            [`${d.value}-textarea-rtl`]: p.value === "rtl",
            [`${d.value}-textarea-show-count`]: y.value,
            [`${d.value}-textarea-in-form-item`]: i.isFormItemInput
          }, `${d.value}-textarea-show-count`, U, g.value),
          style: F,
          "data-count": typeof Z != "object" ? Z : void 0
        }, [q, i.hasFeedback && m("span", {
          class: `${d.value}-textarea-suffix`
        }, [i.feedbackIcon])]);
      }
      return v(q);
    };
  }
});
var wk = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, name: "eye", theme: "outlined" };
function rh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      xk(e, r, n[r]);
    });
  }
  return e;
}
function xk(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Us = function(t, n) {
  var o = rh({}, t, n.attrs);
  return m(it, rh({}, o, {
    icon: wk
  }), null);
};
Us.displayName = "EyeOutlined";
Us.inheritAttrs = !1;
var Ok = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { tag: "path", attrs: { d: "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, name: "eye-invisible", theme: "outlined" };
function ah(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      Pk(e, r, n[r]);
    });
  }
  return e;
}
function Pk(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var pp = function(t, n) {
  var o = ah({}, t, n.attrs);
  return m(it, ah({}, o, {
    icon: Ok
  }), null);
};
pp.displayName = "EyeInvisibleOutlined";
pp.inheritAttrs = !1;
var Ik = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const Tk = {
  click: "onClick",
  hover: "onMouseover"
}, Ek = (e) => e ? m(Us, null, null) : m(pp, null, null), Mk = J({
  compatConfig: {
    MODE: 3
  },
  name: "AInputPassword",
  inheritAttrs: !1,
  props: h(h({}, Ks()), {
    prefixCls: String,
    inputPrefixCls: String,
    action: {
      type: String,
      default: "click"
    },
    visibilityToggle: {
      type: Boolean,
      default: !0
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    "onUpdate:visible": Function,
    iconRender: Function
  }),
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: r,
      emit: a
    } = t;
    const i = K(!1), l = () => {
      const {
        disabled: b
      } = e;
      b || (i.value = !i.value, a("update:visible", i.value));
    };
    Ve(() => {
      e.visible !== void 0 && (i.value = !!e.visible);
    });
    const u = K();
    r({
      focus: () => {
        var b;
        (b = u.value) === null || b === void 0 || b.focus();
      },
      blur: () => {
        var b;
        (b = u.value) === null || b === void 0 || b.blur();
      }
    });
    const d = (b) => {
      const {
        action: y,
        iconRender: S = n.iconRender || Ek
      } = e, w = Tk[y] || "", C = S(i.value), $ = {
        [w]: l,
        class: `${b}-icon`,
        key: "passwordIcon",
        onMousedown: (O) => {
          O.preventDefault();
        },
        onMouseup: (O) => {
          O.preventDefault();
        }
      };
      return Tt(on(C) ? C : m("span", null, [C]), $);
    }, {
      prefixCls: f,
      getPrefixCls: p
    } = Ke("input-password", e), v = T(() => p("input", e.inputPrefixCls)), g = () => {
      const {
        size: b,
        visibilityToggle: y
      } = e, S = Ik(e, ["size", "visibilityToggle"]), w = y && d(f.value), C = ae(f.value, o.class, {
        [`${f.value}-${b}`]: !!b
      }), $ = h(h(h({}, pt(S, ["suffix", "iconRender", "action"])), o), {
        type: i.value ? "text" : "password",
        class: C,
        prefixCls: v.value,
        suffix: w
      });
      return b && ($.size = b), m(At, L({
        ref: u
      }, $), n);
    };
    return () => g();
  }
});
At.Group = fk;
At.Search = vk;
At.TextArea = vC;
At.Password = Mk;
At.install = function(e) {
  return e.component(At.name, At), e.component(At.Group.name, At.Group), e.component(At.Search.name, At.Search), e.component(At.TextArea.name, At.TextArea), e.component(At.Password.name, At.Password), e;
};
function vp() {
  return {
    keyboard: {
      type: Boolean,
      default: void 0
    },
    mask: {
      type: Boolean,
      default: void 0
    },
    afterClose: Function,
    closable: {
      type: Boolean,
      default: void 0
    },
    maskClosable: {
      type: Boolean,
      default: void 0
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    destroyOnClose: {
      type: Boolean,
      default: void 0
    },
    mousePosition: W.shape({
      x: Number,
      y: Number
    }).loose,
    title: W.any,
    footer: W.any,
    transitionName: String,
    maskTransitionName: String,
    animation: W.any,
    maskAnimation: W.any,
    wrapStyle: {
      type: Object,
      default: void 0
    },
    bodyStyle: {
      type: Object,
      default: void 0
    },
    maskStyle: {
      type: Object,
      default: void 0
    },
    prefixCls: String,
    wrapClassName: String,
    rootClassName: String,
    width: [String, Number],
    height: [String, Number],
    zIndex: Number,
    bodyProps: W.any,
    maskProps: W.any,
    wrapProps: W.any,
    getContainer: W.any,
    dialogStyle: {
      type: Object,
      default: void 0
    },
    dialogClass: String,
    closeIcon: W.any,
    forceRender: {
      type: Boolean,
      default: void 0
    },
    getOpenCount: Function,
    // https://github.com/ant-design/ant-design/issues/19771
    // https://github.com/react-component/dialog/issues/95
    focusTriggerAfterClose: {
      type: Boolean,
      default: void 0
    },
    onClose: Function,
    modalRender: Function
  };
}
function ih(e, t, n) {
  let o = t;
  return !o && n && (o = `${e}-${n}`), o;
}
let lh = -1;
function _k() {
  return lh += 1, lh;
}
function sh(e, t) {
  let n = e[`page${t ? "Y" : "X"}Offset`];
  const o = `scroll${t ? "Top" : "Left"}`;
  if (typeof n != "number") {
    const r = e.document;
    n = r.documentElement[o], typeof n != "number" && (n = r.body[o]);
  }
  return n;
}
function Dk(e) {
  const t = e.getBoundingClientRect(), n = {
    left: t.left,
    top: t.top
  }, o = e.ownerDocument, r = o.defaultView || o.parentWindow;
  return n.left += sh(r), n.top += sh(r, !0), n;
}
const uh = {
  width: 0,
  height: 0,
  overflow: "hidden",
  outline: "none"
}, Ak = J({
  compatConfig: {
    MODE: 3
  },
  name: "DialogContent",
  inheritAttrs: !1,
  props: h(h({}, vp()), {
    motionName: String,
    ariaId: String,
    onVisibleChanged: Function,
    onMousedown: Function,
    onMouseup: Function
  }),
  setup(e, t) {
    let {
      expose: n,
      slots: o,
      attrs: r
    } = t;
    const a = G(), i = G(), l = G();
    n({
      focus: () => {
        var f;
        (f = a.value) === null || f === void 0 || f.focus();
      },
      changeActive: (f) => {
        const {
          activeElement: p
        } = document;
        f && p === i.value ? a.value.focus() : !f && p === a.value && i.value.focus();
      }
    });
    const u = G(), s = T(() => {
      const {
        width: f,
        height: p
      } = e, v = {};
      return f !== void 0 && (v.width = typeof f == "number" ? `${f}px` : f), p !== void 0 && (v.height = typeof p == "number" ? `${p}px` : p), u.value && (v.transformOrigin = u.value), v;
    }), c = () => {
      mt(() => {
        if (l.value) {
          const f = Dk(l.value);
          u.value = e.mousePosition ? `${e.mousePosition.x - f.left}px ${e.mousePosition.y - f.top}px` : "";
        }
      });
    }, d = (f) => {
      e.onVisibleChanged(f);
    };
    return () => {
      var f, p, v, g;
      const {
        prefixCls: b,
        footer: y = (f = o.footer) === null || f === void 0 ? void 0 : f.call(o),
        title: S = (p = o.title) === null || p === void 0 ? void 0 : p.call(o),
        ariaId: w,
        closable: C,
        closeIcon: $ = (v = o.closeIcon) === null || v === void 0 ? void 0 : v.call(o),
        onClose: O,
        bodyStyle: x,
        bodyProps: M,
        onMousedown: _,
        onMouseup: N,
        visible: I,
        modalRender: E = o.modalRender,
        destroyOnClose: B,
        motionName: k
      } = e;
      let P;
      y && (P = m("div", {
        class: `${b}-footer`
      }, [y]));
      let R;
      S && (R = m("div", {
        class: `${b}-header`
      }, [m("div", {
        class: `${b}-title`,
        id: w
      }, [S])]));
      let D;
      C && (D = m("button", {
        type: "button",
        onClick: O,
        "aria-label": "Close",
        class: `${b}-close`
      }, [$ || m("span", {
        class: `${b}-close-x`
      }, null)]));
      const A = m("div", {
        class: `${b}-content`
      }, [D, R, m("div", L({
        class: `${b}-body`,
        style: x
      }, M), [(g = o.default) === null || g === void 0 ? void 0 : g.call(o)]), P]), H = Ca(k);
      return m(Yn, L(L({}, H), {}, {
        onBeforeEnter: c,
        onAfterEnter: () => d(!0),
        onAfterLeave: () => d(!1)
      }), {
        default: () => [I || !B ? An(m("div", L(L({}, r), {}, {
          ref: l,
          key: "dialog-element",
          role: "document",
          style: [s.value, r.style],
          class: [b, r.class],
          onMousedown: _,
          onMouseup: N
        }), [m("div", {
          tabindex: 0,
          ref: a,
          style: uh,
          "aria-hidden": "true"
        }, null), E ? E({
          originVNode: A
        }) : A, m("div", {
          tabindex: 0,
          ref: i,
          style: uh,
          "aria-hidden": "true"
        }, null)]), [[wo, I]]) : null]
      });
    };
  }
}), Nk = J({
  compatConfig: {
    MODE: 3
  },
  name: "DialogMask",
  props: {
    prefixCls: String,
    visible: Boolean,
    motionName: String,
    maskProps: Object
  },
  setup(e, t) {
    return () => {
      const {
        prefixCls: n,
        visible: o,
        maskProps: r,
        motionName: a
      } = e, i = Ca(a);
      return m(Yn, i, {
        default: () => [An(m("div", L({
          class: `${n}-mask`
        }, r), null), [[wo, o]])]
      });
    };
  }
}), ch = J({
  compatConfig: {
    MODE: 3
  },
  name: "VcDialog",
  inheritAttrs: !1,
  props: bt(h(h({}, vp()), {
    getOpenCount: Function,
    scrollLocker: Object
  }), {
    mask: !0,
    visible: !1,
    keyboard: !0,
    closable: !0,
    maskClosable: !0,
    destroyOnClose: !1,
    prefixCls: "rc-dialog",
    getOpenCount: () => null,
    focusTriggerAfterClose: !0
  }),
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const r = K(), a = K(), i = K(), l = K(e.visible), u = K(`vcDialogTitle${_k()}`), s = (y) => {
      var S, w;
      if (y)
        ko(a.value, document.activeElement) || (r.value = document.activeElement, (S = i.value) === null || S === void 0 || S.focus());
      else {
        const C = l.value;
        if (l.value = !1, e.mask && r.value && e.focusTriggerAfterClose) {
          try {
            r.value.focus({
              preventScroll: !0
            });
          } catch {
          }
          r.value = null;
        }
        C && ((w = e.afterClose) === null || w === void 0 || w.call(e));
      }
    }, c = (y) => {
      var S;
      (S = e.onClose) === null || S === void 0 || S.call(e, y);
    }, d = K(!1), f = K(), p = () => {
      clearTimeout(f.value), d.value = !0;
    }, v = () => {
      f.value = setTimeout(() => {
        d.value = !1;
      });
    }, g = (y) => {
      if (!e.maskClosable)
        return null;
      d.value ? d.value = !1 : a.value === y.target && c(y);
    }, b = (y) => {
      if (e.keyboard && y.keyCode === ee.ESC) {
        y.stopPropagation(), c(y);
        return;
      }
      e.visible && y.keyCode === ee.TAB && i.value.changeActive(!y.shiftKey);
    };
    return le(() => e.visible, () => {
      e.visible && (l.value = !0);
    }, {
      flush: "post"
    }), at(() => {
      var y;
      clearTimeout(f.value), (y = e.scrollLocker) === null || y === void 0 || y.unLock();
    }), Ve(() => {
      var y, S;
      (y = e.scrollLocker) === null || y === void 0 || y.unLock(), l.value && ((S = e.scrollLocker) === null || S === void 0 || S.lock());
    }), () => {
      const {
        prefixCls: y,
        mask: S,
        visible: w,
        maskTransitionName: C,
        maskAnimation: $,
        zIndex: O,
        wrapClassName: x,
        rootClassName: M,
        wrapStyle: _,
        closable: N,
        maskProps: I,
        maskStyle: E,
        transitionName: B,
        animation: k,
        wrapProps: P,
        title: R = o.title
      } = e, {
        style: D,
        class: A
      } = n;
      return m("div", L({
        class: [`${y}-root`, M]
      }, _r(e, {
        data: !0
      })), [m(Nk, {
        prefixCls: y,
        visible: S && w,
        motionName: ih(y, C, $),
        style: h({
          zIndex: O
        }, E),
        maskProps: I
      }, null), m("div", L({
        tabIndex: -1,
        onKeydown: b,
        class: ae(`${y}-wrap`, x),
        ref: a,
        onClick: g,
        role: "dialog",
        "aria-labelledby": R ? u.value : null,
        style: h(h({
          zIndex: O
        }, _), {
          display: l.value ? null : "none"
        })
      }, P), [m(Ak, L(L({}, pt(e, ["scrollLocker"])), {}, {
        style: D,
        class: A,
        onMousedown: p,
        onMouseup: v,
        ref: i,
        closable: N,
        ariaId: u.value,
        prefixCls: y,
        visible: w,
        onClose: c,
        onVisibleChanged: s,
        motionName: ih(y, B, k)
      }), o)])]);
    };
  }
}), Rk = vp(), Fk = J({
  compatConfig: {
    MODE: 3
  },
  name: "DialogWrap",
  inheritAttrs: !1,
  props: bt(Rk, {
    visible: !1
  }),
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const r = G(e.visible);
    return Yd({}, {
      inTriggerContext: !1
    }), le(() => e.visible, () => {
      e.visible && (r.value = !0);
    }, {
      flush: "post"
    }), () => {
      const {
        visible: a,
        getContainer: i,
        forceRender: l,
        destroyOnClose: u = !1,
        afterClose: s
      } = e;
      let c = h(h(h({}, e), n), {
        ref: "_component",
        key: "dialog"
      });
      return i === !1 ? m(ch, L(L({}, c), {}, {
        getOpenCount: () => 2
      }), o) : !l && u && !r.value ? null : m(Qy, {
        autoLock: !0,
        visible: a,
        forceRender: l,
        getContainer: i
      }, {
        default: (d) => (c = h(h(h({}, c), d), {
          afterClose: () => {
            s == null || s(), r.value = !1;
          }
        }), m(ch, c, o))
      });
    };
  }
});
function dh(e) {
  return {
    position: e,
    top: 0,
    insetInlineEnd: 0,
    bottom: 0,
    insetInlineStart: 0
  };
}
const Bk = (e) => {
  const {
    componentCls: t
  } = e;
  return [{
    [`${t}-root`]: {
      [`${t}${e.antCls}-zoom-enter, ${t}${e.antCls}-zoom-appear`]: {
        // reset scale avoid mousePosition bug
        transform: "none",
        opacity: 0,
        animationDuration: e.motionDurationSlow,
        // https://github.com/ant-design/ant-design/issues/11777
        userSelect: "none"
      },
      [`${t}${e.antCls}-zoom-leave ${t}-content`]: {
        pointerEvents: "none"
      },
      [`${t}-mask`]: h(h({}, dh("fixed")), {
        zIndex: e.zIndexPopupBase,
        height: "100%",
        backgroundColor: e.colorBgMask,
        [`${t}-hidden`]: {
          display: "none"
        }
      }),
      [`${t}-wrap`]: h(h({}, dh("fixed")), {
        overflow: "auto",
        outline: 0,
        WebkitOverflowScrolling: "touch"
      })
    }
  }, {
    [`${t}-root`]: pA(e)
  }];
}, kk = (e) => {
  const {
    componentCls: t
  } = e;
  return [
    // ======================== Root =========================
    {
      [`${t}-root`]: {
        [`${t}-wrap`]: {
          zIndex: e.zIndexPopupBase,
          position: "fixed",
          inset: 0,
          overflow: "auto",
          outline: 0,
          WebkitOverflowScrolling: "touch"
        },
        [`${t}-wrap-rtl`]: {
          direction: "rtl"
        },
        [`${t}-centered`]: {
          textAlign: "center",
          "&::before": {
            display: "inline-block",
            width: 0,
            height: "100%",
            verticalAlign: "middle",
            content: '""'
          },
          [t]: {
            top: 0,
            display: "inline-block",
            paddingBottom: 0,
            textAlign: "start",
            verticalAlign: "middle"
          }
        },
        [`@media (max-width: ${e.screenSMMax})`]: {
          [t]: {
            maxWidth: "calc(100vw - 16px)",
            margin: `${e.marginXS} auto`
          },
          [`${t}-centered`]: {
            [t]: {
              flex: 1
            }
          }
        }
      }
    },
    // ======================== Modal ========================
    {
      [t]: h(h({}, st(e)), {
        pointerEvents: "none",
        position: "relative",
        top: 100,
        width: "auto",
        maxWidth: `calc(100vw - ${e.margin * 2}px)`,
        margin: "0 auto",
        paddingBottom: e.paddingLG,
        [`${t}-title`]: {
          margin: 0,
          color: e.modalHeadingColor,
          fontWeight: e.fontWeightStrong,
          fontSize: e.modalHeaderTitleFontSize,
          lineHeight: e.modalHeaderTitleLineHeight,
          wordWrap: "break-word"
        },
        [`${t}-content`]: {
          position: "relative",
          backgroundColor: e.modalContentBg,
          backgroundClip: "padding-box",
          border: 0,
          borderRadius: e.borderRadiusLG,
          boxShadow: e.boxShadowSecondary,
          pointerEvents: "auto",
          padding: `${e.paddingMD}px ${e.paddingContentHorizontalLG}px`
        },
        [`${t}-close`]: h({
          position: "absolute",
          top: (e.modalHeaderCloseSize - e.modalCloseBtnSize) / 2,
          insetInlineEnd: (e.modalHeaderCloseSize - e.modalCloseBtnSize) / 2,
          zIndex: e.zIndexPopupBase + 10,
          padding: 0,
          color: e.modalCloseColor,
          fontWeight: e.fontWeightStrong,
          lineHeight: 1,
          textDecoration: "none",
          background: "transparent",
          borderRadius: e.borderRadiusSM,
          width: e.modalConfirmIconSize,
          height: e.modalConfirmIconSize,
          border: 0,
          outline: 0,
          cursor: "pointer",
          transition: `color ${e.motionDurationMid}, background-color ${e.motionDurationMid}`,
          "&-x": {
            display: "block",
            fontSize: e.fontSizeLG,
            fontStyle: "normal",
            lineHeight: `${e.modalCloseBtnSize}px`,
            textAlign: "center",
            textTransform: "none",
            textRendering: "auto"
          },
          "&:hover": {
            color: e.modalIconHoverColor,
            backgroundColor: e.wireframe ? "transparent" : e.colorFillContent,
            textDecoration: "none"
          },
          "&:active": {
            backgroundColor: e.wireframe ? "transparent" : e.colorFillContentHover
          }
        }, $i(e)),
        [`${t}-header`]: {
          color: e.colorText,
          background: e.modalHeaderBg,
          borderRadius: `${e.borderRadiusLG}px ${e.borderRadiusLG}px 0 0`,
          marginBottom: e.marginXS
        },
        [`${t}-body`]: {
          fontSize: e.fontSize,
          lineHeight: e.lineHeight,
          wordWrap: "break-word"
        },
        [`${t}-footer`]: {
          textAlign: "end",
          background: e.modalFooterBg,
          marginTop: e.marginSM,
          [`${e.antCls}-btn + ${e.antCls}-btn:not(${e.antCls}-dropdown-trigger)`]: {
            marginBottom: 0,
            marginInlineStart: e.marginXS
          }
        },
        [`${t}-open`]: {
          overflow: "hidden"
        }
      })
    },
    // ======================== Pure =========================
    {
      [`${t}-pure-panel`]: {
        top: "auto",
        padding: 0,
        display: "flex",
        flexDirection: "column",
        [`${t}-content,
          ${t}-body,
          ${t}-confirm-body-wrapper`]: {
          display: "flex",
          flexDirection: "column",
          flex: "auto"
        },
        [`${t}-confirm-body`]: {
          marginBottom: "auto"
        }
      }
    }
  ];
}, Lk = (e) => {
  const {
    componentCls: t
  } = e, n = `${t}-confirm`;
  return {
    [n]: {
      "&-rtl": {
        direction: "rtl"
      },
      [`${e.antCls}-modal-header`]: {
        display: "none"
      },
      [`${n}-body-wrapper`]: h({}, ca()),
      [`${n}-body`]: {
        display: "flex",
        flexWrap: "wrap",
        alignItems: "center",
        [`${n}-title`]: {
          flex: "0 0 100%",
          display: "block",
          // create BFC to avoid
          // https://user-images.githubusercontent.com/507615/37702510-ba844e06-2d2d-11e8-9b67-8e19be57f445.png
          overflow: "hidden",
          color: e.colorTextHeading,
          fontWeight: e.fontWeightStrong,
          fontSize: e.modalHeaderTitleFontSize,
          lineHeight: e.modalHeaderTitleLineHeight,
          [`+ ${n}-content`]: {
            marginBlockStart: e.marginXS,
            flexBasis: "100%",
            maxWidth: `calc(100% - ${e.modalConfirmIconSize + e.marginSM}px)`
          }
        },
        [`${n}-content`]: {
          color: e.colorText,
          fontSize: e.fontSize
        },
        [`> ${e.iconCls}`]: {
          flex: "none",
          marginInlineEnd: e.marginSM,
          fontSize: e.modalConfirmIconSize,
          [`+ ${n}-title`]: {
            flex: 1
          },
          // `content` after `icon` should set marginLeft
          [`+ ${n}-title + ${n}-content`]: {
            marginInlineStart: e.modalConfirmIconSize + e.marginSM
          }
        }
      },
      [`${n}-btns`]: {
        textAlign: "end",
        marginTop: e.marginSM,
        [`${e.antCls}-btn + ${e.antCls}-btn`]: {
          marginBottom: 0,
          marginInlineStart: e.marginXS
        }
      }
    },
    [`${n}-error ${n}-body > ${e.iconCls}`]: {
      color: e.colorError
    },
    [`${n}-warning ${n}-body > ${e.iconCls},
        ${n}-confirm ${n}-body > ${e.iconCls}`]: {
      color: e.colorWarning
    },
    [`${n}-info ${n}-body > ${e.iconCls}`]: {
      color: e.colorInfo
    },
    [`${n}-success ${n}-body > ${e.iconCls}`]: {
      color: e.colorSuccess
    },
    // https://github.com/ant-design/ant-design/issues/37329
    [`${t}-zoom-leave ${t}-btns`]: {
      pointerEvents: "none"
    }
  };
}, Hk = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-root`]: {
      [`${t}-wrap-rtl`]: {
        direction: "rtl",
        [`${t}-confirm-body`]: {
          direction: "rtl"
        }
      }
    }
  };
}, zk = (e) => {
  const {
    componentCls: t,
    antCls: n
  } = e, o = `${t}-confirm`;
  return {
    [t]: {
      [`${t}-content`]: {
        padding: 0
      },
      [`${t}-header`]: {
        padding: e.modalHeaderPadding,
        borderBottom: `${e.modalHeaderBorderWidth}px ${e.modalHeaderBorderStyle} ${e.modalHeaderBorderColorSplit}`,
        marginBottom: 0
      },
      [`${t}-body`]: {
        padding: e.modalBodyPadding
      },
      [`${t}-footer`]: {
        padding: `${e.modalFooterPaddingVertical}px ${e.modalFooterPaddingHorizontal}px`,
        borderTop: `${e.modalFooterBorderWidth}px ${e.modalFooterBorderStyle} ${e.modalFooterBorderColorSplit}`,
        borderRadius: `0 0 ${e.borderRadiusLG}px ${e.borderRadiusLG}px`,
        marginTop: 0
      }
    },
    [o]: {
      [`${n}-modal-body`]: {
        padding: `${e.padding * 2}px ${e.padding * 2}px ${e.paddingLG}px`
      },
      [`${o}-body`]: {
        [`> ${e.iconCls}`]: {
          marginInlineEnd: e.margin,
          // `content` after `icon` should set marginLeft
          [`+ ${o}-title + ${o}-content`]: {
            marginInlineStart: e.modalConfirmIconSize + e.margin
          }
        }
      },
      [`${o}-btns`]: {
        marginTop: e.marginLG
      }
    }
  };
}, jk = ht("Modal", (e) => {
  const t = e.padding, n = e.fontSizeHeading5, o = e.lineHeightHeading5, r = qe(e, {
    modalBodyPadding: e.paddingLG,
    modalHeaderBg: e.colorBgElevated,
    modalHeaderPadding: `${t}px ${e.paddingLG}px`,
    modalHeaderBorderWidth: e.lineWidth,
    modalHeaderBorderStyle: e.lineType,
    modalHeaderTitleLineHeight: o,
    modalHeaderTitleFontSize: n,
    modalHeaderBorderColorSplit: e.colorSplit,
    modalHeaderCloseSize: o * n + t * 2,
    modalContentBg: e.colorBgElevated,
    modalHeadingColor: e.colorTextHeading,
    modalCloseColor: e.colorTextDescription,
    modalFooterBg: "transparent",
    modalFooterBorderColorSplit: e.colorSplit,
    modalFooterBorderStyle: e.lineType,
    modalFooterPaddingVertical: e.paddingXS,
    modalFooterPaddingHorizontal: e.padding,
    modalFooterBorderWidth: e.lineWidth,
    modalConfirmTitleFontSize: e.fontSizeLG,
    modalIconHoverColor: e.colorIconHover,
    modalConfirmIconSize: e.fontSize * e.lineHeight,
    modalCloseBtnSize: e.controlHeightLG * 0.55
  });
  return [kk(r), Lk(r), Hk(r), Bk(r), e.wireframe && zk(r), _s(r, "zoom")];
});
var Vk = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M890.5 755.3L537.9 269.2c-12.8-17.6-39-17.6-51.7 0L133.5 755.3A8 8 0 00140 768h75c5.1 0 9.9-2.5 12.9-6.6L512 369.8l284.1 391.6c3 4.1 7.8 6.6 12.9 6.6h75c6.5 0 10.3-7.4 6.5-12.7z" } }] }, name: "up", theme: "outlined" };
function fh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      Wk(e, r, n[r]);
    });
  }
  return e;
}
function Wk(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var mp = function(t, n) {
  var o = fh({}, t, n.attrs);
  return m(it, fh({}, o, {
    icon: Vk
  }), null);
};
mp.displayName = "UpOutlined";
mp.inheritAttrs = !1;
function sd() {
  return typeof BigInt == "function";
}
function ni(e) {
  let t = e.trim(), n = t.startsWith("-");
  n && (t = t.slice(1)), t = t.replace(/(\.\d*[^0])0*$/, "$1").replace(/\.0*$/, "").replace(/^0+/, ""), t.startsWith(".") && (t = `0${t}`);
  const o = t || "0", r = o.split("."), a = r[0] || "0", i = r[1] || "0";
  a === "0" && i === "0" && (n = !1);
  const l = n ? "-" : "";
  return {
    negative: n,
    negativeStr: l,
    trimStr: o,
    integerStr: a,
    decimalStr: i,
    fullStr: `${l}${o}`
  };
}
function gp(e) {
  const t = String(e);
  return !Number.isNaN(Number(t)) && t.includes("e");
}
function bi(e) {
  const t = String(e);
  if (gp(e)) {
    let n = Number(t.slice(t.indexOf("e-") + 2));
    const o = t.match(/\.(\d+)/);
    return o != null && o[1] && (n += o[1].length), n;
  }
  return t.includes(".") && bp(t) ? t.length - t.indexOf(".") - 1 : 0;
}
function hp(e) {
  let t = String(e);
  if (gp(e)) {
    if (e > Number.MAX_SAFE_INTEGER)
      return String(sd() ? BigInt(e).toString() : Number.MAX_SAFE_INTEGER);
    if (e < Number.MIN_SAFE_INTEGER)
      return String(sd() ? BigInt(e).toString() : Number.MIN_SAFE_INTEGER);
    t = e.toFixed(bi(t));
  }
  return ni(t).fullStr;
}
function bp(e) {
  return typeof e == "number" ? !Number.isNaN(e) : e ? (
    // Normal type: 11.28
    /^\s*-?\d+(\.\d+)?\s*$/.test(e) || // Pre-number: 1.
    /^\s*-?\d+\.\s*$/.test(e) || // Post-number: .1
    /^\s*-?\.\d+\s*$/.test(e)
  ) : !1;
}
function mC(e) {
  return !e && e !== 0 && !Number.isNaN(e) || !String(e).trim();
}
class sr {
  constructor(t) {
    if (this.origin = "", mC(t)) {
      this.empty = !0;
      return;
    }
    this.origin = String(t), this.number = Number(t);
  }
  negate() {
    return new sr(-this.toNumber());
  }
  add(t) {
    if (this.isInvalidate())
      return new sr(t);
    const n = Number(t);
    if (Number.isNaN(n))
      return this;
    const o = this.number + n;
    if (o > Number.MAX_SAFE_INTEGER)
      return new sr(Number.MAX_SAFE_INTEGER);
    if (o < Number.MIN_SAFE_INTEGER)
      return new sr(Number.MIN_SAFE_INTEGER);
    const r = Math.max(bi(this.number), bi(n));
    return new sr(o.toFixed(r));
  }
  isEmpty() {
    return this.empty;
  }
  isNaN() {
    return Number.isNaN(this.number);
  }
  isInvalidate() {
    return this.isEmpty() || this.isNaN();
  }
  equals(t) {
    return this.toNumber() === (t == null ? void 0 : t.toNumber());
  }
  lessEquals(t) {
    return this.add(t.negate().toString()).toNumber() <= 0;
  }
  toNumber() {
    return this.number;
  }
  toString() {
    return (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0) ? this.isInvalidate() ? "" : hp(this.number) : this.origin;
  }
}
class Xr {
  constructor(t) {
    if (this.origin = "", mC(t)) {
      this.empty = !0;
      return;
    }
    if (this.origin = String(t), t === "-" || Number.isNaN(t)) {
      this.nan = !0;
      return;
    }
    let n = t;
    if (gp(n) && (n = Number(n)), n = typeof n == "string" ? n : hp(n), bp(n)) {
      const o = ni(n);
      this.negative = o.negative;
      const r = o.trimStr.split(".");
      this.integer = BigInt(r[0]);
      const a = r[1] || "0";
      this.decimal = BigInt(a), this.decimalLen = a.length;
    } else
      this.nan = !0;
  }
  getMark() {
    return this.negative ? "-" : "";
  }
  getIntegerStr() {
    return this.integer.toString();
  }
  getDecimalStr() {
    return this.decimal.toString().padStart(this.decimalLen, "0");
  }
  /**
   * Align BigIntDecimal with same decimal length. e.g. 12.3 + 5 = 1230000
   * This is used for add function only.
   */
  alignDecimal(t) {
    const n = `${this.getMark()}${this.getIntegerStr()}${this.getDecimalStr().padEnd(t, "0")}`;
    return BigInt(n);
  }
  negate() {
    const t = new Xr(this.toString());
    return t.negative = !t.negative, t;
  }
  add(t) {
    if (this.isInvalidate())
      return new Xr(t);
    const n = new Xr(t);
    if (n.isInvalidate())
      return this;
    const o = Math.max(this.getDecimalStr().length, n.getDecimalStr().length), r = this.alignDecimal(o), a = n.alignDecimal(o), i = (r + a).toString(), {
      negativeStr: l,
      trimStr: u
    } = ni(i), s = `${l}${u.padStart(o + 1, "0")}`;
    return new Xr(`${s.slice(0, -o)}.${s.slice(-o)}`);
  }
  isEmpty() {
    return this.empty;
  }
  isNaN() {
    return this.nan;
  }
  isInvalidate() {
    return this.isEmpty() || this.isNaN();
  }
  equals(t) {
    return this.toString() === (t == null ? void 0 : t.toString());
  }
  lessEquals(t) {
    return this.add(t.negate().toString()).toNumber() <= 0;
  }
  toNumber() {
    return this.isNaN() ? NaN : Number(this.toString());
  }
  toString() {
    return (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0) ? this.isInvalidate() ? "" : ni(`${this.getMark()}${this.getIntegerStr()}.${this.getDecimalStr()}`).fullStr : this.origin;
  }
}
function eo(e) {
  return sd() ? new Xr(e) : new sr(e);
}
function ud(e, t, n) {
  let o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  if (e === "")
    return "";
  const {
    negativeStr: r,
    integerStr: a,
    decimalStr: i
  } = ni(e), l = `${t}${i}`, u = `${r}${a}`;
  if (n >= 0) {
    const s = Number(i[n]);
    if (s >= 5 && !o) {
      const c = eo(e).add(`${r}0.${"0".repeat(n)}${10 - s}`);
      return ud(c.toString(), t, n, o);
    }
    return n === 0 ? u : `${u}${t}${i.padEnd(n, "0").slice(0, n)}`;
  }
  return l === ".0" ? u : `${u}${l}`;
}
const Kk = 200, Uk = 600, Gk = J({
  compatConfig: {
    MODE: 3
  },
  name: "StepHandler",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    upDisabled: Boolean,
    downDisabled: Boolean,
    onStep: de()
  },
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      emit: o
    } = t;
    const r = G(), a = (l, u) => {
      l.preventDefault(), o("step", u);
      function s() {
        o("step", u), r.value = setTimeout(s, Kk);
      }
      r.value = setTimeout(s, Uk);
    }, i = () => {
      clearTimeout(r.value);
    };
    return at(() => {
      i();
    }), () => {
      if (qd())
        return null;
      const {
        prefixCls: l,
        upDisabled: u,
        downDisabled: s
      } = e, c = `${l}-handler`, d = ae(c, `${c}-up`, {
        [`${c}-up-disabled`]: u
      }), f = ae(c, `${c}-down`, {
        [`${c}-down-disabled`]: s
      }), p = {
        unselectable: "on",
        role: "button",
        onMouseup: i,
        onMouseleave: i
      }, {
        upNode: v,
        downNode: g
      } = n;
      return m("div", {
        class: `${c}-wrap`
      }, [m("span", L(L({}, p), {}, {
        onMousedown: (b) => {
          a(b, !0);
        },
        "aria-label": "Increase Value",
        "aria-disabled": u,
        class: d
      }), [(v == null ? void 0 : v()) || m("span", {
        unselectable: "on",
        class: `${l}-handler-up-inner`
      }, null)]), m("span", L(L({}, p), {}, {
        onMousedown: (b) => {
          a(b, !1);
        },
        "aria-label": "Decrease Value",
        "aria-disabled": s,
        class: f
      }), [(g == null ? void 0 : g()) || m("span", {
        unselectable: "on",
        class: `${l}-handler-down-inner`
      }, null)])]);
    };
  }
});
function Yk(e, t) {
  const n = G(null);
  function o() {
    try {
      const {
        selectionStart: a,
        selectionEnd: i,
        value: l
      } = e.value, u = l.substring(0, a), s = l.substring(i);
      n.value = {
        start: a,
        end: i,
        value: l,
        beforeTxt: u,
        afterTxt: s
      };
    } catch {
    }
  }
  function r() {
    if (e.value && n.value && t.value)
      try {
        const {
          value: a
        } = e.value, {
          beforeTxt: i,
          afterTxt: l,
          start: u
        } = n.value;
        let s = a.length;
        if (a.endsWith(l))
          s = a.length - n.value.afterTxt.length;
        else if (a.startsWith(i))
          s = i.length;
        else {
          const c = i[u - 1], d = a.indexOf(c, u - 1);
          d !== -1 && (s = d + 1);
        }
        e.value.setSelectionRange(s, s);
      } catch (a) {
        lt(!1, `Something warning of cursor restore. Please fire issue about this: ${a.message}`);
      }
  }
  return [o, r];
}
const Xk = () => {
  const e = K(0), t = () => {
    Ue.cancel(e.value);
  };
  return at(() => {
    t();
  }), (n) => {
    t(), e.value = Ue(() => {
      n();
    });
  };
};
var qk = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const ph = (e, t) => e || t.isEmpty() ? t.toString() : t.toNumber(), vh = (e) => {
  const t = eo(e);
  return t.isInvalidate() ? null : t;
}, gC = () => ({
  /** value will show as string */
  stringMode: Me(),
  defaultValue: dt([String, Number]),
  value: dt([String, Number]),
  prefixCls: Ze(),
  min: dt([String, Number]),
  max: dt([String, Number]),
  step: dt([String, Number], 1),
  tabindex: Number,
  controls: Me(!0),
  readonly: Me(),
  disabled: Me(),
  autofocus: Me(),
  keyboard: Me(!0),
  /** Parse display value to validate number */
  parser: de(),
  /** Transform `value` to display value show in input */
  formatter: de(),
  /** Syntactic sugar of `formatter`. Config precision of display. */
  precision: Number,
  /** Syntactic sugar of `formatter`. Config decimal separator of display. */
  decimalSeparator: String,
  onInput: de(),
  onChange: de(),
  onPressEnter: de(),
  onStep: de(),
  onBlur: de(),
  onFocus: de()
}), Qk = J({
  compatConfig: {
    MODE: 3
  },
  name: "InnerInputNumber",
  inheritAttrs: !1,
  props: h(h({}, gC()), {
    lazy: Boolean
  }),
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      emit: r,
      expose: a
    } = t;
    const i = K(), l = K(!1), u = K(!1), s = K(!1), c = K(eo(e.value));
    function d(z) {
      e.value === void 0 && (c.value = z);
    }
    const f = (z, F) => {
      if (!F)
        return e.precision >= 0 ? e.precision : Math.max(bi(z), bi(e.step));
    }, p = (z) => {
      const F = String(z);
      if (e.parser)
        return e.parser(F);
      let U = F;
      return e.decimalSeparator && (U = U.replace(e.decimalSeparator, ".")), U.replace(/[^\w.-]+/g, "");
    }, v = K(""), g = (z, F) => {
      if (e.formatter)
        return e.formatter(z, {
          userTyping: F,
          input: String(v.value)
        });
      let U = typeof z == "number" ? hp(z) : z;
      if (!F) {
        const Q = f(U, F);
        if (bp(U) && (e.decimalSeparator || Q >= 0)) {
          const q = e.decimalSeparator || ".";
          U = ud(U, q, Q);
        }
      }
      return U;
    }, b = (() => {
      const z = e.value;
      return c.value.isInvalidate() && ["string", "number"].includes(typeof z) ? Number.isNaN(z) ? "" : z : g(c.value.toString(), !1);
    })();
    v.value = b;
    function y(z, F) {
      v.value = g(
        // Invalidate number is sometime passed by external control, we should let it go
        // Otherwise is controlled by internal interactive logic which check by userTyping
        // You can ref 'show limited value when input is not focused' test for more info.
        z.isInvalidate() ? z.toString(!1) : z.toString(!F),
        F
      );
    }
    const S = T(() => vh(e.max)), w = T(() => vh(e.min)), C = T(() => !S.value || !c.value || c.value.isInvalidate() ? !1 : S.value.lessEquals(c.value)), $ = T(() => !w.value || !c.value || c.value.isInvalidate() ? !1 : c.value.lessEquals(w.value)), [O, x] = Yk(i, l), M = (z) => S.value && !z.lessEquals(S.value) ? S.value : w.value && !w.value.lessEquals(z) ? w.value : null, _ = (z) => !M(z), N = (z, F) => {
      var U;
      let Q = z, q = _(Q) || Q.isEmpty();
      if (!Q.isEmpty() && !F && (Q = M(Q) || Q, q = !0), !e.readonly && !e.disabled && q) {
        const oe = Q.toString(), Z = f(oe, F);
        return Z >= 0 && (Q = eo(ud(oe, ".", Z))), Q.equals(c.value) || (d(Q), (U = e.onChange) === null || U === void 0 || U.call(e, Q.isEmpty() ? null : ph(e.stringMode, Q)), e.value === void 0 && y(Q, F)), Q;
      }
      return c.value;
    }, I = Xk(), E = (z) => {
      var F;
      if (O(), v.value = z, !s.value) {
        const U = p(z), Q = eo(U);
        Q.isNaN() || N(Q, !0);
      }
      (F = e.onInput) === null || F === void 0 || F.call(e, z), I(() => {
        let U = z;
        e.parser || (U = z.replace(/。/g, ".")), U !== z && E(U);
      });
    }, B = () => {
      s.value = !0;
    }, k = () => {
      s.value = !1, E(i.value.value);
    }, P = (z) => {
      E(z.target.value);
    }, R = (z) => {
      var F, U;
      if (z && C.value || !z && $.value)
        return;
      u.value = !1;
      let Q = eo(e.step);
      z || (Q = Q.negate());
      const q = (c.value || eo(0)).add(Q.toString()), oe = N(q, !1);
      (F = e.onStep) === null || F === void 0 || F.call(e, ph(e.stringMode, oe), {
        offset: e.step,
        type: z ? "up" : "down"
      }), (U = i.value) === null || U === void 0 || U.focus();
    }, D = (z) => {
      const F = eo(p(v.value));
      let U = F;
      F.isNaN() ? U = c.value : U = N(F, z), e.value !== void 0 ? y(c.value, !1) : U.isNaN() || y(U, !1);
    }, A = (z) => {
      var F;
      const {
        which: U
      } = z;
      u.value = !0, U === ee.ENTER && (s.value || (u.value = !1), D(!1), (F = e.onPressEnter) === null || F === void 0 || F.call(e, z)), e.keyboard !== !1 && !s.value && [ee.UP, ee.DOWN].includes(U) && (R(ee.UP === U), z.preventDefault());
    }, H = () => {
      u.value = !1;
    }, j = (z) => {
      D(!1), l.value = !1, u.value = !1, r("blur", z);
    };
    return le(() => e.precision, () => {
      c.value.isInvalidate() || y(c.value, !1);
    }, {
      flush: "post"
    }), le(() => e.value, () => {
      const z = eo(e.value);
      c.value = z;
      const F = eo(p(v.value));
      (!z.equals(F) || !u.value || e.formatter) && y(z, u.value);
    }, {
      flush: "post"
    }), le(v, () => {
      e.formatter && x();
    }, {
      flush: "post"
    }), le(() => e.disabled, (z) => {
      z && (l.value = !1);
    }), a({
      focus: () => {
        var z;
        (z = i.value) === null || z === void 0 || z.focus();
      },
      blur: () => {
        var z;
        (z = i.value) === null || z === void 0 || z.blur();
      }
    }), () => {
      const z = h(h({}, n), e), {
        prefixCls: F = "rc-input-number",
        min: U,
        max: Q,
        step: q = 1,
        defaultValue: oe,
        value: Z,
        disabled: ne,
        readonly: Y,
        keyboard: V,
        controls: X = !0,
        autofocus: re,
        stringMode: ie,
        parser: he,
        formatter: ge,
        precision: we,
        decimalSeparator: Le,
        onChange: be,
        onInput: pe,
        onPressEnter: xe,
        onStep: Ne,
        lazy: ye,
        class: Ce,
        style: Te
      } = z, te = qk(z, ["prefixCls", "min", "max", "step", "defaultValue", "value", "disabled", "readonly", "keyboard", "controls", "autofocus", "stringMode", "parser", "formatter", "precision", "decimalSeparator", "onChange", "onInput", "onPressEnter", "onStep", "lazy", "class", "style"]), {
        upHandler: se,
        downHandler: Pe
      } = o, _e = `${F}-input`, Ee = {};
      return ye ? Ee.onChange = P : Ee.onInput = P, m("div", {
        class: ae(F, Ce, {
          [`${F}-focused`]: l.value,
          [`${F}-disabled`]: ne,
          [`${F}-readonly`]: Y,
          [`${F}-not-a-number`]: c.value.isNaN(),
          [`${F}-out-of-range`]: !c.value.isInvalidate() && !_(c.value)
        }),
        style: Te,
        onKeydown: A,
        onKeyup: H
      }, [X && m(Gk, {
        prefixCls: F,
        upDisabled: C.value,
        downDisabled: $.value,
        onStep: R
      }, {
        upNode: se,
        downNode: Pe
      }), m("div", {
        class: `${_e}-wrap`
      }, [m("input", L(L(L({
        autofocus: re,
        autocomplete: "off",
        role: "spinbutton",
        "aria-valuemin": U,
        "aria-valuemax": Q,
        "aria-valuenow": c.value.isInvalidate() ? null : c.value.toString(),
        step: q
      }, te), {}, {
        ref: i,
        class: _e,
        value: v.value,
        disabled: ne,
        readonly: Y,
        onFocus: (Be) => {
          l.value = !0, r("focus", Be);
        }
      }, Ee), {}, {
        onBlur: j,
        onCompositionstart: B,
        onCompositionend: k
      }), null)])]);
    };
  }
});
function Ku(e) {
  return e != null;
}
const Zk = (e) => {
  const {
    componentCls: t,
    lineWidth: n,
    lineType: o,
    colorBorder: r,
    borderRadius: a,
    fontSizeLG: i,
    controlHeightLG: l,
    controlHeightSM: u,
    colorError: s,
    inputPaddingHorizontalSM: c,
    colorTextDescription: d,
    motionDurationMid: f,
    colorPrimary: p,
    controlHeight: v,
    inputPaddingHorizontal: g,
    colorBgContainer: b,
    colorTextDisabled: y,
    borderRadiusSM: S,
    borderRadiusLG: w,
    controlWidth: C,
    handleVisible: $
  } = e;
  return [
    {
      [t]: h(h(h(h({}, st(e)), Ta(e)), Ii(e, t)), {
        display: "inline-block",
        width: C,
        margin: 0,
        padding: 0,
        border: `${n}px ${o} ${r}`,
        borderRadius: a,
        "&-rtl": {
          direction: "rtl",
          [`${t}-input`]: {
            direction: "rtl"
          }
        },
        "&-lg": {
          padding: 0,
          fontSize: i,
          borderRadius: w,
          [`input${t}-input`]: {
            height: l - 2 * n
          }
        },
        "&-sm": {
          padding: 0,
          borderRadius: S,
          [`input${t}-input`]: {
            height: u - 2 * n,
            padding: `0 ${c}px`
          }
        },
        "&:hover": h({}, Ia(e)),
        "&-focused": h({}, Yo(e)),
        "&-disabled": h(h({}, Zf(e)), {
          [`${t}-input`]: {
            cursor: "not-allowed"
          }
        }),
        // ===================== Out Of Range =====================
        "&-out-of-range": {
          input: {
            color: s
          }
        },
        // Style for input-group: input with label, with button or dropdown...
        "&-group": h(h(h({}, st(e)), t$(e)), {
          "&-wrapper": {
            display: "inline-block",
            textAlign: "start",
            verticalAlign: "top",
            [`${t}-affix-wrapper`]: {
              width: "100%"
            },
            // Size
            "&-lg": {
              [`${t}-group-addon`]: {
                borderRadius: w
              }
            },
            "&-sm": {
              [`${t}-group-addon`]: {
                borderRadius: S
              }
            }
          }
        }),
        [t]: {
          "&-input": h(h({
            width: "100%",
            height: v - 2 * n,
            padding: `0 ${g}px`,
            textAlign: "start",
            backgroundColor: "transparent",
            border: 0,
            borderRadius: a,
            outline: 0,
            transition: `all ${f} linear`,
            appearance: "textfield",
            color: e.colorText,
            fontSize: "inherit",
            verticalAlign: "top"
          }, Qf(e.colorTextPlaceholder)), {
            '&[type="number"]::-webkit-inner-spin-button, &[type="number"]::-webkit-outer-spin-button': {
              margin: 0,
              /* stylelint-disable-next-line property-no-vendor-prefix */
              webkitAppearance: "none",
              appearance: "none"
            }
          })
        }
      })
    },
    // Handler
    {
      [t]: {
        [`&:hover ${t}-handler-wrap, &-focused ${t}-handler-wrap`]: {
          opacity: 1
        },
        [`${t}-handler-wrap`]: {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineEnd: 0,
          width: e.handleWidth,
          height: "100%",
          background: b,
          borderStartStartRadius: 0,
          borderStartEndRadius: a,
          borderEndEndRadius: a,
          borderEndStartRadius: 0,
          opacity: $ === !0 ? 1 : 0,
          display: "flex",
          flexDirection: "column",
          alignItems: "stretch",
          transition: `opacity ${f} linear ${f}`,
          // Fix input number inside Menu makes icon too large
          // We arise the selector priority by nest selector here
          // https://github.com/ant-design/ant-design/issues/14367
          [`${t}-handler`]: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            flex: "auto",
            height: "40%",
            [`
              ${t}-handler-up-inner,
              ${t}-handler-down-inner
            `]: {
              marginInlineEnd: 0,
              fontSize: e.handleFontSize
            }
          }
        },
        [`${t}-handler`]: {
          height: "50%",
          overflow: "hidden",
          color: d,
          fontWeight: "bold",
          lineHeight: 0,
          textAlign: "center",
          cursor: "pointer",
          borderInlineStart: `${n}px ${o} ${r}`,
          transition: `all ${f} linear`,
          "&:active": {
            background: e.colorFillAlter
          },
          // Hover
          "&:hover": {
            height: "60%",
            [`
              ${t}-handler-up-inner,
              ${t}-handler-down-inner
            `]: {
              color: p
            }
          },
          "&-up-inner, &-down-inner": h(h({}, Si()), {
            color: d,
            transition: `all ${f} linear`,
            userSelect: "none"
          })
        },
        [`${t}-handler-up`]: {
          borderStartEndRadius: a
        },
        [`${t}-handler-down`]: {
          borderBlockStart: `${n}px ${o} ${r}`,
          borderEndEndRadius: a
        },
        // Disabled
        "&-disabled, &-readonly": {
          [`${t}-handler-wrap`]: {
            display: "none"
          }
        },
        [`
          ${t}-handler-up-disabled,
          ${t}-handler-down-disabled
        `]: {
          cursor: "not-allowed"
        },
        [`
          ${t}-handler-up-disabled:hover &-handler-up-inner,
          ${t}-handler-down-disabled:hover &-handler-down-inner
        `]: {
          color: y
        }
      }
    },
    // Border-less
    {
      [`${t}-borderless`]: {
        borderColor: "transparent",
        boxShadow: "none",
        [`${t}-handler-down`]: {
          borderBlockStartWidth: 0
        }
      }
    }
  ];
}, Jk = (e) => {
  const {
    componentCls: t,
    inputPaddingHorizontal: n,
    inputAffixPadding: o,
    controlWidth: r,
    borderRadiusLG: a,
    borderRadiusSM: i
  } = e;
  return {
    [`${t}-affix-wrapper`]: h(h(h({}, Ta(e)), Ii(e, `${t}-affix-wrapper`)), {
      // or number handler will cover form status
      position: "relative",
      display: "inline-flex",
      width: r,
      padding: 0,
      paddingInlineStart: n,
      "&-lg": {
        borderRadius: a
      },
      "&-sm": {
        borderRadius: i
      },
      [`&:not(${t}-affix-wrapper-disabled):hover`]: h(h({}, Ia(e)), {
        zIndex: 1
      }),
      "&-focused, &:focus": {
        zIndex: 1
      },
      "&-disabled": {
        [`${t}[disabled]`]: {
          background: "transparent"
        }
      },
      [`> div${t}`]: {
        width: "100%",
        border: "none",
        outline: "none",
        [`&${t}-focused`]: {
          boxShadow: "none !important"
        }
      },
      [`input${t}-input`]: {
        padding: 0
      },
      "&::before": {
        width: 0,
        visibility: "hidden",
        content: '"\\a0"'
      },
      [`${t}-handler-wrap`]: {
        zIndex: 2
      },
      [t]: {
        "&-prefix, &-suffix": {
          display: "flex",
          flex: "none",
          alignItems: "center",
          pointerEvents: "none"
        },
        "&-prefix": {
          marginInlineEnd: o
        },
        "&-suffix": {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineEnd: 0,
          zIndex: 1,
          height: "100%",
          marginInlineEnd: n,
          marginInlineStart: o
        }
      }
    })
  };
}, e8 = ht("InputNumber", (e) => {
  const t = ks(e);
  return [
    Zk(t),
    Jk(t),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    xi(t)
  ];
}, (e) => ({
  controlWidth: 90,
  handleWidth: e.controlHeightSM - e.lineWidth * 2,
  handleFontSize: e.fontSize / 2,
  handleVisible: "auto"
}));
var t8 = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const mh = gC(), n8 = () => h(h({}, mh), {
  size: Ze(),
  bordered: Me(!0),
  placeholder: String,
  name: String,
  id: String,
  type: String,
  addonBefore: W.any,
  addonAfter: W.any,
  prefix: W.any,
  "onUpdate:value": mh.onChange,
  valueModifiers: Object,
  status: Ze()
}), Uu = J({
  compatConfig: {
    MODE: 3
  },
  name: "AInputNumber",
  inheritAttrs: !1,
  props: n8(),
  // emits: ['focus', 'blur', 'change', 'input', 'update:value'],
  slots: Object,
  setup(e, t) {
    let {
      emit: n,
      expose: o,
      attrs: r,
      slots: a
    } = t;
    const i = Lt(), l = rn.useInject(), u = T(() => Po(l.status, e.status)), {
      prefixCls: s,
      size: c,
      direction: d,
      disabled: f
    } = Ke("input-number", e), {
      compactSize: p,
      compactItemClassnames: v
    } = Dr(s, d), g = Cn(), b = T(() => {
      var E;
      return (E = f.value) !== null && E !== void 0 ? E : g.value;
    }), [y, S] = e8(s), w = T(() => p.value || c.value), C = K(e.value === void 0 ? e.defaultValue : e.value), $ = K(!1);
    le(() => e.value, () => {
      C.value = e.value;
    });
    const O = K(null), x = () => {
      var E;
      (E = O.value) === null || E === void 0 || E.focus();
    };
    o({
      focus: x,
      blur: () => {
        var E;
        (E = O.value) === null || E === void 0 || E.blur();
      }
    });
    const _ = (E) => {
      e.value === void 0 && (C.value = E), n("update:value", E), n("change", E), i.onFieldChange();
    }, N = (E) => {
      $.value = !1, n("blur", E), i.onFieldBlur();
    }, I = (E) => {
      $.value = !0, n("focus", E);
    };
    return () => {
      var E, B, k, P;
      const {
        hasFeedback: R,
        isFormItemInput: D,
        feedbackIcon: A
      } = l, H = (E = e.id) !== null && E !== void 0 ? E : i.id.value, j = h(h(h({}, r), e), {
        id: H,
        disabled: b.value
      }), {
        class: z,
        bordered: F,
        readonly: U,
        style: Q,
        addonBefore: q = (B = a.addonBefore) === null || B === void 0 ? void 0 : B.call(a),
        addonAfter: oe = (k = a.addonAfter) === null || k === void 0 ? void 0 : k.call(a),
        prefix: Z = (P = a.prefix) === null || P === void 0 ? void 0 : P.call(a),
        valueModifiers: ne = {}
      } = j, Y = t8(j, ["class", "bordered", "readonly", "style", "addonBefore", "addonAfter", "prefix", "valueModifiers"]), V = s.value, X = ae({
        [`${V}-lg`]: w.value === "large",
        [`${V}-sm`]: w.value === "small",
        [`${V}-rtl`]: d.value === "rtl",
        [`${V}-readonly`]: U,
        [`${V}-borderless`]: !F,
        [`${V}-in-form-item`]: D
      }, dn(V, u.value), z, v.value, S.value);
      let re = m(Qk, L(L({}, pt(Y, ["size", "defaultValue"])), {}, {
        ref: O,
        lazy: !!ne.lazy,
        value: C.value,
        class: X,
        prefixCls: V,
        readonly: U,
        onChange: _,
        onBlur: N,
        onFocus: I
      }), {
        upHandler: a.upIcon ? () => m("span", {
          class: `${V}-handler-up-inner`
        }, [a.upIcon()]) : () => m(mp, {
          class: `${V}-handler-up-inner`
        }, null),
        downHandler: a.downIcon ? () => m("span", {
          class: `${V}-handler-down-inner`
        }, [a.downIcon()]) : () => m(ws, {
          class: `${V}-handler-down-inner`
        }, null)
      });
      const ie = Ku(q) || Ku(oe), he = Ku(Z);
      if (he || R) {
        const ge = ae(`${V}-affix-wrapper`, dn(`${V}-affix-wrapper`, u.value, R), {
          [`${V}-affix-wrapper-focused`]: $.value,
          [`${V}-affix-wrapper-disabled`]: b.value,
          [`${V}-affix-wrapper-sm`]: w.value === "small",
          [`${V}-affix-wrapper-lg`]: w.value === "large",
          [`${V}-affix-wrapper-rtl`]: d.value === "rtl",
          [`${V}-affix-wrapper-readonly`]: U,
          [`${V}-affix-wrapper-borderless`]: !F,
          // className will go to addon wrapper
          [`${z}`]: !ie && z
        }, S.value);
        re = m("div", {
          class: ge,
          style: Q,
          onClick: x
        }, [he && m("span", {
          class: `${V}-prefix`
        }, [Z]), re, R && m("span", {
          class: `${V}-suffix`
        }, [A])]);
      }
      if (ie) {
        const ge = `${V}-group`, we = `${ge}-addon`, Le = q ? m("div", {
          class: we
        }, [q]) : null, be = oe ? m("div", {
          class: we
        }, [oe]) : null, pe = ae(`${V}-wrapper`, ge, {
          [`${ge}-rtl`]: d.value === "rtl"
        }, S.value), xe = ae(`${V}-group-wrapper`, {
          [`${V}-group-wrapper-sm`]: w.value === "small",
          [`${V}-group-wrapper-lg`]: w.value === "large",
          [`${V}-group-wrapper-rtl`]: d.value === "rtl"
        }, dn(`${s}-group-wrapper`, u.value, R), z, S.value);
        re = m("div", {
          class: xe,
          style: Q
        }, [m("div", {
          class: pe
        }, [Le && m(zl, null, {
          default: () => [m(Ll, null, {
            default: () => [Le]
          })]
        }), re, be && m(zl, null, {
          default: () => [m(Ll, null, {
            default: () => [be]
          })]
        })])]);
      }
      return y(Tt(re, {
        style: Q
      }));
    };
  }
}), hC = h(Uu, {
  install: (e) => (e.component(Uu.name, Uu), e)
});
function o8(e, t, n) {
  var o = n || {}, r = o.noTrailing, a = r === void 0 ? !1 : r, i = o.noLeading, l = i === void 0 ? !1 : i, u = o.debounceMode, s = u === void 0 ? void 0 : u, c, d = !1, f = 0;
  function p() {
    c && clearTimeout(c);
  }
  function v(b) {
    var y = b || {}, S = y.upcomingOnly, w = S === void 0 ? !1 : S;
    p(), d = !w;
  }
  function g() {
    for (var b = arguments.length, y = new Array(b), S = 0; S < b; S++)
      y[S] = arguments[S];
    var w = this, C = Date.now() - f;
    if (d)
      return;
    function $() {
      f = Date.now(), t.apply(w, y);
    }
    function O() {
      c = void 0;
    }
    !l && s && !c && $(), p(), s === void 0 && C > e ? l ? (f = Date.now(), a || (c = setTimeout(s ? O : $, e))) : $() : a !== !0 && (c = setTimeout(s ? O : $, s === void 0 ? e - C : e));
  }
  return g.cancel = v, g;
}
function r8(e, t, n) {
  var o = {}, r = o.atBegin, a = r === void 0 ? !1 : r;
  return o8(e, t, {
    debounceMode: a !== !1
  });
}
const a8 = new Xe("antSpinMove", {
  to: {
    opacity: 1
  }
}), i8 = new Xe("antRotate", {
  to: {
    transform: "rotate(405deg)"
  }
}), l8 = (e) => ({
  [`${e.componentCls}`]: h(h({}, st(e)), {
    position: "absolute",
    display: "none",
    color: e.colorPrimary,
    textAlign: "center",
    verticalAlign: "middle",
    opacity: 0,
    transition: `transform ${e.motionDurationSlow} ${e.motionEaseInOutCirc}`,
    "&-spinning": {
      position: "static",
      display: "inline-block",
      opacity: 1
    },
    "&-nested-loading": {
      position: "relative",
      [`> div > ${e.componentCls}`]: {
        position: "absolute",
        top: 0,
        insetInlineStart: 0,
        zIndex: 4,
        display: "block",
        width: "100%",
        height: "100%",
        maxHeight: e.contentHeight,
        [`${e.componentCls}-dot`]: {
          position: "absolute",
          top: "50%",
          insetInlineStart: "50%",
          margin: -e.spinDotSize / 2
        },
        [`${e.componentCls}-text`]: {
          position: "absolute",
          top: "50%",
          width: "100%",
          paddingTop: (e.spinDotSize - e.fontSize) / 2 + 2,
          textShadow: `0 1px 2px ${e.colorBgContainer}`
          // FIXME: shadow
        },
        [`&${e.componentCls}-show-text ${e.componentCls}-dot`]: {
          marginTop: -(e.spinDotSize / 2) - 10
        },
        "&-sm": {
          [`${e.componentCls}-dot`]: {
            margin: -e.spinDotSizeSM / 2
          },
          [`${e.componentCls}-text`]: {
            paddingTop: (e.spinDotSizeSM - e.fontSize) / 2 + 2
          },
          [`&${e.componentCls}-show-text ${e.componentCls}-dot`]: {
            marginTop: -(e.spinDotSizeSM / 2) - 10
          }
        },
        "&-lg": {
          [`${e.componentCls}-dot`]: {
            margin: -(e.spinDotSizeLG / 2)
          },
          [`${e.componentCls}-text`]: {
            paddingTop: (e.spinDotSizeLG - e.fontSize) / 2 + 2
          },
          [`&${e.componentCls}-show-text ${e.componentCls}-dot`]: {
            marginTop: -(e.spinDotSizeLG / 2) - 10
          }
        }
      },
      [`${e.componentCls}-container`]: {
        position: "relative",
        transition: `opacity ${e.motionDurationSlow}`,
        "&::after": {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: 0,
          insetInlineStart: 0,
          zIndex: 10,
          width: "100%",
          height: "100%",
          background: e.colorBgContainer,
          opacity: 0,
          transition: `all ${e.motionDurationSlow}`,
          content: '""',
          pointerEvents: "none"
        }
      },
      [`${e.componentCls}-blur`]: {
        clear: "both",
        opacity: 0.5,
        userSelect: "none",
        pointerEvents: "none",
        "&::after": {
          opacity: 0.4,
          pointerEvents: "auto"
        }
      }
    },
    // tip
    // ------------------------------
    "&-tip": {
      color: e.spinDotDefault
    },
    // dots
    // ------------------------------
    [`${e.componentCls}-dot`]: {
      position: "relative",
      display: "inline-block",
      fontSize: e.spinDotSize,
      width: "1em",
      height: "1em",
      "&-item": {
        position: "absolute",
        display: "block",
        width: (e.spinDotSize - e.marginXXS / 2) / 2,
        height: (e.spinDotSize - e.marginXXS / 2) / 2,
        backgroundColor: e.colorPrimary,
        borderRadius: "100%",
        transform: "scale(0.75)",
        transformOrigin: "50% 50%",
        opacity: 0.3,
        animationName: a8,
        animationDuration: "1s",
        animationIterationCount: "infinite",
        animationTimingFunction: "linear",
        animationDirection: "alternate",
        "&:nth-child(1)": {
          top: 0,
          insetInlineStart: 0
        },
        "&:nth-child(2)": {
          top: 0,
          insetInlineEnd: 0,
          animationDelay: "0.4s"
        },
        "&:nth-child(3)": {
          insetInlineEnd: 0,
          bottom: 0,
          animationDelay: "0.8s"
        },
        "&:nth-child(4)": {
          bottom: 0,
          insetInlineStart: 0,
          animationDelay: "1.2s"
        }
      },
      "&-spin": {
        transform: "rotate(45deg)",
        animationName: i8,
        animationDuration: "1.2s",
        animationIterationCount: "infinite",
        animationTimingFunction: "linear"
      }
    },
    // Sizes
    // ------------------------------
    // small
    [`&-sm ${e.componentCls}-dot`]: {
      fontSize: e.spinDotSizeSM,
      i: {
        width: (e.spinDotSizeSM - e.marginXXS / 2) / 2,
        height: (e.spinDotSizeSM - e.marginXXS / 2) / 2
      }
    },
    // large
    [`&-lg ${e.componentCls}-dot`]: {
      fontSize: e.spinDotSizeLG,
      i: {
        width: (e.spinDotSizeLG - e.marginXXS) / 2,
        height: (e.spinDotSizeLG - e.marginXXS) / 2
      }
    },
    [`&${e.componentCls}-show-text ${e.componentCls}-text`]: {
      display: "block"
    }
  })
}), s8 = ht("Spin", (e) => {
  const t = qe(e, {
    spinDotDefault: e.colorTextDescription,
    spinDotSize: e.controlHeightLG / 2,
    spinDotSizeSM: e.controlHeightLG * 0.35,
    spinDotSizeLG: e.controlHeight
  });
  return [l8(t)];
}, {
  contentHeight: 400
});
var u8 = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const c8 = () => ({
  prefixCls: String,
  spinning: {
    type: Boolean,
    default: void 0
  },
  size: String,
  wrapperClassName: String,
  tip: W.any,
  delay: Number,
  indicator: W.any
});
let Cl = null;
function d8(e, t) {
  return !!e && !!t && !isNaN(Number(t));
}
function f8(e) {
  const t = e.indicator;
  Cl = typeof t == "function" ? t : () => m(t, null, null);
}
const ia = J({
  compatConfig: {
    MODE: 3
  },
  name: "ASpin",
  inheritAttrs: !1,
  props: bt(c8(), {
    size: "default",
    spinning: !0,
    wrapperClassName: ""
  }),
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const {
      prefixCls: r,
      size: a,
      direction: i
    } = Ke("spin", e), [l, u] = s8(r), s = K(e.spinning && !d8(e.spinning, e.delay));
    let c;
    return le([() => e.spinning, () => e.delay], () => {
      c == null || c.cancel(), c = r8(e.delay, () => {
        s.value = e.spinning;
      }), c == null || c();
    }, {
      immediate: !0,
      flush: "post"
    }), at(() => {
      c == null || c.cancel();
    }), () => {
      var d, f;
      const {
        class: p
      } = n, v = u8(n, ["class"]), {
        tip: g = (d = o.tip) === null || d === void 0 ? void 0 : d.call(o)
      } = e, b = (f = o.default) === null || f === void 0 ? void 0 : f.call(o), y = {
        [u.value]: !0,
        [r.value]: !0,
        [`${r.value}-sm`]: a.value === "small",
        [`${r.value}-lg`]: a.value === "large",
        [`${r.value}-spinning`]: s.value,
        [`${r.value}-show-text`]: !!g,
        [`${r.value}-rtl`]: i.value === "rtl",
        [p]: !!p
      };
      function S(C) {
        const $ = `${C}-dot`;
        let O = Uo(o, e, "indicator");
        return O === null ? null : (Array.isArray(O) && (O = O.length === 1 ? O[0] : O), Wo(O) ? Ko(O, {
          class: $
        }) : Cl && Wo(Cl()) ? Ko(Cl(), {
          class: $
        }) : m("span", {
          class: `${$} ${C}-dot-spin`
        }, [m("i", {
          class: `${C}-dot-item`
        }, null), m("i", {
          class: `${C}-dot-item`
        }, null), m("i", {
          class: `${C}-dot-item`
        }, null), m("i", {
          class: `${C}-dot-item`
        }, null)]));
      }
      const w = m("div", L(L({}, v), {}, {
        class: y,
        "aria-live": "polite",
        "aria-busy": s.value
      }), [S(r.value), g ? m("div", {
        class: `${r.value}-text`
      }, [g]) : null]);
      if (b && nn(b).length) {
        const C = {
          [`${r.value}-container`]: !0,
          [`${r.value}-blur`]: s.value
        };
        return l(m("div", {
          class: [`${r.value}-nested-loading`, e.wrapperClassName, u.value]
        }, [s.value && m("div", {
          key: "loading"
        }, [w]), m("div", {
          class: C,
          key: "container"
        }, [b])]));
      }
      return l(w);
    };
  }
});
ia.setDefaultIndicator = f8;
ia.install = function(e) {
  return e.component(ia.name, ia), e;
};
function p8(e) {
  const {
    selectionStart: t
  } = e;
  return e.value.slice(0, t);
}
function v8(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return (Array.isArray(t) ? t : [t]).reduce((o, r) => {
    const a = e.lastIndexOf(r);
    return a > o.location ? {
      location: a,
      prefix: r
    } : o;
  }, {
    location: -1,
    prefix: ""
  });
}
function gh(e) {
  return (e || "").toLowerCase();
}
function m8(e, t, n) {
  const o = e[0];
  if (!o || o === n)
    return e;
  let r = e;
  const a = t.length;
  for (let i = 0; i < a; i += 1)
    if (gh(r[i]) !== gh(t[i])) {
      r = r.slice(i);
      break;
    } else
      i === a - 1 && (r = r.slice(a));
  return r;
}
function g8(e, t) {
  const {
    measureLocation: n,
    prefix: o,
    targetText: r,
    selectionStart: a,
    split: i
  } = t;
  let l = e.slice(0, n);
  l[l.length - i.length] === i && (l = l.slice(0, l.length - i.length)), l && (l = `${l}${i}`);
  let u = m8(e.slice(a), r.slice(a - n - o.length), i);
  u.slice(0, i.length) === i && (u = u.slice(i.length));
  const s = `${l}${o}${r}${i}`;
  return {
    text: `${s}${u}`,
    selectionLocation: s.length
  };
}
function h8(e, t) {
  e.setSelectionRange(t, t), e.blur(), e.focus();
}
function b8(e, t) {
  const {
    split: n
  } = t;
  return !n || e.indexOf(n) === -1;
}
function y8(e, t) {
  let {
    value: n = ""
  } = t;
  const o = e.toLowerCase();
  return n.toLowerCase().indexOf(o) !== -1;
}
const bC = Symbol("MentionsContextKey");
function S8() {
}
const $8 = J({
  compatConfig: {
    MODE: 3
  },
  name: "DropdownMenu",
  props: {
    prefixCls: String,
    options: {
      type: Array,
      default: () => []
    }
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      activeIndex: o,
      setActiveIndex: r,
      selectOption: a,
      onFocus: i = S8,
      loading: l
    } = nt(bC, {
      activeIndex: K(),
      loading: K(!1)
    });
    let u;
    const s = (c) => {
      clearTimeout(u), u = setTimeout(() => {
        i(c);
      });
    };
    return at(() => {
      clearTimeout(u);
    }), () => {
      var c;
      const {
        prefixCls: d,
        options: f
      } = e, p = f[o.value] || {};
      return m(ho, {
        prefixCls: `${d}-menu`,
        activeKey: p.value,
        onSelect: (v) => {
          let {
            key: g
          } = v;
          const b = f.find((y) => {
            let {
              value: S
            } = y;
            return S === g;
          });
          a(b);
        },
        onMousedown: s
      }, {
        default: () => [!l.value && f.map((v, g) => {
          var b, y;
          const {
            value: S,
            disabled: w,
            label: C = v.value,
            class: $,
            style: O
          } = v;
          return m(go, {
            key: S,
            disabled: w,
            onMouseenter: () => {
              r(g);
            },
            class: $,
            style: O
          }, {
            default: () => [(y = (b = n.option) === null || b === void 0 ? void 0 : b.call(n, v)) !== null && y !== void 0 ? y : typeof C == "function" ? C(v) : C]
          });
        }), !l.value && f.length === 0 ? m(go, {
          key: "notFoundContent",
          disabled: !0
        }, {
          default: () => [(c = n.notFoundContent) === null || c === void 0 ? void 0 : c.call(n)]
        }) : null, l.value && m(go, {
          key: "loading",
          disabled: !0
        }, {
          default: () => [m(ia, {
            size: "small"
          }, null)]
        })]
      });
    };
  }
}), C8 = {
  bottomRight: {
    points: ["tl", "br"],
    offset: [0, 4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  bottomLeft: {
    points: ["tr", "bl"],
    offset: [0, 4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  topRight: {
    points: ["bl", "tr"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  topLeft: {
    points: ["br", "tl"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  }
}, w8 = J({
  compatConfig: {
    MODE: 3
  },
  name: "KeywordTrigger",
  props: {
    loading: {
      type: Boolean,
      default: void 0
    },
    options: {
      type: Array,
      default: () => []
    },
    prefixCls: String,
    placement: String,
    visible: {
      type: Boolean,
      default: void 0
    },
    transitionName: String,
    getPopupContainer: Function,
    direction: String,
    dropdownClassName: String
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = () => `${e.prefixCls}-dropdown`, r = () => {
      const {
        options: i
      } = e;
      return m($8, {
        prefixCls: o(),
        options: i
      }, {
        notFoundContent: n.notFoundContent,
        option: n.option
      });
    }, a = T(() => {
      const {
        placement: i,
        direction: l
      } = e;
      let u = "topRight";
      return l === "rtl" ? u = i === "top" ? "topLeft" : "bottomLeft" : u = i === "top" ? "topRight" : "bottomRight", u;
    });
    return () => {
      const {
        visible: i,
        transitionName: l,
        getPopupContainer: u
      } = e;
      return m(wa, {
        prefixCls: o(),
        popupVisible: i,
        popup: r(),
        popupClassName: e.dropdownClassName,
        popupPlacement: a.value,
        popupTransitionName: l,
        builtinPlacements: C8,
        getPopupContainer: u
      }, {
        default: n.default
      });
    };
  }
}), x8 = ro("top", "bottom"), yC = {
  autofocus: {
    type: Boolean,
    default: void 0
  },
  prefix: W.oneOfType([W.string, W.arrayOf(W.string)]),
  prefixCls: String,
  value: String,
  disabled: {
    type: Boolean,
    default: void 0
  },
  split: String,
  transitionName: String,
  placement: W.oneOf(x8),
  character: W.any,
  characterRender: Function,
  filterOption: {
    type: [Boolean, Function]
  },
  validateSearch: Function,
  getPopupContainer: {
    type: Function
  },
  options: Nt(),
  loading: {
    type: Boolean,
    default: void 0
  },
  rows: [Number, String],
  direction: {
    type: String
  }
}, SC = h(h({}, yC), {
  dropdownClassName: String
}), $C = {
  prefix: "@",
  split: " ",
  rows: 1,
  validateSearch: b8,
  filterOption: () => y8
};
bt(SC, $C);
var hh = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function bh() {
}
const O8 = J({
  compatConfig: {
    MODE: 3
  },
  name: "Mentions",
  inheritAttrs: !1,
  props: bt(SC, $C),
  emits: ["change", "select", "search", "focus", "blur", "pressenter"],
  setup(e, t) {
    let {
      emit: n,
      attrs: o,
      expose: r,
      slots: a
    } = t;
    const i = G(null), l = G(null), u = G(), s = Et({
      value: e.value || "",
      measuring: !1,
      measureLocation: 0,
      measureText: null,
      measurePrefix: "",
      activeIndex: 0,
      isFocus: !1
    });
    Ve(() => {
      s.value = e.value;
    });
    const c = (I) => {
      n("change", I);
    }, d = (I) => {
      let {
        target: {
          value: E
        }
      } = I;
      c(E);
    }, f = (I, E, B) => {
      h(s, {
        measuring: !0,
        measureText: I,
        measurePrefix: E,
        measureLocation: B,
        activeIndex: 0
      });
    }, p = (I) => {
      h(s, {
        measuring: !1,
        measureLocation: 0,
        measureText: null
      }), I == null || I();
    }, v = (I) => {
      const {
        which: E
      } = I;
      if (s.measuring) {
        if (E === ee.UP || E === ee.DOWN) {
          const B = M.value.length, k = E === ee.UP ? -1 : 1, P = (s.activeIndex + k + B) % B;
          s.activeIndex = P, I.preventDefault();
        } else if (E === ee.ESC)
          p();
        else if (E === ee.ENTER) {
          if (I.preventDefault(), !M.value.length) {
            p();
            return;
          }
          const B = M.value[s.activeIndex];
          $(B);
        }
      }
    }, g = (I) => {
      const {
        key: E,
        which: B
      } = I, {
        measureText: k,
        measuring: P
      } = s, {
        prefix: R,
        validateSearch: D
      } = e, A = I.target;
      if (A.composing)
        return;
      const H = p8(A), {
        location: j,
        prefix: z
      } = v8(H, R);
      if ([ee.ESC, ee.UP, ee.DOWN, ee.ENTER].indexOf(B) === -1)
        if (j !== -1) {
          const F = H.slice(j + z.length), U = D(F, e), Q = !!x(F).length;
          U ? (E === z || E === "Shift" || P || F !== k && Q) && f(F, z, j) : P && p(), U && n("search", F, z);
        } else
          P && p();
    }, b = (I) => {
      s.measuring || n("pressenter", I);
    }, y = (I) => {
      w(I);
    }, S = (I) => {
      C(I);
    }, w = (I) => {
      clearTimeout(u.value);
      const {
        isFocus: E
      } = s;
      !E && I && n("focus", I), s.isFocus = !0;
    }, C = (I) => {
      u.value = setTimeout(() => {
        s.isFocus = !1, p(), n("blur", I);
      }, 100);
    }, $ = (I) => {
      const {
        split: E
      } = e, {
        value: B = ""
      } = I, {
        text: k,
        selectionLocation: P
      } = g8(s.value, {
        measureLocation: s.measureLocation,
        targetText: B,
        prefix: s.measurePrefix,
        selectionStart: l.value.getSelectionStart(),
        split: E
      });
      c(k), p(() => {
        h8(l.value.input, P);
      }), n("select", I, s.measurePrefix);
    }, O = (I) => {
      s.activeIndex = I;
    }, x = (I) => {
      const E = I || s.measureText || "", {
        filterOption: B
      } = e;
      return e.options.filter((P) => B ? B(E, P) : !0);
    }, M = T(() => x());
    return r({
      blur: () => {
        l.value.blur();
      },
      focus: () => {
        l.value.focus();
      }
    }), ot(bC, {
      activeIndex: Je(s, "activeIndex"),
      setActiveIndex: O,
      selectOption: $,
      onFocus: w,
      onBlur: C,
      loading: Je(e, "loading")
    }), Co(() => {
      mt(() => {
        s.measuring && (i.value.scrollTop = l.value.getScrollTop());
      });
    }), () => {
      const {
        measureLocation: I,
        measurePrefix: E,
        measuring: B
      } = s, {
        prefixCls: k,
        placement: P,
        transitionName: R,
        getPopupContainer: D,
        direction: A
      } = e, H = hh(e, ["prefixCls", "placement", "transitionName", "getPopupContainer", "direction"]), {
        class: j,
        style: z
      } = o, F = hh(o, ["class", "style"]), U = pt(H, ["value", "prefix", "split", "validateSearch", "filterOption", "options", "loading"]), Q = h(h(h({}, U), F), {
        onChange: bh,
        onSelect: bh,
        value: s.value,
        onInput: d,
        onBlur: S,
        onKeydown: v,
        onKeyup: g,
        onFocus: y,
        onPressenter: b
      });
      return m("div", {
        class: ae(k, j),
        style: z
      }, [m(Ss, L(L({}, Q), {}, {
        ref: l,
        tag: "textarea"
      }), null), B && m("div", {
        ref: i,
        class: `${k}-measure`
      }, [s.value.slice(0, I), m(w8, {
        prefixCls: k,
        transitionName: R,
        dropdownClassName: e.dropdownClassName,
        placement: P,
        options: B ? M.value : [],
        visible: !0,
        direction: A,
        getPopupContainer: D
      }, {
        default: () => [m("span", null, [E])],
        notFoundContent: a.notFoundContent,
        option: a.option
      }), s.value.slice(I + E.length)])]);
    };
  }
}), P8 = {
  value: String,
  disabled: Boolean,
  payload: He()
}, CC = h(h({}, P8), {
  label: Wt([])
}), wC = {
  name: "Option",
  props: CC,
  render(e, t) {
    let {
      slots: n
    } = t;
    var o;
    return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
  }
};
J(h({
  compatConfig: {
    MODE: 3
  }
}, wC));
const I8 = (e) => {
  const {
    componentCls: t,
    colorTextDisabled: n,
    controlItemBgHover: o,
    controlPaddingHorizontal: r,
    colorText: a,
    motionDurationSlow: i,
    lineHeight: l,
    controlHeight: u,
    inputPaddingHorizontal: s,
    inputPaddingVertical: c,
    fontSize: d,
    colorBgElevated: f,
    borderRadiusLG: p,
    boxShadowSecondary: v
  } = e, g = Math.round((e.controlHeight - e.fontSize * e.lineHeight) / 2);
  return {
    [t]: h(h(h(h(h({}, st(e)), Ta(e)), {
      position: "relative",
      display: "inline-block",
      height: "auto",
      padding: 0,
      overflow: "hidden",
      lineHeight: l,
      whiteSpace: "pre-wrap",
      verticalAlign: "bottom"
    }), Ii(e, t)), {
      "&-disabled": {
        "> textarea": h({}, Zf(e))
      },
      "&-focused": h({}, Yo(e)),
      [`&-affix-wrapper ${t}-suffix`]: {
        position: "absolute",
        top: 0,
        insetInlineEnd: s,
        bottom: 0,
        zIndex: 1,
        display: "inline-flex",
        alignItems: "center",
        margin: "auto"
      },
      // ================= Input Area =================
      [`> textarea, ${t}-measure`]: {
        color: a,
        boxSizing: "border-box",
        minHeight: u - 2,
        margin: 0,
        padding: `${c}px ${s}px`,
        overflow: "inherit",
        overflowX: "hidden",
        overflowY: "auto",
        fontWeight: "inherit",
        fontSize: "inherit",
        fontFamily: "inherit",
        fontStyle: "inherit",
        fontVariant: "inherit",
        fontSizeAdjust: "inherit",
        fontStretch: "inherit",
        lineHeight: "inherit",
        direction: "inherit",
        letterSpacing: "inherit",
        whiteSpace: "inherit",
        textAlign: "inherit",
        verticalAlign: "top",
        wordWrap: "break-word",
        wordBreak: "inherit",
        tabSize: "inherit"
      },
      "> textarea": h({
        width: "100%",
        border: "none",
        outline: "none",
        resize: "none",
        backgroundColor: "inherit"
      }, Qf(e.colorTextPlaceholder)),
      [`${t}-measure`]: {
        position: "absolute",
        top: 0,
        insetInlineEnd: 0,
        bottom: 0,
        insetInlineStart: 0,
        zIndex: -1,
        color: "transparent",
        pointerEvents: "none",
        "> span": {
          display: "inline-block",
          minHeight: "1em"
        }
      },
      // ================== Dropdown ==================
      "&-dropdown": h(h({}, st(e)), {
        position: "absolute",
        top: -9999,
        insetInlineStart: -9999,
        zIndex: e.zIndexPopup,
        boxSizing: "border-box",
        fontSize: d,
        fontVariant: "initial",
        backgroundColor: f,
        borderRadius: p,
        outline: "none",
        boxShadow: v,
        "&-hidden": {
          display: "none"
        },
        [`${t}-dropdown-menu`]: {
          maxHeight: e.dropdownHeight,
          marginBottom: 0,
          paddingInlineStart: 0,
          overflow: "auto",
          listStyle: "none",
          outline: "none",
          "&-item": h(h({}, So), {
            position: "relative",
            display: "block",
            minWidth: e.controlItemWidth,
            padding: `${g}px ${r}px`,
            color: a,
            fontWeight: "normal",
            lineHeight: l,
            cursor: "pointer",
            transition: `background ${i} ease`,
            "&:hover": {
              backgroundColor: o
            },
            "&:first-child": {
              borderStartStartRadius: p,
              borderStartEndRadius: p,
              borderEndStartRadius: 0,
              borderEndEndRadius: 0
            },
            "&:last-child": {
              borderStartStartRadius: 0,
              borderStartEndRadius: 0,
              borderEndStartRadius: p,
              borderEndEndRadius: p
            },
            "&-disabled": {
              color: n,
              cursor: "not-allowed",
              "&:hover": {
                color: n,
                backgroundColor: o,
                cursor: "not-allowed"
              }
            },
            "&-selected": {
              color: a,
              fontWeight: e.fontWeightStrong,
              backgroundColor: o
            },
            "&-active": {
              backgroundColor: o
            }
          })
        }
      })
    })
  };
}, T8 = ht("Mentions", (e) => {
  const t = ks(e);
  return [I8(t)];
}, (e) => ({
  dropdownHeight: 250,
  controlItemWidth: 100,
  zIndexPopup: e.zIndexPopupBase + 50
}));
var yh = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function E8() {
  return !0;
}
const M8 = function() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    prefix: n = "@",
    split: o = " "
  } = t, r = Array.isArray(n) ? n : [n];
  return e.split(o).map(function() {
    let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", i = null;
    return r.some((l) => a.slice(0, l.length) === l ? (i = l, !0) : !1), i !== null ? {
      prefix: i,
      value: a.slice(i.length)
    } : null;
  }).filter((a) => !!a && !!a.value);
}, _8 = () => h(h({}, yC), {
  loading: {
    type: Boolean,
    default: void 0
  },
  onFocus: {
    type: Function
  },
  onBlur: {
    type: Function
  },
  onSelect: {
    type: Function
  },
  onChange: {
    type: Function
  },
  onPressenter: {
    type: Function
  },
  "onUpdate:value": {
    type: Function
  },
  notFoundContent: W.any,
  defaultValue: String,
  id: String,
  status: String
}), Gu = J({
  compatConfig: {
    MODE: 3
  },
  name: "AMentions",
  inheritAttrs: !1,
  props: _8(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: r,
      expose: a
    } = t;
    var i, l, u;
    process.env.NODE_ENV !== "production" && gt(!xt(((i = n.default) === null || i === void 0 ? void 0 : i.call(n)) || []).length, "Mentions", "`Mentions.Option` is deprecated. Please use `options` instead.");
    const {
      prefixCls: s,
      renderEmpty: c,
      direction: d
    } = Ke("mentions", e), [f, p] = T8(s), v = K(!1), g = K(null), b = K((u = (l = e.value) !== null && l !== void 0 ? l : e.defaultValue) !== null && u !== void 0 ? u : ""), y = Lt(), S = rn.useInject(), w = T(() => Po(S.status, e.status));
    iS({
      prefixCls: T(() => `${s.value}-menu`),
      mode: T(() => "vertical"),
      selectable: T(() => !1),
      onClick: () => {
      },
      validator: (B) => {
        let {
          mode: k
        } = B;
        Pt(!k || k === "vertical", "Mentions", `mode="${k}" is not supported for Mentions's Menu.`);
      }
    }), le(() => e.value, (B) => {
      b.value = B;
    });
    const C = (B) => {
      v.value = !0, o("focus", B);
    }, $ = (B) => {
      v.value = !1, o("blur", B), y.onFieldBlur();
    }, O = function() {
      for (var B = arguments.length, k = new Array(B), P = 0; P < B; P++)
        k[P] = arguments[P];
      o("select", ...k), v.value = !0;
    }, x = (B) => {
      e.value === void 0 && (b.value = B), o("update:value", B), o("change", B), y.onFieldChange();
    }, M = () => {
      const B = e.notFoundContent;
      return B !== void 0 ? B : n.notFoundContent ? n.notFoundContent() : c("Select");
    }, _ = () => {
      var B;
      return xt(((B = n.default) === null || B === void 0 ? void 0 : B.call(n)) || []).map((k) => {
        var P, R;
        return h(h({}, yb(k)), {
          label: (R = (P = k.children) === null || P === void 0 ? void 0 : P.default) === null || R === void 0 ? void 0 : R.call(P)
        });
      });
    };
    a({
      focus: () => {
        g.value.focus();
      },
      blur: () => {
        g.value.blur();
      }
    });
    const E = T(() => e.loading ? E8 : e.filterOption);
    return () => {
      const {
        disabled: B,
        getPopupContainer: k,
        rows: P = 1,
        id: R = y.id.value
      } = e, D = yh(e, ["disabled", "getPopupContainer", "rows", "id"]), {
        hasFeedback: A,
        feedbackIcon: H
      } = S, {
        class: j
      } = r, z = yh(r, ["class"]), F = pt(D, ["defaultValue", "onUpdate:value", "prefixCls"]), U = ae({
        [`${s.value}-disabled`]: B,
        [`${s.value}-focused`]: v.value,
        [`${s.value}-rtl`]: d.value === "rtl"
      }, dn(s.value, w.value), !A && j, p.value), Q = h(h(h(h({
        prefixCls: s.value
      }, F), {
        disabled: B,
        direction: d.value,
        filterOption: E.value,
        getPopupContainer: k,
        options: e.loading ? [{
          value: "ANTDV_SEARCHING",
          disabled: !0,
          label: m(ia, {
            size: "small"
          }, null)
        }] : e.options || _(),
        class: U
      }), z), {
        rows: P,
        onChange: x,
        onSelect: O,
        onFocus: C,
        onBlur: $,
        ref: g,
        value: b.value,
        id: R
      }), q = m(O8, L(L({}, Q), {}, {
        dropdownClassName: p.value
      }), {
        notFoundContent: M,
        option: n.option
      });
      return f(A ? m("div", {
        class: ae(`${s.value}-affix-wrapper`, dn(`${s.value}-affix-wrapper`, w.value, A), j, p.value)
      }, [q, m("span", {
        class: `${s.value}-suffix`
      }, [H])]) : q);
    };
  }
}), Yu = J(h(h({
  compatConfig: {
    MODE: 3
  }
}, wC), {
  name: "AMentionsOption",
  props: CC
})), D8 = h(Gu, {
  Option: Yu,
  getMentions: M8,
  install: (e) => (e.component(Gu.name, Gu), e.component(Yu.name, Yu), e)
});
var A8 = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
let cd;
const N8 = (e) => {
  cd = {
    x: e.pageX,
    y: e.pageY
  }, setTimeout(() => cd = null, 100);
};
g$() && Kn(document.documentElement, "click", N8, !0);
const R8 = () => ({
  prefixCls: String,
  /** @deprecated Please use `open` instead. */
  visible: {
    type: Boolean,
    default: void 0
  },
  open: {
    type: Boolean,
    default: void 0
  },
  confirmLoading: {
    type: Boolean,
    default: void 0
  },
  title: W.any,
  closable: {
    type: Boolean,
    default: void 0
  },
  closeIcon: W.any,
  onOk: Function,
  onCancel: Function,
  "onUpdate:visible": Function,
  "onUpdate:open": Function,
  onChange: Function,
  afterClose: Function,
  centered: {
    type: Boolean,
    default: void 0
  },
  width: [String, Number],
  footer: W.any,
  okText: W.any,
  okType: String,
  cancelText: W.any,
  icon: W.any,
  maskClosable: {
    type: Boolean,
    default: void 0
  },
  forceRender: {
    type: Boolean,
    default: void 0
  },
  okButtonProps: He(),
  cancelButtonProps: He(),
  destroyOnClose: {
    type: Boolean,
    default: void 0
  },
  wrapClassName: String,
  maskTransitionName: String,
  transitionName: String,
  getContainer: {
    type: [String, Function, Boolean, Object],
    default: void 0
  },
  zIndex: Number,
  bodyStyle: He(),
  maskStyle: He(),
  mask: {
    type: Boolean,
    default: void 0
  },
  keyboard: {
    type: Boolean,
    default: void 0
  },
  wrapProps: Object,
  focusTriggerAfterClose: {
    type: Boolean,
    default: void 0
  },
  modalRender: Function,
  mousePosition: He()
}), fn = J({
  compatConfig: {
    MODE: 3
  },
  name: "AModal",
  inheritAttrs: !1,
  props: bt(R8(), {
    width: 520,
    confirmLoading: !1,
    okType: "primary"
  }),
  setup(e, t) {
    let {
      emit: n,
      slots: o,
      attrs: r
    } = t;
    const [a] = Pr("Modal"), {
      prefixCls: i,
      rootPrefixCls: l,
      direction: u,
      getPopupContainer: s
    } = Ke("modal", e), [c, d] = jk(i);
    Pt(e.visible === void 0, "Modal", "`visible` will be removed in next major version, please use `open` instead.");
    const f = (g) => {
      n("update:visible", !1), n("update:open", !1), n("cancel", g), n("change", !1);
    }, p = (g) => {
      n("ok", g);
    }, v = () => {
      var g, b;
      const {
        okText: y = (g = o.okText) === null || g === void 0 ? void 0 : g.call(o),
        okType: S,
        cancelText: w = (b = o.cancelText) === null || b === void 0 ? void 0 : b.call(o),
        confirmLoading: C
      } = e;
      return m(We, null, [m(Zt, L({
        onClick: f
      }, e.cancelButtonProps), {
        default: () => [w || a.value.cancelText]
      }), m(Zt, L(L({}, eS(S)), {}, {
        loading: C,
        onClick: p
      }, e.okButtonProps), {
        default: () => [y || a.value.okText]
      })]);
    };
    return () => {
      var g, b;
      const {
        prefixCls: y,
        visible: S,
        open: w,
        wrapClassName: C,
        centered: $,
        getContainer: O,
        closeIcon: x = (g = o.closeIcon) === null || g === void 0 ? void 0 : g.call(o),
        focusTriggerAfterClose: M = !0
      } = e, _ = A8(e, ["prefixCls", "visible", "open", "wrapClassName", "centered", "getContainer", "closeIcon", "focusTriggerAfterClose"]), N = ae(C, {
        [`${i.value}-centered`]: !!$,
        [`${i.value}-wrap-rtl`]: u.value === "rtl"
      });
      return c(m(Fk, L(L(L({}, _), r), {}, {
        rootClassName: d.value,
        class: ae(d.value, r.class),
        getContainer: O || (s == null ? void 0 : s.value),
        prefixCls: i.value,
        wrapClassName: N,
        visible: w ?? S,
        onClose: f,
        focusTriggerAfterClose: M,
        transitionName: wr(l.value, "zoom", e.transitionName),
        maskTransitionName: wr(l.value, "fade", e.maskTransitionName),
        mousePosition: (b = _.mousePosition) !== null && b !== void 0 ? b : cd
      }), h(h({}, o), {
        footer: o.footer || v,
        closeIcon: () => m("span", {
          class: `${i.value}-close-x`
        }, [x || m(Qn, {
          class: `${i.value}-close-icon`
        }, null)])
      })));
    };
  }
}), F8 = () => {
  const e = K(!1);
  return at(() => {
    e.value = !0;
  }), e;
}, B8 = {
  type: {
    type: String
  },
  actionFn: Function,
  close: Function,
  autofocus: Boolean,
  prefixCls: String,
  buttonProps: He(),
  emitEvent: Boolean,
  quitOnNullishReturnValue: Boolean
};
function Sh(e) {
  return !!(e && e.then);
}
const $h = J({
  compatConfig: {
    MODE: 3
  },
  name: "ActionButton",
  props: B8,
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = K(!1), r = K(), a = K(!1);
    let i;
    const l = F8();
    ze(() => {
      e.autofocus && (i = setTimeout(() => {
        var d, f;
        return (f = (d = to(r.value)) === null || d === void 0 ? void 0 : d.focus) === null || f === void 0 ? void 0 : f.call(d);
      }));
    }), at(() => {
      clearTimeout(i);
    });
    const u = function() {
      for (var d, f = arguments.length, p = new Array(f), v = 0; v < f; v++)
        p[v] = arguments[v];
      (d = e.close) === null || d === void 0 || d.call(e, ...p);
    }, s = (d) => {
      Sh(d) && (a.value = !0, d.then(function() {
        l.value || (a.value = !1), u(...arguments), o.value = !1;
      }, (f) => (l.value || (a.value = !1), o.value = !1, Promise.reject(f))));
    }, c = (d) => {
      const {
        actionFn: f
      } = e;
      if (o.value)
        return;
      if (o.value = !0, !f) {
        u();
        return;
      }
      let p;
      if (e.emitEvent) {
        if (p = f(d), e.quitOnNullishReturnValue && !Sh(p)) {
          o.value = !1, u(d);
          return;
        }
      } else if (f.length)
        p = f(e.close), o.value = !1;
      else if (p = f(), !p) {
        u();
        return;
      }
      s(p);
    };
    return () => {
      const {
        type: d,
        prefixCls: f,
        buttonProps: p
      } = e;
      return m(Zt, L(L(L({}, eS(d)), {}, {
        onClick: c,
        loading: a.value,
        prefixCls: f
      }, p), {}, {
        ref: r
      }), n);
    };
  }
});
function Vr(e) {
  return typeof e == "function" ? e() : e;
}
const xC = J({
  name: "ConfirmDialog",
  inheritAttrs: !1,
  props: ["icon", "onCancel", "onOk", "close", "closable", "zIndex", "afterClose", "visible", "open", "keyboard", "centered", "getContainer", "maskStyle", "okButtonProps", "cancelButtonProps", "okType", "prefixCls", "okCancel", "width", "mask", "maskClosable", "okText", "cancelText", "autoFocusButton", "transitionName", "maskTransitionName", "type", "title", "content", "direction", "rootPrefixCls", "bodyStyle", "closeIcon", "modalRender", "focusTriggerAfterClose", "wrapClassName", "confirmPrefixCls", "footer"],
  setup(e, t) {
    let {
      attrs: n
    } = t;
    const [o] = Pr("Modal");
    return process.env.NODE_ENV !== "production" && Pt(e.visible === void 0, "Modal", "`visible` is deprecated, please use `open` instead."), () => {
      const {
        icon: r,
        onCancel: a,
        onOk: i,
        close: l,
        okText: u,
        closable: s = !1,
        zIndex: c,
        afterClose: d,
        keyboard: f,
        centered: p,
        getContainer: v,
        maskStyle: g,
        okButtonProps: b,
        cancelButtonProps: y,
        okCancel: S,
        width: w = 416,
        mask: C = !0,
        maskClosable: $ = !1,
        type: O,
        open: x,
        title: M,
        content: _,
        direction: N,
        closeIcon: I,
        modalRender: E,
        focusTriggerAfterClose: B,
        rootPrefixCls: k,
        bodyStyle: P,
        wrapClassName: R,
        footer: D
      } = e;
      let A = r;
      if (!r && r !== null)
        switch (O) {
          case "info":
            A = m(Ar, null, null);
            break;
          case "success":
            A = m(Io, null, null);
            break;
          case "error":
            A = m(vn, null, null);
            break;
          default:
            A = m(Qo, null, null);
        }
      const H = e.okType || "primary", j = e.prefixCls || "ant-modal", z = `${j}-confirm`, F = n.style || {}, U = S ?? O === "confirm", Q = e.autoFocusButton === null ? !1 : e.autoFocusButton || "ok", q = `${j}-confirm`, oe = ae(q, `${q}-${e.type}`, {
        [`${q}-rtl`]: N === "rtl"
      }, n.class), Z = o.value, ne = U && m($h, {
        actionFn: a,
        close: l,
        autofocus: Q === "cancel",
        buttonProps: y,
        prefixCls: `${k}-btn`
      }, {
        default: () => [Vr(e.cancelText) || Z.cancelText]
      });
      return m(fn, {
        prefixCls: j,
        class: oe,
        wrapClassName: ae({
          [`${q}-centered`]: !!p
        }, R),
        onCancel: (Y) => l == null ? void 0 : l({
          triggerCancel: !0
        }, Y),
        open: x,
        title: "",
        footer: "",
        transitionName: wr(k, "zoom", e.transitionName),
        maskTransitionName: wr(k, "fade", e.maskTransitionName),
        mask: C,
        maskClosable: $,
        maskStyle: g,
        style: F,
        bodyStyle: P,
        width: w,
        zIndex: c,
        afterClose: d,
        keyboard: f,
        centered: p,
        getContainer: v,
        closable: s,
        closeIcon: I,
        modalRender: E,
        focusTriggerAfterClose: B
      }, {
        default: () => [m("div", {
          class: `${z}-body-wrapper`
        }, [m("div", {
          class: `${z}-body`
        }, [Vr(A), M === void 0 ? null : m("span", {
          class: `${z}-title`
        }, [Vr(M)]), m("div", {
          class: `${z}-content`
        }, [Vr(_)])]), D !== void 0 ? Vr(D) : m("div", {
          class: `${z}-btns`
        }, [ne, m($h, {
          type: H,
          actionFn: i,
          close: l,
          autofocus: Q === "ok",
          buttonProps: b,
          prefixCls: `${k}-btn`
        }, {
          default: () => [Vr(u) || (U ? Z.okText : Z.justOkText)]
        })])])]
      });
    };
  }
}), dr = [], Mi = (e) => {
  const t = document.createDocumentFragment();
  let n = h(h({}, pt(e, ["parentContext", "appContext"])), {
    close: a,
    open: !0
  }), o = null;
  function r() {
    o && (hr(null, t), o = null);
    for (var s = arguments.length, c = new Array(s), d = 0; d < s; d++)
      c[d] = arguments[d];
    const f = c.some((p) => p && p.triggerCancel);
    e.onCancel && f && e.onCancel(() => {
    }, ...c.slice(1));
    for (let p = 0; p < dr.length; p++)
      if (dr[p] === a) {
        dr.splice(p, 1);
        break;
      }
  }
  function a() {
    for (var s = arguments.length, c = new Array(s), d = 0; d < s; d++)
      c[d] = arguments[d];
    n = h(h({}, n), {
      open: !1,
      afterClose: () => {
        typeof e.afterClose == "function" && e.afterClose(), r.apply(this, c);
      }
    }), n.visible && delete n.visible, i(n);
  }
  function i(s) {
    typeof s == "function" ? n = s(n) : n = h(h({}, n), s), o && nP(o, n, t);
  }
  const l = (s) => {
    const c = Vt, d = c.prefixCls, f = s.prefixCls || `${d}-modal`, p = c.iconPrefixCls, v = LB();
    return m(nC, L(L({}, c), {}, {
      prefixCls: d
    }), {
      default: () => [m(xC, L(L({}, s), {}, {
        rootPrefixCls: d,
        prefixCls: f,
        iconPrefixCls: p,
        locale: v,
        cancelText: s.cancelText || v.cancelText
      }), null)]
    });
  };
  function u(s) {
    const c = m(l, h({}, s));
    return c.appContext = e.parentContext || e.appContext || c.appContext, hr(c, t), c;
  }
  return o = u(n), dr.push(a), {
    destroy: a,
    update: i
  };
};
function OC(e) {
  return h(h({}, e), {
    type: "warning"
  });
}
function PC(e) {
  return h(h({}, e), {
    type: "info"
  });
}
function IC(e) {
  return h(h({}, e), {
    type: "success"
  });
}
function TC(e) {
  return h(h({}, e), {
    type: "error"
  });
}
function EC(e) {
  return h(h({}, e), {
    type: "confirm"
  });
}
const k8 = () => ({
  config: Object,
  afterClose: Function,
  destroyAction: Function,
  open: Boolean
}), L8 = J({
  name: "HookModal",
  inheritAttrs: !1,
  props: bt(k8(), {
    config: {
      width: 520,
      okType: "primary"
    }
  }),
  setup(e, t) {
    let {
      expose: n
    } = t;
    var o;
    const r = T(() => e.open), a = T(() => e.config), {
      direction: i,
      getPrefixCls: l
    } = rs(), u = l("modal"), s = l(), c = () => {
      var v, g;
      e == null || e.afterClose(), (g = (v = a.value).afterClose) === null || g === void 0 || g.call(v);
    }, d = function() {
      e.destroyAction(...arguments);
    };
    n({
      destroy: d
    });
    const f = (o = a.value.okCancel) !== null && o !== void 0 ? o : a.value.type === "confirm", [p] = Pr("Modal", yo.Modal);
    return () => m(xC, L(L({
      prefixCls: u,
      rootPrefixCls: s
    }, a.value), {}, {
      close: d,
      open: r.value,
      afterClose: c,
      okText: a.value.okText || (f ? p == null ? void 0 : p.value.okText : p == null ? void 0 : p.value.justOkText),
      direction: a.value.direction || i.value,
      cancelText: a.value.cancelText || (p == null ? void 0 : p.value.cancelText)
    }), null);
  }
});
let Ch = 0;
const H8 = J({
  name: "ElementsHolder",
  inheritAttrs: !1,
  setup(e, t) {
    let {
      expose: n
    } = t;
    const o = K([]);
    return n({
      addModal: (a) => (o.value.push(a), o.value = o.value.slice(), () => {
        o.value = o.value.filter((i) => i !== a);
      })
    }), () => o.value.map((a) => a());
  }
});
function z8() {
  const e = K(null), t = K([]);
  le(t, () => {
    t.value.length && ([...t.value].forEach((i) => {
      i();
    }), t.value = []);
  }, {
    immediate: !0
  });
  const n = (a) => function(l) {
    var u;
    Ch += 1;
    const s = K(!0), c = K(null), d = K(Ye(l)), f = K({});
    le(() => l, (w) => {
      b(h(h({}, cb(w) ? w.value : w), f.value));
    });
    const p = function() {
      s.value = !1;
      for (var w = arguments.length, C = new Array(w), $ = 0; $ < w; $++)
        C[$] = arguments[$];
      const O = C.some((x) => x && x.triggerCancel);
      d.value.onCancel && O && d.value.onCancel(() => {
      }, ...C.slice(1));
    };
    let v;
    const g = () => m(L8, {
      key: `modal-${Ch}`,
      config: a(d.value),
      ref: c,
      open: s.value,
      destroyAction: p,
      afterClose: () => {
        v == null || v();
      }
    }, null);
    v = (u = e.value) === null || u === void 0 ? void 0 : u.addModal(g), v && dr.push(v);
    const b = (w) => {
      d.value = h(h({}, d.value), w);
    };
    return {
      destroy: () => {
        c.value ? p() : t.value = [...t.value, p];
      },
      update: (w) => {
        f.value = w, c.value ? b(w) : t.value = [...t.value, () => b(w)];
      }
    };
  }, o = T(() => ({
    info: n(PC),
    success: n(IC),
    error: n(TC),
    warning: n(OC),
    confirm: n(EC)
  })), r = Symbol("modalHolderKey");
  return [o.value, () => m(H8, {
    key: r,
    ref: e
  }, null)];
}
function MC(e) {
  return Mi(OC(e));
}
fn.useModal = z8;
fn.info = function(t) {
  return Mi(PC(t));
};
fn.success = function(t) {
  return Mi(IC(t));
};
fn.error = function(t) {
  return Mi(TC(t));
};
fn.warning = MC;
fn.warn = MC;
fn.confirm = function(t) {
  return Mi(EC(t));
};
fn.destroyAll = function() {
  for (; dr.length; ) {
    const t = dr.pop();
    t && t();
  }
};
fn.install = function(e) {
  return e.component(fn.name, fn), e;
};
const j8 = ["normal", "exception", "active", "success"], Gs = () => ({
  prefixCls: String,
  type: Ze(),
  percent: Number,
  format: de(),
  status: Ze(),
  showInfo: Me(),
  strokeWidth: Number,
  strokeLinecap: Ze(),
  strokeColor: Wt(),
  trailColor: String,
  /** @deprecated Use `size` instead */
  width: Number,
  success: He(),
  gapDegree: Number,
  gapPosition: Ze(),
  size: dt([String, Number, Array]),
  steps: Number,
  /** @deprecated Use `success` instead */
  successPercent: Number,
  title: String,
  progressStatus: Ze()
});
function gr(e) {
  return !e || e < 0 ? 0 : e > 100 ? 100 : e;
}
function ts(e) {
  let {
    success: t,
    successPercent: n
  } = e, o = n;
  return t && "progress" in t && (gt(!1, "Progress", "`success.progress` is deprecated. Please use `success.percent` instead."), o = t.progress), t && "percent" in t && (o = t.percent), o;
}
function V8(e) {
  let {
    percent: t,
    success: n,
    successPercent: o
  } = e;
  const r = gr(ts({
    success: n,
    successPercent: o
  }));
  return [r, gr(gr(t) - r)];
}
function W8(e) {
  let {
    success: t = {},
    strokeColor: n
  } = e;
  const {
    strokeColor: o
  } = t;
  return [o || Qr.green, n || null];
}
const Ys = (e, t, n) => {
  var o, r, a, i;
  let l = -1, u = -1;
  if (t === "step") {
    const s = n.steps, c = n.strokeWidth;
    typeof e == "string" || typeof e > "u" ? (l = e === "small" ? 2 : 14, u = c ?? 8) : typeof e == "number" ? [l, u] = [e, e] : [l = 14, u = 8] = e, l *= s;
  } else if (t === "line") {
    const s = n == null ? void 0 : n.strokeWidth;
    typeof e == "string" || typeof e > "u" ? u = s || (e === "small" ? 6 : 8) : typeof e == "number" ? [l, u] = [e, e] : [l = -1, u = 8] = e;
  } else
    (t === "circle" || t === "dashboard") && (typeof e == "string" || typeof e > "u" ? [l, u] = e === "small" ? [60, 60] : [120, 120] : typeof e == "number" ? [l, u] = [e, e] : (process.env.NODE_ENV !== "production" && gt(!1, "Progress", 'Type "circle" and "dashboard" do not accept array as `size`, please use number or preset size instead.'), l = (r = (o = e[0]) !== null && o !== void 0 ? o : e[1]) !== null && r !== void 0 ? r : 120, u = (i = (a = e[0]) !== null && a !== void 0 ? a : e[1]) !== null && i !== void 0 ? i : 120));
  return {
    width: l,
    height: u
  };
};
var K8 = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const U8 = () => h(h({}, Gs()), {
  strokeColor: Wt(),
  direction: Ze()
}), G8 = (e) => {
  let t = [];
  return Object.keys(e).forEach((n) => {
    const o = parseFloat(n.replace(/%/g, ""));
    isNaN(o) || t.push({
      key: o,
      value: e[n]
    });
  }), t = t.sort((n, o) => n.key - o.key), t.map((n) => {
    let {
      key: o,
      value: r
    } = n;
    return `${r} ${o}%`;
  }).join(", ");
}, Y8 = (e, t) => {
  const {
    from: n = Qr.blue,
    to: o = Qr.blue,
    direction: r = t === "rtl" ? "to left" : "to right"
  } = e, a = K8(e, ["from", "to", "direction"]);
  if (Object.keys(a).length !== 0) {
    const i = G8(a);
    return {
      backgroundImage: `linear-gradient(${r}, ${i})`
    };
  }
  return {
    backgroundImage: `linear-gradient(${r}, ${n}, ${o})`
  };
}, X8 = J({
  compatConfig: {
    MODE: 3
  },
  name: "ProgressLine",
  inheritAttrs: !1,
  props: U8(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const r = T(() => {
      const {
        strokeColor: p,
        direction: v
      } = e;
      return p && typeof p != "string" ? Y8(p, v) : {
        backgroundColor: p
      };
    }), a = T(() => e.strokeLinecap === "square" || e.strokeLinecap === "butt" ? 0 : void 0), i = T(() => e.trailColor ? {
      backgroundColor: e.trailColor
    } : void 0), l = T(() => {
      var p;
      return (p = e.size) !== null && p !== void 0 ? p : [-1, e.strokeWidth || (e.size === "small" ? 6 : 8)];
    }), u = T(() => Ys(l.value, "line", {
      strokeWidth: e.strokeWidth
    }));
    process.env.NODE_ENV !== "production" && gt("strokeWidth" in e, "Progress", "`strokeWidth` is deprecated. Please use `size` instead.");
    const s = T(() => {
      const {
        percent: p
      } = e;
      return h({
        width: `${gr(p)}%`,
        height: `${u.value.height}px`,
        borderRadius: a.value
      }, r.value);
    }), c = T(() => ts(e)), d = T(() => {
      const {
        success: p
      } = e;
      return {
        width: `${gr(c.value)}%`,
        height: `${u.value.height}px`,
        borderRadius: a.value,
        backgroundColor: p == null ? void 0 : p.strokeColor
      };
    }), f = {
      width: u.value.width < 0 ? "100%" : u.value.width,
      height: `${u.value.height}px`
    };
    return () => {
      var p;
      return m(We, null, [m("div", L(L({}, o), {}, {
        class: [`${e.prefixCls}-outer`, o.class],
        style: [o.style, f]
      }), [m("div", {
        class: `${e.prefixCls}-inner`,
        style: i.value
      }, [m("div", {
        class: `${e.prefixCls}-bg`,
        style: s.value
      }, null), c.value !== void 0 ? m("div", {
        class: `${e.prefixCls}-success-bg`,
        style: d.value
      }, null) : null])]), (p = n.default) === null || p === void 0 ? void 0 : p.call(n)]);
    };
  }
}), q8 = {
  percent: 0,
  prefixCls: "vc-progress",
  strokeColor: "#2db7f5",
  strokeLinecap: "round",
  strokeWidth: 1,
  trailColor: "#D9D9D9",
  trailWidth: 1
}, Q8 = (e) => {
  const t = G(null);
  return Co(() => {
    const n = Date.now();
    let o = !1;
    e.value.forEach((r) => {
      const a = (r == null ? void 0 : r.$el) || r;
      if (!a)
        return;
      o = !0;
      const i = a.style;
      i.transitionDuration = ".3s, .3s, .3s, .06s", t.value && n - t.value < 100 && (i.transitionDuration = "0s, 0s");
    }), o && (t.value = Date.now());
  }), e;
}, Z8 = {
  gapDegree: Number,
  gapPosition: {
    type: String
  },
  percent: {
    type: [Array, Number]
  },
  prefixCls: String,
  strokeColor: {
    type: [Object, String, Array]
  },
  strokeLinecap: {
    type: String
  },
  strokeWidth: Number,
  trailColor: String,
  trailWidth: Number,
  transition: String
};
var J8 = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
let wh = 0;
function xh(e) {
  return +e.replace("%", "");
}
function Oh(e) {
  return Array.isArray(e) ? e : [e];
}
function Ph(e, t, n, o) {
  let r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, a = arguments.length > 5 ? arguments[5] : void 0;
  const i = 50 - o / 2;
  let l = 0, u = -i, s = 0, c = -2 * i;
  switch (a) {
    case "left":
      l = -i, u = 0, s = 2 * i, c = 0;
      break;
    case "right":
      l = i, u = 0, s = -2 * i, c = 0;
      break;
    case "bottom":
      u = i, c = 2 * i;
      break;
  }
  const d = `M 50,50 m ${l},${u}
   a ${i},${i} 0 1 1 ${s},${-c}
   a ${i},${i} 0 1 1 ${-s},${c}`, f = Math.PI * 2 * i, p = {
    stroke: n,
    strokeDasharray: `${t / 100 * (f - r)}px ${f}px`,
    strokeDashoffset: `-${r / 2 + e / 100 * (f - r)}px`,
    transition: "stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s, opacity .3s ease 0s"
    // eslint-disable-line
  };
  return {
    pathString: d,
    pathStyle: p
  };
}
const eL = J({
  compatConfig: {
    MODE: 3
  },
  name: "VCCircle",
  props: bt(Z8, q8),
  setup(e) {
    wh += 1;
    const t = G(wh), n = T(() => Oh(e.percent)), o = T(() => Oh(e.strokeColor)), [r, a] = ep();
    Q8(a);
    const i = () => {
      const {
        prefixCls: l,
        strokeWidth: u,
        strokeLinecap: s,
        gapDegree: c,
        gapPosition: d
      } = e;
      let f = 0;
      return n.value.map((p, v) => {
        const g = o.value[v] || o.value[o.value.length - 1], b = Object.prototype.toString.call(g) === "[object Object]" ? `url(#${l}-gradient-${t.value})` : "", {
          pathString: y,
          pathStyle: S
        } = Ph(f, p, g, u, c, d);
        f += p;
        const w = {
          key: v,
          d: y,
          stroke: b,
          "stroke-linecap": s,
          "stroke-width": u,
          opacity: p === 0 ? 0 : 1,
          "fill-opacity": "0",
          class: `${l}-circle-path`,
          style: S
        };
        return m("path", L({
          ref: r(v)
        }, w), null);
      });
    };
    return () => {
      const {
        prefixCls: l,
        strokeWidth: u,
        trailWidth: s,
        gapDegree: c,
        gapPosition: d,
        trailColor: f,
        strokeLinecap: p,
        strokeColor: v
      } = e, g = J8(e, ["prefixCls", "strokeWidth", "trailWidth", "gapDegree", "gapPosition", "trailColor", "strokeLinecap", "strokeColor"]), {
        pathString: b,
        pathStyle: y
      } = Ph(0, 100, f, u, c, d);
      delete g.percent;
      const S = o.value.find((C) => Object.prototype.toString.call(C) === "[object Object]"), w = {
        d: b,
        stroke: f,
        "stroke-linecap": p,
        "stroke-width": s || u,
        "fill-opacity": "0",
        class: `${l}-circle-trail`,
        style: y
      };
      return m("svg", L({
        class: `${l}-circle`,
        viewBox: "0 0 100 100"
      }, g), [S && m("defs", null, [m("linearGradient", {
        id: `${l}-gradient-${t.value}`,
        x1: "100%",
        y1: "0%",
        x2: "0%",
        y2: "0%"
      }, [Object.keys(S).sort((C, $) => xh(C) - xh($)).map((C, $) => m("stop", {
        key: $,
        offset: C,
        "stop-color": S[C]
      }, null))])]), m("path", w, null), i().reverse()]);
    };
  }
}), tL = () => h(h({}, Gs()), {
  strokeColor: Wt()
}), nL = 3, oL = (e) => nL / e * 100, rL = J({
  compatConfig: {
    MODE: 3
  },
  name: "ProgressCircle",
  inheritAttrs: !1,
  props: bt(tL(), {
    trailColor: null
  }),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const r = T(() => {
      var g;
      return (g = e.width) !== null && g !== void 0 ? g : 120;
    }), a = T(() => {
      var g;
      return (g = e.size) !== null && g !== void 0 ? g : [r.value, r.value];
    }), i = T(() => Ys(a.value, "circle")), l = T(() => {
      if (e.gapDegree || e.gapDegree === 0)
        return e.gapDegree;
      if (e.type === "dashboard")
        return 75;
    }), u = T(() => ({
      width: `${i.value.width}px`,
      height: `${i.value.height}px`,
      fontSize: `${i.value.width * 0.15 + 6}px`
    })), s = T(() => {
      var g;
      return (g = e.strokeWidth) !== null && g !== void 0 ? g : Math.max(oL(i.value.width), 6);
    }), c = T(() => e.gapPosition || e.type === "dashboard" && "bottom" || void 0), d = T(() => V8(e)), f = T(() => Object.prototype.toString.call(e.strokeColor) === "[object Object]"), p = T(() => W8({
      success: e.success,
      strokeColor: e.strokeColor
    })), v = T(() => ({
      [`${e.prefixCls}-inner`]: !0,
      [`${e.prefixCls}-circle-gradient`]: f.value
    }));
    return () => {
      var g;
      const b = m(eL, {
        percent: d.value,
        strokeWidth: s.value,
        trailWidth: s.value,
        strokeColor: p.value,
        strokeLinecap: e.strokeLinecap,
        trailColor: e.trailColor,
        prefixCls: e.prefixCls,
        gapDegree: l.value,
        gapPosition: c.value
      }, null);
      return m("div", L(L({}, o), {}, {
        class: [v.value, o.class],
        style: [o.style, u.value]
      }), [i.value.width <= 20 ? m(Nr, null, {
        default: () => [m("span", null, [b])],
        title: n.default
      }) : m(We, null, [b, (g = n.default) === null || g === void 0 ? void 0 : g.call(n)])]);
    };
  }
}), aL = () => h(h({}, Gs()), {
  steps: Number,
  strokeColor: dt(),
  trailColor: String
}), iL = J({
  compatConfig: {
    MODE: 3
  },
  name: "Steps",
  props: aL(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = T(() => Math.round(e.steps * ((e.percent || 0) / 100))), r = T(() => {
      var l;
      return (l = e.size) !== null && l !== void 0 ? l : [e.size === "small" ? 2 : 14, e.strokeWidth || 8];
    }), a = T(() => Ys(r.value, "step", {
      steps: e.steps,
      strokeWidth: e.strokeWidth || 8
    })), i = T(() => {
      const {
        steps: l,
        strokeColor: u,
        trailColor: s,
        prefixCls: c
      } = e, d = [];
      for (let f = 0; f < l; f += 1) {
        const p = Array.isArray(u) ? u[f] : u, v = {
          [`${c}-steps-item`]: !0,
          [`${c}-steps-item-active`]: f <= o.value - 1
        };
        d.push(m("div", {
          key: f,
          class: v,
          style: {
            backgroundColor: f <= o.value - 1 ? p : s,
            width: `${a.value.width / l}px`,
            height: `${a.value.height}px`
          }
        }, null));
      }
      return d;
    });
    return () => {
      var l;
      return m("div", {
        class: `${e.prefixCls}-steps-outer`
      }, [i.value, (l = n.default) === null || l === void 0 ? void 0 : l.call(n)]);
    };
  }
}), lL = new Xe("antProgressActive", {
  "0%": {
    transform: "translateX(-100%) scaleX(0)",
    opacity: 0.1
  },
  "20%": {
    transform: "translateX(-100%) scaleX(0)",
    opacity: 0.5
  },
  to: {
    transform: "translateX(0) scaleX(1)",
    opacity: 0
  }
}), sL = (e) => {
  const {
    componentCls: t,
    iconCls: n
  } = e;
  return {
    [t]: h(h({}, st(e)), {
      display: "inline-block",
      "&-rtl": {
        direction: "rtl"
      },
      "&-line": {
        position: "relative",
        width: "100%",
        fontSize: e.fontSize,
        marginInlineEnd: e.marginXS,
        marginBottom: e.marginXS
      },
      [`${t}-outer`]: {
        display: "inline-block",
        width: "100%"
      },
      [`&${t}-show-info`]: {
        [`${t}-outer`]: {
          marginInlineEnd: `calc(-2em - ${e.marginXS}px)`,
          paddingInlineEnd: `calc(2em + ${e.paddingXS}px)`
        }
      },
      [`${t}-inner`]: {
        position: "relative",
        display: "inline-block",
        width: "100%",
        overflow: "hidden",
        verticalAlign: "middle",
        backgroundColor: e.progressRemainingColor,
        borderRadius: e.progressLineRadius
      },
      [`${t}-inner:not(${t}-circle-gradient)`]: {
        [`${t}-circle-path`]: {
          stroke: e.colorInfo
        }
      },
      [`${t}-success-bg, ${t}-bg`]: {
        position: "relative",
        backgroundColor: e.colorInfo,
        borderRadius: e.progressLineRadius,
        transition: `all ${e.motionDurationSlow} ${e.motionEaseInOutCirc}`
      },
      [`${t}-success-bg`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        backgroundColor: e.colorSuccess
      },
      [`${t}-text`]: {
        display: "inline-block",
        width: "2em",
        marginInlineStart: e.marginXS,
        color: e.progressInfoTextColor,
        lineHeight: 1,
        whiteSpace: "nowrap",
        textAlign: "start",
        verticalAlign: "middle",
        wordBreak: "normal",
        [n]: {
          fontSize: e.fontSize
        }
      },
      [`&${t}-status-active`]: {
        [`${t}-bg::before`]: {
          position: "absolute",
          inset: 0,
          backgroundColor: e.colorBgContainer,
          borderRadius: e.progressLineRadius,
          opacity: 0,
          animationName: lL,
          animationDuration: e.progressActiveMotionDuration,
          animationTimingFunction: e.motionEaseOutQuint,
          animationIterationCount: "infinite",
          content: '""'
        }
      },
      [`&${t}-status-exception`]: {
        [`${t}-bg`]: {
          backgroundColor: e.colorError
        },
        [`${t}-text`]: {
          color: e.colorError
        }
      },
      [`&${t}-status-exception ${t}-inner:not(${t}-circle-gradient)`]: {
        [`${t}-circle-path`]: {
          stroke: e.colorError
        }
      },
      [`&${t}-status-success`]: {
        [`${t}-bg`]: {
          backgroundColor: e.colorSuccess
        },
        [`${t}-text`]: {
          color: e.colorSuccess
        }
      },
      [`&${t}-status-success ${t}-inner:not(${t}-circle-gradient)`]: {
        [`${t}-circle-path`]: {
          stroke: e.colorSuccess
        }
      }
    })
  };
}, uL = (e) => {
  const {
    componentCls: t,
    iconCls: n
  } = e;
  return {
    [t]: {
      [`${t}-circle-trail`]: {
        stroke: e.progressRemainingColor
      },
      [`&${t}-circle ${t}-inner`]: {
        position: "relative",
        lineHeight: 1,
        backgroundColor: "transparent"
      },
      [`&${t}-circle ${t}-text`]: {
        position: "absolute",
        insetBlockStart: "50%",
        insetInlineStart: 0,
        width: "100%",
        margin: 0,
        padding: 0,
        color: e.colorText,
        lineHeight: 1,
        whiteSpace: "normal",
        textAlign: "center",
        transform: "translateY(-50%)",
        [n]: {
          fontSize: `${e.fontSize / e.fontSizeSM}em`
        }
      },
      [`${t}-circle&-status-exception`]: {
        [`${t}-text`]: {
          color: e.colorError
        }
      },
      [`${t}-circle&-status-success`]: {
        [`${t}-text`]: {
          color: e.colorSuccess
        }
      }
    },
    [`${t}-inline-circle`]: {
      lineHeight: 1,
      [`${t}-inner`]: {
        verticalAlign: "bottom"
      }
    }
  };
}, cL = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      [`${t}-steps`]: {
        display: "inline-block",
        "&-outer": {
          display: "flex",
          flexDirection: "row",
          alignItems: "center"
        },
        "&-item": {
          flexShrink: 0,
          minWidth: e.progressStepMinWidth,
          marginInlineEnd: e.progressStepMarginInlineEnd,
          backgroundColor: e.progressRemainingColor,
          transition: `all ${e.motionDurationSlow}`,
          "&-active": {
            backgroundColor: e.colorInfo
          }
        }
      }
    }
  };
}, dL = (e) => {
  const {
    componentCls: t,
    iconCls: n
  } = e;
  return {
    [t]: {
      [`${t}-small&-line, ${t}-small&-line ${t}-text ${n}`]: {
        fontSize: e.fontSizeSM
      }
    }
  };
}, fL = ht("Progress", (e) => {
  const t = e.marginXXS / 2, n = qe(e, {
    progressLineRadius: 100,
    progressInfoTextColor: e.colorText,
    progressDefaultColor: e.colorInfo,
    progressRemainingColor: e.colorFillSecondary,
    progressStepMarginInlineEnd: t,
    progressStepMinWidth: t,
    progressActiveMotionDuration: "2.4s"
  });
  return [sL(n), uL(n), cL(n), dL(n)];
});
var pL = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const vL = J({
  compatConfig: {
    MODE: 3
  },
  name: "AProgress",
  inheritAttrs: !1,
  props: bt(Gs(), {
    type: "line",
    percent: 0,
    showInfo: !0,
    // null for different theme definition
    trailColor: null,
    size: "default",
    strokeLinecap: "round"
  }),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r,
      direction: a
    } = Ke("progress", e), [i, l] = fL(r);
    process.env.NODE_ENV !== "production" && (gt("successPercent" in e, "Progress", "`successPercent` is deprecated. Please use `success.percent` instead."), gt("width" in e, "Progress", "`width` is deprecated. Please use `size` instead."));
    const u = T(() => Array.isArray(e.strokeColor) ? e.strokeColor[0] : e.strokeColor), s = T(() => {
      const {
        percent: v = 0
      } = e, g = ts(e);
      return parseInt(g !== void 0 ? g.toString() : v.toString(), 10);
    }), c = T(() => {
      const {
        status: v
      } = e;
      return !j8.includes(v) && s.value >= 100 ? "success" : v || "normal";
    }), d = T(() => {
      const {
        type: v,
        showInfo: g,
        size: b
      } = e, y = r.value;
      return {
        [y]: !0,
        [`${y}-inline-circle`]: v === "circle" && Ys(b, "circle").width <= 20,
        [`${y}-${v === "dashboard" && "circle" || v}`]: !0,
        [`${y}-status-${c.value}`]: !0,
        [`${y}-show-info`]: g,
        [`${y}-${b}`]: b,
        [`${y}-rtl`]: a.value === "rtl",
        [l.value]: !0
      };
    }), f = T(() => typeof e.strokeColor == "string" || Array.isArray(e.strokeColor) ? e.strokeColor : void 0), p = () => {
      const {
        showInfo: v,
        format: g,
        type: b,
        percent: y,
        title: S
      } = e, w = ts(e);
      if (!v)
        return null;
      let C;
      const $ = g || (n == null ? void 0 : n.format) || ((x) => `${x}%`), O = b === "line";
      return g || n != null && n.format || c.value !== "exception" && c.value !== "success" ? C = $(gr(y), gr(w)) : c.value === "exception" ? C = O ? m(vn, null, null) : m(Qn, null, null) : c.value === "success" && (C = O ? m(Io, null, null) : m(xs, null, null)), m("span", {
        class: `${r.value}-text`,
        title: S === void 0 && typeof C == "string" ? C : void 0
      }, [C]);
    };
    return () => {
      const {
        type: v,
        steps: g,
        title: b
      } = e, {
        class: y
      } = o, S = pL(o, ["class"]), w = p();
      let C;
      return v === "line" ? C = g ? m(iL, L(L({}, e), {}, {
        strokeColor: f.value,
        prefixCls: r.value,
        steps: g
      }), {
        default: () => [w]
      }) : m(X8, L(L({}, e), {}, {
        strokeColor: u.value,
        prefixCls: r.value,
        direction: a.value
      }), {
        default: () => [w]
      }) : (v === "circle" || v === "dashboard") && (C = m(rL, L(L({}, e), {}, {
        prefixCls: r.value,
        strokeColor: u.value,
        progressStatus: c.value
      }), {
        default: () => [w]
      })), i(m("div", L(L({
        role: "progressbar"
      }, S), {}, {
        class: [d.value, y],
        title: b
      }), [C]));
    };
  }
}), mL = Xn(vL);
function gL(e) {
  let t = e.scrollX;
  const n = "scrollLeft";
  if (typeof t != "number") {
    const o = e.document;
    t = o.documentElement[n], typeof t != "number" && (t = o.body[n]);
  }
  return t;
}
function hL(e) {
  let t, n;
  const o = e.ownerDocument, {
    body: r
  } = o, a = o && o.documentElement, i = e.getBoundingClientRect();
  return t = i.left, n = i.top, t -= a.clientLeft || r.clientLeft || 0, n -= a.clientTop || r.clientTop || 0, {
    left: t,
    top: n
  };
}
function bL(e) {
  const t = hL(e), n = e.ownerDocument, o = n.defaultView || n.parentWindow;
  return t.left += gL(o), t.left;
}
var yL = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M908.1 353.1l-253.9-36.9L540.7 86.1c-3.1-6.3-8.2-11.4-14.5-14.5-15.8-7.8-35-1.3-42.9 14.5L369.8 316.2l-253.9 36.9c-7 1-13.4 4.3-18.3 9.3a32.05 32.05 0 00.6 45.3l183.7 179.1-43.4 252.9a31.95 31.95 0 0046.4 33.7L512 754l227.1 119.4c6.2 3.3 13.4 4.4 20.3 3.2 17.4-3 29.1-19.5 26.1-36.9l-43.4-252.9 183.7-179.1c5-4.9 8.3-11.3 9.3-18.3 2.7-17.5-9.5-33.7-27-36.3z" } }] }, name: "star", theme: "filled" };
function Ih(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      SL(e, r, n[r]);
    });
  }
  return e;
}
function SL(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var yp = function(t, n) {
  var o = Ih({}, t, n.attrs);
  return m(it, Ih({}, o, {
    icon: yL
  }), null);
};
yp.displayName = "StarFilled";
yp.inheritAttrs = !1;
const $L = {
  value: Number,
  index: Number,
  prefixCls: String,
  allowHalf: {
    type: Boolean,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  character: W.any,
  characterRender: Function,
  focused: {
    type: Boolean,
    default: void 0
  },
  count: Number,
  onClick: Function,
  onHover: Function
}, CL = J({
  compatConfig: {
    MODE: 3
  },
  name: "Star",
  inheritAttrs: !1,
  props: $L,
  emits: ["hover", "click"],
  setup(e, t) {
    let {
      emit: n
    } = t;
    const o = (l) => {
      const {
        index: u
      } = e;
      n("hover", l, u);
    }, r = (l) => {
      const {
        index: u
      } = e;
      n("click", l, u);
    }, a = (l) => {
      const {
        index: u
      } = e;
      l.keyCode === 13 && n("click", l, u);
    }, i = T(() => {
      const {
        prefixCls: l,
        index: u,
        value: s,
        allowHalf: c,
        focused: d
      } = e, f = u + 1;
      let p = l;
      return s === 0 && u === 0 && d ? p += ` ${l}-focused` : c && s + 0.5 >= f && s < f ? (p += ` ${l}-half ${l}-active`, d && (p += ` ${l}-focused`)) : (p += f <= s ? ` ${l}-full` : ` ${l}-zero`, f === s && d && (p += ` ${l}-focused`)), p;
    });
    return () => {
      const {
        disabled: l,
        prefixCls: u,
        characterRender: s,
        character: c,
        index: d,
        count: f,
        value: p
      } = e, v = typeof c == "function" ? c({
        disabled: l,
        prefixCls: u,
        index: d,
        count: f,
        value: p
      }) : c;
      let g = m("li", {
        class: i.value
      }, [m("div", {
        onClick: l ? null : r,
        onKeydown: l ? null : a,
        onMousemove: l ? null : o,
        role: "radio",
        "aria-checked": p > d ? "true" : "false",
        "aria-posinset": d + 1,
        "aria-setsize": f,
        tabindex: l ? -1 : 0
      }, [m("div", {
        class: `${u}-first`
      }, [v]), m("div", {
        class: `${u}-second`
      }, [v])])]);
      return s && (g = s(g, e)), g;
    };
  }
}), wL = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-star`]: {
      position: "relative",
      display: "inline-block",
      color: "inherit",
      cursor: "pointer",
      "&:not(:last-child)": {
        marginInlineEnd: e.marginXS
      },
      "> div": {
        transition: `all ${e.motionDurationMid}, outline 0s`,
        "&:hover": {
          transform: e.rateStarHoverScale
        },
        "&:focus": {
          outline: 0
        },
        "&:focus-visible": {
          outline: `${e.lineWidth}px dashed ${e.rateStarColor}`,
          transform: e.rateStarHoverScale
        }
      },
      "&-first, &-second": {
        color: e.defaultColor,
        transition: `all ${e.motionDurationMid}`,
        userSelect: "none",
        [e.iconCls]: {
          verticalAlign: "middle"
        }
      },
      "&-first": {
        position: "absolute",
        top: 0,
        insetInlineStart: 0,
        width: "50%",
        height: "100%",
        overflow: "hidden",
        opacity: 0
      },
      [`&-half ${t}-star-first, &-half ${t}-star-second`]: {
        opacity: 1
      },
      [`&-half ${t}-star-first, &-full ${t}-star-second`]: {
        color: "inherit"
      }
    }
  };
}, xL = (e) => ({
  [`&-rtl${e.componentCls}`]: {
    direction: "rtl"
  }
}), OL = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: h(h(h(h(h({}, st(e)), {
      display: "inline-block",
      margin: 0,
      padding: 0,
      color: e.rateStarColor,
      fontSize: e.rateStarSize,
      lineHeight: "unset",
      listStyle: "none",
      outline: "none",
      // disable styles
      [`&-disabled${t} ${t}-star`]: {
        cursor: "default",
        "&:hover": {
          transform: "scale(1)"
        }
      }
    }), wL(e)), {
      // text styles
      [`+ ${t}-text`]: {
        display: "inline-block",
        marginInlineStart: e.marginXS,
        fontSize: e.fontSize
      }
    }), xL(e))
  };
}, PL = ht("Rate", (e) => {
  const {
    colorFillContent: t
  } = e, n = qe(e, {
    rateStarColor: e["yellow-6"],
    rateStarSize: e.controlHeightLG * 0.5,
    rateStarHoverScale: "scale(1.1)",
    defaultColor: t
  });
  return [OL(n)];
}), IL = () => ({
  prefixCls: String,
  count: Number,
  value: Number,
  allowHalf: {
    type: Boolean,
    default: void 0
  },
  allowClear: {
    type: Boolean,
    default: void 0
  },
  tooltips: Array,
  disabled: {
    type: Boolean,
    default: void 0
  },
  character: W.any,
  autofocus: {
    type: Boolean,
    default: void 0
  },
  tabindex: W.oneOfType([W.number, W.string]),
  direction: String,
  id: String,
  onChange: Function,
  onHoverChange: Function,
  "onUpdate:value": Function,
  onFocus: Function,
  onBlur: Function,
  onKeydown: Function
}), TL = J({
  compatConfig: {
    MODE: 3
  },
  name: "ARate",
  inheritAttrs: !1,
  props: bt(IL(), {
    value: 0,
    count: 5,
    allowHalf: !1,
    allowClear: !0,
    tabindex: 0,
    direction: "ltr"
  }),
  // emits: ['hoverChange', 'update:value', 'change', 'focus', 'blur', 'keydown'],
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      emit: r,
      expose: a
    } = t;
    const {
      prefixCls: i,
      direction: l
    } = Ke("rate", e), [u, s] = PL(i), c = Lt(), d = G(), [f, p] = ep(), v = Et({
      value: e.value,
      focused: !1,
      cleanedValue: null,
      hoverValue: void 0
    });
    le(() => e.value, () => {
      v.value = e.value;
    });
    const g = (I) => to(p.value.get(I)), b = (I, E) => {
      const B = l.value === "rtl";
      let k = I + 1;
      if (e.allowHalf) {
        const P = g(I), R = bL(P), D = P.clientWidth;
        (B && E - R > D / 2 || !B && E - R < D / 2) && (k -= 0.5);
      }
      return k;
    }, y = (I) => {
      e.value === void 0 && (v.value = I), r("update:value", I), r("change", I), c.onFieldChange();
    }, S = (I, E) => {
      const B = b(E, I.pageX);
      B !== v.cleanedValue && (v.hoverValue = B, v.cleanedValue = null), r("hoverChange", B);
    }, w = () => {
      v.hoverValue = void 0, v.cleanedValue = null, r("hoverChange", void 0);
    }, C = (I, E) => {
      const {
        allowClear: B
      } = e, k = b(E, I.pageX);
      let P = !1;
      B && (P = k === v.value), w(), y(P ? 0 : k), v.cleanedValue = P ? k : null;
    }, $ = (I) => {
      v.focused = !0, r("focus", I);
    }, O = (I) => {
      v.focused = !1, r("blur", I), c.onFieldBlur();
    }, x = (I) => {
      const {
        keyCode: E
      } = I, {
        count: B,
        allowHalf: k
      } = e, P = l.value === "rtl";
      E === ee.RIGHT && v.value < B && !P ? (k ? v.value += 0.5 : v.value += 1, y(v.value), I.preventDefault()) : E === ee.LEFT && v.value > 0 && !P || E === ee.RIGHT && v.value > 0 && P ? (k ? v.value -= 0.5 : v.value -= 1, y(v.value), I.preventDefault()) : E === ee.LEFT && v.value < B && P && (k ? v.value += 0.5 : v.value += 1, y(v.value), I.preventDefault()), r("keydown", I);
    }, M = () => {
      e.disabled || d.value.focus();
    };
    a({
      focus: M,
      blur: () => {
        e.disabled || d.value.blur();
      }
    }), ze(() => {
      const {
        autofocus: I,
        disabled: E
      } = e;
      I && !E && M();
    });
    const N = (I, E) => {
      let {
        index: B
      } = E;
      const {
        tooltips: k
      } = e;
      return k ? m(Nr, {
        title: k[B]
      }, {
        default: () => [I]
      }) : I;
    };
    return () => {
      const {
        count: I,
        allowHalf: E,
        disabled: B,
        tabindex: k,
        id: P = c.id.value
      } = e, {
        class: R,
        style: D
      } = o, A = [], H = B ? `${i.value}-disabled` : "", j = e.character || n.character || (() => m(yp, null, null));
      for (let F = 0; F < I; F++)
        A.push(m(CL, {
          ref: f(F),
          key: F,
          index: F,
          count: I,
          disabled: B,
          prefixCls: `${i.value}-star`,
          allowHalf: E,
          value: v.hoverValue === void 0 ? v.value : v.hoverValue,
          onClick: C,
          onHover: S,
          character: j,
          characterRender: N,
          focused: v.focused
        }, null));
      const z = ae(i.value, H, R, {
        [s.value]: !0,
        [`${i.value}-rtl`]: l.value === "rtl"
      });
      return u(m("ul", L(L({}, o), {}, {
        id: P,
        class: z,
        style: D,
        onMouseleave: B ? null : w,
        tabindex: B ? -1 : k,
        onFocus: B ? null : $,
        onBlur: B ? null : O,
        onKeydown: B ? null : x,
        ref: d,
        role: "radiogroup"
      }), [A]));
    };
  }
}), EL = Xn(TL), ML = Xn(b$), Sp = (e, t) => {
  let {
    attrs: n
  } = t;
  const {
    included: o,
    vertical: r,
    style: a,
    class: i
  } = n;
  let {
    length: l,
    offset: u,
    reverse: s
  } = n;
  l < 0 && (s = !s, l = Math.abs(l), u = 100 - u);
  const c = r ? {
    [s ? "top" : "bottom"]: `${u}%`,
    [s ? "bottom" : "top"]: "auto",
    height: `${l}%`
  } : {
    [s ? "right" : "left"]: `${u}%`,
    [s ? "left" : "right"]: "auto",
    width: `${l}%`
  }, d = h(h({}, a), c);
  return o ? m("div", {
    class: i,
    style: d
  }, null) : null;
};
Sp.inheritAttrs = !1;
const _L = (e, t, n, o, r, a) => {
  Pt(n ? o > 0 : !0, "Slider", "`Slider[step]` should be a positive number in order to make Slider[dots] work.");
  const i = Object.keys(t).map(parseFloat).sort((l, u) => l - u);
  if (n && o)
    for (let l = r; l <= a; l += o)
      i.indexOf(l) === -1 && i.push(l);
  return i;
}, _C = (e, t) => {
  let {
    attrs: n
  } = t;
  const {
    prefixCls: o,
    vertical: r,
    reverse: a,
    marks: i,
    dots: l,
    step: u,
    included: s,
    lowerBound: c,
    upperBound: d,
    max: f,
    min: p,
    dotStyle: v,
    activeDotStyle: g
  } = n, b = f - p, y = _L(r, i, l, u, p, f).map((S) => {
    const w = `${Math.abs(S - p) / b * 100}%`, C = !s && S === d || s && S <= d && S >= c;
    let $ = r ? h(h({}, v), {
      [a ? "top" : "bottom"]: w
    }) : h(h({}, v), {
      [a ? "right" : "left"]: w
    });
    C && ($ = h(h({}, $), g));
    const O = ae({
      [`${o}-dot`]: !0,
      [`${o}-dot-active`]: C,
      [`${o}-dot-reverse`]: a
    });
    return m("span", {
      class: O,
      style: $,
      key: S
    }, null);
  });
  return m("div", {
    class: `${o}-step`
  }, [y]);
};
_C.inheritAttrs = !1;
const DC = (e, t) => {
  let {
    attrs: n,
    slots: o
  } = t;
  const {
    class: r,
    vertical: a,
    reverse: i,
    marks: l,
    included: u,
    upperBound: s,
    lowerBound: c,
    max: d,
    min: f,
    onClickLabel: p
  } = n, v = Object.keys(l), g = o.mark, b = d - f, y = v.map(parseFloat).sort((S, w) => S - w).map((S) => {
    const w = typeof l[S] == "function" ? l[S]() : l[S], C = typeof w == "object" && !on(w);
    let $ = C ? w.label : w;
    if (!$ && $ !== 0)
      return null;
    g && ($ = g({
      point: S,
      label: $
    }));
    const O = !u && S === s || u && S <= s && S >= c, x = ae({
      [`${r}-text`]: !0,
      [`${r}-text-active`]: O
    }), M = {
      marginBottom: "-50%",
      [i ? "top" : "bottom"]: `${(S - f) / b * 100}%`
    }, _ = {
      transform: `translateX(${i ? "50%" : "-50%"})`,
      msTransform: `translateX(${i ? "50%" : "-50%"})`,
      [i ? "right" : "left"]: `${(S - f) / b * 100}%`
    }, N = a ? M : _, I = C ? h(h({}, N), w.style) : N, E = {
      [Kt ? "onTouchstartPassive" : "onTouchstart"]: (B) => p(B, S)
    };
    return m("span", L({
      class: x,
      style: I,
      key: S,
      onMousedown: (B) => p(B, S)
    }, E), [$]);
  });
  return m("div", {
    class: r
  }, [y]);
};
DC.inheritAttrs = !1;
const AC = J({
  compatConfig: {
    MODE: 3
  },
  name: "Handle",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    vertical: {
      type: Boolean,
      default: void 0
    },
    offset: Number,
    disabled: {
      type: Boolean,
      default: void 0
    },
    min: Number,
    max: Number,
    value: Number,
    tabindex: W.oneOfType([W.number, W.string]),
    reverse: {
      type: Boolean,
      default: void 0
    },
    ariaLabel: String,
    ariaLabelledBy: String,
    ariaValueTextFormatter: Function,
    onMouseenter: {
      type: Function
    },
    onMouseleave: {
      type: Function
    },
    onMousedown: {
      type: Function
    }
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: o,
      expose: r
    } = t;
    const a = K(!1), i = K(), l = () => {
      document.activeElement === i.value && (a.value = !0);
    }, u = (b) => {
      a.value = !1, o("blur", b);
    }, s = () => {
      a.value = !1;
    }, c = () => {
      var b;
      (b = i.value) === null || b === void 0 || b.focus();
    }, d = () => {
      var b;
      (b = i.value) === null || b === void 0 || b.blur();
    }, f = () => {
      a.value = !0, c();
    }, p = (b) => {
      b.preventDefault(), c(), o("mousedown", b);
    };
    r({
      focus: c,
      blur: d,
      clickFocus: f,
      ref: i
    });
    let v = null;
    ze(() => {
      v = Kn(document, "mouseup", l);
    }), at(() => {
      v == null || v.remove();
    });
    const g = T(() => {
      const {
        vertical: b,
        offset: y,
        reverse: S
      } = e;
      return b ? {
        [S ? "top" : "bottom"]: `${y}%`,
        [S ? "bottom" : "top"]: "auto",
        transform: S ? null : "translateY(+50%)"
      } : {
        [S ? "right" : "left"]: `${y}%`,
        [S ? "left" : "right"]: "auto",
        transform: `translateX(${S ? "+" : "-"}50%)`
      };
    });
    return () => {
      const {
        prefixCls: b,
        disabled: y,
        min: S,
        max: w,
        value: C,
        tabindex: $,
        ariaLabel: O,
        ariaLabelledBy: x,
        ariaValueTextFormatter: M,
        onMouseenter: _,
        onMouseleave: N
      } = e, I = ae(n.class, {
        [`${b}-handle-click-focused`]: a.value
      }), E = {
        "aria-valuemin": S,
        "aria-valuemax": w,
        "aria-valuenow": C,
        "aria-disabled": !!y
      }, B = [n.style, g.value];
      let k = $ || 0;
      (y || $ === null) && (k = null);
      let P;
      M && (P = M(C));
      const R = h(h(h(h({}, n), {
        role: "slider",
        tabindex: k
      }), E), {
        class: I,
        onBlur: u,
        onKeydown: s,
        onMousedown: p,
        onMouseenter: _,
        onMouseleave: N,
        ref: i,
        style: B
      });
      return m("div", L(L({}, R), {}, {
        "aria-label": O,
        "aria-labelledby": x,
        "aria-valuetext": P
      }), null);
    };
  }
});
function Xu(e, t) {
  try {
    return Object.keys(t).some((n) => e.target === t[n].ref);
  } catch {
    return !1;
  }
}
function NC(e, t) {
  let {
    min: n,
    max: o
  } = t;
  return e < n || e > o;
}
function Th(e) {
  return e.touches.length > 1 || e.type.toLowerCase() === "touchend" && e.touches.length > 0;
}
function Eh(e, t) {
  let {
    marks: n,
    step: o,
    min: r,
    max: a
  } = t;
  const i = Object.keys(n).map(parseFloat);
  if (o !== null) {
    const u = Math.pow(10, RC(o)), s = Math.floor((a * u - r * u) / (o * u)), c = Math.min((e - r) / o, s), d = Math.round(c) * o + r;
    i.push(d);
  }
  const l = i.map((u) => Math.abs(e - u));
  return i[l.indexOf(Math.min(...l))];
}
function RC(e) {
  const t = e.toString();
  let n = 0;
  return t.indexOf(".") >= 0 && (n = t.length - t.indexOf(".") - 1), n;
}
function Mh(e, t) {
  let n = 1;
  return window.visualViewport && (n = +(window.visualViewport.width / document.body.getBoundingClientRect().width).toFixed(2)), (e ? t.clientY : t.pageX) / n;
}
function _h(e, t) {
  let n = 1;
  return window.visualViewport && (n = +(window.visualViewport.width / document.body.getBoundingClientRect().width).toFixed(2)), (e ? t.touches[0].clientY : t.touches[0].pageX) / n;
}
function Dh(e, t) {
  const n = t.getBoundingClientRect();
  return e ? n.top + n.height * 0.5 : window.scrollX + n.left + n.width * 0.5;
}
function $p(e, t) {
  let {
    max: n,
    min: o
  } = t;
  return e <= o ? o : e >= n ? n : e;
}
function FC(e, t) {
  const {
    step: n
  } = t, o = isFinite(Eh(e, t)) ? Eh(e, t) : 0;
  return n === null ? o : parseFloat(o.toFixed(RC(n)));
}
function ha(e) {
  e.stopPropagation(), e.preventDefault();
}
function DL(e, t, n) {
  const o = {
    increase: (i, l) => i + l,
    decrease: (i, l) => i - l
  }, r = o[e](Object.keys(n.marks).indexOf(JSON.stringify(t)), 1), a = Object.keys(n.marks)[r];
  return n.step ? o[e](t, n.step) : Object.keys(n.marks).length && n.marks[a] ? n.marks[a] : t;
}
function BC(e, t, n) {
  const o = "increase", r = "decrease";
  let a = o;
  switch (e.keyCode) {
    case ee.UP:
      a = t && n ? r : o;
      break;
    case ee.RIGHT:
      a = !t && n ? r : o;
      break;
    case ee.DOWN:
      a = t && n ? o : r;
      break;
    case ee.LEFT:
      a = !t && n ? o : r;
      break;
    case ee.END:
      return (i, l) => l.max;
    case ee.HOME:
      return (i, l) => l.min;
    case ee.PAGE_UP:
      return (i, l) => i + l.step * 2;
    case ee.PAGE_DOWN:
      return (i, l) => i - l.step * 2;
    default:
      return;
  }
  return (i, l) => DL(a, i, l);
}
var AL = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function ar() {
}
function kC(e) {
  const t = {
    id: String,
    min: Number,
    max: Number,
    step: Number,
    marks: W.object,
    included: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    disabled: {
      type: Boolean,
      default: void 0
    },
    handle: Function,
    dots: {
      type: Boolean,
      default: void 0
    },
    vertical: {
      type: Boolean,
      default: void 0
    },
    reverse: {
      type: Boolean,
      default: void 0
    },
    minimumTrackStyle: W.object,
    maximumTrackStyle: W.object,
    handleStyle: W.oneOfType([W.object, W.arrayOf(W.object)]),
    trackStyle: W.oneOfType([W.object, W.arrayOf(W.object)]),
    railStyle: W.object,
    dotStyle: W.object,
    activeDotStyle: W.object,
    autofocus: {
      type: Boolean,
      default: void 0
    },
    draggableTrack: {
      type: Boolean,
      default: void 0
    }
  };
  return J({
    compatConfig: {
      MODE: 3
    },
    name: "CreateSlider",
    mixins: [ys, e],
    inheritAttrs: !1,
    props: bt(t, {
      prefixCls: "rc-slider",
      min: 0,
      max: 100,
      step: 1,
      marks: {},
      included: !0,
      disabled: !1,
      dots: !1,
      vertical: !1,
      reverse: !1,
      trackStyle: [{}],
      handleStyle: [{}],
      railStyle: {},
      dotStyle: {},
      activeDotStyle: {}
    }),
    emits: ["change", "blur", "focus"],
    data() {
      const {
        step: n,
        max: o,
        min: r
      } = this, a = isFinite(o - r) ? (o - r) % n === 0 : !0;
      return Pt(n && Math.floor(n) === n ? a : !0, `Slider[max] - Slider[min] (${o - r}) should be a multiple of Slider[step] (${n})`), this.handlesRefs = {}, {};
    },
    mounted() {
      this.$nextTick(() => {
        this.document = this.sliderRef && this.sliderRef.ownerDocument;
        const {
          autofocus: n,
          disabled: o
        } = this;
        n && !o && this.focus();
      });
    },
    beforeUnmount() {
      this.$nextTick(() => {
        this.removeDocumentEvents();
      });
    },
    methods: {
      defaultHandle(n) {
        var {
          index: o,
          directives: r,
          className: a,
          style: i
        } = n, l = AL(n, ["index", "directives", "className", "style"]);
        if (delete l.dragging, l.value === null)
          return null;
        const u = h(h({}, l), {
          class: a,
          style: i,
          key: o
        });
        return m(AC, u, null);
      },
      onDown(n, o) {
        let r = o;
        const {
          draggableTrack: a,
          vertical: i
        } = this.$props, {
          bounds: l
        } = this.$data, u = a && this.positionGetValue ? this.positionGetValue(r) || [] : [], s = Xu(n, this.handlesRefs);
        if (this.dragTrack = a && l.length >= 2 && !s && !u.map((c, d) => {
          const f = d ? !0 : c >= l[d];
          return d === u.length - 1 ? c <= l[d] : f;
        }).some((c) => !c), this.dragTrack)
          this.dragOffset = r, this.startBounds = [...l];
        else {
          if (!s)
            this.dragOffset = 0;
          else {
            const c = Dh(i, n.target);
            this.dragOffset = r - c, r = c;
          }
          this.onStart(r);
        }
      },
      onMouseDown(n) {
        if (n.button !== 0)
          return;
        this.removeDocumentEvents();
        const o = this.$props.vertical, r = Mh(o, n);
        this.onDown(n, r), this.addDocumentMouseEvents();
      },
      onTouchStart(n) {
        if (Th(n))
          return;
        const o = this.vertical, r = _h(o, n);
        this.onDown(n, r), this.addDocumentTouchEvents(), ha(n);
      },
      onFocus(n) {
        const {
          vertical: o
        } = this;
        if (Xu(n, this.handlesRefs) && !this.dragTrack) {
          const r = Dh(o, n.target);
          this.dragOffset = 0, this.onStart(r), ha(n), this.$emit("focus", n);
        }
      },
      onBlur(n) {
        this.dragTrack || this.onEnd(), this.$emit("blur", n);
      },
      onMouseUp() {
        this.handlesRefs[this.prevMovedHandleIndex] && this.handlesRefs[this.prevMovedHandleIndex].clickFocus();
      },
      onMouseMove(n) {
        if (!this.sliderRef) {
          this.onEnd();
          return;
        }
        const o = Mh(this.vertical, n);
        this.onMove(n, o - this.dragOffset, this.dragTrack, this.startBounds);
      },
      onTouchMove(n) {
        if (Th(n) || !this.sliderRef) {
          this.onEnd();
          return;
        }
        const o = _h(this.vertical, n);
        this.onMove(n, o - this.dragOffset, this.dragTrack, this.startBounds);
      },
      onKeyDown(n) {
        this.sliderRef && Xu(n, this.handlesRefs) && this.onKeyboard(n);
      },
      onClickMarkLabel(n, o) {
        n.stopPropagation(), this.onChange({
          sValue: o
        }), this.setState({
          sValue: o
        }, () => this.onEnd(!0));
      },
      getSliderStart() {
        const n = this.sliderRef, {
          vertical: o,
          reverse: r
        } = this, a = n.getBoundingClientRect();
        return o ? r ? a.bottom : a.top : window.scrollX + (r ? a.right : a.left);
      },
      getSliderLength() {
        const n = this.sliderRef;
        if (!n)
          return 0;
        const o = n.getBoundingClientRect();
        return this.vertical ? o.height : o.width;
      },
      addDocumentTouchEvents() {
        this.onTouchMoveListener = Kn(this.document, "touchmove", this.onTouchMove), this.onTouchUpListener = Kn(this.document, "touchend", this.onEnd);
      },
      addDocumentMouseEvents() {
        this.onMouseMoveListener = Kn(this.document, "mousemove", this.onMouseMove), this.onMouseUpListener = Kn(this.document, "mouseup", this.onEnd);
      },
      removeDocumentEvents() {
        this.onTouchMoveListener && this.onTouchMoveListener.remove(), this.onTouchUpListener && this.onTouchUpListener.remove(), this.onMouseMoveListener && this.onMouseMoveListener.remove(), this.onMouseUpListener && this.onMouseUpListener.remove();
      },
      focus() {
        var n;
        this.$props.disabled || (n = this.handlesRefs[0]) === null || n === void 0 || n.focus();
      },
      blur() {
        this.$props.disabled || Object.keys(this.handlesRefs).forEach((n) => {
          var o, r;
          (r = (o = this.handlesRefs[n]) === null || o === void 0 ? void 0 : o.blur) === null || r === void 0 || r.call(o);
        });
      },
      calcValue(n) {
        const {
          vertical: o,
          min: r,
          max: a
        } = this, i = Math.abs(Math.max(n, 0) / this.getSliderLength());
        return o ? (1 - i) * (a - r) + r : i * (a - r) + r;
      },
      calcValueByPos(n) {
        const r = (this.reverse ? -1 : 1) * (n - this.getSliderStart());
        return this.trimAlignValue(this.calcValue(r));
      },
      calcOffset(n) {
        const {
          min: o,
          max: r
        } = this, a = (n - o) / (r - o);
        return Math.max(0, a * 100);
      },
      saveSlider(n) {
        this.sliderRef = n;
      },
      saveHandle(n, o) {
        this.handlesRefs[n] = o;
      }
    },
    render() {
      const {
        prefixCls: n,
        marks: o,
        dots: r,
        step: a,
        included: i,
        disabled: l,
        vertical: u,
        reverse: s,
        min: c,
        max: d,
        maximumTrackStyle: f,
        railStyle: p,
        dotStyle: v,
        activeDotStyle: g,
        id: b
      } = this, {
        class: y,
        style: S
      } = this.$attrs, {
        tracks: w,
        handles: C
      } = this.renderSlider(), $ = ae(n, y, {
        [`${n}-with-marks`]: Object.keys(o).length,
        [`${n}-disabled`]: l,
        [`${n}-vertical`]: u,
        [`${n}-horizontal`]: !u
      }), O = {
        vertical: u,
        marks: o,
        included: i,
        lowerBound: this.getLowerBound(),
        upperBound: this.getUpperBound(),
        max: d,
        min: c,
        reverse: s,
        class: `${n}-mark`,
        onClickLabel: l ? ar : this.onClickMarkLabel
      }, x = {
        [Kt ? "onTouchstartPassive" : "onTouchstart"]: l ? ar : this.onTouchStart
      };
      return m("div", L(L({
        id: b,
        ref: this.saveSlider,
        tabindex: "-1",
        class: $
      }, x), {}, {
        onMousedown: l ? ar : this.onMouseDown,
        onMouseup: l ? ar : this.onMouseUp,
        onKeydown: l ? ar : this.onKeyDown,
        onFocus: l ? ar : this.onFocus,
        onBlur: l ? ar : this.onBlur,
        style: S
      }), [m("div", {
        class: `${n}-rail`,
        style: h(h({}, f), p)
      }, null), w, m(_C, {
        prefixCls: n,
        vertical: u,
        reverse: s,
        marks: o,
        dots: r,
        step: a,
        included: i,
        lowerBound: this.getLowerBound(),
        upperBound: this.getUpperBound(),
        max: d,
        min: c,
        dotStyle: v,
        activeDotStyle: g
      }, null), C, m(DC, O, {
        mark: this.$slots.mark
      }), bb(this)]);
    }
  });
}
const NL = J({
  compatConfig: {
    MODE: 3
  },
  name: "Slider",
  mixins: [ys],
  inheritAttrs: !1,
  props: {
    defaultValue: Number,
    value: Number,
    disabled: {
      type: Boolean,
      default: void 0
    },
    autofocus: {
      type: Boolean,
      default: void 0
    },
    tabindex: W.oneOfType([W.number, W.string]),
    reverse: {
      type: Boolean,
      default: void 0
    },
    min: Number,
    max: Number,
    ariaLabelForHandle: String,
    ariaLabelledByForHandle: String,
    ariaValueTextFormatterForHandle: String,
    startPoint: Number
  },
  emits: ["beforeChange", "afterChange", "change"],
  data() {
    const e = this.defaultValue !== void 0 ? this.defaultValue : this.min, t = this.value !== void 0 ? this.value : e;
    return {
      sValue: this.trimAlignValue(t),
      dragging: !1
    };
  },
  watch: {
    value: {
      handler(e) {
        this.setChangeValue(e);
      },
      deep: !0
    },
    min() {
      const {
        sValue: e
      } = this;
      this.setChangeValue(e);
    },
    max() {
      const {
        sValue: e
      } = this;
      this.setChangeValue(e);
    }
  },
  methods: {
    setChangeValue(e) {
      const t = e !== void 0 ? e : this.sValue, n = this.trimAlignValue(t, this.$props);
      n !== this.sValue && (this.setState({
        sValue: n
      }), NC(t, this.$props) && this.$emit("change", n));
    },
    onChange(e) {
      const t = !Tl(this, "value"), n = e.sValue > this.max ? h(h({}, e), {
        sValue: this.max
      }) : e;
      t && this.setState(n);
      const o = n.sValue;
      this.$emit("change", o);
    },
    onStart(e) {
      this.setState({
        dragging: !0
      });
      const {
        sValue: t
      } = this;
      this.$emit("beforeChange", t);
      const n = this.calcValueByPos(e);
      this.startValue = n, this.startPosition = e, n !== t && (this.prevMovedHandleIndex = 0, this.onChange({
        sValue: n
      }));
    },
    onEnd(e) {
      const {
        dragging: t
      } = this;
      this.removeDocumentEvents(), (t || e) && this.$emit("afterChange", this.sValue), this.setState({
        dragging: !1
      });
    },
    onMove(e, t) {
      ha(e);
      const {
        sValue: n
      } = this, o = this.calcValueByPos(t);
      o !== n && this.onChange({
        sValue: o
      });
    },
    onKeyboard(e) {
      const {
        reverse: t,
        vertical: n
      } = this.$props, o = BC(e, n, t);
      if (o) {
        ha(e);
        const {
          sValue: r
        } = this, a = o(r, this.$props), i = this.trimAlignValue(a);
        if (i === r)
          return;
        this.onChange({
          sValue: i
        }), this.$emit("afterChange", i), this.onEnd();
      }
    },
    getLowerBound() {
      const e = this.$props.startPoint || this.$props.min;
      return this.$data.sValue > e ? e : this.$data.sValue;
    },
    getUpperBound() {
      return this.$data.sValue < this.$props.startPoint ? this.$props.startPoint : this.$data.sValue;
    },
    trimAlignValue(e) {
      let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (e === null)
        return null;
      const n = h(h({}, this.$props), t), o = $p(e, n);
      return FC(o, n);
    },
    getTrack(e) {
      let {
        prefixCls: t,
        reverse: n,
        vertical: o,
        included: r,
        minimumTrackStyle: a,
        mergedTrackStyle: i,
        length: l,
        offset: u
      } = e;
      return m(Sp, {
        class: `${t}-track`,
        vertical: o,
        included: r,
        offset: u,
        reverse: n,
        length: l,
        style: h(h({}, a), i)
      }, null);
    },
    renderSlider() {
      const {
        prefixCls: e,
        vertical: t,
        included: n,
        disabled: o,
        minimumTrackStyle: r,
        trackStyle: a,
        handleStyle: i,
        tabindex: l,
        ariaLabelForHandle: u,
        ariaLabelledByForHandle: s,
        ariaValueTextFormatterForHandle: c,
        min: d,
        max: f,
        startPoint: p,
        reverse: v,
        handle: g,
        defaultHandle: b
      } = this, y = g || b, {
        sValue: S,
        dragging: w
      } = this, C = this.calcOffset(S), $ = y({
        class: `${e}-handle`,
        prefixCls: e,
        vertical: t,
        offset: C,
        value: S,
        dragging: w,
        disabled: o,
        min: d,
        max: f,
        reverse: v,
        index: 0,
        tabindex: l,
        ariaLabel: u,
        ariaLabelledBy: s,
        ariaValueTextFormatter: c,
        style: i[0] || i,
        ref: (M) => this.saveHandle(0, M),
        onFocus: this.onFocus,
        onBlur: this.onBlur
      }), O = p !== void 0 ? this.calcOffset(p) : 0, x = a[0] || a;
      return {
        tracks: this.getTrack({
          prefixCls: e,
          reverse: v,
          vertical: t,
          included: n,
          offset: O,
          minimumTrackStyle: r,
          mergedTrackStyle: x,
          length: C - O
        }),
        handles: $
      };
    }
  }
}), RL = kC(NL), La = (e) => {
  let {
    value: t,
    handle: n,
    bounds: o,
    props: r
  } = e;
  const {
    allowCross: a,
    pushable: i
  } = r, l = Number(i), u = $p(t, r);
  let s = u;
  return !a && n != null && o !== void 0 && (n > 0 && u <= o[n - 1] + l && (s = o[n - 1] + l), n < o.length - 1 && u >= o[n + 1] - l && (s = o[n + 1] - l)), FC(s, r);
}, FL = {
  defaultValue: W.arrayOf(W.number),
  value: W.arrayOf(W.number),
  count: Number,
  pushable: hO(W.oneOfType([W.looseBool, W.number])),
  allowCross: {
    type: Boolean,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  reverse: {
    type: Boolean,
    default: void 0
  },
  tabindex: W.arrayOf(W.number),
  prefixCls: String,
  min: Number,
  max: Number,
  autofocus: {
    type: Boolean,
    default: void 0
  },
  ariaLabelGroupForHandles: Array,
  ariaLabelledByGroupForHandles: Array,
  ariaValueTextFormatterGroupForHandles: Array,
  draggableTrack: {
    type: Boolean,
    default: void 0
  }
}, BL = J({
  compatConfig: {
    MODE: 3
  },
  name: "Range",
  mixins: [ys],
  inheritAttrs: !1,
  props: bt(FL, {
    count: 1,
    allowCross: !0,
    pushable: !1,
    tabindex: [],
    draggableTrack: !1,
    ariaLabelGroupForHandles: [],
    ariaLabelledByGroupForHandles: [],
    ariaValueTextFormatterGroupForHandles: []
  }),
  emits: ["beforeChange", "afterChange", "change"],
  displayName: "Range",
  data() {
    const {
      count: e,
      min: t,
      max: n
    } = this, o = Array(...Array(e + 1)).map(() => t), r = Tl(this, "defaultValue") ? this.defaultValue : o;
    let {
      value: a
    } = this;
    a === void 0 && (a = r);
    const i = a.map((u, s) => La({
      value: u,
      handle: s,
      props: this.$props
    }));
    return {
      sHandle: null,
      recent: i[0] === n ? 0 : i.length - 1,
      bounds: i
    };
  },
  watch: {
    value: {
      handler(e) {
        const {
          bounds: t
        } = this;
        this.setChangeValue(e || t);
      },
      deep: !0
    },
    min() {
      const {
        value: e
      } = this;
      this.setChangeValue(e || this.bounds);
    },
    max() {
      const {
        value: e
      } = this;
      this.setChangeValue(e || this.bounds);
    }
  },
  methods: {
    setChangeValue(e) {
      const {
        bounds: t
      } = this;
      let n = e.map((o, r) => La({
        value: o,
        handle: r,
        bounds: t,
        props: this.$props
      }));
      if (t.length === n.length) {
        if (n.every((o, r) => o === t[r]))
          return null;
      } else
        n = e.map((o, r) => La({
          value: o,
          handle: r,
          props: this.$props
        }));
      if (this.setState({
        bounds: n
      }), e.some((o) => NC(o, this.$props))) {
        const o = e.map((r) => $p(r, this.$props));
        this.$emit("change", o);
      }
    },
    onChange(e) {
      if (!Tl(this, "value"))
        this.setState(e);
      else {
        const r = {};
        ["sHandle", "recent"].forEach((a) => {
          e[a] !== void 0 && (r[a] = e[a]);
        }), Object.keys(r).length && this.setState(r);
      }
      const o = h(h({}, this.$data), e).bounds;
      this.$emit("change", o);
    },
    positionGetValue(e) {
      const t = this.getValue(), n = this.calcValueByPos(e), o = this.getClosestBound(n), r = this.getBoundNeedMoving(n, o), a = t[r];
      if (n === a)
        return null;
      const i = [...t];
      return i[r] = n, i;
    },
    onStart(e) {
      const {
        bounds: t
      } = this;
      this.$emit("beforeChange", t);
      const n = this.calcValueByPos(e);
      this.startValue = n, this.startPosition = e;
      const o = this.getClosestBound(n);
      this.prevMovedHandleIndex = this.getBoundNeedMoving(n, o), this.setState({
        sHandle: this.prevMovedHandleIndex,
        recent: this.prevMovedHandleIndex
      });
      const r = t[this.prevMovedHandleIndex];
      if (n === r)
        return;
      const a = [...t];
      a[this.prevMovedHandleIndex] = n, this.onChange({
        bounds: a
      });
    },
    onEnd(e) {
      const {
        sHandle: t
      } = this;
      this.removeDocumentEvents(), t || (this.dragTrack = !1), (t !== null || e) && this.$emit("afterChange", this.bounds), this.setState({
        sHandle: null
      });
    },
    onMove(e, t, n, o) {
      ha(e);
      const {
        $data: r,
        $props: a
      } = this, i = a.max || 100, l = a.min || 0;
      if (n) {
        let f = a.vertical ? -t : t;
        f = a.reverse ? -f : f;
        const p = i - Math.max(...o), v = l - Math.min(...o), g = Math.min(Math.max(f / (this.getSliderLength() / 100), v), p), b = o.map((y) => Math.floor(Math.max(Math.min(y + g, i), l)));
        r.bounds.map((y, S) => y === b[S]).some((y) => !y) && this.onChange({
          bounds: b
        });
        return;
      }
      const {
        bounds: u,
        sHandle: s
      } = this, c = this.calcValueByPos(t), d = u[s];
      c !== d && this.moveTo(c);
    },
    onKeyboard(e) {
      const {
        reverse: t,
        vertical: n
      } = this.$props, o = BC(e, n, t);
      if (o) {
        ha(e);
        const {
          bounds: r,
          sHandle: a
        } = this, i = r[a === null ? this.recent : a], l = o(i, this.$props), u = La({
          value: l,
          handle: a,
          bounds: r,
          props: this.$props
        });
        if (u === i)
          return;
        this.moveTo(u, !0);
      }
    },
    getClosestBound(e) {
      const {
        bounds: t
      } = this;
      let n = 0;
      for (let o = 1; o < t.length - 1; o += 1)
        e >= t[o] && (n = o);
      return Math.abs(t[n + 1] - e) < Math.abs(t[n] - e) && (n += 1), n;
    },
    getBoundNeedMoving(e, t) {
      const {
        bounds: n,
        recent: o
      } = this;
      let r = t;
      const a = n[t + 1] === n[t];
      return a && n[o] === n[t] && (r = o), a && e !== n[t + 1] && (r = e < n[t + 1] ? t : t + 1), r;
    },
    getLowerBound() {
      return this.bounds[0];
    },
    getUpperBound() {
      const {
        bounds: e
      } = this;
      return e[e.length - 1];
    },
    /**
     * Returns an array of possible slider points, taking into account both
     * `marks` and `step`. The result is cached.
     */
    getPoints() {
      const {
        marks: e,
        step: t,
        min: n,
        max: o
      } = this, r = this.internalPointsCache;
      if (!r || r.marks !== e || r.step !== t) {
        const a = h({}, e);
        if (t !== null)
          for (let l = n; l <= o; l += t)
            a[l] = l;
        const i = Object.keys(a).map(parseFloat);
        i.sort((l, u) => l - u), this.internalPointsCache = {
          marks: e,
          step: t,
          points: i
        };
      }
      return this.internalPointsCache.points;
    },
    moveTo(e, t) {
      const n = [...this.bounds], {
        sHandle: o,
        recent: r
      } = this, a = o === null ? r : o;
      n[a] = e;
      let i = a;
      this.$props.pushable !== !1 ? this.pushSurroundingHandles(n, i) : this.$props.allowCross && (n.sort((l, u) => l - u), i = n.indexOf(e)), this.onChange({
        recent: i,
        sHandle: i,
        bounds: n
      }), t && (this.$emit("afterChange", n), this.setState({}, () => {
        this.handlesRefs[i].focus();
      }), this.onEnd());
    },
    pushSurroundingHandles(e, t) {
      const n = e[t], {
        pushable: o
      } = this, r = Number(o);
      let a = 0;
      if (e[t + 1] - n < r && (a = 1), n - e[t - 1] < r && (a = -1), a === 0)
        return;
      const i = t + a, l = a * (e[i] - n);
      this.pushHandle(e, i, a, r - l) || (e[t] = e[i] - a * r);
    },
    pushHandle(e, t, n, o) {
      const r = e[t];
      let a = e[t];
      for (; n * (a - r) < o; ) {
        if (!this.pushHandleOnePoint(e, t, n))
          return e[t] = r, !1;
        a = e[t];
      }
      return !0;
    },
    pushHandleOnePoint(e, t, n) {
      const o = this.getPoints(), a = o.indexOf(e[t]) + n;
      if (a >= o.length || a < 0)
        return !1;
      const i = t + n, l = o[a], {
        pushable: u
      } = this, s = Number(u), c = n * (e[i] - l);
      return this.pushHandle(e, i, n, s - c) ? (e[t] = l, !0) : !1;
    },
    trimAlignValue(e) {
      const {
        sHandle: t,
        bounds: n
      } = this;
      return La({
        value: e,
        handle: t,
        bounds: n,
        props: this.$props
      });
    },
    ensureValueNotConflict(e, t, n) {
      let {
        allowCross: o,
        pushable: r
      } = n;
      const a = this.$data || {}, {
        bounds: i
      } = a;
      if (e = e === void 0 ? a.sHandle : e, r = Number(r), !o && e != null && i !== void 0) {
        if (e > 0 && t <= i[e - 1] + r)
          return i[e - 1] + r;
        if (e < i.length - 1 && t >= i[e + 1] - r)
          return i[e + 1] - r;
      }
      return t;
    },
    getTrack(e) {
      let {
        bounds: t,
        prefixCls: n,
        reverse: o,
        vertical: r,
        included: a,
        offsets: i,
        trackStyle: l
      } = e;
      return t.slice(0, -1).map((u, s) => {
        const c = s + 1, d = ae({
          [`${n}-track`]: !0,
          [`${n}-track-${c}`]: !0
        });
        return m(Sp, {
          class: d,
          vertical: r,
          reverse: o,
          included: a,
          offset: i[c - 1],
          length: i[c] - i[c - 1],
          style: l[s],
          key: c
        }, null);
      });
    },
    renderSlider() {
      const {
        sHandle: e,
        bounds: t,
        prefixCls: n,
        vertical: o,
        included: r,
        disabled: a,
        min: i,
        max: l,
        reverse: u,
        handle: s,
        defaultHandle: c,
        trackStyle: d,
        handleStyle: f,
        tabindex: p,
        ariaLabelGroupForHandles: v,
        ariaLabelledByGroupForHandles: g,
        ariaValueTextFormatterGroupForHandles: b
      } = this, y = s || c, S = t.map(($) => this.calcOffset($)), w = `${n}-handle`, C = t.map(($, O) => {
        let x = p[O] || 0;
        (a || p[O] === null) && (x = null);
        const M = e === O;
        return y({
          class: ae({
            [w]: !0,
            [`${w}-${O + 1}`]: !0,
            [`${w}-dragging`]: M
          }),
          prefixCls: n,
          vertical: o,
          dragging: M,
          offset: S[O],
          value: $,
          index: O,
          tabindex: x,
          min: i,
          max: l,
          reverse: u,
          disabled: a,
          style: f[O],
          ref: (_) => this.saveHandle(O, _),
          onFocus: this.onFocus,
          onBlur: this.onBlur,
          ariaLabel: v[O],
          ariaLabelledBy: g[O],
          ariaValueTextFormatter: b[O]
        });
      });
      return {
        tracks: this.getTrack({
          bounds: t,
          prefixCls: n,
          reverse: u,
          vertical: o,
          included: r,
          offsets: S,
          trackStyle: d
        }),
        handles: C
      };
    }
  }
}), kL = kC(BL), LL = J({
  compatConfig: {
    MODE: 3
  },
  name: "SliderTooltip",
  inheritAttrs: !1,
  props: J0(),
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const r = G(null), a = G(null);
    function i() {
      Ue.cancel(a.value), a.value = null;
    }
    function l() {
      a.value = Ue(() => {
        var s;
        (s = r.value) === null || s === void 0 || s.forcePopupAlign(), a.value = null;
      });
    }
    const u = () => {
      i(), e.open && l();
    };
    return le([() => e.open, () => e.title], () => {
      u();
    }, {
      flush: "post",
      immediate: !0
    }), fw(() => {
      u();
    }), at(() => {
      i();
    }), () => m(Nr, L(L({
      ref: r
    }, e), n), o);
  }
}), HL = (e) => {
  const {
    componentCls: t,
    controlSize: n,
    dotSize: o,
    marginFull: r,
    marginPart: a,
    colorFillContentHover: i
  } = e;
  return {
    [t]: h(h({}, st(e)), {
      position: "relative",
      height: n,
      margin: `${a}px ${r}px`,
      padding: 0,
      cursor: "pointer",
      touchAction: "none",
      "&-vertical": {
        margin: `${r}px ${a}px`
      },
      [`${t}-rail`]: {
        position: "absolute",
        backgroundColor: e.colorFillTertiary,
        borderRadius: e.borderRadiusXS,
        transition: `background-color ${e.motionDurationMid}`
      },
      [`${t}-track`]: {
        position: "absolute",
        backgroundColor: e.colorPrimaryBorder,
        borderRadius: e.borderRadiusXS,
        transition: `background-color ${e.motionDurationMid}`
      },
      "&:hover": {
        [`${t}-rail`]: {
          backgroundColor: e.colorFillSecondary
        },
        [`${t}-track`]: {
          backgroundColor: e.colorPrimaryBorderHover
        },
        [`${t}-dot`]: {
          borderColor: i
        },
        [`${t}-handle::after`]: {
          boxShadow: `0 0 0 ${e.handleLineWidth}px ${e.colorPrimaryBorderHover}`
        },
        [`${t}-dot-active`]: {
          borderColor: e.colorPrimary
        }
      },
      [`${t}-handle`]: {
        position: "absolute",
        width: e.handleSize,
        height: e.handleSize,
        outline: "none",
        [`${t}-dragging`]: {
          zIndex: 1
        },
        // 扩大选区
        "&::before": {
          content: '""',
          position: "absolute",
          insetInlineStart: -e.handleLineWidth,
          insetBlockStart: -e.handleLineWidth,
          width: e.handleSize + e.handleLineWidth * 2,
          height: e.handleSize + e.handleLineWidth * 2,
          backgroundColor: "transparent"
        },
        "&::after": {
          content: '""',
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          width: e.handleSize,
          height: e.handleSize,
          backgroundColor: e.colorBgElevated,
          boxShadow: `0 0 0 ${e.handleLineWidth}px ${e.colorPrimaryBorder}`,
          borderRadius: "50%",
          cursor: "pointer",
          transition: `
            inset-inline-start ${e.motionDurationMid},
            inset-block-start ${e.motionDurationMid},
            width ${e.motionDurationMid},
            height ${e.motionDurationMid},
            box-shadow ${e.motionDurationMid}
          `
        },
        "&:hover, &:active, &:focus": {
          "&::before": {
            insetInlineStart: -((e.handleSizeHover - e.handleSize) / 2 + e.handleLineWidthHover),
            insetBlockStart: -((e.handleSizeHover - e.handleSize) / 2 + e.handleLineWidthHover),
            width: e.handleSizeHover + e.handleLineWidthHover * 2,
            height: e.handleSizeHover + e.handleLineWidthHover * 2
          },
          "&::after": {
            boxShadow: `0 0 0 ${e.handleLineWidthHover}px ${e.colorPrimary}`,
            width: e.handleSizeHover,
            height: e.handleSizeHover,
            insetInlineStart: (e.handleSize - e.handleSizeHover) / 2,
            insetBlockStart: (e.handleSize - e.handleSizeHover) / 2
          }
        }
      },
      [`${t}-mark`]: {
        position: "absolute",
        fontSize: e.fontSize
      },
      [`${t}-mark-text`]: {
        position: "absolute",
        display: "inline-block",
        color: e.colorTextDescription,
        textAlign: "center",
        wordBreak: "keep-all",
        cursor: "pointer",
        userSelect: "none",
        "&-active": {
          color: e.colorText
        }
      },
      [`${t}-step`]: {
        position: "absolute",
        background: "transparent",
        pointerEvents: "none"
      },
      [`${t}-dot`]: {
        position: "absolute",
        width: o,
        height: o,
        backgroundColor: e.colorBgElevated,
        border: `${e.handleLineWidth}px solid ${e.colorBorderSecondary}`,
        borderRadius: "50%",
        cursor: "pointer",
        transition: `border-color ${e.motionDurationSlow}`,
        "&-active": {
          borderColor: e.colorPrimaryBorder
        }
      },
      [`&${t}-disabled`]: {
        cursor: "not-allowed",
        [`${t}-rail`]: {
          backgroundColor: `${e.colorFillSecondary} !important`
        },
        [`${t}-track`]: {
          backgroundColor: `${e.colorTextDisabled} !important`
        },
        [`
          ${t}-dot
        `]: {
          backgroundColor: e.colorBgElevated,
          borderColor: e.colorTextDisabled,
          boxShadow: "none",
          cursor: "not-allowed"
        },
        [`${t}-handle::after`]: {
          backgroundColor: e.colorBgElevated,
          cursor: "not-allowed",
          width: e.handleSize,
          height: e.handleSize,
          boxShadow: `0 0 0 ${e.handleLineWidth}px ${new Ct(e.colorTextDisabled).onBackground(e.colorBgContainer).toHexString()}`,
          insetInlineStart: 0,
          insetBlockStart: 0
        },
        [`
          ${t}-mark-text,
          ${t}-dot
        `]: {
          cursor: "not-allowed !important"
        }
      }
    })
  };
}, LC = (e, t) => {
  const {
    componentCls: n,
    railSize: o,
    handleSize: r,
    dotSize: a
  } = e, i = t ? "paddingBlock" : "paddingInline", l = t ? "width" : "height", u = t ? "height" : "width", s = t ? "insetBlockStart" : "insetInlineStart", c = t ? "top" : "insetInlineStart";
  return {
    [i]: o,
    [u]: o * 3,
    [`${n}-rail`]: {
      [l]: "100%",
      [u]: o
    },
    [`${n}-track`]: {
      [u]: o
    },
    [`${n}-handle`]: {
      [s]: (o * 3 - r) / 2
    },
    [`${n}-mark`]: {
      // Reset all
      insetInlineStart: 0,
      top: 0,
      [c]: r,
      [l]: "100%"
    },
    [`${n}-step`]: {
      // Reset all
      insetInlineStart: 0,
      top: 0,
      [c]: o,
      [l]: "100%",
      [u]: o
    },
    [`${n}-dot`]: {
      position: "absolute",
      [s]: (o - a) / 2
    }
  };
}, zL = (e) => {
  const {
    componentCls: t,
    marginPartWithMark: n
  } = e;
  return {
    [`${t}-horizontal`]: h(h({}, LC(e, !0)), {
      [`&${t}-with-marks`]: {
        marginBottom: n
      }
    })
  };
}, jL = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-vertical`]: h(h({}, LC(e, !1)), {
      height: "100%"
    })
  };
}, VL = ht("Slider", (e) => {
  const t = qe(e, {
    marginPart: (e.controlHeight - e.controlSize) / 2,
    marginFull: e.controlSize / 2,
    marginPartWithMark: e.controlHeightLG - e.controlSize
  });
  return [HL(t), zL(t), jL(t)];
}, (e) => {
  const n = e.controlHeightLG / 4, o = e.controlHeightSM / 2, r = e.lineWidth + 1, a = e.lineWidth + 1 * 3;
  return {
    controlSize: n,
    railSize: 4,
    handleSize: n,
    handleSizeHover: o,
    dotSize: 8,
    handleLineWidth: r,
    handleLineWidthHover: a
  };
});
var Ah = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const WL = (e) => typeof e == "number" ? e.toString() : "", KL = () => ({
  id: String,
  prefixCls: String,
  tooltipPrefixCls: String,
  range: dt([Boolean, Object]),
  reverse: Me(),
  min: Number,
  max: Number,
  step: dt([Object, Number]),
  marks: He(),
  dots: Me(),
  value: dt([Array, Number]),
  defaultValue: dt([Array, Number]),
  included: Me(),
  disabled: Me(),
  vertical: Me(),
  tipFormatter: dt([Function, Object], () => WL),
  tooltipOpen: Me(),
  /** @deprecated `tooltipVisible` is deprecated. Please use `tooltipOpen` instead. */
  tooltipVisible: Me(),
  tooltipPlacement: Ze(),
  getTooltipPopupContainer: de(),
  autofocus: Me(),
  handleStyle: dt([Array, Object]),
  trackStyle: dt([Array, Object]),
  onChange: de(),
  onAfterChange: de(),
  onFocus: de(),
  onBlur: de(),
  "onUpdate:value": de()
}), UL = J({
  compatConfig: {
    MODE: 3
  },
  name: "ASlider",
  inheritAttrs: !1,
  props: KL(),
  // emits: ['update:value', 'change', 'afterChange', 'blur'],
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      emit: r,
      expose: a
    } = t;
    process.env.NODE_ENV !== "production" && [["tooltipVisible", "tooltipOpen"]].forEach((x) => {
      let [M, _] = x;
      gt(e.tooltipVisible === void 0, "Slider", `\`${M}\` is deprecated, please use \`${_}\` instead.`);
    });
    const {
      prefixCls: i,
      rootPrefixCls: l,
      direction: u,
      getPopupContainer: s,
      configProvider: c
    } = Ke("slider", e), [d, f] = VL(i), p = Lt(), v = G(), g = G({}), b = (x, M) => {
      g.value[x] = M;
    }, y = T(() => e.tooltipPlacement ? e.tooltipPlacement : e.vertical ? u.value === "rtl" ? "left" : "right" : "top"), S = () => {
      var x;
      (x = v.value) === null || x === void 0 || x.focus();
    }, w = () => {
      var x;
      (x = v.value) === null || x === void 0 || x.blur();
    }, C = (x) => {
      r("update:value", x), r("change", x), p.onFieldChange();
    }, $ = (x) => {
      r("blur", x);
    };
    a({
      focus: S,
      blur: w
    });
    const O = (x) => {
      var {
        tooltipPrefixCls: M
      } = x, _ = x.info, {
        value: N,
        dragging: I,
        index: E
      } = _, B = Ah(_, ["value", "dragging", "index"]);
      const {
        tipFormatter: k,
        tooltipOpen: P = e.tooltipVisible,
        getTooltipPopupContainer: R
      } = e, D = k ? g.value[E] || I : !1, A = P || P === void 0 && D;
      return m(LL, {
        prefixCls: M,
        title: k ? k(N) : "",
        open: A,
        placement: y.value,
        transitionName: `${l.value}-zoom-down`,
        key: E,
        overlayClassName: `${i.value}-tooltip`,
        getPopupContainer: R || (s == null ? void 0 : s.value)
      }, {
        default: () => [m(AC, L(L({}, B), {}, {
          value: N,
          onMouseenter: () => b(E, !0),
          onMouseleave: () => b(E, !1)
        }), null)]
      });
    };
    return () => {
      const {
        tooltipPrefixCls: x,
        range: M,
        id: _ = p.id.value
      } = e, N = Ah(e, ["tooltipPrefixCls", "range", "id"]), I = c.getPrefixCls("tooltip", x), E = ae(n.class, {
        [`${i.value}-rtl`]: u.value === "rtl"
      }, f.value);
      u.value === "rtl" && !N.vertical && (N.reverse = !N.reverse);
      let B;
      return typeof M == "object" && (B = M.draggableTrack), d(M ? m(kL, L(L(L({}, n), N), {}, {
        step: N.step,
        draggableTrack: B,
        class: E,
        ref: v,
        handle: (k) => O({
          tooltipPrefixCls: I,
          prefixCls: i.value,
          info: k
        }),
        prefixCls: i.value,
        onChange: C,
        onBlur: $
      }), {
        mark: o.mark
      }) : m(RL, L(L(L({}, n), N), {}, {
        id: _,
        step: N.step,
        class: E,
        ref: v,
        handle: (k) => O({
          tooltipPrefixCls: I,
          prefixCls: i.value,
          info: k
        }),
        prefixCls: i.value,
        onChange: C,
        onBlur: $
      }), {
        mark: o.mark
      }));
    };
  }
}), GL = Xn(UL), YL = (e) => {
  const {
    componentCls: t
  } = e, n = `${t}-inner`;
  return {
    [t]: {
      [`&${t}-small`]: {
        minWidth: e.switchMinWidthSM,
        height: e.switchHeightSM,
        lineHeight: `${e.switchHeightSM}px`,
        [`${t}-inner`]: {
          paddingInlineStart: e.switchInnerMarginMaxSM,
          paddingInlineEnd: e.switchInnerMarginMinSM,
          [`${n}-checked`]: {
            marginInlineStart: `calc(-100% + ${e.switchPinSizeSM + e.switchPadding * 2}px - ${e.switchInnerMarginMaxSM * 2}px)`,
            marginInlineEnd: `calc(100% - ${e.switchPinSizeSM + e.switchPadding * 2}px + ${e.switchInnerMarginMaxSM * 2}px)`
          },
          [`${n}-unchecked`]: {
            marginTop: -e.switchHeightSM,
            marginInlineStart: 0,
            marginInlineEnd: 0
          }
        },
        [`${t}-handle`]: {
          width: e.switchPinSizeSM,
          height: e.switchPinSizeSM
        },
        [`${t}-loading-icon`]: {
          top: (e.switchPinSizeSM - e.switchLoadingIconSize) / 2,
          fontSize: e.switchLoadingIconSize
        },
        [`&${t}-checked`]: {
          [`${t}-inner`]: {
            paddingInlineStart: e.switchInnerMarginMinSM,
            paddingInlineEnd: e.switchInnerMarginMaxSM,
            [`${n}-checked`]: {
              marginInlineStart: 0,
              marginInlineEnd: 0
            },
            [`${n}-unchecked`]: {
              marginInlineStart: `calc(100% - ${e.switchPinSizeSM + e.switchPadding * 2}px + ${e.switchInnerMarginMaxSM * 2}px)`,
              marginInlineEnd: `calc(-100% + ${e.switchPinSizeSM + e.switchPadding * 2}px - ${e.switchInnerMarginMaxSM * 2}px)`
            }
          },
          [`${t}-handle`]: {
            insetInlineStart: `calc(100% - ${e.switchPinSizeSM + e.switchPadding}px)`
          }
        },
        [`&:not(${t}-disabled):active`]: {
          [`&:not(${t}-checked) ${n}`]: {
            [`${n}-unchecked`]: {
              marginInlineStart: e.marginXXS / 2,
              marginInlineEnd: -e.marginXXS / 2
            }
          },
          [`&${t}-checked ${n}`]: {
            [`${n}-checked`]: {
              marginInlineStart: -e.marginXXS / 2,
              marginInlineEnd: e.marginXXS / 2
            }
          }
        }
      }
    }
  };
}, XL = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      [`${t}-loading-icon${e.iconCls}`]: {
        position: "relative",
        top: (e.switchPinSize - e.fontSize) / 2,
        color: e.switchLoadingIconColor,
        verticalAlign: "top"
      },
      [`&${t}-checked ${t}-loading-icon`]: {
        color: e.switchColor
      }
    }
  };
}, qL = (e) => {
  const {
    componentCls: t
  } = e, n = `${t}-handle`;
  return {
    [t]: {
      [n]: {
        position: "absolute",
        top: e.switchPadding,
        insetInlineStart: e.switchPadding,
        width: e.switchPinSize,
        height: e.switchPinSize,
        transition: `all ${e.switchDuration} ease-in-out`,
        "&::before": {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: 0,
          insetInlineStart: 0,
          backgroundColor: e.colorWhite,
          borderRadius: e.switchPinSize / 2,
          boxShadow: e.switchHandleShadow,
          transition: `all ${e.switchDuration} ease-in-out`,
          content: '""'
        }
      },
      [`&${t}-checked ${n}`]: {
        insetInlineStart: `calc(100% - ${e.switchPinSize + e.switchPadding}px)`
      },
      [`&:not(${t}-disabled):active`]: {
        [`${n}::before`]: {
          insetInlineEnd: e.switchHandleActiveInset,
          insetInlineStart: 0
        },
        [`&${t}-checked ${n}::before`]: {
          insetInlineEnd: 0,
          insetInlineStart: e.switchHandleActiveInset
        }
      }
    }
  };
}, QL = (e) => {
  const {
    componentCls: t
  } = e, n = `${t}-inner`;
  return {
    [t]: {
      [n]: {
        display: "block",
        overflow: "hidden",
        borderRadius: 100,
        height: "100%",
        paddingInlineStart: e.switchInnerMarginMax,
        paddingInlineEnd: e.switchInnerMarginMin,
        transition: `padding-inline-start ${e.switchDuration} ease-in-out, padding-inline-end ${e.switchDuration} ease-in-out`,
        [`${n}-checked, ${n}-unchecked`]: {
          display: "block",
          color: e.colorTextLightSolid,
          fontSize: e.fontSizeSM,
          transition: `margin-inline-start ${e.switchDuration} ease-in-out, margin-inline-end ${e.switchDuration} ease-in-out`,
          pointerEvents: "none"
        },
        [`${n}-checked`]: {
          marginInlineStart: `calc(-100% + ${e.switchPinSize + e.switchPadding * 2}px - ${e.switchInnerMarginMax * 2}px)`,
          marginInlineEnd: `calc(100% - ${e.switchPinSize + e.switchPadding * 2}px + ${e.switchInnerMarginMax * 2}px)`
        },
        [`${n}-unchecked`]: {
          marginTop: -e.switchHeight,
          marginInlineStart: 0,
          marginInlineEnd: 0
        }
      },
      [`&${t}-checked ${n}`]: {
        paddingInlineStart: e.switchInnerMarginMin,
        paddingInlineEnd: e.switchInnerMarginMax,
        [`${n}-checked`]: {
          marginInlineStart: 0,
          marginInlineEnd: 0
        },
        [`${n}-unchecked`]: {
          marginInlineStart: `calc(100% - ${e.switchPinSize + e.switchPadding * 2}px + ${e.switchInnerMarginMax * 2}px)`,
          marginInlineEnd: `calc(-100% + ${e.switchPinSize + e.switchPadding * 2}px - ${e.switchInnerMarginMax * 2}px)`
        }
      },
      [`&:not(${t}-disabled):active`]: {
        [`&:not(${t}-checked) ${n}`]: {
          [`${n}-unchecked`]: {
            marginInlineStart: e.switchPadding * 2,
            marginInlineEnd: -e.switchPadding * 2
          }
        },
        [`&${t}-checked ${n}`]: {
          [`${n}-checked`]: {
            marginInlineStart: -e.switchPadding * 2,
            marginInlineEnd: e.switchPadding * 2
          }
        }
      }
    }
  };
}, ZL = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: h(h(h(h({}, st(e)), {
      position: "relative",
      display: "inline-block",
      boxSizing: "border-box",
      minWidth: e.switchMinWidth,
      height: e.switchHeight,
      lineHeight: `${e.switchHeight}px`,
      verticalAlign: "middle",
      background: e.colorTextQuaternary,
      border: "0",
      borderRadius: 100,
      cursor: "pointer",
      transition: `all ${e.motionDurationMid}`,
      userSelect: "none",
      [`&:hover:not(${t}-disabled)`]: {
        background: e.colorTextTertiary
      }
    }), $i(e)), {
      [`&${t}-checked`]: {
        background: e.switchColor,
        [`&:hover:not(${t}-disabled)`]: {
          background: e.colorPrimaryHover
        }
      },
      [`&${t}-loading, &${t}-disabled`]: {
        cursor: "not-allowed",
        opacity: e.switchDisabledOpacity,
        "*": {
          boxShadow: "none",
          cursor: "not-allowed"
        }
      },
      // rtl style
      [`&${t}-rtl`]: {
        direction: "rtl"
      }
    })
  };
}, JL = ht("Switch", (e) => {
  const t = e.fontSize * e.lineHeight, n = e.controlHeight / 2, o = 2, r = t - o * 2, a = n - o * 2, i = qe(e, {
    switchMinWidth: r * 2 + o * 4,
    switchHeight: t,
    switchDuration: e.motionDurationMid,
    switchColor: e.colorPrimary,
    switchDisabledOpacity: e.opacityLoading,
    switchInnerMarginMin: r / 2,
    switchInnerMarginMax: r + o + o * 2,
    switchPadding: o,
    switchPinSize: r,
    switchBg: e.colorBgContainer,
    switchMinWidthSM: a * 2 + o * 2,
    switchHeightSM: n,
    switchInnerMarginMinSM: a / 2,
    switchInnerMarginMaxSM: a + o + o * 2,
    switchPinSizeSM: a,
    switchHandleShadow: `0 2px 4px 0 ${new Ct("#00230b").setAlpha(0.2).toRgbString()}`,
    switchLoadingIconSize: e.fontSizeIcon * 0.75,
    switchLoadingIconColor: `rgba(0, 0, 0, ${e.opacityLoading})`,
    switchHandleActiveInset: "-30%"
  });
  return [
    ZL(i),
    // inner style
    QL(i),
    // handle style
    qL(i),
    // loading style
    XL(i),
    // small style
    YL(i)
  ];
}), eH = ro("small", "default"), tH = () => ({
  id: String,
  prefixCls: String,
  size: W.oneOf(eH),
  disabled: {
    type: Boolean,
    default: void 0
  },
  checkedChildren: W.any,
  unCheckedChildren: W.any,
  tabindex: W.oneOfType([W.string, W.number]),
  autofocus: {
    type: Boolean,
    default: void 0
  },
  loading: {
    type: Boolean,
    default: void 0
  },
  checked: W.oneOfType([W.string, W.number, W.looseBool]),
  checkedValue: W.oneOfType([W.string, W.number, W.looseBool]).def(!0),
  unCheckedValue: W.oneOfType([W.string, W.number, W.looseBool]).def(!1),
  onChange: {
    type: Function
  },
  onClick: {
    type: Function
  },
  onKeydown: {
    type: Function
  },
  onMouseup: {
    type: Function
  },
  "onUpdate:checked": {
    type: Function
  },
  onBlur: Function,
  onFocus: Function
}), nH = J({
  compatConfig: {
    MODE: 3
  },
  name: "ASwitch",
  __ANT_SWITCH: !0,
  inheritAttrs: !1,
  props: tH(),
  slots: Object,
  // emits: ['update:checked', 'mouseup', 'change', 'click', 'keydown', 'blur'],
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      expose: r,
      emit: a
    } = t;
    const i = Lt(), l = Cn(), u = T(() => {
      var _;
      return (_ = e.disabled) !== null && _ !== void 0 ? _ : l.value;
    });
    gd(() => {
      Pt(!("defaultChecked" in n), "Switch", "'defaultChecked' is deprecated, please use 'v-model:checked'"), Pt(!("value" in n), "Switch", "`value` is not validate prop, do you mean `checked`?");
    });
    const s = G(e.checked !== void 0 ? e.checked : n.defaultChecked), c = T(() => s.value === e.checkedValue);
    le(() => e.checked, () => {
      s.value = e.checked;
    });
    const {
      prefixCls: d,
      direction: f,
      size: p
    } = Ke("switch", e), [v, g] = JL(d), b = G(), y = () => {
      var _;
      (_ = b.value) === null || _ === void 0 || _.focus();
    };
    r({
      focus: y,
      blur: () => {
        var _;
        (_ = b.value) === null || _ === void 0 || _.blur();
      }
    }), ze(() => {
      mt(() => {
        e.autofocus && !u.value && b.value.focus();
      });
    });
    const w = (_, N) => {
      u.value || (a("update:checked", _), a("change", _, N), i.onFieldChange());
    }, C = (_) => {
      a("blur", _);
    }, $ = (_) => {
      y();
      const N = c.value ? e.unCheckedValue : e.checkedValue;
      w(N, _), a("click", N, _);
    }, O = (_) => {
      _.keyCode === ee.LEFT ? w(e.unCheckedValue, _) : _.keyCode === ee.RIGHT && w(e.checkedValue, _), a("keydown", _);
    }, x = (_) => {
      var N;
      (N = b.value) === null || N === void 0 || N.blur(), a("mouseup", _);
    }, M = T(() => ({
      [`${d.value}-small`]: p.value === "small",
      [`${d.value}-loading`]: e.loading,
      [`${d.value}-checked`]: c.value,
      [`${d.value}-disabled`]: u.value,
      [d.value]: !0,
      [`${d.value}-rtl`]: f.value === "rtl",
      [g.value]: !0
    }));
    return () => {
      var _;
      return v(m(Pf, null, {
        default: () => [m("button", L(L(L({}, pt(e, ["prefixCls", "checkedChildren", "unCheckedChildren", "checked", "autofocus", "checkedValue", "unCheckedValue", "id", "onChange", "onUpdate:checked"])), n), {}, {
          id: (_ = e.id) !== null && _ !== void 0 ? _ : i.id.value,
          onKeydown: O,
          onClick: $,
          onBlur: C,
          onMouseup: x,
          type: "button",
          role: "switch",
          "aria-checked": s.value,
          disabled: u.value || e.loading,
          class: [n.class, M.value],
          ref: b
        }), [m("div", {
          class: `${d.value}-handle`
        }, [e.loading ? m(pn, {
          class: `${d.value}-loading-icon`
        }, null) : null]), m("span", {
          class: `${d.value}-inner`
        }, [m("span", {
          class: `${d.value}-inner-checked`
        }, [Uo(o, e, "checkedChildren")]), m("span", {
          class: `${d.value}-inner-unchecked`
        }, [Uo(o, e, "unCheckedChildren")])])])]
      }));
    };
  }
}), oH = Xn(nH);
var Nh = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const rH = J({
  compatConfig: {
    MODE: 3
  },
  name: "MotionTreeNode",
  inheritAttrs: !1,
  props: h(h({}, d$), {
    active: Boolean,
    motion: Object,
    motionNodes: {
      type: Array
    },
    onMotionStart: Function,
    onMotionEnd: Function,
    motionType: String
  }),
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const r = K(!0), a = tp(), i = K(!1), l = T(() => e.motion ? e.motion : As()), u = (s, c) => {
      var d, f, p, v;
      c === "appear" ? (f = (d = l.value) === null || d === void 0 ? void 0 : d.onAfterEnter) === null || f === void 0 || f.call(d, s) : c === "leave" && ((v = (p = l.value) === null || p === void 0 ? void 0 : p.onAfterLeave) === null || v === void 0 || v.call(p, s)), i.value || e.onMotionEnd(), i.value = !0;
    };
    return le(() => e.motionNodes, () => {
      e.motionNodes && e.motionType === "hide" && r.value && mt(() => {
        r.value = !1;
      });
    }, {
      immediate: !0,
      flush: "post"
    }), ze(() => {
      e.motionNodes && e.onMotionStart();
    }), at(() => {
      e.motionNodes && u();
    }), () => {
      const {
        motion: s,
        motionNodes: c,
        motionType: d,
        active: f,
        eventKey: p
      } = e, v = Nh(e, ["motion", "motionNodes", "motionType", "active", "eventKey"]);
      return c ? m(Yn, L(L({}, l.value), {}, {
        appear: d === "show",
        onAfterAppear: (g) => u(g, "appear"),
        onAfterLeave: (g) => u(g, "leave")
      }), {
        default: () => [An(m("div", {
          class: `${a.value.prefixCls}-treenode-motion`
        }, [c.map((g) => {
          const b = Nh(g.data, []), {
            title: y,
            key: S,
            isStart: w,
            isEnd: C
          } = g;
          return delete b.children, m(Mg, L(L({}, b), {}, {
            title: y,
            active: f,
            data: g.data,
            key: S,
            eventKey: S,
            isStart: w,
            isEnd: C
          }), o);
        })]), [[wo, r.value]])]
      }) : m(Mg, L(L({
        class: n.class,
        style: n.style
      }, v), {}, {
        active: f,
        eventKey: p
      }), o);
    };
  }
});
function aH() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  const n = e.length, o = t.length;
  if (Math.abs(n - o) !== 1)
    return {
      add: !1,
      key: null
    };
  function r(a, i) {
    const l = /* @__PURE__ */ new Map();
    a.forEach((s) => {
      l.set(s, !0);
    });
    const u = i.filter((s) => !l.has(s));
    return u.length === 1 ? u[0] : null;
  }
  return n < o ? {
    add: !0,
    key: r(e, t)
  } : {
    add: !1,
    key: r(t, e)
  };
}
function Rh(e, t, n) {
  const o = e.findIndex((i) => i.key === n), r = e[o + 1], a = t.findIndex((i) => i.key === n);
  if (r) {
    const i = t.findIndex((l) => l.key === r.key);
    return t.slice(a + 1, i);
  }
  return t.slice(a + 1);
}
var Fh = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const Bh = {
  width: 0,
  height: 0,
  display: "flex",
  overflow: "hidden",
  opacity: 0,
  border: 0,
  padding: 0,
  margin: 0
}, iH = () => {
}, Or = `RC_TREE_MOTION_${Math.random()}`, dd = {
  key: Or
}, HC = {
  key: Or,
  level: 0,
  index: 0,
  pos: "0",
  node: dd,
  nodes: [dd]
}, kh = {
  parent: null,
  children: [],
  pos: HC.pos,
  data: dd,
  title: null,
  key: Or,
  /** Hold empty list here since we do not use it */
  isStart: [],
  isEnd: []
};
function Lh(e, t, n, o) {
  return t === !1 || !n ? e : e.slice(0, Math.ceil(n / o) + 1);
}
function Hh(e) {
  const {
    key: t,
    pos: n
  } = e;
  return Ti(t, n);
}
function lH(e) {
  let t = String(e.key), n = e;
  for (; n.parent; )
    n = n.parent, t = `${n.key} > ${t}`;
  return t;
}
const sH = J({
  compatConfig: {
    MODE: 3
  },
  name: "NodeList",
  inheritAttrs: !1,
  props: Y3,
  setup(e, t) {
    let {
      expose: n,
      attrs: o
    } = t;
    const r = G(), a = G(), {
      expandedKeys: i,
      flattenNodes: l
    } = c$();
    n({
      scrollTo: (g) => {
        r.value.scrollTo(g);
      },
      getIndentWidth: () => a.value.offsetWidth
    });
    const u = K(l.value), s = K([]), c = G(null);
    function d() {
      u.value = l.value, s.value = [], c.value = null, e.onListChangeEnd();
    }
    const f = tp();
    le([() => i.value.slice(), l], (g, b) => {
      let [y, S] = g, [w, C] = b;
      const $ = aH(w, y);
      if ($.key !== null) {
        const {
          virtual: O,
          height: x,
          itemHeight: M
        } = e;
        if ($.add) {
          const _ = C.findIndex((E) => {
            let {
              key: B
            } = E;
            return B === $.key;
          }), N = Lh(Rh(C, S, $.key), O, x, M), I = C.slice();
          I.splice(_ + 1, 0, kh), u.value = I, s.value = N, c.value = "show";
        } else {
          const _ = S.findIndex((E) => {
            let {
              key: B
            } = E;
            return B === $.key;
          }), N = Lh(Rh(S, C, $.key), O, x, M), I = S.slice();
          I.splice(_ + 1, 0, kh), u.value = I, s.value = N, c.value = "hide";
        }
      } else
        C !== S && (u.value = S);
    }), le(() => f.value.dragging, (g) => {
      g || d();
    });
    const p = T(() => e.motion === void 0 ? u.value : l.value), v = () => {
      e.onActiveChange(null);
    };
    return () => {
      const g = h(h({}, e), o), {
        prefixCls: b,
        selectable: y,
        checkable: S,
        disabled: w,
        motion: C,
        height: $,
        itemHeight: O,
        virtual: x,
        focusable: M,
        activeItem: _,
        focused: N,
        tabindex: I,
        onKeydown: E,
        onFocus: B,
        onBlur: k,
        onListChangeStart: P,
        onListChangeEnd: R
      } = g, D = Fh(g, ["prefixCls", "selectable", "checkable", "disabled", "motion", "height", "itemHeight", "virtual", "focusable", "activeItem", "focused", "tabindex", "onKeydown", "onFocus", "onBlur", "onListChangeStart", "onListChangeEnd"]);
      return m(We, null, [N && _ && m("span", {
        style: Bh,
        "aria-live": "assertive"
      }, [lH(_)]), m("div", null, [m("input", {
        style: Bh,
        disabled: M === !1 || w,
        tabindex: M !== !1 ? I : null,
        onKeydown: E,
        onFocus: B,
        onBlur: k,
        value: "",
        onChange: iH,
        "aria-label": "for screen reader"
      }, null)]), m("div", {
        class: `${b}-treenode`,
        "aria-hidden": !0,
        style: {
          position: "absolute",
          pointerEvents: "none",
          visibility: "hidden",
          height: 0,
          overflow: "hidden"
        }
      }, [m("div", {
        class: `${b}-indent`
      }, [m("div", {
        ref: a,
        class: `${b}-indent-unit`
      }, null)])]), m(u0, L(L({}, pt(D, ["onActiveChange"])), {}, {
        data: p.value,
        itemKey: Hh,
        height: $,
        fullHeight: !1,
        virtual: x,
        itemHeight: O,
        prefixCls: `${b}-list`,
        ref: r,
        onVisibleChange: (A, H) => {
          const j = new Set(A);
          H.filter((F) => !j.has(F)).some((F) => Hh(F) === Or) && d();
        }
      }), {
        default: (A) => {
          const {
            pos: H
          } = A, j = Fh(A.data, []), {
            title: z,
            key: F,
            isStart: U,
            isEnd: Q
          } = A, q = Ti(F, H);
          return delete j.key, delete j.children, m(rH, L(L({}, j), {}, {
            eventKey: q,
            title: z,
            active: !!_ && F === _.key,
            data: A.data,
            isStart: U,
            isEnd: Q,
            motion: C,
            motionNodes: F === Or ? s.value : null,
            motionType: c.value,
            onMotionStart: P,
            onMotionEnd: d,
            onMousemove: v
          }), null);
        }
      })]);
    };
  }
});
function uH(e) {
  let {
    dropPosition: t,
    dropLevelOffset: n,
    indent: o
  } = e;
  const r = {
    pointerEvents: "none",
    position: "absolute",
    right: 0,
    backgroundColor: "red",
    height: "2px"
  };
  switch (t) {
    case -1:
      r.top = 0, r.left = `${-n * o}px`;
      break;
    case 1:
      r.bottom = 0, r.left = `${-n * o}px`;
      break;
    case 0:
      r.bottom = 0, r.left = `${o}`;
      break;
  }
  return m("div", {
    style: r
  }, null);
}
const cH = 10, dH = J({
  compatConfig: {
    MODE: 3
  },
  name: "Tree",
  inheritAttrs: !1,
  props: bt(X3(), {
    prefixCls: "vc-tree",
    showLine: !1,
    showIcon: !0,
    selectable: !0,
    multiple: !1,
    checkable: !1,
    disabled: !1,
    checkStrictly: !1,
    draggable: !1,
    expandAction: !1,
    defaultExpandParent: !0,
    autoExpandParent: !1,
    defaultExpandAll: !1,
    defaultExpandedKeys: [],
    defaultCheckedKeys: [],
    defaultSelectedKeys: [],
    dropIndicatorRender: uH,
    allowDrop: () => !0
  }),
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      expose: r
    } = t;
    const a = K(!1);
    let i = {};
    const l = K(), u = K([]), s = K([]), c = K([]), d = K([]), f = K([]), p = K([]), v = {}, g = Et({
      draggingNodeKey: null,
      dragChildrenKeys: [],
      // dropTargetKey is the key of abstract-drop-node
      // the abstract-drop-node is the real drop node when drag and drop
      // not the DOM drag over node
      dropTargetKey: null,
      dropPosition: null,
      dropContainerKey: null,
      dropLevelOffset: null,
      dropTargetPos: null,
      dropAllowed: !0,
      // the abstract-drag-over-node
      // if mouse is on the bottom of top dom node or no the top of the bottom dom node
      // abstract-drag-over-node is the top node
      dragOverNodeKey: null
    }), b = K([]);
    le([() => e.treeData, () => e.children], () => {
      b.value = e.treeData !== void 0 ? Ft(e.treeData).slice() : oF(Ft(e.children));
    }, {
      immediate: !0,
      deep: !0
    });
    const y = K({}), S = K(!1), w = K(null), C = K(!1), $ = T(() => op(e.fieldNames)), O = K();
    let x = null, M = null, _ = null;
    const N = T(() => ({
      expandedKeysSet: I.value,
      selectedKeysSet: E.value,
      loadedKeysSet: B.value,
      loadingKeysSet: k.value,
      checkedKeysSet: P.value,
      halfCheckedKeysSet: R.value,
      dragOverNodeKey: g.dragOverNodeKey,
      dropPosition: g.dropPosition,
      keyEntities: y.value
    })), I = T(() => new Set(p.value)), E = T(() => new Set(u.value)), B = T(() => new Set(d.value)), k = T(() => new Set(f.value)), P = T(() => new Set(s.value)), R = T(() => new Set(c.value));
    Ve(() => {
      if (b.value) {
        const ue = p$(b.value, {
          fieldNames: $.value
        });
        y.value = h({
          [Or]: HC
        }, ue.keyEntities);
      }
    });
    let D = !1;
    le(
      [() => e.expandedKeys, () => e.autoExpandParent, y],
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      (ue, fe) => {
        let [ve, Ie] = ue, [Fe, Oe] = fe, De = p.value;
        if (e.expandedKeys !== void 0 || D && Ie !== Oe)
          De = e.autoExpandParent || !D && e.defaultExpandParent ? Ag(e.expandedKeys, y.value) : e.expandedKeys;
        else if (!D && e.defaultExpandAll) {
          const je = h({}, y.value);
          delete je[Or], De = Object.keys(je).map((et) => je[et].key);
        } else
          !D && e.defaultExpandedKeys && (De = e.autoExpandParent || e.defaultExpandParent ? Ag(e.defaultExpandedKeys, y.value) : e.defaultExpandedKeys);
        De && (p.value = De), D = !0;
      },
      {
        immediate: !0
      }
    );
    const A = K([]);
    Ve(() => {
      A.value = rF(b.value, p.value, $.value);
    }), Ve(() => {
      e.selectable && (e.selectedKeys !== void 0 ? u.value = Dg(e.selectedKeys, e) : !D && e.defaultSelectedKeys && (u.value = Dg(e.defaultSelectedKeys, e)));
    });
    const {
      maxLevel: H,
      levelEntities: j
    } = m$(y);
    Ve(() => {
      if (e.checkable) {
        let ue;
        if (e.checkedKeys !== void 0 ? ue = _u(e.checkedKeys) || {} : !D && e.defaultCheckedKeys ? ue = _u(e.defaultCheckedKeys) || {} : b.value && (ue = _u(e.checkedKeys) || {
          checkedKeys: s.value,
          halfCheckedKeys: c.value
        }), ue) {
          let {
            checkedKeys: fe = [],
            halfCheckedKeys: ve = []
          } = ue;
          e.checkStrictly || ({
            checkedKeys: fe,
            halfCheckedKeys: ve
          } = na(fe, !0, y.value, H.value, j.value)), s.value = fe, c.value = ve;
        }
      }
    }), Ve(() => {
      e.loadedKeys && (d.value = e.loadedKeys);
    });
    const z = () => {
      h(g, {
        dragOverNodeKey: null,
        dropPosition: null,
        dropLevelOffset: null,
        dropTargetKey: null,
        dropContainerKey: null,
        dropTargetPos: null,
        dropAllowed: !1
      });
    }, F = (ue) => {
      O.value.scrollTo(ue);
    };
    le(() => e.activeKey, () => {
      e.activeKey !== void 0 && (w.value = e.activeKey);
    }, {
      immediate: !0
    }), le(w, (ue) => {
      mt(() => {
        ue !== null && F({
          key: ue
        });
      });
    }, {
      immediate: !0,
      flush: "post"
    });
    const U = (ue) => {
      e.expandedKeys === void 0 && (p.value = ue);
    }, Q = () => {
      g.draggingNodeKey !== null && h(g, {
        draggingNodeKey: null,
        dropPosition: null,
        dropContainerKey: null,
        dropTargetKey: null,
        dropLevelOffset: null,
        dropAllowed: !0,
        dragOverNodeKey: null
      }), x = null, _ = null;
    }, q = (ue, fe) => {
      const {
        onDragend: ve
      } = e;
      g.dragOverNodeKey = null, Q(), ve == null || ve({
        event: ue,
        node: fe.eventData
      }), M = null;
    }, oe = (ue) => {
      q(ue, null), window.removeEventListener("dragend", oe);
    }, Z = (ue, fe) => {
      const {
        onDragstart: ve
      } = e, {
        eventKey: Ie,
        eventData: Fe
      } = fe;
      M = fe, x = {
        x: ue.clientX,
        y: ue.clientY
      };
      const Oe = co(p.value, Ie);
      g.draggingNodeKey = Ie, g.dragChildrenKeys = J3(Ie, y.value), l.value = O.value.getIndentWidth(), U(Oe), window.addEventListener("dragend", oe), ve && ve({
        event: ue,
        node: Fe
      });
    }, ne = (ue, fe) => {
      const {
        onDragenter: ve,
        onExpand: Ie,
        allowDrop: Fe,
        direction: Oe
      } = e, {
        pos: De,
        eventKey: je
      } = fe;
      if (_ !== je && (_ = je), !M) {
        z();
        return;
      }
      const {
        dropPosition: et,
        dropLevelOffset: Ge,
        dropTargetKey: tt,
        dropContainerKey: ut,
        dropTargetPos: Bt,
        dropAllowed: Jt,
        dragOverNodeKey: en
      } = _g(ue, M, fe, l.value, x, Fe, A.value, y.value, I.value, Oe);
      if (
        // don't allow drop inside its children
        g.dragChildrenKeys.indexOf(tt) !== -1 || // don't allow drop when drop is not allowed caculated by calcDropPosition
        !Jt
      ) {
        z();
        return;
      }
      if (i || (i = {}), Object.keys(i).forEach((zt) => {
        clearTimeout(i[zt]);
      }), M.eventKey !== fe.eventKey && (i[De] = window.setTimeout(() => {
        if (g.draggingNodeKey === null)
          return;
        let zt = p.value.slice();
        const an = y.value[fe.eventKey];
        an && (an.children || []).length && (zt = Ro(p.value, fe.eventKey)), U(zt), Ie && Ie(zt, {
          node: fe.eventData,
          expanded: !0,
          nativeEvent: ue
        });
      }, 800)), M.eventKey === tt && Ge === 0) {
        z();
        return;
      }
      h(g, {
        dragOverNodeKey: en,
        dropPosition: et,
        dropLevelOffset: Ge,
        dropTargetKey: tt,
        dropContainerKey: ut,
        dropTargetPos: Bt,
        dropAllowed: Jt
      }), ve && ve({
        event: ue,
        node: fe.eventData,
        expandedKeys: p.value
      });
    }, Y = (ue, fe) => {
      const {
        onDragover: ve,
        allowDrop: Ie,
        direction: Fe
      } = e;
      if (!M)
        return;
      const {
        dropPosition: Oe,
        dropLevelOffset: De,
        dropTargetKey: je,
        dropContainerKey: et,
        dropAllowed: Ge,
        dropTargetPos: tt,
        dragOverNodeKey: ut
      } = _g(ue, M, fe, l.value, x, Ie, A.value, y.value, I.value, Fe);
      g.dragChildrenKeys.indexOf(je) !== -1 || !Ge || (M.eventKey === je && De === 0 ? g.dropPosition === null && g.dropLevelOffset === null && g.dropTargetKey === null && g.dropContainerKey === null && g.dropTargetPos === null && g.dropAllowed === !1 && g.dragOverNodeKey === null || z() : Oe === g.dropPosition && De === g.dropLevelOffset && je === g.dropTargetKey && et === g.dropContainerKey && tt === g.dropTargetPos && Ge === g.dropAllowed && ut === g.dragOverNodeKey || h(g, {
        dropPosition: Oe,
        dropLevelOffset: De,
        dropTargetKey: je,
        dropContainerKey: et,
        dropTargetPos: tt,
        dropAllowed: Ge,
        dragOverNodeKey: ut
      }), ve && ve({
        event: ue,
        node: fe.eventData
      }));
    }, V = (ue, fe) => {
      _ === fe.eventKey && !ue.currentTarget.contains(ue.relatedTarget) && (z(), _ = null);
      const {
        onDragleave: ve
      } = e;
      ve && ve({
        event: ue,
        node: fe.eventData
      });
    }, X = function(ue, fe) {
      let ve = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
      var Ie;
      const {
        dragChildrenKeys: Fe,
        dropPosition: Oe,
        dropTargetKey: De,
        dropTargetPos: je,
        dropAllowed: et
      } = g;
      if (!et)
        return;
      const {
        onDrop: Ge
      } = e;
      if (g.dragOverNodeKey = null, Q(), De === null)
        return;
      const tt = h(h({}, gl(De, Ft(N.value))), {
        active: ((Ie = Pe.value) === null || Ie === void 0 ? void 0 : Ie.key) === De,
        data: y.value[De].node
      }), ut = Fe.indexOf(De) !== -1;
      lt(!ut, "Can not drop to dragNode's children node. Maybe this is a bug of ant-design-vue. Please report an issue.");
      const Bt = np(je), Jt = {
        event: ue,
        node: hl(tt),
        dragNode: M ? M.eventData : null,
        dragNodesKeys: [M.eventKey].concat(Fe),
        dropToGap: Oe !== 0,
        dropPosition: Oe + Number(Bt[Bt.length - 1])
      };
      ve || Ge == null || Ge(Jt), M = null;
    }, re = (ue, fe) => {
      const {
        expanded: ve,
        key: Ie
      } = fe, Fe = A.value.filter((De) => De.key === Ie)[0], Oe = hl(h(h({}, gl(Ie, N.value)), {
        data: Fe.data
      }));
      U(ve ? co(p.value, Ie) : Ro(p.value, Ie)), Ce(ue, Oe);
    }, ie = (ue, fe) => {
      const {
        onClick: ve,
        expandAction: Ie
      } = e;
      Ie === "click" && re(ue, fe), ve && ve(ue, fe);
    }, he = (ue, fe) => {
      const {
        onDblclick: ve,
        expandAction: Ie
      } = e;
      (Ie === "doubleclick" || Ie === "dblclick") && re(ue, fe), ve && ve(ue, fe);
    }, ge = (ue, fe) => {
      let ve = u.value;
      const {
        onSelect: Ie,
        multiple: Fe
      } = e, {
        selected: Oe
      } = fe, De = fe[$.value.key], je = !Oe;
      je ? Fe ? ve = Ro(ve, De) : ve = [De] : ve = co(ve, De);
      const et = y.value, Ge = ve.map((tt) => {
        const ut = et[tt];
        return ut ? ut.node : null;
      }).filter((tt) => tt);
      e.selectedKeys === void 0 && (u.value = ve), Ie && Ie(ve, {
        event: "select",
        selected: je,
        node: fe,
        selectedNodes: Ge,
        nativeEvent: ue
      });
    }, we = (ue, fe, ve) => {
      const {
        checkStrictly: Ie,
        onCheck: Fe
      } = e, Oe = fe[$.value.key];
      let De;
      const je = {
        event: "check",
        node: fe,
        checked: ve,
        nativeEvent: ue
      }, et = y.value;
      if (Ie) {
        const Ge = ve ? Ro(s.value, Oe) : co(s.value, Oe), tt = co(c.value, Oe);
        De = {
          checked: Ge,
          halfChecked: tt
        }, je.checkedNodes = Ge.map((ut) => et[ut]).filter((ut) => ut).map((ut) => ut.node), e.checkedKeys === void 0 && (s.value = Ge);
      } else {
        let {
          checkedKeys: Ge,
          halfCheckedKeys: tt
        } = na([...s.value, Oe], !0, et, H.value, j.value);
        if (!ve) {
          const ut = new Set(Ge);
          ut.delete(Oe), {
            checkedKeys: Ge,
            halfCheckedKeys: tt
          } = na(Array.from(ut), {
            checked: !1,
            halfCheckedKeys: tt
          }, et, H.value, j.value);
        }
        De = Ge, je.checkedNodes = [], je.checkedNodesPositions = [], je.halfCheckedKeys = tt, Ge.forEach((ut) => {
          const Bt = et[ut];
          if (!Bt)
            return;
          const {
            node: Jt,
            pos: en
          } = Bt;
          je.checkedNodes.push(Jt), je.checkedNodesPositions.push({
            node: Jt,
            pos: en
          });
        }), e.checkedKeys === void 0 && (s.value = Ge, c.value = tt);
      }
      Fe && Fe(De, je);
    }, Le = (ue) => {
      const fe = ue[$.value.key], ve = new Promise((Ie, Fe) => {
        const {
          loadData: Oe,
          onLoad: De
        } = e;
        if (!Oe || B.value.has(fe) || k.value.has(fe))
          return null;
        Oe(ue).then(() => {
          const et = Ro(d.value, fe), Ge = co(f.value, fe);
          De && De(et, {
            event: "load",
            node: ue
          }), e.loadedKeys === void 0 && (d.value = et), f.value = Ge, Ie();
        }).catch((et) => {
          const Ge = co(f.value, fe);
          if (f.value = Ge, v[fe] = (v[fe] || 0) + 1, v[fe] >= cH) {
            lt(!1, "Retry for `loadData` many times but still failed. No more retry.");
            const tt = Ro(d.value, fe);
            e.loadedKeys === void 0 && (d.value = tt), Ie();
          }
          Fe(et);
        }), f.value = Ro(f.value, fe);
      });
      return ve.catch(() => {
      }), ve;
    }, be = (ue, fe) => {
      const {
        onMouseenter: ve
      } = e;
      ve && ve({
        event: ue,
        node: fe
      });
    }, pe = (ue, fe) => {
      const {
        onMouseleave: ve
      } = e;
      ve && ve({
        event: ue,
        node: fe
      });
    }, xe = (ue, fe) => {
      const {
        onRightClick: ve
      } = e;
      ve && (ue.preventDefault(), ve({
        event: ue,
        node: fe
      }));
    }, Ne = (ue) => {
      const {
        onFocus: fe
      } = e;
      S.value = !0, fe && fe(ue);
    }, ye = (ue) => {
      const {
        onBlur: fe
      } = e;
      S.value = !1, se(null), fe && fe(ue);
    }, Ce = (ue, fe) => {
      let ve = p.value;
      const {
        onExpand: Ie,
        loadData: Fe
      } = e, {
        expanded: Oe
      } = fe, De = fe[$.value.key];
      if (C.value)
        return;
      const je = ve.indexOf(De), et = !Oe;
      if (lt(Oe && je !== -1 || !Oe && je === -1, "Expand state not sync with index check"), et ? ve = Ro(ve, De) : ve = co(ve, De), U(ve), Ie && Ie(ve, {
        node: fe,
        expanded: et,
        nativeEvent: ue
      }), et && Fe) {
        const Ge = Le(fe);
        Ge && Ge.then(() => {
        }).catch((tt) => {
          const ut = co(p.value, De);
          U(ut), Promise.reject(tt);
        });
      }
    }, Te = () => {
      C.value = !0;
    }, te = () => {
      setTimeout(() => {
        C.value = !1;
      });
    }, se = (ue) => {
      const {
        onActiveChange: fe
      } = e;
      w.value !== ue && (e.activeKey !== void 0 && (w.value = ue), ue !== null && F({
        key: ue
      }), fe && fe(ue));
    }, Pe = T(() => w.value === null ? null : A.value.find((ue) => {
      let {
        key: fe
      } = ue;
      return fe === w.value;
    }) || null), _e = (ue) => {
      let fe = A.value.findIndex((Ie) => {
        let {
          key: Fe
        } = Ie;
        return Fe === w.value;
      });
      fe === -1 && ue < 0 && (fe = A.value.length), fe = (fe + ue + A.value.length) % A.value.length;
      const ve = A.value[fe];
      if (ve) {
        const {
          key: Ie
        } = ve;
        se(Ie);
      } else
        se(null);
    }, Ee = T(() => hl(h(h({}, gl(w.value, N.value)), {
      data: Pe.value.data,
      active: !0
    }))), Be = (ue) => {
      const {
        onKeydown: fe,
        checkable: ve,
        selectable: Ie
      } = e;
      switch (ue.which) {
        case ee.UP: {
          _e(-1), ue.preventDefault();
          break;
        }
        case ee.DOWN: {
          _e(1), ue.preventDefault();
          break;
        }
      }
      const Fe = Pe.value;
      if (Fe && Fe.data) {
        const Oe = Fe.data.isLeaf === !1 || !!(Fe.data.children || []).length, De = Ee.value;
        switch (ue.which) {
          case ee.LEFT: {
            Oe && I.value.has(w.value) ? Ce({}, De) : Fe.parent && se(Fe.parent.key), ue.preventDefault();
            break;
          }
          case ee.RIGHT: {
            Oe && !I.value.has(w.value) ? Ce({}, De) : Fe.children && Fe.children.length && se(Fe.children[0].key), ue.preventDefault();
            break;
          }
          case ee.ENTER:
          case ee.SPACE: {
            ve && !De.disabled && De.checkable !== !1 && !De.disableCheckbox ? we({}, De, !P.value.has(w.value)) : !ve && Ie && !De.disabled && De.selectable !== !1 && ge({}, De);
            break;
          }
        }
      }
      fe && fe(ue);
    };
    return r({
      onNodeExpand: Ce,
      scrollTo: F,
      onKeydown: Be,
      selectedKeys: T(() => u.value),
      checkedKeys: T(() => s.value),
      halfCheckedKeys: T(() => c.value),
      loadedKeys: T(() => d.value),
      loadingKeys: T(() => f.value),
      expandedKeys: T(() => p.value)
    }), Xo(() => {
      window.removeEventListener("dragend", oe), a.value = !0;
    }), U3({
      expandedKeys: p,
      selectedKeys: u,
      loadedKeys: d,
      loadingKeys: f,
      checkedKeys: s,
      halfCheckedKeys: c,
      expandedKeysSet: I,
      selectedKeysSet: E,
      loadedKeysSet: B,
      loadingKeysSet: k,
      checkedKeysSet: P,
      halfCheckedKeysSet: R,
      flattenNodes: A
    }), () => {
      const {
        // focused,
        // flattenNodes,
        // keyEntities,
        draggingNodeKey: ue,
        // activeKey,
        dropLevelOffset: fe,
        dropContainerKey: ve,
        dropTargetKey: Ie,
        dropPosition: Fe,
        dragOverNodeKey: Oe
        // indent,
      } = g, {
        prefixCls: De,
        showLine: je,
        focusable: et,
        tabindex: Ge = 0,
        selectable: tt,
        showIcon: ut,
        icon: Bt = o.icon,
        switcherIcon: Jt,
        draggable: en,
        checkable: zt,
        checkStrictly: an,
        disabled: Bn,
        motion: Eo,
        loadData: Mo,
        filterTreeNode: tr,
        height: Ma,
        itemHeight: me,
        virtual: Re,
        dropIndicatorRender: Ae,
        onContextmenu: vt,
        onScroll: _t,
        direction: It,
        rootClassName: ln,
        rootStyle: jt
      } = e, {
        class: Zn,
        style: mn
      } = n, Pn = _r(h(h({}, e), n), {
        aria: !0,
        data: !0
      });
      let St;
      return en ? typeof en == "object" ? St = en : typeof en == "function" ? St = {
        nodeDraggable: en
      } : St = {} : St = !1, m(K3, {
        value: {
          prefixCls: De,
          selectable: tt,
          showIcon: ut,
          icon: Bt,
          switcherIcon: Jt,
          draggable: St,
          draggingNodeKey: ue,
          checkable: zt,
          customCheckable: o.checkable,
          checkStrictly: an,
          disabled: Bn,
          keyEntities: y.value,
          dropLevelOffset: fe,
          dropContainerKey: ve,
          dropTargetKey: Ie,
          dropPosition: Fe,
          dragOverNodeKey: Oe,
          dragging: ue !== null,
          indent: l.value,
          direction: It,
          dropIndicatorRender: Ae,
          loadData: Mo,
          filterTreeNode: tr,
          onNodeClick: ie,
          onNodeDoubleClick: he,
          onNodeExpand: Ce,
          onNodeSelect: ge,
          onNodeCheck: we,
          onNodeLoad: Le,
          onNodeMouseEnter: be,
          onNodeMouseLeave: pe,
          onNodeContextMenu: xe,
          onNodeDragStart: Z,
          onNodeDragEnter: ne,
          onNodeDragOver: Y,
          onNodeDragLeave: V,
          onNodeDragEnd: q,
          onNodeDrop: X,
          slots: o
        }
      }, {
        default: () => [m("div", {
          role: "tree",
          class: ae(De, Zn, ln, {
            [`${De}-show-line`]: je,
            [`${De}-focused`]: S.value,
            [`${De}-active-focused`]: w.value !== null
          }),
          style: jt
        }, [m(sH, L({
          ref: O,
          prefixCls: De,
          style: mn,
          disabled: Bn,
          selectable: tt,
          checkable: !!zt,
          motion: Eo,
          height: Ma,
          itemHeight: me,
          virtual: Re,
          focusable: et,
          focused: S.value,
          tabindex: Ge,
          activeItem: Pe.value,
          onFocus: Ne,
          onBlur: ye,
          onKeydown: Be,
          onActiveChange: se,
          onListChangeStart: Te,
          onListChangeEnd: te,
          onContextmenu: vt,
          onScroll: _t
        }, Pn), null)])]
      });
    };
  }
});
var fH = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494z" } }] }, name: "file", theme: "outlined" };
function zh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      pH(e, r, n[r]);
    });
  }
  return e;
}
function pH(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Cp = function(t, n) {
  var o = zh({}, t, n.attrs);
  return m(it, zh({}, o, {
    icon: fH
  }), null);
};
Cp.displayName = "FileOutlined";
Cp.inheritAttrs = !1;
var vH = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M328 544h368c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { tag: "path", attrs: { d: "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, name: "minus-square", theme: "outlined" };
function jh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      mH(e, r, n[r]);
    });
  }
  return e;
}
function mH(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var wp = function(t, n) {
  var o = jh({}, t, n.attrs);
  return m(it, jh({}, o, {
    icon: vH
  }), null);
};
wp.displayName = "MinusSquareOutlined";
wp.inheritAttrs = !1;
var gH = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M328 544h152v152c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V544h152c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H544V328c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v152H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { tag: "path", attrs: { d: "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, name: "plus-square", theme: "outlined" };
function Vh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      hH(e, r, n[r]);
    });
  }
  return e;
}
function hH(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var xp = function(t, n) {
  var o = Vh({}, t, n.attrs);
  return m(it, Vh({}, o, {
    icon: gH
  }), null);
};
xp.displayName = "PlusSquareOutlined";
xp.inheritAttrs = !1;
var bH = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, name: "caret-down", theme: "filled" };
function Wh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      yH(e, r, n[r]);
    });
  }
  return e;
}
function yH(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Op = function(t, n) {
  var o = Wh({}, t, n.attrs);
  return m(it, Wh({}, o, {
    icon: bH
  }), null);
};
Op.displayName = "CaretDownFilled";
Op.inheritAttrs = !1;
function SH(e, t, n, o, r) {
  const {
    isLeaf: a,
    expanded: i,
    loading: l
  } = n;
  let u = t;
  if (l)
    return m(pn, {
      class: `${e}-switcher-loading-icon`
    }, null);
  let s;
  r && typeof r == "object" && (s = r.showLeafIcon);
  let c = null;
  const d = `${e}-switcher-icon`;
  return a ? r ? s && o ? o(n) : (typeof r == "object" && !s ? c = m("span", {
    class: `${e}-switcher-leaf-line`
  }, null) : c = m(Cp, {
    class: `${e}-switcher-line-icon`
  }, null), c) : null : (c = m(Op, {
    class: d
  }, null), r && (c = i ? m(wp, {
    class: `${e}-switcher-line-icon`
  }, null) : m(xp, {
    class: `${e}-switcher-line-icon`
  }, null)), typeof t == "function" ? u = t(h(h({}, n), {
    defaultIcon: c,
    switcherCls: d
  })) : on(u) && (u = Ko(u, {
    class: d
  })), u || c);
}
const $H = new Xe("ant-tree-node-fx-do-not-use", {
  "0%": {
    opacity: 0
  },
  "100%": {
    opacity: 1
  }
}), CH = (e, t) => ({
  [`.${e}-switcher-icon`]: {
    display: "inline-block",
    fontSize: 10,
    verticalAlign: "baseline",
    svg: {
      transition: `transform ${t.motionDurationSlow}`
    }
  }
}), wH = (e, t) => ({
  [`.${e}-drop-indicator`]: {
    position: "absolute",
    // it should displayed over the following node
    zIndex: 1,
    height: 2,
    backgroundColor: t.colorPrimary,
    borderRadius: 1,
    pointerEvents: "none",
    "&:after": {
      position: "absolute",
      top: -3,
      insetInlineStart: -6,
      width: 8,
      height: 8,
      backgroundColor: "transparent",
      border: `${t.lineWidthBold}px solid ${t.colorPrimary}`,
      borderRadius: "50%",
      content: '""'
    }
  }
}), xH = (e, t) => {
  const {
    treeCls: n,
    treeNodeCls: o,
    treeNodePadding: r,
    treeTitleHeight: a
  } = t, i = (a - t.fontSizeLG) / 2, l = t.paddingXS;
  return {
    [n]: h(h({}, st(t)), {
      background: t.colorBgContainer,
      borderRadius: t.borderRadius,
      transition: `background-color ${t.motionDurationSlow}`,
      [`&${n}-rtl`]: {
        // >>> Switcher
        [`${n}-switcher`]: {
          "&_close": {
            [`${n}-switcher-icon`]: {
              svg: {
                transform: "rotate(90deg)"
              }
            }
          }
        }
      },
      [`&-focused:not(:hover):not(${n}-active-focused)`]: h({}, Sr(t)),
      // =================== Virtual List ===================
      [`${n}-list-holder-inner`]: {
        alignItems: "flex-start"
      },
      [`&${n}-block-node`]: {
        [`${n}-list-holder-inner`]: {
          alignItems: "stretch",
          // >>> Title
          [`${n}-node-content-wrapper`]: {
            flex: "auto"
          },
          // >>> Drag
          [`${o}.dragging`]: {
            position: "relative",
            "&:after": {
              position: "absolute",
              top: 0,
              insetInlineEnd: 0,
              bottom: r,
              insetInlineStart: 0,
              border: `1px solid ${t.colorPrimary}`,
              opacity: 0,
              animationName: $H,
              animationDuration: t.motionDurationSlow,
              animationPlayState: "running",
              animationFillMode: "forwards",
              content: '""',
              pointerEvents: "none"
            }
          }
        }
      },
      // ===================== TreeNode =====================
      [`${o}`]: {
        display: "flex",
        alignItems: "flex-start",
        padding: `0 0 ${r}px 0`,
        outline: "none",
        "&-rtl": {
          direction: "rtl"
        },
        // Disabled
        "&-disabled": {
          // >>> Title
          [`${n}-node-content-wrapper`]: {
            color: t.colorTextDisabled,
            cursor: "not-allowed",
            "&:hover": {
              background: "transparent"
            }
          }
        },
        [`&-active ${n}-node-content-wrapper`]: h({}, Sr(t)),
        [`&:not(${o}-disabled).filter-node ${n}-title`]: {
          color: "inherit",
          fontWeight: 500
        },
        "&-draggable": {
          [`${n}-draggable-icon`]: {
            width: a,
            lineHeight: `${a}px`,
            textAlign: "center",
            visibility: "visible",
            opacity: 0.2,
            transition: `opacity ${t.motionDurationSlow}`,
            [`${o}:hover &`]: {
              opacity: 0.45
            }
          },
          [`&${o}-disabled`]: {
            [`${n}-draggable-icon`]: {
              visibility: "hidden"
            }
          }
        }
      },
      // >>> Indent
      [`${n}-indent`]: {
        alignSelf: "stretch",
        whiteSpace: "nowrap",
        userSelect: "none",
        "&-unit": {
          display: "inline-block",
          width: a
        }
      },
      // >>> Drag Handler
      [`${n}-draggable-icon`]: {
        visibility: "hidden"
      },
      // >>> Switcher
      [`${n}-switcher`]: h(h({}, CH(e, t)), {
        position: "relative",
        flex: "none",
        alignSelf: "stretch",
        width: a,
        margin: 0,
        lineHeight: `${a}px`,
        textAlign: "center",
        cursor: "pointer",
        userSelect: "none",
        "&-noop": {
          cursor: "default"
        },
        "&_close": {
          [`${n}-switcher-icon`]: {
            svg: {
              transform: "rotate(-90deg)"
            }
          }
        },
        "&-loading-icon": {
          color: t.colorPrimary
        },
        "&-leaf-line": {
          position: "relative",
          zIndex: 1,
          display: "inline-block",
          width: "100%",
          height: "100%",
          // https://github.com/ant-design/ant-design/issues/31884
          "&:before": {
            position: "absolute",
            top: 0,
            insetInlineEnd: a / 2,
            bottom: -r,
            marginInlineStart: -1,
            borderInlineEnd: `1px solid ${t.colorBorder}`,
            content: '""'
          },
          "&:after": {
            position: "absolute",
            width: a / 2 * 0.8,
            height: a / 2,
            borderBottom: `1px solid ${t.colorBorder}`,
            content: '""'
          }
        }
      }),
      // >>> Checkbox
      [`${n}-checkbox`]: {
        top: "initial",
        marginInlineEnd: l,
        marginBlockStart: i
      },
      // >>> Title
      // add `${treeCls}-checkbox + span` to cover checkbox `${checkboxCls} + span`
      [`${n}-node-content-wrapper, ${n}-checkbox + span`]: {
        position: "relative",
        zIndex: "auto",
        minHeight: a,
        margin: 0,
        padding: `0 ${t.paddingXS / 2}px`,
        color: "inherit",
        lineHeight: `${a}px`,
        background: "transparent",
        borderRadius: t.borderRadius,
        cursor: "pointer",
        transition: `all ${t.motionDurationMid}, border 0s, line-height 0s, box-shadow 0s`,
        "&:hover": {
          backgroundColor: t.controlItemBgHover
        },
        [`&${n}-node-selected`]: {
          backgroundColor: t.controlItemBgActive
        },
        // Icon
        [`${n}-iconEle`]: {
          display: "inline-block",
          width: a,
          height: a,
          lineHeight: `${a}px`,
          textAlign: "center",
          verticalAlign: "top",
          "&:empty": {
            display: "none"
          }
        }
      },
      // https://github.com/ant-design/ant-design/issues/28217
      [`${n}-unselectable ${n}-node-content-wrapper:hover`]: {
        backgroundColor: "transparent"
      },
      // ==================== Draggable =====================
      [`${n}-node-content-wrapper`]: h({
        lineHeight: `${a}px`,
        userSelect: "none"
      }, wH(e, t)),
      [`${o}.drop-container`]: {
        "> [draggable]": {
          boxShadow: `0 0 0 2px ${t.colorPrimary}`
        }
      },
      // ==================== Show Line =====================
      "&-show-line": {
        // ================ Indent lines ================
        [`${n}-indent`]: {
          "&-unit": {
            position: "relative",
            height: "100%",
            "&:before": {
              position: "absolute",
              top: 0,
              insetInlineEnd: a / 2,
              bottom: -r,
              borderInlineEnd: `1px solid ${t.colorBorder}`,
              content: '""'
            },
            "&-end": {
              "&:before": {
                display: "none"
              }
            }
          }
        },
        // ============== Cover Background ==============
        [`${n}-switcher`]: {
          background: "transparent",
          "&-line-icon": {
            // https://github.com/ant-design/ant-design/issues/32813
            verticalAlign: "-0.15em"
          }
        }
      },
      [`${o}-leaf-last`]: {
        [`${n}-switcher`]: {
          "&-leaf-line": {
            "&:before": {
              top: "auto !important",
              bottom: "auto !important",
              height: `${a / 2}px !important`
            }
          }
        }
      }
    })
  };
}, OH = (e) => {
  const {
    treeCls: t,
    treeNodeCls: n,
    treeNodePadding: o
  } = e;
  return {
    [`${t}${t}-directory`]: {
      // ================== TreeNode ==================
      [n]: {
        position: "relative",
        // Hover color
        "&:before": {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: o,
          insetInlineStart: 0,
          transition: `background-color ${e.motionDurationMid}`,
          content: '""',
          pointerEvents: "none"
        },
        "&:hover": {
          "&:before": {
            background: e.controlItemBgHover
          }
        },
        // Elements
        "> *": {
          zIndex: 1
        },
        // >>> Switcher
        [`${t}-switcher`]: {
          transition: `color ${e.motionDurationMid}`
        },
        // >>> Title
        [`${t}-node-content-wrapper`]: {
          borderRadius: 0,
          userSelect: "none",
          "&:hover": {
            background: "transparent"
          },
          [`&${t}-node-selected`]: {
            color: e.colorTextLightSolid,
            background: "transparent"
          }
        },
        // ============= Selected =============
        "&-selected": {
          "\n            &:hover::before,\n            &::before\n          ": {
            background: e.colorPrimary
          },
          // >>> Switcher
          [`${t}-switcher`]: {
            color: e.colorTextLightSolid
          },
          // >>> Title
          [`${t}-node-content-wrapper`]: {
            color: e.colorTextLightSolid,
            background: "transparent"
          }
        }
      }
    }
  };
}, PH = (e, t) => {
  const n = `.${e}`, o = `${n}-treenode`, r = t.paddingXS / 2, a = t.controlHeightSM, i = qe(t, {
    treeCls: n,
    treeNodeCls: o,
    treeNodePadding: r,
    treeTitleHeight: a
  });
  return [
    // Basic
    xH(e, i),
    // Directory
    OH(i)
  ];
};
var IH = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M360 184h-8c4.4 0 8-3.6 8-8v8h304v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72v-72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32zM731.3 840H292.7l-24.2-512h487l-24.2 512z" } }] }, name: "delete", theme: "outlined" };
function Kh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      TH(e, r, n[r]);
    });
  }
  return e;
}
function TH(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Pp = function(t, n) {
  var o = Kh({}, t, n.attrs);
  return m(it, Kh({}, o, {
    icon: IH
  }), null);
};
Pp.displayName = "DeleteOutlined";
Pp.inheritAttrs = !1;
function zC(e) {
  return Array.isArray(e) ? e : e !== void 0 ? [e] : [];
}
function EH(e) {
  const {
    label: t,
    value: n,
    children: o
  } = e || {}, r = n || "value";
  return {
    _title: t ? [t] : ["title", "label"],
    value: r,
    key: r,
    children: o || "children"
  };
}
function fd(e) {
  return e.disabled || e.disableCheckbox || e.checkable === !1;
}
function MH(e, t) {
  const n = [];
  function o(r) {
    r.forEach((a) => {
      n.push(a[t.value]);
      const i = a[t.children];
      i && o(i);
    });
  }
  return o(e), n;
}
function pd(e) {
  return e == null;
}
const jC = Symbol("TreeSelectContextPropsKey");
function _H(e) {
  return ot(jC, e);
}
function DH() {
  return nt(jC, {});
}
const AH = {
  width: 0,
  height: 0,
  display: "flex",
  overflow: "hidden",
  opacity: 0,
  border: 0,
  padding: 0,
  margin: 0
}, NH = J({
  compatConfig: {
    MODE: 3
  },
  name: "OptionList",
  inheritAttrs: !1,
  setup(e, t) {
    let {
      slots: n,
      expose: o
    } = t;
    const r = a0(), a = $s(), i = DH(), l = G(), u = Jd(() => i.treeData, [() => r.open, () => i.treeData], ($) => $[0]), s = T(() => {
      const {
        checkable: $,
        halfCheckedKeys: O,
        checkedKeys: x
      } = a;
      return $ ? {
        checked: x,
        halfChecked: O
      } : null;
    });
    le(() => r.open, () => {
      mt(() => {
        var $;
        r.open && !r.multiple && a.checkedKeys.length && (($ = l.value) === null || $ === void 0 || $.scrollTo({
          key: a.checkedKeys[0]
        }));
      });
    }, {
      immediate: !0,
      flush: "post"
    });
    const c = T(() => String(r.searchValue).toLowerCase()), d = ($) => c.value ? String($[a.treeNodeFilterProp]).toLowerCase().includes(c.value) : !1, f = K(a.treeDefaultExpandedKeys), p = K(null);
    le(() => r.searchValue, () => {
      r.searchValue && (p.value = MH(Ft(i.treeData), Ft(i.fieldNames)));
    }, {
      immediate: !0
    });
    const v = T(() => a.treeExpandedKeys ? a.treeExpandedKeys.slice() : r.searchValue ? p.value : f.value), g = ($) => {
      var O;
      f.value = $, p.value = $, (O = a.onTreeExpand) === null || O === void 0 || O.call(a, $);
    }, b = ($) => {
      $.preventDefault();
    }, y = ($, O) => {
      let {
        node: x
      } = O;
      var M, _;
      const {
        checkable: N,
        checkedKeys: I
      } = a;
      N && fd(x) || ((M = i.onSelect) === null || M === void 0 || M.call(i, x.key, {
        selected: !I.includes(x.key)
      }), r.multiple || (_ = r.toggleOpen) === null || _ === void 0 || _.call(r, !1));
    }, S = G(null), w = T(() => a.keyEntities[S.value]), C = ($) => {
      S.value = $;
    };
    return o({
      scrollTo: function() {
        for (var $, O, x = arguments.length, M = new Array(x), _ = 0; _ < x; _++)
          M[_] = arguments[_];
        return (O = ($ = l.value) === null || $ === void 0 ? void 0 : $.scrollTo) === null || O === void 0 ? void 0 : O.call($, ...M);
      },
      onKeydown: ($) => {
        var O;
        const {
          which: x
        } = $;
        switch (x) {
          case ee.UP:
          case ee.DOWN:
          case ee.LEFT:
          case ee.RIGHT:
            (O = l.value) === null || O === void 0 || O.onKeydown($);
            break;
          case ee.ENTER: {
            if (w.value) {
              const {
                selectable: M,
                value: _
              } = w.value.node || {};
              M !== !1 && y(null, {
                node: {
                  key: S.value
                },
                selected: !a.checkedKeys.includes(_)
              });
            }
            break;
          }
          case ee.ESC:
            r.toggleOpen(!1);
        }
      },
      onKeyup: () => {
      }
    }), () => {
      var $;
      const {
        prefixCls: O,
        multiple: x,
        searchValue: M,
        open: _,
        notFoundContent: N = ($ = n.notFoundContent) === null || $ === void 0 ? void 0 : $.call(n)
      } = r, {
        listHeight: I,
        listItemHeight: E,
        virtual: B,
        dropdownMatchSelectWidth: k,
        treeExpandAction: P
      } = i, {
        checkable: R,
        treeDefaultExpandAll: D,
        treeIcon: A,
        showTreeIcon: H,
        switcherIcon: j,
        treeLine: z,
        loadData: F,
        treeLoadedKeys: U,
        treeMotion: Q,
        onTreeLoad: q,
        checkedKeys: oe
      } = a;
      if (u.value.length === 0)
        return m("div", {
          role: "listbox",
          class: `${O}-empty`,
          onMousedown: b
        }, [N]);
      const Z = {
        fieldNames: i.fieldNames
      };
      return U && (Z.loadedKeys = U), v.value && (Z.expandedKeys = v.value), m("div", {
        onMousedown: b
      }, [w.value && _ && m("span", {
        style: AH,
        "aria-live": "assertive"
      }, [w.value.node.value]), m(dH, L(L({
        ref: l,
        focusable: !1,
        prefixCls: `${O}-tree`,
        treeData: u.value,
        height: I,
        itemHeight: E,
        virtual: B !== !1 && k !== !1,
        multiple: x,
        icon: A,
        showIcon: H,
        switcherIcon: j,
        showLine: z,
        loadData: M ? null : F,
        motion: Q,
        activeKey: S.value,
        checkable: R,
        checkStrictly: !0,
        checkedKeys: s.value,
        selectedKeys: R ? [] : oe,
        defaultExpandAll: D
      }, Z), {}, {
        onActiveChange: C,
        onSelect: y,
        onCheck: y,
        onExpand: g,
        onLoad: q,
        filterTreeNode: d,
        expandAction: P
      }), h(h({}, n), {
        checkable: a.customSlots.treeCheckable
      }))]);
    };
  }
}), RH = "SHOW_ALL", VC = "SHOW_PARENT", Ip = "SHOW_CHILD";
function Uh(e, t, n, o) {
  const r = new Set(e);
  return t === Ip ? e.filter((a) => {
    const i = n[a];
    return !(i && i.children && i.children.some((l) => {
      let {
        node: u
      } = l;
      return r.has(u[o.value]);
    }) && i.children.every((l) => {
      let {
        node: u
      } = l;
      return fd(u) || r.has(u[o.value]);
    }));
  }) : t === VC ? e.filter((a) => {
    const i = n[a], l = i ? i.parent : null;
    return !(l && !fd(l.node) && r.has(l.key));
  }) : e;
}
const Ea = () => null;
Ea.inheritAttrs = !1;
Ea.displayName = "ATreeSelectNode";
Ea.isTreeSelectNode = !0;
var FH = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function BH(e) {
  return e && e.type && e.type.isTreeSelectNode;
}
function kH(e) {
  function t() {
    let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return nn(n).map((o) => {
      var r, a, i;
      if (!BH(o))
        return lt(!o, "TreeSelect/TreeSelectNode can only accept TreeSelectNode as children."), null;
      const l = o.children || {}, u = o.key, s = {};
      for (const [x, M] of Object.entries(o.props))
        s[yi(x)] = M;
      const {
        isLeaf: c,
        checkable: d,
        selectable: f,
        disabled: p,
        disableCheckbox: v
      } = s, g = {
        isLeaf: c || c === "" || void 0,
        checkable: d || d === "" || void 0,
        selectable: f || f === "" || void 0,
        disabled: p || p === "" || void 0,
        disableCheckbox: v || v === "" || void 0
      }, b = h(h({}, s), g), {
        title: y = (r = l.title) === null || r === void 0 ? void 0 : r.call(l, b),
        switcherIcon: S = (a = l.switcherIcon) === null || a === void 0 ? void 0 : a.call(l, b)
      } = s, w = FH(s, ["title", "switcherIcon"]), C = (i = l.default) === null || i === void 0 ? void 0 : i.call(l), $ = h(h(h({}, w), {
        title: y,
        switcherIcon: S,
        key: u,
        isLeaf: c
      }), g), O = t(C);
      return O.length && ($.children = O), $;
    });
  }
  return t(e);
}
function vd(e) {
  if (!e)
    return e;
  const t = h({}, e);
  return "props" in t || Object.defineProperty(t, "props", {
    get() {
      return lt(!1, "New `vc-tree-select` not support return node instance as argument anymore. Please consider to remove `props` access."), t;
    }
  }), t;
}
function LH(e, t, n, o, r, a) {
  let i = null, l = null;
  function u() {
    function s(c) {
      let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "0", f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
      return c.map((p, v) => {
        const g = `${d}-${v}`, b = p[a.value], y = n.includes(b), S = s(p[a.children] || [], g, y), w = m(Ea, p, {
          default: () => [S.map((C) => C.node)]
        });
        if (t === b && (i = w), y) {
          const C = {
            pos: g,
            node: w,
            children: S
          };
          return f || l.push(C), C;
        }
        return null;
      }).filter((p) => p);
    }
    l || (l = [], s(o), l.sort((c, d) => {
      let {
        node: {
          props: {
            value: f
          }
        }
      } = c, {
        node: {
          props: {
            value: p
          }
        }
      } = d;
      const v = n.indexOf(f), g = n.indexOf(p);
      return v - g;
    }));
  }
  Object.defineProperty(e, "triggerNode", {
    get() {
      return lt(!1, "`triggerNode` is deprecated. Please consider decoupling data with node."), u(), i;
    }
  }), Object.defineProperty(e, "allCheckedNodes", {
    get() {
      return lt(!1, "`allCheckedNodes` is deprecated. Please consider decoupling data with node."), u(), r ? l : l.map((s) => {
        let {
          node: c
        } = s;
        return c;
      });
    }
  });
}
function HH(e, t) {
  let {
    id: n,
    pId: o,
    rootPId: r
  } = t;
  const a = {}, i = [];
  return e.map((u) => {
    const s = h({}, u), c = s[n];
    return a[c] = s, s.key = s.key || c, s;
  }).forEach((u) => {
    const s = u[o], c = a[s];
    c && (c.children = c.children || [], c.children.push(u)), (s === r || !c && r === null) && i.push(u);
  }), i;
}
function zH(e, t, n) {
  const o = K();
  return le([n, e, t], () => {
    const r = n.value;
    e.value ? o.value = n.value ? HH(Ft(e.value), h({
      id: "id",
      pId: "pId",
      rootPId: null
    }, r !== !0 ? r : {})) : Ft(e.value).slice() : o.value = kH(Ft(t.value));
  }, {
    immediate: !0,
    deep: !0
  }), o;
}
const jH = (e) => {
  const t = K({
    valueLabels: /* @__PURE__ */ new Map()
  }), n = K();
  return le(e, () => {
    n.value = Ft(e.value);
  }, {
    immediate: !0
  }), [T(() => {
    const {
      valueLabels: r
    } = t.value, a = /* @__PURE__ */ new Map(), i = n.value.map((l) => {
      var u;
      const {
        value: s
      } = l, c = (u = l.label) !== null && u !== void 0 ? u : r.get(s);
      return a.set(s, c), h(h({}, l), {
        label: c
      });
    });
    return t.value.valueLabels = a, i;
  })];
}, VH = (e, t) => {
  const n = K(/* @__PURE__ */ new Map()), o = K({});
  return Ve(() => {
    const r = t.value, a = p$(e.value, {
      fieldNames: r,
      initWrapper: (i) => h(h({}, i), {
        valueEntities: /* @__PURE__ */ new Map()
      }),
      processEntity: (i, l) => {
        const u = i.node[r.value];
        if (process.env.NODE_ENV !== "production") {
          const s = i.node.key;
          lt(!pd(u), "TreeNode `value` is invalidate: undefined"), lt(!l.valueEntities.has(u), `Same \`value\` exist in the tree: ${u}`), lt(!s || String(s) === String(u), `\`key\` or \`value\` with TreeNode must be the same or you can remove one of them. key: ${s}, value: ${u}.`);
        }
        l.valueEntities.set(u, i);
      }
    });
    n.value = a.valueEntities, o.value = a.keyEntities;
  }), {
    valueEntities: n,
    keyEntities: o
  };
}, WH = (e, t, n, o, r, a) => {
  const i = K([]), l = K([]);
  return Ve(() => {
    let u = e.value.map((d) => {
      let {
        value: f
      } = d;
      return f;
    }), s = t.value.map((d) => {
      let {
        value: f
      } = d;
      return f;
    });
    const c = u.filter((d) => !o.value[d]);
    n.value && ({
      checkedKeys: u,
      halfCheckedKeys: s
    } = na(u, !0, o.value, r.value, a.value)), i.value = Array.from(/* @__PURE__ */ new Set([...c, ...u])), l.value = s;
  }), [i, l];
}, KH = (e, t, n) => {
  let {
    treeNodeFilterProp: o,
    filterTreeNode: r,
    fieldNames: a
  } = n;
  return T(() => {
    const {
      children: i
    } = a.value, l = t.value, u = o == null ? void 0 : o.value;
    if (!l || r.value === !1)
      return e.value;
    let s;
    if (typeof r.value == "function")
      s = r.value;
    else {
      const d = l.toUpperCase();
      s = (f, p) => {
        const v = p[u];
        return String(v).toUpperCase().includes(d);
      };
    }
    function c(d) {
      let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      const p = [];
      for (let v = 0, g = d.length; v < g; v++) {
        const b = d[v], y = b[i], S = f || s(l, vd(b)), w = c(y || [], S);
        (S || w.length) && p.push(h(h({}, b), {
          [i]: w
        }));
      }
      return p;
    }
    return c(e.value);
  });
};
function UH(e) {
  const {
    searchPlaceholder: t,
    treeCheckStrictly: n,
    treeCheckable: o,
    labelInValue: r,
    value: a,
    multiple: i
  } = e;
  lt(!t, "`searchPlaceholder` has been removed, please use `placeholder` instead"), n && r === !1 && lt(!1, "`treeCheckStrictly` will force set `labelInValue` to `true`."), (r || n) && lt(zC(a).every((l) => l && typeof l == "object" && "value" in l), "Invalid prop `value` supplied to `TreeSelect`. You should use { label: string, value: string | number } or [{ label: string, value: string | number }] instead."), n || i || o ? lt(!a || Array.isArray(a), "`value` should be an array when `TreeSelect` is checkable or multiple.") : lt(!Array.isArray(a), "`value` should not be array when `TreeSelect` is single mode.");
}
function WC() {
  return h(h({}, pt(Qd(), ["mode"])), {
    prefixCls: String,
    id: String,
    value: {
      type: [String, Number, Object, Array]
    },
    defaultValue: {
      type: [String, Number, Object, Array]
    },
    onChange: {
      type: Function
    },
    searchValue: String,
    /** @deprecated Use `searchValue` instead */
    inputValue: String,
    onSearch: {
      type: Function
    },
    autoClearSearchValue: {
      type: Boolean,
      default: void 0
    },
    filterTreeNode: {
      type: [Boolean, Function],
      default: void 0
    },
    treeNodeFilterProp: String,
    // >>> Select
    onSelect: Function,
    onDeselect: Function,
    showCheckedStrategy: {
      type: String
    },
    treeNodeLabelProp: String,
    fieldNames: {
      type: Object
    },
    // >>> Mode
    multiple: {
      type: Boolean,
      default: void 0
    },
    treeCheckable: {
      type: Boolean,
      default: void 0
    },
    treeCheckStrictly: {
      type: Boolean,
      default: void 0
    },
    labelInValue: {
      type: Boolean,
      default: void 0
    },
    // >>> Data
    treeData: {
      type: Array
    },
    treeDataSimpleMode: {
      type: [Boolean, Object],
      default: void 0
    },
    loadData: {
      type: Function
    },
    treeLoadedKeys: {
      type: Array
    },
    onTreeLoad: {
      type: Function
    },
    // >>> Expanded
    treeDefaultExpandAll: {
      type: Boolean,
      default: void 0
    },
    treeExpandedKeys: {
      type: Array
    },
    treeDefaultExpandedKeys: {
      type: Array
    },
    onTreeExpand: {
      type: Function
    },
    // >>> Options
    virtual: {
      type: Boolean,
      default: void 0
    },
    listHeight: Number,
    listItemHeight: Number,
    onDropdownVisibleChange: {
      type: Function
    },
    // >>> Tree
    treeLine: {
      type: [Boolean, Object],
      default: void 0
    },
    treeIcon: W.any,
    showTreeIcon: {
      type: Boolean,
      default: void 0
    },
    switcherIcon: W.any,
    treeMotion: W.any,
    children: Array,
    treeExpandAction: String,
    showArrow: {
      type: Boolean,
      default: void 0
    },
    showSearch: {
      type: Boolean,
      default: void 0
    },
    open: {
      type: Boolean,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    placeholder: W.any,
    maxTagPlaceholder: {
      type: Function
    },
    dropdownPopupAlign: W.any,
    customSlots: Object
  });
}
function GH(e) {
  return !e || typeof e != "object";
}
const YH = J({
  compatConfig: {
    MODE: 3
  },
  name: "TreeSelect",
  inheritAttrs: !1,
  props: bt(WC(), {
    treeNodeFilterProp: "value",
    autoClearSearchValue: !0,
    showCheckedStrategy: Ip,
    listHeight: 200,
    listItemHeight: 20,
    prefixCls: "vc-tree-select"
  }),
  setup(e, t) {
    let {
      attrs: n,
      expose: o,
      slots: r
    } = t;
    const a = d0(Je(e, "id")), i = T(() => e.treeCheckable && !e.treeCheckStrictly), l = T(() => e.treeCheckable || e.treeCheckStrictly), u = T(() => e.treeCheckStrictly || e.labelInValue), s = T(() => l.value || e.multiple);
    process.env.NODE_ENV !== "production" && Ve(() => {
      UH(e);
    });
    const c = T(() => EH(e.fieldNames)), [d, f] = Gt("", {
      value: T(() => e.searchValue !== void 0 ? e.searchValue : e.inputValue),
      postState: (ye) => ye || ""
    }), p = (ye) => {
      var Ce;
      f(ye), (Ce = e.onSearch) === null || Ce === void 0 || Ce.call(e, ye);
    }, v = zH(Je(e, "treeData"), Je(e, "children"), Je(e, "treeDataSimpleMode")), {
      keyEntities: g,
      valueEntities: b
    } = VH(v, c), y = (ye) => {
      const Ce = [], Te = [];
      return ye.forEach((te) => {
        b.value.has(te) ? Te.push(te) : Ce.push(te);
      }), {
        missingRawValues: Ce,
        existRawValues: Te
      };
    }, S = KH(v, d, {
      fieldNames: c,
      treeNodeFilterProp: Je(e, "treeNodeFilterProp"),
      filterTreeNode: Je(e, "filterTreeNode")
    }), w = (ye) => {
      if (ye) {
        if (e.treeNodeLabelProp)
          return ye[e.treeNodeLabelProp];
        const {
          _title: Ce
        } = c.value;
        for (let Te = 0; Te < Ce.length; Te += 1) {
          const te = ye[Ce[Te]];
          if (te !== void 0)
            return te;
        }
      }
    }, C = (ye) => zC(ye).map((Te) => GH(Te) ? {
      value: Te
    } : Te), $ = (ye) => C(ye).map((Te) => {
      let {
        label: te
      } = Te;
      const {
        value: se,
        halfChecked: Pe
      } = Te;
      let _e;
      const Ee = b.value.get(se);
      return Ee && (te = te ?? w(Ee.node), _e = Ee.node.disabled), {
        label: te,
        value: se,
        halfChecked: Pe,
        disabled: _e
      };
    }), [O, x] = Gt(e.defaultValue, {
      value: Je(e, "value")
    }), M = T(() => C(O.value)), _ = K([]), N = K([]);
    Ve(() => {
      const ye = [], Ce = [];
      M.value.forEach((Te) => {
        Te.halfChecked ? Ce.push(Te) : ye.push(Te);
      }), _.value = ye, N.value = Ce;
    });
    const I = T(() => _.value.map((ye) => ye.value)), {
      maxLevel: E,
      levelEntities: B
    } = m$(g), [k, P] = WH(_, N, i, g, E, B), R = T(() => {
      const Te = Uh(k.value, e.showCheckedStrategy, g.value, c.value).map((Pe) => {
        var _e, Ee, Be;
        return (Be = (Ee = (_e = g.value[Pe]) === null || _e === void 0 ? void 0 : _e.node) === null || Ee === void 0 ? void 0 : Ee[c.value.value]) !== null && Be !== void 0 ? Be : Pe;
      }).map((Pe) => {
        const _e = _.value.find((Ee) => Ee.value === Pe);
        return {
          value: Pe,
          label: _e == null ? void 0 : _e.label
        };
      }), te = $(Te), se = te[0];
      return !s.value && se && pd(se.value) && pd(se.label) ? [] : te.map((Pe) => {
        var _e;
        return h(h({}, Pe), {
          label: (_e = Pe.label) !== null && _e !== void 0 ? _e : Pe.value
        });
      });
    }), [D] = jH(R), A = (ye, Ce, Te) => {
      const te = $(ye);
      if (x(te), e.autoClearSearchValue && f(""), e.onChange) {
        let se = ye;
        i.value && (se = Uh(ye, e.showCheckedStrategy, g.value, c.value).map((Fe) => {
          const Oe = b.value.get(Fe);
          return Oe ? Oe.node[c.value.value] : Fe;
        }));
        const {
          triggerValue: Pe,
          selected: _e
        } = Ce || {
          triggerValue: void 0,
          selected: void 0
        };
        let Ee = se;
        if (e.treeCheckStrictly) {
          const Ie = N.value.filter((Fe) => !se.includes(Fe.value));
          Ee = [...Ee, ...Ie];
        }
        const Be = $(Ee), ue = {
          // [Legacy] Always return as array contains label & value
          preValue: _.value,
          triggerValue: Pe
        };
        let fe = !0;
        (e.treeCheckStrictly || Te === "selection" && !_e) && (fe = !1), LH(ue, Pe, ye, v.value, fe, c.value), l.value ? ue.checked = _e : ue.selected = _e;
        const ve = u.value ? Be : Be.map((Ie) => Ie.value);
        e.onChange(s.value ? ve : ve[0], u.value ? null : Be.map((Ie) => Ie.label), ue);
      }
    }, H = (ye, Ce) => {
      let {
        selected: Te,
        source: te
      } = Ce;
      var se, Pe, _e;
      const Ee = Ft(g.value), Be = Ft(b.value), ue = Ee[ye], fe = ue == null ? void 0 : ue.node, ve = (se = fe == null ? void 0 : fe[c.value.value]) !== null && se !== void 0 ? se : ye;
      if (!s.value)
        A([ve], {
          selected: !0,
          triggerValue: ve
        }, "option");
      else {
        let Ie = Te ? [...I.value, ve] : k.value.filter((Fe) => Fe !== ve);
        if (i.value) {
          const {
            missingRawValues: Fe,
            existRawValues: Oe
          } = y(Ie), De = Oe.map((et) => Be.get(et).key);
          let je;
          Te ? {
            checkedKeys: je
          } = na(De, !0, Ee, E.value, B.value) : {
            checkedKeys: je
          } = na(De, {
            checked: !1,
            halfCheckedKeys: P.value
          }, Ee, E.value, B.value), Ie = [...Fe, ...je.map((et) => Ee[et].node[c.value.value])];
        }
        A(Ie, {
          selected: Te,
          triggerValue: ve
        }, te || "option");
      }
      Te || !s.value ? (Pe = e.onSelect) === null || Pe === void 0 || Pe.call(e, ve, vd(fe)) : (_e = e.onDeselect) === null || _e === void 0 || _e.call(e, ve, vd(fe));
    }, j = (ye) => {
      if (e.onDropdownVisibleChange) {
        const Ce = {};
        Object.defineProperty(Ce, "documentClickClose", {
          get() {
            return lt(!1, "Second param of `onDropdownVisibleChange` has been removed."), !1;
          }
        }), e.onDropdownVisibleChange(ye, Ce);
      }
    }, z = (ye, Ce) => {
      const Te = ye.map((te) => te.value);
      if (Ce.type === "clear") {
        A(Te, {}, "selection");
        return;
      }
      Ce.values.length && H(Ce.values[0].value, {
        selected: !1,
        source: "selection"
      });
    }, {
      treeNodeFilterProp: F,
      // Data
      loadData: U,
      treeLoadedKeys: Q,
      onTreeLoad: q,
      // Expanded
      treeDefaultExpandAll: oe,
      treeExpandedKeys: Z,
      treeDefaultExpandedKeys: ne,
      onTreeExpand: Y,
      // Options
      virtual: V,
      listHeight: X,
      listItemHeight: re,
      // Tree
      treeLine: ie,
      treeIcon: he,
      showTreeIcon: ge,
      switcherIcon: we,
      treeMotion: Le,
      customSlots: be,
      dropdownMatchSelectWidth: pe,
      treeExpandAction: xe
    } = bd(e);
    aE(Fl({
      checkable: l,
      loadData: U,
      treeLoadedKeys: Q,
      onTreeLoad: q,
      checkedKeys: k,
      halfCheckedKeys: P,
      treeDefaultExpandAll: oe,
      treeExpandedKeys: Z,
      treeDefaultExpandedKeys: ne,
      onTreeExpand: Y,
      treeIcon: he,
      treeMotion: Le,
      showTreeIcon: ge,
      switcherIcon: we,
      treeLine: ie,
      treeNodeFilterProp: F,
      keyEntities: g,
      customSlots: be
    })), _H(Fl({
      virtual: V,
      listHeight: X,
      listItemHeight: re,
      treeData: S,
      fieldNames: c,
      onSelect: H,
      dropdownMatchSelectWidth: pe,
      treeExpandAction: xe
    }));
    const Ne = G();
    return o({
      focus() {
        var ye;
        (ye = Ne.value) === null || ye === void 0 || ye.focus();
      },
      blur() {
        var ye;
        (ye = Ne.value) === null || ye === void 0 || ye.blur();
      },
      scrollTo(ye) {
        var Ce;
        (Ce = Ne.value) === null || Ce === void 0 || Ce.scrollTo(ye);
      }
    }), () => {
      var ye;
      const Ce = pt(e, [
        "id",
        "prefixCls",
        "customSlots",
        // Value
        "value",
        "defaultValue",
        "onChange",
        "onSelect",
        "onDeselect",
        // Search
        "searchValue",
        "inputValue",
        "onSearch",
        "autoClearSearchValue",
        "filterTreeNode",
        "treeNodeFilterProp",
        // Selector
        "showCheckedStrategy",
        "treeNodeLabelProp",
        //  Mode
        "multiple",
        "treeCheckable",
        "treeCheckStrictly",
        "labelInValue",
        // FieldNames
        "fieldNames",
        // Data
        "treeDataSimpleMode",
        "treeData",
        "children",
        "loadData",
        "treeLoadedKeys",
        "onTreeLoad",
        // Expanded
        "treeDefaultExpandAll",
        "treeExpandedKeys",
        "treeDefaultExpandedKeys",
        "onTreeExpand",
        // Options
        "virtual",
        "listHeight",
        "listItemHeight",
        "onDropdownVisibleChange",
        // Tree
        "treeLine",
        "treeIcon",
        "showTreeIcon",
        "switcherIcon",
        "treeMotion"
      ]);
      return m(i0, L(L(L({
        ref: Ne
      }, n), Ce), {}, {
        id: a,
        prefixCls: e.prefixCls,
        mode: s.value ? "multiple" : void 0,
        displayValues: D.value,
        onDisplayValuesChange: z,
        searchValue: d.value,
        onSearch: p,
        OptionList: NH,
        emptyOptions: !v.value.length,
        onDropdownVisibleChange: j,
        tagRender: e.tagRender || r.tagRender,
        dropdownMatchSelectWidth: (ye = e.dropdownMatchSelectWidth) !== null && ye !== void 0 ? ye : !0
      }), r);
    };
  }
}), XH = (e) => {
  const {
    componentCls: t,
    treePrefixCls: n,
    colorBgElevated: o
  } = e, r = `.${n}`;
  return [
    // ======================================================
    // ==                     Dropdown                     ==
    // ======================================================
    {
      [`${t}-dropdown`]: [
        {
          padding: `${e.paddingXS}px ${e.paddingXS / 2}px`
        },
        // ====================== Tree ======================
        PH(n, qe(e, {
          colorBgContainer: o
        })),
        {
          [r]: {
            borderRadius: 0,
            "&-list-holder-inner": {
              alignItems: "stretch",
              [`${r}-treenode`]: {
                [`${r}-node-content-wrapper`]: {
                  flex: "auto"
                }
              }
            }
          }
        },
        // ==================== Checkbox ====================
        _$(`${n}-checkbox`, e),
        // ====================== RTL =======================
        {
          "&-rtl": {
            direction: "rtl",
            [`${r}-switcher${r}-switcher_close`]: {
              [`${r}-switcher-icon svg`]: {
                transform: "rotate(90deg)"
              }
            }
          }
        }
      ]
    }
  ];
};
function qH(e, t) {
  return ht("TreeSelect", (n) => {
    const o = qe(n, {
      treePrefixCls: t.value
    });
    return [XH(o)];
  })(e);
}
const Gh = (e, t, n) => n !== void 0 ? n : `${e}-${t}`;
function QH() {
  return h(h({}, pt(WC(), ["showTreeIcon", "treeMotion", "inputIcon", "getInputElement", "treeLine", "customSlots"])), {
    suffixIcon: W.any,
    size: Ze(),
    bordered: Me(),
    treeLine: dt([Boolean, Object]),
    replaceFields: He(),
    placement: Ze(),
    status: Ze(),
    popupClassName: String,
    /** @deprecated Please use `popupClassName` instead */
    dropdownClassName: String,
    "onUpdate:value": de(),
    "onUpdate:treeExpandedKeys": de(),
    "onUpdate:searchValue": de()
  });
}
const qu = J({
  compatConfig: {
    MODE: 3
  },
  name: "ATreeSelect",
  inheritAttrs: !1,
  props: bt(QH(), {
    choiceTransitionName: "",
    listHeight: 256,
    treeIcon: !1,
    listItemHeight: 26,
    bordered: !0
  }),
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      expose: r,
      emit: a
    } = t;
    lt(!(e.treeData === void 0 && o.default), "`children` of TreeSelect is deprecated. Please use `treeData` instead."), gt(e.multiple !== !1 || !e.treeCheckable, "TreeSelect", "`multiple` will always be `true` when `treeCheckable` is true"), gt(e.replaceFields === void 0, "TreeSelect", "`replaceFields` is deprecated, please use fieldNames instead"), gt(!e.dropdownClassName, "TreeSelect", "`dropdownClassName` is deprecated. Please use `popupClassName` instead.");
    const i = Lt(), l = rn.useInject(), u = T(() => Po(l.status, e.status)), {
      prefixCls: s,
      renderEmpty: c,
      direction: d,
      virtual: f,
      dropdownMatchSelectWidth: p,
      size: v,
      getPopupContainer: g,
      getPrefixCls: b,
      disabled: y
    } = Ke("select", e), {
      compactSize: S,
      compactItemClassnames: w
    } = Dr(s, d), C = T(() => S.value || v.value), $ = Cn(), O = T(() => {
      var Q;
      return (Q = y.value) !== null && Q !== void 0 ? Q : $.value;
    }), x = T(() => b()), M = T(() => e.placement !== void 0 ? e.placement : d.value === "rtl" ? "bottomRight" : "bottomLeft"), _ = T(() => Gh(x.value, Yy(M.value), e.transitionName)), N = T(() => Gh(x.value, "", e.choiceTransitionName)), I = T(() => b("select-tree", e.prefixCls)), E = T(() => b("tree-select", e.prefixCls)), [B, k] = V0(s), [P] = qH(E, I), R = T(() => ae(e.popupClassName || e.dropdownClassName, `${E.value}-dropdown`, {
      [`${E.value}-dropdown-rtl`]: d.value === "rtl"
    }, k.value)), D = T(() => !!(e.treeCheckable || e.multiple)), A = T(() => e.showArrow !== void 0 ? e.showArrow : e.loading || !D.value), H = G();
    r({
      focus() {
        var Q, q;
        (q = (Q = H.value).focus) === null || q === void 0 || q.call(Q);
      },
      blur() {
        var Q, q;
        (q = (Q = H.value).blur) === null || q === void 0 || q.call(Q);
      }
    });
    const j = function() {
      for (var Q = arguments.length, q = new Array(Q), oe = 0; oe < Q; oe++)
        q[oe] = arguments[oe];
      a("update:value", q[0]), a("change", ...q), i.onFieldChange();
    }, z = (Q) => {
      a("update:treeExpandedKeys", Q), a("treeExpand", Q);
    }, F = (Q) => {
      a("update:searchValue", Q), a("search", Q);
    }, U = (Q) => {
      a("blur", Q), i.onFieldBlur();
    };
    return () => {
      var Q, q;
      const {
        notFoundContent: oe = (Q = o.notFoundContent) === null || Q === void 0 ? void 0 : Q.call(o),
        prefixCls: Z,
        bordered: ne,
        listHeight: Y,
        listItemHeight: V,
        multiple: X,
        treeIcon: re,
        treeLine: ie,
        showArrow: he,
        switcherIcon: ge = (q = o.switcherIcon) === null || q === void 0 ? void 0 : q.call(o),
        fieldNames: we = e.replaceFields,
        id: Le = i.id.value
      } = e, {
        isFormItemInput: be,
        hasFeedback: pe,
        feedbackIcon: xe
      } = l, {
        suffixIcon: Ne,
        removeIcon: ye,
        clearIcon: Ce
      } = $0(h(h({}, e), {
        multiple: D.value,
        showArrow: A.value,
        hasFeedback: pe,
        feedbackIcon: xe,
        prefixCls: s.value
      }), o);
      let Te;
      oe !== void 0 ? Te = oe : Te = c("Select");
      const te = pt(e, ["suffixIcon", "itemIcon", "removeIcon", "clearIcon", "switcherIcon", "bordered", "status", "onUpdate:value", "onUpdate:treeExpandedKeys", "onUpdate:searchValue"]), se = ae(!Z && E.value, {
        [`${s.value}-lg`]: C.value === "large",
        [`${s.value}-sm`]: C.value === "small",
        [`${s.value}-rtl`]: d.value === "rtl",
        [`${s.value}-borderless`]: !ne,
        [`${s.value}-in-form-item`]: be
      }, dn(s.value, u.value, pe), w.value, n.class, k.value), Pe = {};
      return e.treeData === void 0 && o.default && (Pe.children = xt(o.default())), B(P(m(YH, L(L(L(L({}, n), te), {}, {
        disabled: O.value,
        virtual: f.value,
        dropdownMatchSelectWidth: p.value,
        id: Le,
        fieldNames: we,
        ref: H,
        prefixCls: s.value,
        class: se,
        listHeight: Y,
        listItemHeight: V,
        treeLine: !!ie,
        inputIcon: Ne,
        multiple: X,
        removeIcon: ye,
        clearIcon: Ce,
        switcherIcon: (_e) => SH(I.value, ge, _e, o.leafIcon, ie),
        showTreeIcon: re,
        notFoundContent: Te,
        getPopupContainer: g == null ? void 0 : g.value,
        treeMotion: null,
        dropdownClassName: R.value,
        choiceTransitionName: N.value,
        onChange: j,
        onBlur: U,
        onSearch: F,
        onTreeExpand: z
      }, Pe), {}, {
        transitionName: _.value,
        customSlots: h(h({}, o), {
          treeCheckable: () => m("span", {
            class: `${s.value}-tree-checkbox-inner`
          }, null)
        }),
        maxTagPlaceholder: e.maxTagPlaceholder || o.maxTagPlaceholder,
        placement: M.value,
        showArrow: pe || he
      }), h(h({}, o), {
        treeCheckable: () => m("span", {
          class: `${s.value}-tree-checkbox-inner`
        }, null)
      }))));
    };
  }
}), Yh = Ea, ZH = h(qu, {
  TreeNode: Ea,
  SHOW_ALL: RH,
  SHOW_PARENT: VC,
  SHOW_CHILD: Ip,
  install: (e) => (e.component(qu.name, qu), e.component(Yh.displayName, Yh), e)
}), Qu = () => ({
  format: String,
  showNow: Me(),
  showHour: Me(),
  showMinute: Me(),
  showSecond: Me(),
  use12Hours: Me(),
  hourStep: Number,
  minuteStep: Number,
  secondStep: Number,
  hideDisabledOptions: Me(),
  popupClassName: String,
  status: Ze()
});
function JH(e) {
  const t = sC(e, h(h({}, Qu()), {
    order: {
      type: Boolean,
      default: !0
    }
  })), {
    TimePicker: n,
    RangePicker: o
  } = t, r = J({
    name: "ATimePicker",
    inheritAttrs: !1,
    props: h(h(h(h({}, Jl()), aC()), Qu()), {
      addon: {
        type: Function
      }
    }),
    slots: Object,
    setup(i, l) {
      let {
        slots: u,
        expose: s,
        emit: c,
        attrs: d
      } = l;
      const f = i, p = Lt();
      gt(!(u.addon || f.addon), "TimePicker", "`addon` is deprecated. Please use `v-slot:renderExtraFooter` instead.");
      const v = G();
      s({
        focus: () => {
          var C;
          (C = v.value) === null || C === void 0 || C.focus();
        },
        blur: () => {
          var C;
          (C = v.value) === null || C === void 0 || C.blur();
        }
      });
      const g = (C, $) => {
        c("update:value", C), c("change", C, $), p.onFieldChange();
      }, b = (C) => {
        c("update:open", C), c("openChange", C);
      }, y = (C) => {
        c("focus", C);
      }, S = (C) => {
        c("blur", C), p.onFieldBlur();
      }, w = (C) => {
        c("ok", C);
      };
      return () => {
        const {
          id: C = p.id.value
        } = f;
        return m(n, L(L(L({}, d), pt(f, ["onUpdate:value", "onUpdate:open"])), {}, {
          id: C,
          dropdownClassName: f.popupClassName,
          mode: void 0,
          ref: v,
          renderExtraFooter: f.addon || u.addon || f.renderExtraFooter || u.renderExtraFooter,
          onChange: g,
          onOpenChange: b,
          onFocus: y,
          onBlur: S,
          onOk: w
        }), u);
      };
    }
  }), a = J({
    name: "ATimeRangePicker",
    inheritAttrs: !1,
    props: h(h(h(h({}, Jl()), iC()), Qu()), {
      order: {
        type: Boolean,
        default: !0
      }
    }),
    slots: Object,
    setup(i, l) {
      let {
        slots: u,
        expose: s,
        emit: c,
        attrs: d
      } = l;
      const f = i, p = G(), v = Lt();
      s({
        focus: () => {
          var O;
          (O = p.value) === null || O === void 0 || O.focus();
        },
        blur: () => {
          var O;
          (O = p.value) === null || O === void 0 || O.blur();
        }
      });
      const g = (O, x) => {
        c("update:value", O), c("change", O, x), v.onFieldChange();
      }, b = (O) => {
        c("update:open", O), c("openChange", O);
      }, y = (O) => {
        c("focus", O);
      }, S = (O) => {
        c("blur", O), v.onFieldBlur();
      }, w = (O, x) => {
        c("panelChange", O, x);
      }, C = (O) => {
        c("ok", O);
      }, $ = (O, x, M) => {
        c("calendarChange", O, x, M);
      };
      return () => {
        const {
          id: O = v.id.value
        } = f;
        return m(o, L(L(L({}, d), pt(f, ["onUpdate:open", "onUpdate:value"])), {}, {
          id: O,
          dropdownClassName: f.popupClassName,
          picker: "time",
          mode: void 0,
          ref: p,
          onChange: g,
          onOpenChange: b,
          onFocus: y,
          onBlur: S,
          onPanelChange: w,
          onOk: C,
          onCalendarChange: $
        }), u);
      };
    }
  });
  return {
    TimePicker: r,
    TimeRangePicker: a
  };
}
const {
  TimePicker: tl,
  TimeRangePicker: Zu
} = JH(OS), e5 = h(tl, {
  TimePicker: tl,
  TimeRangePicker: Zu,
  install: (e) => (e.component(tl.name, tl), e.component(Zu.name, Zu), e)
});
function t5(e, t) {
  const n = `cannot ${e.method} ${e.action} ${t.status}'`, o = new Error(n);
  return o.status = t.status, o.method = e.method, o.url = e.action, o;
}
function Xh(e) {
  const t = e.responseText || e.response;
  if (!t)
    return t;
  try {
    return JSON.parse(t);
  } catch {
    return t;
  }
}
function n5(e) {
  const t = new XMLHttpRequest();
  e.onProgress && t.upload && (t.upload.onprogress = function(a) {
    a.total > 0 && (a.percent = a.loaded / a.total * 100), e.onProgress(a);
  });
  const n = new FormData();
  e.data && Object.keys(e.data).forEach((r) => {
    const a = e.data[r];
    if (Array.isArray(a)) {
      a.forEach((i) => {
        n.append(`${r}[]`, i);
      });
      return;
    }
    n.append(r, a);
  }), e.file instanceof Blob ? n.append(e.filename, e.file, e.file.name) : n.append(e.filename, e.file), t.onerror = function(a) {
    e.onError(a);
  }, t.onload = function() {
    return t.status < 200 || t.status >= 300 ? e.onError(t5(e, t), Xh(t)) : e.onSuccess(Xh(t), t);
  }, t.open(e.method, e.action, !0), e.withCredentials && "withCredentials" in t && (t.withCredentials = !0);
  const o = e.headers || {};
  return o["X-Requested-With"] !== null && t.setRequestHeader("X-Requested-With", "XMLHttpRequest"), Object.keys(o).forEach((r) => {
    o[r] !== null && t.setRequestHeader(r, o[r]);
  }), t.send(n), {
    abort() {
      t.abort();
    }
  };
}
const o5 = +/* @__PURE__ */ new Date();
let r5 = 0;
function Ju() {
  return `vc-upload-${o5}-${++r5}`;
}
const ec = (e, t) => {
  if (e && t) {
    const n = Array.isArray(t) ? t : t.split(","), o = e.name || "", r = e.type || "", a = r.replace(/\/.*$/, "");
    return n.some((i) => {
      const l = i.trim();
      if (/^\*(\/\*)?$/.test(i))
        return !0;
      if (l.charAt(0) === ".") {
        const u = o.toLowerCase(), s = l.toLowerCase();
        let c = [s];
        return (s === ".jpg" || s === ".jpeg") && (c = [".jpg", ".jpeg"]), c.some((d) => u.endsWith(d));
      }
      return /\/\*$/.test(l) ? a === l.replace(/\/.*$/, "") : r === l ? !0 : /^\w+$/.test(l) ? (lt(!1, `Upload takes an invalidate 'accept' type '${l}'.Skip for check.`), !0) : !1;
    });
  }
  return !0;
};
function a5(e, t) {
  const n = e.createReader();
  let o = [];
  function r() {
    n.readEntries((a) => {
      const i = Array.prototype.slice.apply(a);
      o = o.concat(i), !i.length ? t(o) : r();
    });
  }
  r();
}
const i5 = (e, t, n) => {
  const o = (r, a) => {
    r.path = a || "", r.isFile ? r.file((i) => {
      n(i) && (r.fullPath && !i.webkitRelativePath && (Object.defineProperties(i, {
        webkitRelativePath: {
          writable: !0
        }
      }), i.webkitRelativePath = r.fullPath.replace(/^\//, ""), Object.defineProperties(i, {
        webkitRelativePath: {
          writable: !1
        }
      })), t([i]));
    }) : r.isDirectory && a5(r, (i) => {
      i.forEach((l) => {
        o(l, `${a}${r.name}/`);
      });
    });
  };
  e.forEach((r) => {
    o(r.webkitGetAsEntry());
  });
}, KC = () => ({
  capture: [Boolean, String],
  multipart: {
    type: Boolean,
    default: void 0
  },
  name: String,
  disabled: {
    type: Boolean,
    default: void 0
  },
  componentTag: String,
  action: [String, Function],
  method: String,
  directory: {
    type: Boolean,
    default: void 0
  },
  data: [Object, Function],
  headers: Object,
  accept: String,
  multiple: {
    type: Boolean,
    default: void 0
  },
  onBatchStart: Function,
  onReject: Function,
  onStart: Function,
  onError: Function,
  onSuccess: Function,
  onProgress: Function,
  beforeUpload: Function,
  customRequest: Function,
  withCredentials: {
    type: Boolean,
    default: void 0
  },
  openFileDialogOnClick: {
    type: Boolean,
    default: void 0
  },
  prefixCls: String,
  id: String,
  onMouseenter: Function,
  onMouseleave: Function,
  onClick: Function
});
var l5 = function(e, t, n, o) {
  function r(a) {
    return a instanceof n ? a : new n(function(i) {
      i(a);
    });
  }
  return new (n || (n = Promise))(function(a, i) {
    function l(c) {
      try {
        s(o.next(c));
      } catch (d) {
        i(d);
      }
    }
    function u(c) {
      try {
        s(o.throw(c));
      } catch (d) {
        i(d);
      }
    }
    function s(c) {
      c.done ? a(c.value) : r(c.value).then(l, u);
    }
    s((o = o.apply(e, t || [])).next());
  });
}, s5 = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const u5 = J({
  compatConfig: {
    MODE: 3
  },
  name: "AjaxUploader",
  inheritAttrs: !1,
  props: KC(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: r
    } = t;
    const a = G(Ju()), i = {}, l = G();
    let u = !1;
    const s = (S, w) => l5(this, void 0, void 0, function* () {
      const {
        beforeUpload: C
      } = e;
      let $ = S;
      if (C) {
        try {
          $ = yield C(S, w);
        } catch {
          $ = !1;
        }
        if ($ === !1)
          return {
            origin: S,
            parsedFile: null,
            action: null,
            data: null
          };
      }
      const {
        action: O
      } = e;
      let x;
      typeof O == "function" ? x = yield O(S) : x = O;
      const {
        data: M
      } = e;
      let _;
      typeof M == "function" ? _ = yield M(S) : _ = M;
      const N = (
        // string type is from legacy `transformFile`.
        // Not sure if this will work since no related test case works with it
        (typeof $ == "object" || typeof $ == "string") && $ ? $ : S
      );
      let I;
      N instanceof File ? I = N : I = new File([N], S.name, {
        type: S.type
      });
      const E = I;
      return E.uid = S.uid, {
        origin: S,
        data: _,
        parsedFile: E,
        action: x
      };
    }), c = (S) => {
      let {
        data: w,
        origin: C,
        action: $,
        parsedFile: O
      } = S;
      if (!u)
        return;
      const {
        onStart: x,
        customRequest: M,
        name: _,
        headers: N,
        withCredentials: I,
        method: E
      } = e, {
        uid: B
      } = C, k = M || n5, P = {
        action: $,
        filename: _,
        data: w,
        file: O,
        headers: N,
        withCredentials: I,
        method: E || "post",
        onProgress: (R) => {
          const {
            onProgress: D
          } = e;
          D == null || D(R, O);
        },
        onSuccess: (R, D) => {
          const {
            onSuccess: A
          } = e;
          A == null || A(R, O, D), delete i[B];
        },
        onError: (R, D) => {
          const {
            onError: A
          } = e;
          A == null || A(R, D, O), delete i[B];
        }
      };
      x(C), i[B] = k(P);
    }, d = () => {
      a.value = Ju();
    }, f = (S) => {
      if (S) {
        const w = S.uid ? S.uid : S;
        i[w] && i[w].abort && i[w].abort(), delete i[w];
      } else
        Object.keys(i).forEach((w) => {
          i[w] && i[w].abort && i[w].abort(), delete i[w];
        });
    };
    ze(() => {
      u = !0;
    }), at(() => {
      u = !1, f();
    });
    const p = (S) => {
      const w = [...S], C = w.map(($) => ($.uid = Ju(), s($, w)));
      Promise.all(C).then(($) => {
        const {
          onBatchStart: O
        } = e;
        O == null || O($.map((x) => {
          let {
            origin: M,
            parsedFile: _
          } = x;
          return {
            file: M,
            parsedFile: _
          };
        })), $.filter((x) => x.parsedFile !== null).forEach((x) => {
          c(x);
        });
      });
    }, v = (S) => {
      const {
        accept: w,
        directory: C
      } = e, {
        files: $
      } = S.target, O = [...$].filter((x) => !C || ec(x, w));
      p(O), d();
    }, g = (S) => {
      const w = l.value;
      if (!w)
        return;
      const {
        onClick: C
      } = e;
      w.click(), C && C(S);
    }, b = (S) => {
      S.key === "Enter" && g(S);
    }, y = (S) => {
      const {
        multiple: w
      } = e;
      if (S.preventDefault(), S.type !== "dragover")
        if (e.directory)
          i5(Array.prototype.slice.call(S.dataTransfer.items), p, (C) => ec(C, e.accept));
        else {
          const C = eA(Array.prototype.slice.call(S.dataTransfer.files), (x) => ec(x, e.accept));
          let $ = C[0];
          const O = C[1];
          w === !1 && ($ = $.slice(0, 1)), p($), O.length && e.onReject && e.onReject(O);
        }
    };
    return r({
      abort: f
    }), () => {
      var S;
      const {
        componentTag: w,
        prefixCls: C,
        disabled: $,
        id: O,
        multiple: x,
        accept: M,
        capture: _,
        directory: N,
        openFileDialogOnClick: I,
        onMouseenter: E,
        onMouseleave: B
      } = e, k = s5(e, ["componentTag", "prefixCls", "disabled", "id", "multiple", "accept", "capture", "directory", "openFileDialogOnClick", "onMouseenter", "onMouseleave"]), P = {
        [C]: !0,
        [`${C}-disabled`]: $,
        [o.class]: !!o.class
      }, R = N ? {
        directory: "directory",
        webkitdirectory: "webkitdirectory"
      } : {};
      return m(w, L(L({}, $ ? {} : {
        onClick: I ? g : () => {
        },
        onKeydown: I ? b : () => {
        },
        onMouseenter: E,
        onMouseleave: B,
        onDrop: y,
        onDragover: y,
        tabindex: "0"
      }), {}, {
        class: P,
        role: "button",
        style: o.style
      }), {
        default: () => [m("input", L(L(L({}, _r(k, {
          aria: !0,
          data: !0
        })), {}, {
          id: O,
          type: "file",
          ref: l,
          onClick: (A) => A.stopPropagation(),
          onCancel: (A) => A.stopPropagation(),
          key: a.value,
          style: {
            display: "none"
          },
          accept: M
        }, R), {}, {
          multiple: x,
          onChange: v
        }, _ != null ? {
          capture: _
        } : {}), null), (S = n.default) === null || S === void 0 ? void 0 : S.call(n)]
      });
    };
  }
});
function tc() {
}
const qh = J({
  compatConfig: {
    MODE: 3
  },
  name: "Upload",
  inheritAttrs: !1,
  props: bt(KC(), {
    componentTag: "span",
    prefixCls: "rc-upload",
    data: {},
    headers: {},
    name: "file",
    multipart: !1,
    onStart: tc,
    onError: tc,
    onSuccess: tc,
    multiple: !1,
    beforeUpload: null,
    customRequest: null,
    withCredentials: !1,
    openFileDialogOnClick: !0
  }),
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: r
    } = t;
    const a = G();
    return r({
      abort: (l) => {
        var u;
        (u = a.value) === null || u === void 0 || u.abort(l);
      }
    }), () => m(u5, L(L(L({}, e), o), {}, {
      ref: a
    }), n);
  }
});
var c5 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M779.3 196.6c-94.2-94.2-247.6-94.2-341.7 0l-261 260.8c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l261-260.8c32.4-32.4 75.5-50.2 121.3-50.2s88.9 17.8 121.2 50.2c32.4 32.4 50.2 75.5 50.2 121.2 0 45.8-17.8 88.8-50.2 121.2l-266 265.9-43.1 43.1c-40.3 40.3-105.8 40.3-146.1 0-19.5-19.5-30.2-45.4-30.2-73s10.7-53.5 30.2-73l263.9-263.8c6.7-6.6 15.5-10.3 24.9-10.3h.1c9.4 0 18.1 3.7 24.7 10.3 6.7 6.7 10.3 15.5 10.3 24.9 0 9.3-3.7 18.1-10.3 24.7L372.4 653c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l215.6-215.6c19.9-19.9 30.8-46.3 30.8-74.4s-11-54.6-30.8-74.4c-41.1-41.1-107.9-41-149 0L463 364 224.8 602.1A172.22 172.22 0 00174 724.8c0 46.3 18.1 89.8 50.8 122.5 33.9 33.8 78.3 50.7 122.7 50.7 44.4 0 88.8-16.9 122.6-50.7l309.2-309C824.8 492.7 850 432 850 367.5c.1-64.6-25.1-125.3-70.7-170.9z" } }] }, name: "paper-clip", theme: "outlined" };
function Qh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      d5(e, r, n[r]);
    });
  }
  return e;
}
function d5(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Tp = function(t, n) {
  var o = Qh({}, t, n.attrs);
  return m(it, Qh({}, o, {
    icon: c5
  }), null);
};
Tp.displayName = "PaperClipOutlined";
Tp.inheritAttrs = !1;
var f5 = { icon: function(t, n) {
  return { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 632H136v-39.9l138.5-164.3 150.1 178L658.1 489 888 761.6V792zm0-129.8L664.2 396.8c-3.2-3.8-9-3.8-12.2 0L424.6 666.4l-144-170.7c-3.2-3.8-9-3.8-12.2 0L136 652.7V232h752v430.2z", fill: t } }, { tag: "path", attrs: { d: "M424.6 765.8l-150.1-178L136 752.1V792h752v-30.4L658.1 489z", fill: n } }, { tag: "path", attrs: { d: "M136 652.7l132.4-157c3.2-3.8 9-3.8 12.2 0l144 170.7L652 396.8c3.2-3.8 9-3.8 12.2 0L888 662.2V232H136v420.7zM304 280a88 88 0 110 176 88 88 0 010-176z", fill: n } }, { tag: "path", attrs: { d: "M276 368a28 28 0 1056 0 28 28 0 10-56 0z", fill: n } }, { tag: "path", attrs: { d: "M304 456a88 88 0 100-176 88 88 0 000 176zm0-116c15.5 0 28 12.5 28 28s-12.5 28-28 28-28-12.5-28-28 12.5-28 28-28z", fill: t } }] };
}, name: "picture", theme: "twotone" };
function Zh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      p5(e, r, n[r]);
    });
  }
  return e;
}
function p5(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Ep = function(t, n) {
  var o = Zh({}, t, n.attrs);
  return m(it, Zh({}, o, {
    icon: f5
  }), null);
};
Ep.displayName = "PictureTwoTone";
Ep.inheritAttrs = !1;
var v5 = { icon: function(t, n) {
  return { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M534 352V136H232v752h560V394H576a42 42 0 01-42-42z", fill: n } }, { tag: "path", attrs: { d: "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM602 137.8L790.2 326H602V137.8zM792 888H232V136h302v216a42 42 0 0042 42h216v494z", fill: t } }] };
}, name: "file", theme: "twotone" };
function Jh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      m5(e, r, n[r]);
    });
  }
  return e;
}
function m5(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Mp = function(t, n) {
  var o = Jh({}, t, n.attrs);
  return m(it, Jh({}, o, {
    icon: v5
  }), null);
};
Mp.displayName = "FileTwoTone";
Mp.inheritAttrs = !1;
function UC() {
  return {
    capture: dt([Boolean, String]),
    type: Ze(),
    name: String,
    defaultFileList: Nt(),
    fileList: Nt(),
    action: dt([String, Function]),
    directory: Me(),
    data: dt([Object, Function]),
    method: Ze(),
    headers: He(),
    showUploadList: dt([Boolean, Object]),
    multiple: Me(),
    accept: String,
    beforeUpload: de(),
    onChange: de(),
    "onUpdate:fileList": de(),
    onDrop: de(),
    listType: Ze(),
    onPreview: de(),
    onDownload: de(),
    onReject: de(),
    onRemove: de(),
    /** @deprecated Please use `onRemove` directly */
    remove: de(),
    supportServerRender: Me(),
    disabled: Me(),
    prefixCls: String,
    customRequest: de(),
    withCredentials: Me(),
    openFileDialogOnClick: Me(),
    locale: He(),
    id: String,
    previewFile: de(),
    /** @deprecated Please use `beforeUpload` directly */
    transformFile: de(),
    iconRender: de(),
    isImageUrl: de(),
    progress: He(),
    itemRender: de(),
    /** Config max count of `fileList`. Will replace current one when `maxCount` is 1 */
    maxCount: Number,
    height: dt([Number, String]),
    removeIcon: de(),
    downloadIcon: de(),
    previewIcon: de()
  };
}
function g5() {
  return {
    listType: Ze(),
    onPreview: de(),
    onDownload: de(),
    onRemove: de(),
    items: Nt(),
    progress: He(),
    prefixCls: Ze(),
    showRemoveIcon: Me(),
    showDownloadIcon: Me(),
    showPreviewIcon: Me(),
    removeIcon: de(),
    downloadIcon: de(),
    previewIcon: de(),
    locale: He(void 0),
    previewFile: de(),
    iconRender: de(),
    isImageUrl: de(),
    appendAction: de(),
    appendActionVisible: Me(),
    itemRender: de()
  };
}
function nl(e) {
  return h(h({}, e), {
    lastModified: e.lastModified,
    lastModifiedDate: e.lastModifiedDate,
    name: e.name,
    size: e.size,
    type: e.type,
    uid: e.uid,
    percent: 0,
    originFileObj: e
  });
}
function ol(e, t) {
  const n = [...t], o = n.findIndex((r) => {
    let {
      uid: a
    } = r;
    return a === e.uid;
  });
  return o === -1 ? n.push(e) : n[o] = e, n;
}
function nc(e, t) {
  const n = e.uid !== void 0 ? "uid" : "name";
  return t.filter((o) => o[n] === e[n])[0];
}
function h5(e, t) {
  const n = e.uid !== void 0 ? "uid" : "name", o = t.filter((r) => r[n] !== e[n]);
  return o.length === t.length ? null : o;
}
const b5 = function() {
  const t = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "").split("/"), o = t[t.length - 1].split(/#|\?/)[0];
  return (/\.[^./\\]*$/.exec(o) || [""])[0];
}, GC = (e) => e.indexOf("image/") === 0, y5 = (e) => {
  if (e.type && !e.thumbUrl)
    return GC(e.type);
  const t = e.thumbUrl || e.url || "", n = b5(t);
  return /^data:image\//.test(t) || /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico)$/i.test(n) ? !0 : !(/^data:/.test(t) || n);
}, Fo = 200;
function S5(e) {
  return new Promise((t) => {
    if (!e.type || !GC(e.type)) {
      t("");
      return;
    }
    const n = document.createElement("canvas");
    n.width = Fo, n.height = Fo, n.style.cssText = `position: fixed; left: 0; top: 0; width: ${Fo}px; height: ${Fo}px; z-index: 9999; display: none;`, document.body.appendChild(n);
    const o = n.getContext("2d"), r = new Image();
    if (r.onload = () => {
      const {
        width: a,
        height: i
      } = r;
      let l = Fo, u = Fo, s = 0, c = 0;
      a > i ? (u = i * (Fo / a), c = -(u - l) / 2) : (l = a * (Fo / i), s = -(l - u) / 2), o.drawImage(r, s, c, l, u);
      const d = n.toDataURL();
      document.body.removeChild(n), t(d);
    }, r.crossOrigin = "anonymous", e.type.startsWith("image/svg+xml")) {
      const a = new FileReader();
      a.addEventListener("load", () => {
        a.result && (r.src = a.result);
      }), a.readAsDataURL(e);
    } else
      r.src = window.URL.createObjectURL(e);
  });
}
var $5 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M505.7 661a8 8 0 0012.6 0l112-141.7c4.1-5.2.4-12.9-6.3-12.9h-74.1V168c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v338.3H400c-6.7 0-10.4 7.7-6.3 12.9l112 141.8zM878 626h-60c-4.4 0-8 3.6-8 8v154H214V634c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v198c0 17.7 14.3 32 32 32h684c17.7 0 32-14.3 32-32V634c0-4.4-3.6-8-8-8z" } }] }, name: "download", theme: "outlined" };
function eb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      C5(e, r, n[r]);
    });
  }
  return e;
}
function C5(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var _p = function(t, n) {
  var o = eb({}, t, n.attrs);
  return m(it, eb({}, o, {
    icon: $5
  }), null);
};
_p.displayName = "DownloadOutlined";
_p.inheritAttrs = !1;
const w5 = () => ({
  prefixCls: String,
  locale: He(void 0),
  file: He(),
  items: Nt(),
  listType: Ze(),
  isImgUrl: de(),
  showRemoveIcon: Me(),
  showDownloadIcon: Me(),
  showPreviewIcon: Me(),
  removeIcon: de(),
  downloadIcon: de(),
  previewIcon: de(),
  iconRender: de(),
  actionIconRender: de(),
  itemRender: de(),
  onPreview: de(),
  onClose: de(),
  onDownload: de(),
  progress: He()
}), x5 = J({
  compatConfig: {
    MODE: 3
  },
  name: "ListItem",
  inheritAttrs: !1,
  props: w5(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    var r;
    const a = K(!1), i = K();
    ze(() => {
      i.value = setTimeout(() => {
        a.value = !0;
      }, 300);
    }), at(() => {
      clearTimeout(i.value);
    });
    const l = K((r = e.file) === null || r === void 0 ? void 0 : r.status);
    le(() => {
      var c;
      return (c = e.file) === null || c === void 0 ? void 0 : c.status;
    }, (c) => {
      c !== "removed" && (l.value = c);
    });
    const {
      rootPrefixCls: u
    } = Ke("upload", e), s = T(() => Ca(`${u.value}-fade`));
    return () => {
      var c, d;
      const {
        prefixCls: f,
        locale: p,
        listType: v,
        file: g,
        items: b,
        progress: y,
        iconRender: S = n.iconRender,
        actionIconRender: w = n.actionIconRender,
        itemRender: C = n.itemRender,
        isImgUrl: $,
        showPreviewIcon: O,
        showRemoveIcon: x,
        showDownloadIcon: M,
        previewIcon: _ = n.previewIcon,
        removeIcon: N = n.removeIcon,
        downloadIcon: I = n.downloadIcon,
        onPreview: E,
        onDownload: B,
        onClose: k
      } = e, {
        class: P,
        style: R
      } = o, D = S({
        file: g
      });
      let A = m("div", {
        class: `${f}-text-icon`
      }, [D]);
      if (v === "picture" || v === "picture-card")
        if (l.value === "uploading" || !g.thumbUrl && !g.url) {
          const ie = {
            [`${f}-list-item-thumbnail`]: !0,
            [`${f}-list-item-file`]: l.value !== "uploading"
          };
          A = m("div", {
            class: ie
          }, [D]);
        } else {
          const ie = $ != null && $(g) ? m("img", {
            src: g.thumbUrl || g.url,
            alt: g.name,
            class: `${f}-list-item-image`,
            crossorigin: g.crossOrigin
          }, null) : D, he = {
            [`${f}-list-item-thumbnail`]: !0,
            [`${f}-list-item-file`]: $ && !$(g)
          };
          A = m("a", {
            class: he,
            onClick: (ge) => E(g, ge),
            href: g.url || g.thumbUrl,
            target: "_blank",
            rel: "noopener noreferrer"
          }, [ie]);
        }
      const H = {
        [`${f}-list-item`]: !0,
        [`${f}-list-item-${l.value}`]: !0
      }, j = typeof g.linkProps == "string" ? JSON.parse(g.linkProps) : g.linkProps, z = x ? w({
        customIcon: N ? N({
          file: g
        }) : m(Pp, null, null),
        callback: () => k(g),
        prefixCls: f,
        title: p.removeFile
      }) : null, F = M && l.value === "done" ? w({
        customIcon: I ? I({
          file: g
        }) : m(_p, null, null),
        callback: () => B(g),
        prefixCls: f,
        title: p.downloadFile
      }) : null, U = v !== "picture-card" && m("span", {
        key: "download-delete",
        class: [`${f}-list-item-actions`, {
          picture: v === "picture"
        }]
      }, [F, z]), Q = `${f}-list-item-name`, q = g.url ? [m("a", L(L({
        key: "view",
        target: "_blank",
        rel: "noopener noreferrer",
        class: Q,
        title: g.name
      }, j), {}, {
        href: g.url,
        onClick: (ie) => E(g, ie)
      }), [g.name]), U] : [m("span", {
        key: "view",
        class: Q,
        onClick: (ie) => E(g, ie),
        title: g.name
      }, [g.name]), U], oe = {
        pointerEvents: "none",
        opacity: 0.5
      }, Z = O ? m("a", {
        href: g.url || g.thumbUrl,
        target: "_blank",
        rel: "noopener noreferrer",
        style: g.url || g.thumbUrl ? void 0 : oe,
        onClick: (ie) => E(g, ie),
        title: p.previewFile
      }, [_ ? _({
        file: g
      }) : m(Us, null, null)]) : null, ne = v === "picture-card" && l.value !== "uploading" && m("span", {
        class: `${f}-list-item-actions`
      }, [Z, l.value === "done" && F, z]), Y = m("div", {
        class: H
      }, [A, q, ne, a.value && m(Yn, s.value, {
        default: () => [An(m("div", {
          class: `${f}-list-item-progress`
        }, ["percent" in g ? m(mL, L(L({}, y), {}, {
          type: "line",
          percent: g.percent
        }), null) : null]), [[wo, l.value === "uploading"]])]
      })]), V = {
        [`${f}-list-item-container`]: !0,
        [`${P}`]: !!P
      }, X = g.response && typeof g.response == "string" ? g.response : ((c = g.error) === null || c === void 0 ? void 0 : c.statusText) || ((d = g.error) === null || d === void 0 ? void 0 : d.message) || p.uploadError, re = l.value === "error" ? m(Nr, {
        title: X,
        getPopupContainer: (ie) => ie.parentNode
      }, {
        default: () => [Y]
      }) : Y;
      return m("div", {
        class: V,
        style: R
      }, [C ? C({
        originNode: re,
        file: g,
        fileList: b,
        actions: {
          download: B.bind(null, g),
          preview: E.bind(null, g),
          remove: k.bind(null, g)
        }
      }) : re]);
    };
  }
}), O5 = (e, t) => {
  let {
    slots: n
  } = t;
  var o;
  return nn((o = n.default) === null || o === void 0 ? void 0 : o.call(n))[0];
}, P5 = J({
  compatConfig: {
    MODE: 3
  },
  name: "AUploadList",
  props: bt(g5(), {
    listType: "text",
    progress: {
      strokeWidth: 2,
      showInfo: !1
    },
    showRemoveIcon: !0,
    showDownloadIcon: !1,
    showPreviewIcon: !0,
    previewFile: S5,
    isImageUrl: y5,
    items: [],
    appendActionVisible: !0
  }),
  setup(e, t) {
    let {
      slots: n,
      expose: o
    } = t;
    const r = K(!1);
    ze(() => {
      r.value == !0;
    });
    const a = K([]);
    le(() => e.items, function() {
      let g = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      a.value = g.slice();
    }, {
      immediate: !0,
      deep: !0
    }), Ve(() => {
      if (e.listType !== "picture" && e.listType !== "picture-card")
        return;
      let g = !1;
      (e.items || []).forEach((b, y) => {
        typeof document > "u" || typeof window > "u" || !window.FileReader || !window.File || !(b.originFileObj instanceof File || b.originFileObj instanceof Blob) || b.thumbUrl !== void 0 || (b.thumbUrl = "", e.previewFile && e.previewFile(b.originFileObj).then((S) => {
          const w = S || "";
          w !== b.thumbUrl && (a.value[y].thumbUrl = w, g = !0);
        }));
      }), g && ub(a);
    });
    const i = (g, b) => {
      if (e.onPreview)
        return b == null || b.preventDefault(), e.onPreview(g);
    }, l = (g) => {
      typeof e.onDownload == "function" ? e.onDownload(g) : g.url && window.open(g.url);
    }, u = (g) => {
      var b;
      (b = e.onRemove) === null || b === void 0 || b.call(e, g);
    }, s = (g) => {
      let {
        file: b
      } = g;
      const y = e.iconRender || n.iconRender;
      if (y)
        return y({
          file: b,
          listType: e.listType
        });
      const S = b.status === "uploading", w = e.isImageUrl && e.isImageUrl(b) ? m(Ep, null, null) : m(Mp, null, null);
      let C = S ? m(pn, null, null) : m(Tp, null, null);
      return e.listType === "picture" ? C = S ? m(pn, null, null) : w : e.listType === "picture-card" && (C = S ? e.locale.uploading : w), C;
    }, c = (g) => {
      const {
        customIcon: b,
        callback: y,
        prefixCls: S,
        title: w
      } = g, C = {
        type: "text",
        size: "small",
        title: w,
        onClick: () => {
          y();
        },
        class: `${S}-list-item-action`
      };
      return on(b) ? m(Zt, C, {
        icon: () => b
      }) : m(Zt, C, {
        default: () => [m("span", null, [b])]
      });
    };
    o({
      handlePreview: i,
      handleDownload: l
    });
    const {
      prefixCls: d,
      rootPrefixCls: f
    } = Ke("upload", e), p = T(() => ({
      [`${d.value}-list`]: !0,
      [`${d.value}-list-${e.listType}`]: !0
    })), v = T(() => {
      const g = h({}, As(`${f.value}-motion-collapse`));
      delete g.onAfterAppear, delete g.onAfterEnter, delete g.onAfterLeave;
      const b = h(h({}, bs(`${d.value}-${e.listType === "picture-card" ? "animate-inline" : "animate"}`)), {
        class: p.value,
        appear: r.value
      });
      return e.listType !== "picture-card" ? h(h({}, g), b) : b;
    });
    return () => {
      const {
        listType: g,
        locale: b,
        isImageUrl: y,
        showPreviewIcon: S,
        showRemoveIcon: w,
        showDownloadIcon: C,
        removeIcon: $,
        previewIcon: O,
        downloadIcon: x,
        progress: M,
        appendAction: _,
        itemRender: N,
        appendActionVisible: I
      } = e, E = _ == null ? void 0 : _(), B = a.value;
      return m(ns, L(L({}, v.value), {}, {
        tag: "div"
      }), {
        default: () => [B.map((k) => {
          const {
            uid: P
          } = k;
          return m(x5, {
            key: P,
            locale: b,
            prefixCls: d.value,
            file: k,
            items: B,
            progress: M,
            listType: g,
            isImgUrl: y,
            showPreviewIcon: S,
            showRemoveIcon: w,
            showDownloadIcon: C,
            onPreview: i,
            onDownload: l,
            onClose: u,
            removeIcon: $,
            previewIcon: O,
            downloadIcon: x,
            itemRender: N
          }, h(h({}, n), {
            iconRender: s,
            actionIconRender: c
          }));
        }), _ ? An(m(O5, {
          key: "__ant_upload_appendAction"
        }, {
          default: () => E
        }), [[wo, !!I]]) : null]
      });
    };
  }
}), I5 = (e) => {
  const {
    componentCls: t,
    iconCls: n
  } = e;
  return {
    [`${t}-wrapper`]: {
      [`${t}-drag`]: {
        position: "relative",
        width: "100%",
        height: "100%",
        textAlign: "center",
        background: e.colorFillAlter,
        border: `${e.lineWidth}px dashed ${e.colorBorder}`,
        borderRadius: e.borderRadiusLG,
        cursor: "pointer",
        transition: `border-color ${e.motionDurationSlow}`,
        [t]: {
          padding: `${e.padding}px 0`
        },
        [`${t}-btn`]: {
          display: "table",
          width: "100%",
          height: "100%",
          outline: "none"
        },
        [`${t}-drag-container`]: {
          display: "table-cell",
          verticalAlign: "middle"
        },
        [`&:not(${t}-disabled):hover`]: {
          borderColor: e.colorPrimaryHover
        },
        [`p${t}-drag-icon`]: {
          marginBottom: e.margin,
          [n]: {
            color: e.colorPrimary,
            fontSize: e.uploadThumbnailSize
          }
        },
        [`p${t}-text`]: {
          margin: `0 0 ${e.marginXXS}px`,
          color: e.colorTextHeading,
          fontSize: e.fontSizeLG
        },
        [`p${t}-hint`]: {
          color: e.colorTextDescription,
          fontSize: e.fontSize
        },
        // ===================== Disabled =====================
        [`&${t}-disabled`]: {
          cursor: "not-allowed",
          [`p${t}-drag-icon ${n},
            p${t}-text,
            p${t}-hint
          `]: {
            color: e.colorTextDisabled
          }
        }
      }
    }
  };
}, T5 = (e) => {
  const {
    componentCls: t,
    antCls: n,
    iconCls: o,
    fontSize: r,
    lineHeight: a
  } = e, i = `${t}-list-item`, l = `${i}-actions`, u = `${i}-action`, s = Math.round(r * a);
  return {
    [`${t}-wrapper`]: {
      [`${t}-list`]: h(h({}, ca()), {
        lineHeight: e.lineHeight,
        [i]: {
          position: "relative",
          height: e.lineHeight * r,
          marginTop: e.marginXS,
          fontSize: r,
          display: "flex",
          alignItems: "center",
          transition: `background-color ${e.motionDurationSlow}`,
          "&:hover": {
            backgroundColor: e.controlItemBgHover
          },
          [`${i}-name`]: h(h({}, So), {
            padding: `0 ${e.paddingXS}px`,
            lineHeight: a,
            flex: "auto",
            transition: `all ${e.motionDurationSlow}`
          }),
          [l]: {
            [u]: {
              opacity: 0
            },
            [`${u}${n}-btn-sm`]: {
              height: s,
              border: 0,
              lineHeight: 1,
              // FIXME: should not override small button
              "> span": {
                transform: "scale(1)"
              }
            },
            [`
              ${u}:focus,
              &.picture ${u}
            `]: {
              opacity: 1
            },
            [o]: {
              color: e.colorTextDescription,
              transition: `all ${e.motionDurationSlow}`
            },
            [`&:hover ${o}`]: {
              color: e.colorText
            }
          },
          [`${t}-icon ${o}`]: {
            color: e.colorTextDescription,
            fontSize: r
          },
          [`${i}-progress`]: {
            position: "absolute",
            bottom: -e.uploadProgressOffset,
            width: "100%",
            paddingInlineStart: r + e.paddingXS,
            fontSize: r,
            lineHeight: 0,
            pointerEvents: "none",
            "> div": {
              margin: 0
            }
          }
        },
        [`${i}:hover ${u}`]: {
          opacity: 1,
          color: e.colorText
        },
        [`${i}-error`]: {
          color: e.colorError,
          [`${i}-name, ${t}-icon ${o}`]: {
            color: e.colorError
          },
          [l]: {
            [`${o}, ${o}:hover`]: {
              color: e.colorError
            },
            [u]: {
              opacity: 1
            }
          }
        },
        [`${t}-list-item-container`]: {
          transition: `opacity ${e.motionDurationSlow}, height ${e.motionDurationSlow}`,
          // For smooth removing animation
          "&::before": {
            display: "table",
            width: 0,
            height: 0,
            content: '""'
          }
        }
      })
    }
  };
}, tb = new Xe("uploadAnimateInlineIn", {
  from: {
    width: 0,
    height: 0,
    margin: 0,
    padding: 0,
    opacity: 0
  }
}), nb = new Xe("uploadAnimateInlineOut", {
  to: {
    width: 0,
    height: 0,
    margin: 0,
    padding: 0,
    opacity: 0
  }
}), E5 = (e) => {
  const {
    componentCls: t
  } = e, n = `${t}-animate-inline`;
  return [{
    [`${t}-wrapper`]: {
      [`${n}-appear, ${n}-enter, ${n}-leave`]: {
        animationDuration: e.motionDurationSlow,
        animationTimingFunction: e.motionEaseInOutCirc,
        animationFillMode: "forwards"
      },
      [`${n}-appear, ${n}-enter`]: {
        animationName: tb
      },
      [`${n}-leave`]: {
        animationName: nb
      }
    }
  }, tb, nb];
}, M5 = (e) => {
  const {
    componentCls: t,
    iconCls: n,
    uploadThumbnailSize: o,
    uploadProgressOffset: r
  } = e, a = `${t}-list`, i = `${a}-item`;
  return {
    [`${t}-wrapper`]: {
      // ${listCls} 增加优先级
      [`${a}${a}-picture, ${a}${a}-picture-card`]: {
        [i]: {
          position: "relative",
          height: o + e.lineWidth * 2 + e.paddingXS * 2,
          padding: e.paddingXS,
          border: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`,
          borderRadius: e.borderRadiusLG,
          "&:hover": {
            background: "transparent"
          },
          [`${i}-thumbnail`]: h(h({}, So), {
            width: o,
            height: o,
            lineHeight: `${o + e.paddingSM}px`,
            textAlign: "center",
            flex: "none",
            [n]: {
              fontSize: e.fontSizeHeading2,
              color: e.colorPrimary
            },
            img: {
              display: "block",
              width: "100%",
              height: "100%",
              overflow: "hidden"
            }
          }),
          [`${i}-progress`]: {
            bottom: r,
            width: `calc(100% - ${e.paddingSM * 2}px)`,
            marginTop: 0,
            paddingInlineStart: o + e.paddingXS
          }
        },
        [`${i}-error`]: {
          borderColor: e.colorError,
          // Adjust the color of the error icon : https://github.com/ant-design/ant-design/pull/24160
          [`${i}-thumbnail ${n}`]: {
            "svg path[fill='#e6f7ff']": {
              fill: e.colorErrorBg
            },
            "svg path[fill='#1890ff']": {
              fill: e.colorError
            }
          }
        },
        [`${i}-uploading`]: {
          borderStyle: "dashed",
          [`${i}-name`]: {
            marginBottom: r
          }
        }
      }
    }
  };
}, _5 = (e) => {
  const {
    componentCls: t,
    iconCls: n,
    fontSizeLG: o,
    colorTextLightSolid: r
  } = e, a = `${t}-list`, i = `${a}-item`, l = e.uploadPicCardSize;
  return {
    [`${t}-wrapper${t}-picture-card-wrapper`]: h(h({}, ca()), {
      display: "inline-block",
      width: "100%",
      [`${t}${t}-select`]: {
        width: l,
        height: l,
        marginInlineEnd: e.marginXS,
        marginBottom: e.marginXS,
        textAlign: "center",
        verticalAlign: "top",
        backgroundColor: e.colorFillAlter,
        border: `${e.lineWidth}px dashed ${e.colorBorder}`,
        borderRadius: e.borderRadiusLG,
        cursor: "pointer",
        transition: `border-color ${e.motionDurationSlow}`,
        [`> ${t}`]: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          height: "100%",
          textAlign: "center"
        },
        [`&:not(${t}-disabled):hover`]: {
          borderColor: e.colorPrimary
        }
      },
      // list
      [`${a}${a}-picture-card`]: {
        [`${a}-item-container`]: {
          display: "inline-block",
          width: l,
          height: l,
          marginBlock: `0 ${e.marginXS}px`,
          marginInline: `0 ${e.marginXS}px`,
          verticalAlign: "top"
        },
        "&::after": {
          display: "none"
        },
        [i]: {
          height: "100%",
          margin: 0,
          "&::before": {
            position: "absolute",
            zIndex: 1,
            width: `calc(100% - ${e.paddingXS * 2}px)`,
            height: `calc(100% - ${e.paddingXS * 2}px)`,
            backgroundColor: e.colorBgMask,
            opacity: 0,
            transition: `all ${e.motionDurationSlow}`,
            content: '" "'
          }
        },
        [`${i}:hover`]: {
          [`&::before, ${i}-actions`]: {
            opacity: 1
          }
        },
        [`${i}-actions`]: {
          position: "absolute",
          insetInlineStart: 0,
          zIndex: 10,
          width: "100%",
          whiteSpace: "nowrap",
          textAlign: "center",
          opacity: 0,
          transition: `all ${e.motionDurationSlow}`,
          [`${n}-eye, ${n}-download, ${n}-delete`]: {
            zIndex: 10,
            width: o,
            margin: `0 ${e.marginXXS}px`,
            fontSize: o,
            cursor: "pointer",
            transition: `all ${e.motionDurationSlow}`
          }
        },
        [`${i}-actions, ${i}-actions:hover`]: {
          [`${n}-eye, ${n}-download, ${n}-delete`]: {
            color: new Ct(r).setAlpha(0.65).toRgbString(),
            "&:hover": {
              color: r
            }
          }
        },
        [`${i}-thumbnail, ${i}-thumbnail img`]: {
          position: "static",
          display: "block",
          width: "100%",
          height: "100%",
          objectFit: "contain"
        },
        [`${i}-name`]: {
          display: "none",
          textAlign: "center"
        },
        [`${i}-file + ${i}-name`]: {
          position: "absolute",
          bottom: e.margin,
          display: "block",
          width: `calc(100% - ${e.paddingXS * 2}px)`
        },
        [`${i}-uploading`]: {
          [`&${i}`]: {
            backgroundColor: e.colorFillAlter
          },
          [`&::before, ${n}-eye, ${n}-download, ${n}-delete`]: {
            display: "none"
          }
        },
        [`${i}-progress`]: {
          bottom: e.marginXL,
          width: `calc(100% - ${e.paddingXS * 2}px)`,
          paddingInlineStart: 0
        }
      }
    })
  };
}, D5 = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-rtl`]: {
      direction: "rtl"
    }
  };
}, A5 = (e) => {
  const {
    componentCls: t,
    colorTextDisabled: n
  } = e;
  return {
    [`${t}-wrapper`]: h(h({}, st(e)), {
      [t]: {
        outline: 0,
        "input[type='file']": {
          cursor: "pointer"
        }
      },
      [`${t}-select`]: {
        display: "inline-block"
      },
      [`${t}-disabled`]: {
        color: n,
        cursor: "not-allowed"
      }
    })
  };
}, N5 = ht("Upload", (e) => {
  const {
    fontSizeHeading3: t,
    fontSize: n,
    lineHeight: o,
    lineWidth: r,
    controlHeightLG: a
  } = e, i = Math.round(n * o), l = qe(e, {
    uploadThumbnailSize: t * 2,
    uploadProgressOffset: i / 2 + r,
    uploadPicCardSize: a * 2.55
  });
  return [A5(l), I5(l), M5(l), _5(l), T5(l), E5(l), D5(l), $f(l)];
});
var R5 = function(e, t, n, o) {
  function r(a) {
    return a instanceof n ? a : new n(function(i) {
      i(a);
    });
  }
  return new (n || (n = Promise))(function(a, i) {
    function l(c) {
      try {
        s(o.next(c));
      } catch (d) {
        i(d);
      }
    }
    function u(c) {
      try {
        s(o.throw(c));
      } catch (d) {
        i(d);
      }
    }
    function s(c) {
      c.done ? a(c.value) : r(c.value).then(l, u);
    }
    s((o = o.apply(e, t || [])).next());
  });
}, F5 = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const Wa = `__LIST_IGNORE_${Date.now()}__`, wl = J({
  compatConfig: {
    MODE: 3
  },
  name: "AUpload",
  inheritAttrs: !1,
  props: bt(UC(), {
    type: "select",
    multiple: !1,
    action: "",
    data: {},
    accept: "",
    showUploadList: !0,
    listType: "text",
    supportServerRender: !0
  }),
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: r
    } = t;
    const a = Lt(), {
      prefixCls: i,
      direction: l,
      disabled: u
    } = Ke("upload", e), [s, c] = N5(i), d = Cn(), f = T(() => {
      var I;
      return (I = u.value) !== null && I !== void 0 ? I : d.value;
    }), [p, v] = Gt(e.defaultFileList || [], {
      value: Je(e, "fileList"),
      postState: (I) => {
        const E = Date.now();
        return (I ?? []).map((B, k) => (!B.uid && !Object.isFrozen(B) && (B.uid = `__AUTO__${E}_${k}__`), B));
      }
    }), g = G("drop"), b = G(null);
    ze(() => {
      gt(e.fileList !== void 0 || o.value === void 0, "Upload", "`value` is not a valid prop, do you mean `fileList`?"), gt(e.transformFile === void 0, "Upload", "`transformFile` is deprecated. Please use `beforeUpload` directly."), gt(e.remove === void 0, "Upload", "`remove` props is deprecated. Please use `remove` event.");
    });
    const y = (I, E, B) => {
      var k, P;
      let R = [...E];
      e.maxCount === 1 ? R = R.slice(-1) : e.maxCount && (R = R.slice(0, e.maxCount)), v(R);
      const D = {
        file: I,
        fileList: R
      };
      B && (D.event = B), (k = e["onUpdate:fileList"]) === null || k === void 0 || k.call(e, D.fileList), (P = e.onChange) === null || P === void 0 || P.call(e, D), a.onFieldChange();
    }, S = (I, E) => R5(this, void 0, void 0, function* () {
      const {
        beforeUpload: B,
        transformFile: k
      } = e;
      let P = I;
      if (B) {
        const R = yield B(I, E);
        if (R === !1)
          return !1;
        if (delete I[Wa], R === Wa)
          return Object.defineProperty(I, Wa, {
            value: !0,
            configurable: !0
          }), !1;
        typeof R == "object" && R && (P = R);
      }
      return k && (P = yield k(P)), P;
    }), w = (I) => {
      const E = I.filter((P) => !P.file[Wa]);
      if (!E.length)
        return;
      const B = E.map((P) => nl(P.file));
      let k = [...p.value];
      B.forEach((P) => {
        k = ol(P, k);
      }), B.forEach((P, R) => {
        let D = P;
        if (E[R].parsedFile)
          P.status = "uploading";
        else {
          const {
            originFileObj: A
          } = P;
          let H;
          try {
            H = new File([A], A.name, {
              type: A.type
            });
          } catch {
            H = new Blob([A], {
              type: A.type
            }), H.name = A.name, H.lastModifiedDate = /* @__PURE__ */ new Date(), H.lastModified = (/* @__PURE__ */ new Date()).getTime();
          }
          H.uid = P.uid, D = H;
        }
        y(D, k);
      });
    }, C = (I, E, B) => {
      try {
        typeof I == "string" && (I = JSON.parse(I));
      } catch {
      }
      if (!nc(E, p.value))
        return;
      const k = nl(E);
      k.status = "done", k.percent = 100, k.response = I, k.xhr = B;
      const P = ol(k, p.value);
      y(k, P);
    }, $ = (I, E) => {
      if (!nc(E, p.value))
        return;
      const B = nl(E);
      B.status = "uploading", B.percent = I.percent;
      const k = ol(B, p.value);
      y(B, k, I);
    }, O = (I, E, B) => {
      if (!nc(B, p.value))
        return;
      const k = nl(B);
      k.error = I, k.response = E, k.status = "error";
      const P = ol(k, p.value);
      y(k, P);
    }, x = (I) => {
      let E;
      const B = e.onRemove || e.remove;
      Promise.resolve(typeof B == "function" ? B(I) : B).then((k) => {
        var P, R;
        if (k === !1)
          return;
        const D = h5(I, p.value);
        D && (E = h(h({}, I), {
          status: "removed"
        }), (P = p.value) === null || P === void 0 || P.forEach((A) => {
          const H = E.uid !== void 0 ? "uid" : "name";
          A[H] === E[H] && !Object.isFrozen(A) && (A.status = "removed");
        }), (R = b.value) === null || R === void 0 || R.abort(E), y(E, D));
      });
    }, M = (I) => {
      var E;
      g.value = I.type, I.type === "drop" && ((E = e.onDrop) === null || E === void 0 || E.call(e, I));
    };
    r({
      onBatchStart: w,
      onSuccess: C,
      onProgress: $,
      onError: O,
      fileList: p,
      upload: b
    });
    const [_] = Pr("Upload", yo.Upload, T(() => e.locale)), N = (I, E) => {
      const {
        removeIcon: B,
        previewIcon: k,
        downloadIcon: P,
        previewFile: R,
        onPreview: D,
        onDownload: A,
        isImageUrl: H,
        progress: j,
        itemRender: z,
        iconRender: F,
        showUploadList: U
      } = e, {
        showDownloadIcon: Q,
        showPreviewIcon: q,
        showRemoveIcon: oe
      } = typeof U == "boolean" ? {} : U;
      return U ? m(P5, {
        prefixCls: i.value,
        listType: e.listType,
        items: p.value,
        previewFile: R,
        onPreview: D,
        onDownload: A,
        onRemove: x,
        showRemoveIcon: !f.value && oe,
        showPreviewIcon: q,
        showDownloadIcon: Q,
        removeIcon: B,
        previewIcon: k,
        downloadIcon: P,
        iconRender: F,
        locale: _.value,
        isImageUrl: H,
        progress: j,
        itemRender: z,
        appendActionVisible: E,
        appendAction: I
      }, h({}, n)) : I == null ? void 0 : I();
    };
    return () => {
      var I, E, B;
      const {
        listType: k,
        type: P
      } = e, {
        class: R,
        style: D
      } = o, A = F5(o, ["class", "style"]), H = h(h(h({
        onBatchStart: w,
        onError: O,
        onProgress: $,
        onSuccess: C
      }, A), e), {
        id: (I = e.id) !== null && I !== void 0 ? I : a.id.value,
        prefixCls: i.value,
        beforeUpload: S,
        onChange: void 0,
        disabled: f.value
      });
      delete H.remove, (!n.default || f.value) && delete H.id;
      const j = {
        [`${i.value}-rtl`]: l.value === "rtl"
      };
      if (P === "drag") {
        const Q = ae(i.value, {
          [`${i.value}-drag`]: !0,
          [`${i.value}-drag-uploading`]: p.value.some((q) => q.status === "uploading"),
          [`${i.value}-drag-hover`]: g.value === "dragover",
          [`${i.value}-disabled`]: f.value,
          [`${i.value}-rtl`]: l.value === "rtl"
        }, o.class, c.value);
        return s(m("span", L(L({}, o), {}, {
          class: ae(`${i.value}-wrapper`, j, R, c.value)
        }), [m("div", {
          class: Q,
          onDrop: M,
          onDragover: M,
          onDragleave: M,
          style: o.style
        }, [m(qh, L(L({}, H), {}, {
          ref: b,
          class: `${i.value}-btn`
        }), L({
          default: () => [m("div", {
            class: `${i.value}-drag-container`
          }, [(E = n.default) === null || E === void 0 ? void 0 : E.call(n)])]
        }, n))]), N()]));
      }
      const z = ae(i.value, {
        [`${i.value}-select`]: !0,
        [`${i.value}-select-${k}`]: !0,
        [`${i.value}-disabled`]: f.value,
        [`${i.value}-rtl`]: l.value === "rtl"
      }), F = xt((B = n.default) === null || B === void 0 ? void 0 : B.call(n)), U = (Q) => m("div", {
        class: z,
        style: Q
      }, [m(qh, L(L({}, H), {}, {
        ref: b
      }), n)]);
      return s(k === "picture-card" ? m("span", L(L({}, o), {}, {
        class: ae(`${i.value}-wrapper`, `${i.value}-picture-card-wrapper`, j, o.class, c.value)
      }), [N(U, !!(F && F.length))]) : m("span", L(L({}, o), {}, {
        class: ae(`${i.value}-wrapper`, j, o.class, c.value)
      }), [U(F && F.length ? void 0 : {
        display: "none"
      }), N()]));
    };
  }
});
var ob = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const xl = J({
  compatConfig: {
    MODE: 3
  },
  name: "AUploadDragger",
  inheritAttrs: !1,
  props: UC(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    return () => {
      const {
        height: r
      } = e, a = ob(e, ["height"]), {
        style: i
      } = o, l = ob(o, ["style"]), u = h(h(h({}, a), l), {
        type: "drag",
        style: h(h({}, i), {
          height: typeof r == "number" ? `${r}px` : r
        })
      });
      return m(wl, u, n);
    };
  }
}), B5 = xl, k5 = h(wl, {
  Dragger: xl,
  LIST_IGNORE: Wa,
  install(e) {
    return e.component(wl.name, wl), e.component(xl.name, xl), e;
  }
});
var L5 = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M885.2 446.3l-.2-.8-112.2-285.1c-5-16.1-19.9-27.2-36.8-27.2H281.2c-17 0-32.1 11.3-36.9 27.6L139.4 443l-.3.7-.2.8c-1.3 4.9-1.7 9.9-1 14.8-.1 1.6-.2 3.2-.2 4.8V830a60.9 60.9 0 0060.8 60.8h627.2c33.5 0 60.8-27.3 60.9-60.8V464.1c0-1.3 0-2.6-.1-3.7.4-4.9 0-9.6-1.3-14.1zm-295.8-43l-.3 15.7c-.8 44.9-31.8 75.1-77.1 75.1-22.1 0-41.1-7.1-54.8-20.6S436 441.2 435.6 419l-.3-15.7H229.5L309 210h399.2l81.7 193.3H589.4zm-375 76.8h157.3c24.3 57.1 76 90.8 140.4 90.8 33.7 0 65-9.4 90.3-27.2 22.2-15.6 39.5-37.4 50.7-63.6h156.5V814H214.4V480.1z" } }] }, name: "inbox", theme: "outlined" };
function rb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      H5(e, r, n[r]);
    });
  }
  return e;
}
function H5(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Dp = function(t, n) {
  var o = rb({}, t, n.attrs);
  return m(it, rb({}, o, {
    icon: L5
  }), null);
};
Dp.displayName = "InboxOutlined";
Dp.inheritAttrs = !1;
var z5 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M928 224H768v-56c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v56H548v-56c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v56H328v-56c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v56H96c-17.7 0-32 14.3-32 32v576c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V256c0-17.7-14.3-32-32-32zm-40 568H136V296h120v56c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-56h148v56c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-56h148v56c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-56h120v496zM416 496H232c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h184c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zm0 136H232c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h184c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zm308.2-177.4L620.6 598.3l-52.8-73.1c-3-4.2-7.8-6.6-12.9-6.6H500c-6.5 0-10.3 7.4-6.5 12.7l114.1 158.2a15.9 15.9 0 0025.8 0l165-228.7c3.8-5.3 0-12.7-6.5-12.7H737c-5-.1-9.8 2.4-12.8 6.5z" } }] }, name: "schedule", theme: "outlined" };
function ab(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      j5(e, r, n[r]);
    });
  }
  return e;
}
function j5(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Bo = function(t, n) {
  var o = ab({}, t, n.attrs);
  return m(it, ab({}, o, {
    icon: z5
  }), null);
};
Bo.displayName = "ScheduleOutlined";
Bo.inheritAttrs = !1;
var V5 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M400 317.7h73.9V656c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V317.7H624c6.7 0 10.4-7.7 6.3-12.9L518.3 163a8 8 0 00-12.6 0l-112 141.7c-4.1 5.3-.4 13 6.3 13zM878 626h-60c-4.4 0-8 3.6-8 8v154H214V634c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v198c0 17.7 14.3 32 32 32h684c17.7 0 32-14.3 32-32V634c0-4.4-3.6-8-8-8z" } }] }, name: "upload", theme: "outlined" };
function ib(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      W5(e, r, n[r]);
    });
  }
  return e;
}
function W5(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Ap = function(t, n) {
  var o = ib({}, t, n.attrs);
  return m(it, ib({}, o, {
    icon: V5
  }), null);
};
Ap.displayName = "UploadOutlined";
Ap.inheritAttrs = !1;
const K5 = /* @__PURE__ */ J({
  __name: "AutoCompleteInput",
  props: {
    title: {},
    value: {},
    fetchList: { type: [Function, Array] },
    style: {},
    enableSplit: { type: Boolean },
    splitWord: {},
    placeholder: {}
  },
  emits: ["update:value"],
  setup(e, { emit: t }) {
    const n = e, o = t, r = G([]), a = G([]);
    ze(async () => {
      if (n.fetchList) {
        if (n.fetchList instanceof Function) {
          const p = await n.fetchList();
          r.value.push(...p);
        } else
          r.value.push(...n.fetchList);
        a.value = r.value;
      }
    });
    const i = T({
      get() {
        return n.value;
      },
      set(p) {
        o("update:value", p);
      }
    }), l = T(() => n.splitWord || ","), u = T(() => n.title || ""), s = T(() => !!n.enableSplit), c = (p, v) => {
      var b;
      const g = s.value ? (b = v.split(l.value).pop()) == null ? void 0 : b.trim() : v;
      return p.filter(
        (y) => y.value.includes(g || "") && y.value !== g
      );
    }, d = (p) => {
      if (s.value) {
        const v = i.value ? i.value.endsWith(l.value) ? i.value.split(l.value).slice(0, -1) : i.value.split(l.value) : [], g = i.value ? [...v, p].join(l.value) : p;
        i.value = g;
      } else
        i.value = p;
    }, f = (p) => {
      a.value = c(r.value, p);
    };
    return (p, v) => {
      const g = qA;
      return ke(), Ut(g, cn({
        value: i.value,
        "onUpdate:value": v[0] || (v[0] = (b) => i.value = b),
        placeholder: p.placeholder ? p.placeholder : `输入${u.value}内容${s.value ? "（以" + p.splitWord + "分割）" : ""} 或选择已有${u.value}`,
        onSelect: d,
        options: a.value,
        onSearch: f
      }, {
        ...p.$attrs,
        style: n.style
      }), null, 16, ["value", "placeholder", "options"]);
    };
  }
}), U5 = /* @__PURE__ */ J({
  __name: "CustomSwitch",
  props: {
    value: { type: Boolean }
  },
  emits: ["update:value"],
  setup(e, { emit: t }) {
    const n = e, o = t, r = T({
      get() {
        return n.value;
      },
      set(a) {
        o("update:value", a);
      }
    });
    return (a, i) => (ke(), Ut(Ye(oH), cn({
      checked: r.value,
      "onUpdate:checked": i[0] || (i[0] = (l) => r.value = l)
    }, a.$attrs), null, 16, ["checked"]));
  }
}), G5 = /* @__PURE__ */ J({
  __name: "TagShow",
  props: {
    value: {}
  },
  setup(e) {
    const t = e;
    return (n, o) => (ke(), ct("div", null, [
      m(Ye(aa), Sd($d(n.$attrs)), {
        default: ce(() => [
          Se($e(t.value), 1)
        ]),
        _: 1
      }, 16)
    ]));
  }
}), Y5 = /* @__PURE__ */ J({
  __name: "AsyncRadio",
  props: {
    value: {},
    options: { type: [Array, Function] }
  },
  emits: ["update:value"],
  setup(e, { emit: t }) {
    const n = e, o = t, r = T({
      get() {
        return n.value;
      },
      set(s) {
        o("update:value", s);
      }
    }), a = G("加载中...."), i = G([]), l = async () => {
      a.value = "加载中....";
      try {
        if (n.options instanceof Function) {
          const s = await n.options();
          i.value = s;
        } else {
          if (n.options && !Array.isArray(n.options)) {
            console.error(
              "options must be an array or a function that returns an array"
            );
            return;
          }
          i.value = n.options;
        }
      } catch {
        a.value = "数据加载失败";
      }
    };
    ze(async () => {
      if (!n.options) {
        a.value = "暂无数据";
        return;
      }
      await l();
    });
    const u = async () => {
      await l();
    };
    return (s, c) => (ke(), ct("div", null, [
      Ot("span", {
        onClick: u,
        style: { cursor: "pointer", color: "hsla(237deg 74% 33% / 61%)" }
      }, $e(i.value.length > 0 ? "" : a.value), 1),
      m(Ye(qf), cn({
        value: r.value,
        "onUpdate:value": c[0] || (c[0] = (d) => r.value = d)
      }, s.$attrs), {
        default: ce(() => [
          (ke(!0), ct(We, null, qt(i.value, (d) => (ke(), Ut(Ye(un), {
            key: d.value,
            value: d.value
          }, {
            default: ce(() => [
              Se($e(d.label), 1)
            ]),
            _: 2
          }, 1032, ["value"]))), 128))
        ]),
        _: 1
      }, 16, ["value"])
    ]));
  }
}), X5 = /* @__PURE__ */ J({
  __name: "AsyncCheckBox",
  props: {
    value: {},
    options: { type: [Array, Function] }
  },
  emits: ["update:value"],
  setup(e, { emit: t }) {
    const n = e, o = t, r = T({
      get() {
        return n.value;
      },
      set(s) {
        o("update:value", s);
      }
    }), a = G("加载中...."), i = G([]), l = async () => {
      a.value = "加载中....";
      try {
        if (n.options instanceof Function) {
          const s = await n.options();
          i.value = s;
        } else {
          if (n.options && !Array.isArray(n.options)) {
            console.error(
              "options must be an array or a function that returns an array"
            );
            return;
          }
          i.value = n.options;
        }
      } catch {
        a.value = "数据加载失败";
      }
    };
    ze(async () => {
      if (!n.options) {
        a.value = "暂无数据";
        return;
      }
      await l();
    });
    const u = async () => {
      await l();
    };
    return (s, c) => (ke(), ct("div", null, [
      Ot("span", {
        onClick: u,
        style: { cursor: "pointer", color: "hsla(237deg 74% 33% / 61%)" }
      }, $e(i.value.length > 0 ? "" : a.value), 1),
      m(Ye(Ql), cn({
        value: r.value,
        "onUpdate:value": c[0] || (c[0] = (d) => r.value = d)
      }, s.$attrs), {
        default: ce(() => [
          (ke(!0), ct(We, null, qt(i.value, (d) => (ke(), Ut(Ye(oa), {
            key: d.value,
            value: d.value
          }, {
            default: ce(() => [
              Se($e(d.label), 1)
            ]),
            _: 2
          }, 1032, ["value"]))), 128))
        ]),
        _: 1
      }, 16, ["value"])
    ]));
  }
}), q5 = /* @__PURE__ */ J({
  __name: "CustomDivider",
  props: {
    dividerText: {}
  },
  setup(e) {
    const t = e;
    return (n, o) => (ke(), Ut(Ye(ik), Sd($d(n.$attrs)), {
      default: ce(() => [
        Se($e(t.dividerText), 1)
      ]),
      _: 1
    }, 16));
  }
}), Q5 = /* @__PURE__ */ J({
  __name: "CustomAvatarGroup",
  props: {
    avatarGroupValue: {},
    groupProps: {},
    avatarProps: {}
  },
  setup(e) {
    const t = e;
    return (n, o) => (ke(), ct("div", null, [
      m(Ye(Vl), Sd($d(t.groupProps)), {
        default: ce(() => [
          (ke(!0), ct(We, null, qt(t.avatarGroupValue, (r) => (ke(), Ut(Ye(ea), cn({
            key: r.key,
            ref_for: !0
          }, t.avatarProps, {
            src: r.src
          }), {
            default: ce(() => [
              Se($e(r.label), 1)
            ]),
            _: 2
          }, 1040, ["src"]))), 128))
        ]),
        _: 1
      }, 16)
    ]));
  }
}), Z5 = (e) => (pw("data-v-13425e11"), e = e(), vw(), e), J5 = { class: "inner" }, ez = {
  key: 0,
  class: "btn"
}, tz = {
  key: 1,
  class: "image"
}, nz = { class: "ant-upload-text" }, oz = { class: "ant-upload-drag-icon" }, rz = { class: "ant-upload-text" }, az = /* @__PURE__ */ Z5(() => /* @__PURE__ */ Ot("p", { class: "ant-upload-hint" }, "点击这里/将文件拖拽到这里即可自动上传", -1)), iz = /* @__PURE__ */ J({
  __name: "CustomUpload",
  props: {
    value: {},
    msg: {},
    uploadProps: {},
    uploadEvent: {},
    uploadType: { default: "Button" }
  },
  emits: ["update:value"],
  setup(e, { emit: t }) {
    const n = e, o = T(() => n.msg || "上传"), r = t, a = T({
      get() {
        return n.value;
      },
      set(p) {
        r("update:value", p);
      }
    }), i = G(!1), u = {
      Image: (p) => {
        if (p.file.status === "uploading") {
          i.value = !0;
          return;
        }
        p.file.status === "done" && (i.value = !1), p.file.status === "error" && (i.value = !1, bo.error("upload error"));
      },
      Button: () => {
      },
      Dragger: () => {
      }
    }, s = (p) => {
      var v, g, b;
      (v = u[n.uploadType]) == null || v.call(u, p), (b = (g = n.uploadEvent) == null ? void 0 : g.change) == null || b.call(g, p);
    }, d = {
      Image: (p) => {
        const v = p.type === "image/jpeg" || p.type === "image/png";
        v || bo.error("请选择一个图片文件");
        const g = p.size / 1024 / 1024 < 5;
        return g || bo.error("图片需要小于5MB"), v && g;
      },
      Button: () => !0,
      Dragger: () => !0
    }, f = (p, v) => {
      var g, b, y;
      return ((g = d[n.uploadType]) == null ? void 0 : g.call(d, p)) && ((y = (b = n.uploadProps) == null ? void 0 : b.beforeUpload) == null ? void 0 : y.call(b, p, v));
    };
    return (p, v) => {
      const g = Zt, b = k5, y = B5;
      return n.uploadType !== "Dragger" ? (ke(), Ut(b, cn({ key: 0 }, {
        ...p.$attrs,
        ...n.uploadProps,
        beforeUpload: f
      }, Ol({ ...n.uploadEvent, change: s }), {
        fileList: a.value,
        "onUpdate:fileList": v[0] || (v[0] = (S) => a.value = S)
      }), {
        default: ce(() => [
          Ot("div", J5, [
            n.uploadType == "Button" ? (ke(), ct("div", ez, [
              m(g, null, {
                default: ce(() => [
                  m(Ye(Ap)),
                  Se(" " + $e(o.value), 1)
                ]),
                _: 1
              })
            ])) : Vn("", !0),
            n.uploadType == "Image" ? (ke(), ct("div", tz, [
              Ot("div", null, [
                i.value ? (ke(), Ut(Ye(pn), { key: 0 })) : (ke(), Ut(Ye(Ls), { key: 1 })),
                Ot("div", nz, $e(o.value), 1)
              ])
            ])) : Vn("", !0)
          ])
        ]),
        _: 1
      }, 16, ["fileList"])) : (ke(), Ut(y, cn({
        key: 1,
        fileList: a.value,
        "onUpdate:fileList": v[1] || (v[1] = (S) => a.value = S)
      }, {
        ...p.$attrs,
        ...n.uploadProps
      }, Ol({ ...n.uploadEvent })), {
        default: ce(() => [
          Ot("p", oz, [
            m(Ye(Dp))
          ]),
          Ot("p", rz, $e(o.value), 1),
          az
        ]),
        _: 1
      }, 16, ["fileList"]));
    };
  }
}), Np = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [o, r] of t)
    n[o] = r;
  return n;
}, lz = /* @__PURE__ */ Np(iz, [["__scopeId", "data-v-13425e11"]]), sz = {
  Seconds: {
    name: "Seconds",
    every: "Every second",
    interval: ["Every", "second(s) starting at second"],
    specific: "Specific second (choose one or many)",
    cycle: ["Every second between second", "and second"]
  },
  Minutes: {
    name: "Minutes",
    every: "Every minute",
    interval: ["Every", "minute(s) starting at minute"],
    specific: "Specific minute (choose one or many)",
    cycle: ["Every minute between minute", "and minute"]
  },
  Hours: {
    name: "Hours",
    every: "Every hour",
    interval: ["Every", "hour(s) starting at hour"],
    specific: "Specific hour (choose one or many)",
    cycle: ["Every hour between hour", "and hour"]
  },
  Day: {
    name: "Day",
    every: "Every day",
    intervalWeek: ["Every", "day(s) starting on"],
    intervalDay: ["Every", "day(s) starting at the", "of the month"],
    specificWeek: "Specific day of week (choose one or many)",
    specificDay: "Specific day of month (choose one or many)",
    lastDay: "On the last day of the month",
    lastWeekday: "On the last weekday of the month",
    lastWeek: ["On the last", " of the month"],
    beforeEndMonth: ["day(s) before the end of the month"],
    nearestWeekday: ["Nearest weekday (Monday to Friday) to the", "of the month"],
    someWeekday: ["On the", "of the month"]
  },
  Week: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  Month: {
    name: "Month",
    every: "Every month",
    interval: ["Every", "month(s) starting in"],
    specific: "Specific month (choose one or many)",
    cycle: ["Every month between", "and"]
  },
  Year: {
    name: "Year",
    every: "Any year",
    interval: ["Every", "year(s) starting in"],
    specific: "Specific year (choose one or many)",
    cycle: ["Every year between", "and"]
  },
  Save: "Save",
  Close: "Close"
}, uz = {
  Seconds: {
    name: "秒",
    every: "每一秒钟",
    interval: ["每隔", "秒执行 从", "秒开始"],
    specific: "具体秒数(可多选)",
    cycle: ["周期从", "到", "秒"]
  },
  Minutes: {
    name: "分",
    every: "每一分钟",
    interval: ["每隔", "分执行 从", "分开始"],
    specific: "具体分钟数(可多选)",
    cycle: ["周期从", "到", "分"]
  },
  Hours: {
    name: "时",
    every: "每一小时",
    interval: ["每隔", "小时执行 从", "小时开始"],
    specific: "具体小时数(可多选)",
    cycle: ["周期从", "到", "小时"]
  },
  Day: {
    name: "天",
    every: "每一天",
    intervalWeek: ["每隔", "周执行 从", "开始"],
    intervalDay: ["每隔", "天执行 从", "天开始"],
    specificWeek: "具体星期几(可多选)",
    specificDay: "具体天数(可多选)",
    lastDay: "在这个月的最后一天",
    lastWeekday: "在这个月的最后一个工作日",
    lastWeek: ["在这个月的最后一个"],
    beforeEndMonth: ["在本月底前", "天"],
    nearestWeekday: ["最近的工作日（周一至周五）至本月", "日"],
    someWeekday: ["在这个月的第", "个"]
  },
  Week: ["天", "一", "二", "三", "四", "五", "六"].map((e) => "星期" + e),
  Month: {
    name: "月",
    every: "每一月",
    interval: ["每隔", "月执行 从", "月开始"],
    specific: "具体月数(可多选)",
    cycle: ["从", "到", "月之间的每个月"]
  },
  Year: {
    name: "年",
    every: "每一年",
    interval: ["每隔", "年执行 从", "年开始"],
    specific: "具体年份(可多选)",
    cycle: ["从", "到", "年之间的每一年"]
  },
  Save: "保存",
  Close: "关闭"
}, cz = {
  Seconds: {
    name: "Segundos",
    every: "A cada segundo",
    interval: ["A cada", "segundo(s) começando no segundo"],
    specific: "Segundo específico (escolha um ou muitos)",
    cycle: ["A Cada segundo entre segundos", "e segundo"]
  },
  Minutes: {
    name: "Minutos",
    every: "A cada minuto",
    interval: ["A cada", "minuto(s) começando no minuto"],
    specific: "Minuto específico (escolha um ou muitos)",
    cycle: ["A cada minuto entre minutos", "e minutos"]
  },
  Hours: {
    name: "Horas",
    every: "A cada hora",
    interval: ["A cada", "hora(s) começando na hora"],
    specific: "Hora específica (escolha uma ou muitas)",
    cycle: ["A cada hora entre horas", "e horas"]
  },
  Day: {
    name: "Dia",
    every: "A cada dia",
    intervalWeek: ["A cada", "dia(s) começando em"],
    intervalDay: ["A cada", "dia(s) começando no", "do mês"],
    specificWeek: "Dia específico da semana (escolha um ou vários)",
    specificDay: "Dia específico do mês (escolha um ou vários)",
    lastDay: "No último dia do mês",
    lastWeekday: "No último dia da semana do mês",
    lastWeek: ["No último", " do mês"],
    beforeEndMonth: ["dia(s) antes do final do mês"],
    nearestWeekday: ["Dia da semana mais próximo (segunda a sexta) ao ", "do mês"],
    someWeekday: ["No", "do mês"]
  },
  Week: [
    "Domingo",
    "Segunda-feira",
    "Terça-feira",
    "Quarta-feira",
    "Quinta-feira",
    "Sexta-feira",
    "Sábado"
  ],
  Month: {
    name: "Mês",
    every: "A cada mês",
    interval: ["A cada", "mês(es) começando em"],
    specific: "Mês específico (escolha um ou muitos)",
    cycle: ["Todo mês entre", "e"]
  },
  Year: {
    name: "Ano",
    every: "Qualquer ano",
    interval: ["A cada", "ano(s) começando em"],
    specific: "Ano específico (escolha um ou muitos)",
    cycle: ["Todo ano entre", "e"]
  },
  Save: "Salvar",
  Close: "Fechar"
}, dz = {
  en: sz,
  cn: uz,
  pt: cz
}, fz = { id: "changeContab" }, pz = { class: "" }, vz = { class: "tabBody" }, mz = { class: "tabBody" }, gz = { class: "tabBody" }, hz = { class: "tabBody" }, bz = { class: "tabBody" }, yz = { class: "tabBody" }, Sz = { class: "value-warp" }, $z = { class: "value" }, Cz = { class: "btn-wrap" }, wz = /* @__PURE__ */ J({
  __name: "CronSelector",
  props: {
    i18n: {},
    expression: {}
  },
  emits: ["change", "close"],
  setup(e, { emit: t }) {
    const n = e, o = G(n.i18n || "cn"), r = G({
      second: "",
      minute: "",
      hour: "",
      day: "",
      month: "",
      week: "",
      year: ""
    }), a = G([
      { type: "second", expression: "" },
      { type: "minute", expression: "" },
      { type: "hour", expression: "" },
      { type: "day", expression: "" },
      { type: "month", expression: "" },
      { type: "week", expression: "" },
      { type: "year", expression: "" }
    ]), i = G({
      cronEvery: "3",
      incrementStart: 3,
      incrementIncrement: 5,
      rangeStart: 1,
      rangeEnd: 0,
      specificSpecific: [0]
    }), l = G({
      cronEvery: "3",
      incrementStart: 3,
      incrementIncrement: 5,
      rangeStart: 1,
      rangeEnd: 0,
      specificSpecific: [0]
    }), u = G({
      cronEvery: "1",
      incrementStart: 3,
      incrementIncrement: 5,
      rangeStart: "1",
      rangeEnd: 0,
      specificSpecific: []
    }), s = G({
      cronEvery: "1",
      incrementStart: 0,
      incrementIncrement: 0,
      rangeStart: 0,
      rangeEnd: 0,
      specificSpecific: [],
      cronLastSpecificDomDay: 0,
      cronDaysBeforeEomMinus: 0,
      cronDaysNearestweekday: 0
    }), c = G({
      cronEvery: "1",
      incrementStart: 1,
      incrementIncrement: 1,
      specificSpecific: [],
      cronNthDayDay: 1,
      cronNthDayNth: 1,
      cronLastSpecificDomweek: 1
    }), d = G({
      cronEvery: "1",
      incrementStart: 3,
      incrementIncrement: 5,
      rangeStart: 1,
      rangeEnd: 12,
      specificSpecific: []
    }), f = G({
      cronEvery: "1",
      incrementStart: 2018,
      incrementIncrement: 1,
      rangeStart: 2018,
      rangeEnd: 2018,
      specificSpecific: []
    }), p = {
      second: i,
      minute: l,
      hour: u,
      day: s,
      month: d,
      week: c,
      year: f
    }, v = G(dz[n.i18n || "cn"]), g = () => {
      if (!n.expression || !n.expression.length)
        return;
      let I = n.expression.split(" ");
      if (I.length < 7)
        throw new Error("表达式格式不正确");
      for (let E = 0; E < I.length; E++)
        a.value[E].expression = I[E];
      a.value.forEach((E) => {
        switch (r.value[E.type] = E.expression, E.type) {
          case "year":
          case "month":
          case "hour":
          case "minute":
          case "second":
            b(p[E.type], E.expression);
            return;
          case "week":
            y(E.expression);
            return;
          case "day":
            S(E.expression);
            return;
        }
      });
    }, b = (I, E) => {
      E == "*" ? w(I) : E.indexOf("-") >= 0 ? $(I, E) : E.indexOf("/") >= 0 ? C(I, E) : O(I, E);
    }, y = (I) => {
      if (I.indexOf("/") >= 0)
        s.value.cronEvery = "2", C(c, I);
      else if (I.indexOf(",") >= 0)
        s.value.cronEvery = "4", O(c, I);
      else if (/\dL/.test(I))
        s.value.cronEvery = "8", c.value.cronLastSpecificDomweek = Number(
          (I.match(/(\d)L/) || [0, 0])[1]
        );
      else if (I.indexOf("#") >= 0) {
        s.value.cronEvery = "11";
        let E = I.split("#");
        c.value.cronNthDayDay = +E[0], c.value.cronNthDayNth = +E[1];
      }
    }, S = (I) => {
      I == "*" ? w(s) : I.indexOf("/") >= 0 ? C(s, I, "3") : I == "L" ? s.value.cronEvery = "6" : I == "LW" ? s.value.cronEvery = "7" : /L-\d+/.test(I) ? (s.value.cronEvery = "9", s.value.cronDaysBeforeEomMinus = Number(
        (I.match(/L-(\d+)/) || [0, 0])[1]
      )) : /\d+W/.test(I) ? (s.value.cronEvery = "10", s.value.cronDaysNearestweekday = Number(
        (I.match(/(\d+)W/) || [0, 0])[1]
      )) : O(s, I, "5");
    }, w = (I, E = "1") => {
      I.value.cronEvery = E;
    }, C = (I, E, B = "2") => {
      I.value.cronEvery = B;
      let k = E.split("/");
      I.value.incrementStart = Number(k[0]), I.value.incrementIncrement = Number(k[1]);
    }, $ = (I, E, B = "4") => {
      I.value.cronEvery = B;
      let k = E.split("-");
      I.value.rangeStart = Number(k[0]), I.value.rangeEnd = Number(k[1]);
    }, O = (I, E, B = "3") => {
      I.value.cronEvery = B, I.value.specificSpecific = E.split(",").map((k) => Number(k));
    };
    le(
      () => n.expression,
      () => {
        g();
      },
      { immediate: !0, deep: !0 }
    );
    const x = t, M = () => {
      x("change", r.value), _();
    }, _ = () => {
      x("close");
    }, N = T(() => `${i.value.cronEvery} ${i.value.incrementStart}-${i.value.incrementIncrement} ${i.value.rangeStart}-${i.value.rangeEnd} ${i.value.specificSpecific.join(",")} * * *`);
    return (I, E) => {
      const B = Zt, k = un, P = ML, R = hC, D = GA, A = Sn, H = qf, j = ql, z = Qa;
      return ke(), ct("div", fz, [
        m(B, {
          class: "language",
          type: "text",
          onClick: E[0] || (E[0] = (F) => o.value = o.value === "en" ? "cn" : "en")
        }, {
          default: ce(() => [
            Se($e(o.value == "cn" ? "中文" : "English"), 1)
          ]),
          _: 1
        }),
        m(z, { "default-active-key": "second" }, {
          default: ce(() => [
            m(j, { key: "second" }, {
              tab: ce(() => [
                Ot("span", pz, [
                  m(Ye(Bo)),
                  Se(" " + $e(v.value.Seconds.name), 1)
                ])
              ]),
              default: ce(() => [
                m(H, {
                  name: "second",
                  value: i.value.cronEvery,
                  "onUpdate:value": E[6] || (E[6] = (F) => i.value.cronEvery = F)
                }, {
                  default: ce(() => [
                    Ot("div", vz, [
                      m(P, null, {
                        default: ce(() => [
                          m(k, { value: "1" }, {
                            default: ce(() => [
                              Se($e(v.value.Seconds.every), 1)
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      m(P, null, {
                        default: ce(() => [
                          m(k, { value: "2" }, {
                            default: ce(() => [
                              Se($e(v.value.Seconds.interval[0]) + " ", 1),
                              m(R, {
                                value: i.value.incrementIncrement,
                                "onUpdate:value": E[1] || (E[1] = (F) => i.value.incrementIncrement = F),
                                min: 1,
                                max: 60
                              }, null, 8, ["value"]),
                              Se(" " + $e(v.value.Seconds.interval[1] || "") + " ", 1),
                              m(R, {
                                value: i.value.incrementStart,
                                "onUpdate:value": E[2] || (E[2] = (F) => i.value.incrementStart = F),
                                min: 0,
                                max: 59
                              }, null, 8, ["value"]),
                              Se(" " + $e(v.value.Seconds.interval[2] || ""), 1)
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      m(P, null, {
                        default: ce(() => [
                          m(k, {
                            class: "long",
                            value: "3"
                          }, {
                            default: ce(() => [
                              Se($e(v.value.Seconds.specific) + " ", 1),
                              m(A, {
                                mode: "multiple",
                                value: i.value.specificSpecific,
                                "onUpdate:value": E[3] || (E[3] = (F) => i.value.specificSpecific = F)
                              }, {
                                default: ce(() => [
                                  (ke(), ct(We, null, qt(60, (F) => m(D, {
                                    key: F,
                                    value: F - 1
                                  }, {
                                    default: ce(() => [
                                      Se($e(F - 1), 1)
                                    ]),
                                    _: 2
                                  }, 1032, ["value"])), 64))
                                ]),
                                _: 1
                              }, 8, ["value"])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      m(P, null, {
                        default: ce(() => [
                          m(k, { value: "4" }, {
                            default: ce(() => [
                              Se($e(v.value.Seconds.cycle[0]) + " ", 1),
                              m(R, {
                                value: i.value.rangeStart,
                                "onUpdate:value": E[4] || (E[4] = (F) => i.value.rangeStart = F),
                                min: 1,
                                max: 60
                              }, null, 8, ["value"]),
                              Se(" " + $e(v.value.Seconds.cycle[1] || "") + " ", 1),
                              m(R, {
                                value: i.value.rangeEnd,
                                "onUpdate:value": E[5] || (E[5] = (F) => i.value.rangeEnd = F),
                                min: 0,
                                max: 59
                              }, null, 8, ["value"]),
                              Se(" " + $e(v.value.Seconds.cycle[2] || ""), 1)
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ])
                  ]),
                  _: 1
                }, 8, ["value"])
              ]),
              _: 1
            }),
            m(j, { key: "minute" }, {
              tab: ce(() => [
                Ot("span", null, [
                  m(Ye(Bo)),
                  Se(" " + $e(v.value.Minutes.name), 1)
                ])
              ]),
              default: ce(() => [
                m(H, {
                  name: "minute",
                  value: l.value.cronEvery,
                  "onUpdate:value": E[12] || (E[12] = (F) => l.value.cronEvery = F)
                }, {
                  default: ce(() => [
                    Ot("div", mz, [
                      m(P, null, {
                        default: ce(() => [
                          m(k, { value: "1" }, {
                            default: ce(() => [
                              Se($e(v.value.Minutes.every), 1)
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      m(P, null, {
                        default: ce(() => [
                          m(k, { value: "2" }, {
                            default: ce(() => [
                              Se($e(v.value.Minutes.interval[0]) + " ", 1),
                              m(R, {
                                value: l.value.incrementIncrement,
                                "onUpdate:value": E[7] || (E[7] = (F) => l.value.incrementIncrement = F),
                                min: 1,
                                max: 60
                              }, null, 8, ["value"]),
                              Se(" " + $e(v.value.Minutes.interval[1]) + " ", 1),
                              m(R, {
                                value: l.value.incrementStart,
                                "onUpdate:value": E[8] || (E[8] = (F) => l.value.incrementStart = F),
                                min: 0,
                                max: 59
                              }, null, 8, ["value"]),
                              Se(" " + $e(v.value.Minutes.interval[2] || ""), 1)
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      m(P, null, {
                        default: ce(() => [
                          m(k, {
                            class: "long",
                            value: "3"
                          }, {
                            default: ce(() => [
                              Se($e(v.value.Minutes.specific) + " ", 1),
                              m(A, {
                                mode: "multiple",
                                value: l.value.specificSpecific,
                                "onUpdate:value": E[9] || (E[9] = (F) => l.value.specificSpecific = F)
                              }, {
                                default: ce(() => [
                                  (ke(), ct(We, null, qt(60, (F) => m(D, {
                                    key: F,
                                    value: F - 1
                                  }, {
                                    default: ce(() => [
                                      Se($e(F - 1), 1)
                                    ]),
                                    _: 2
                                  }, 1032, ["value"])), 64))
                                ]),
                                _: 1
                              }, 8, ["value"])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      m(P, null, {
                        default: ce(() => [
                          m(k, { value: "4" }, {
                            default: ce(() => [
                              Se($e(v.value.Minutes.cycle[0]) + " ", 1),
                              m(R, {
                                value: l.value.rangeStart,
                                "onUpdate:value": E[10] || (E[10] = (F) => l.value.rangeStart = F),
                                min: 1,
                                max: 60
                              }, null, 8, ["value"]),
                              Se(" " + $e(v.value.Minutes.cycle[1]) + " ", 1),
                              m(R, {
                                value: l.value.rangeEnd,
                                "onUpdate:value": E[11] || (E[11] = (F) => l.value.rangeEnd = F),
                                min: 0,
                                max: 59
                              }, null, 8, ["value"]),
                              Se(" " + $e(v.value.Minutes.cycle[2]), 1)
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ])
                  ]),
                  _: 1
                }, 8, ["value"])
              ]),
              _: 1
            }),
            m(j, { key: "hour" }, {
              tab: ce(() => [
                Ot("span", null, [
                  m(Ye(Bo)),
                  Se(" " + $e(v.value.Hours.name), 1)
                ])
              ]),
              default: ce(() => [
                m(H, {
                  name: "hour",
                  value: u.value.cronEvery,
                  "onUpdate:value": E[18] || (E[18] = (F) => u.value.cronEvery = F)
                }, {
                  default: ce(() => [
                    Ot("div", gz, [
                      m(P, null, {
                        default: ce(() => [
                          m(k, { value: "1" }, {
                            default: ce(() => [
                              Se($e(v.value.Hours.every), 1)
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      m(P, null, {
                        default: ce(() => [
                          m(k, { value: "2" }, {
                            default: ce(() => [
                              Se($e(v.value.Hours.interval[0]) + " ", 1),
                              m(R, {
                                value: u.value.incrementIncrement,
                                "onUpdate:value": E[13] || (E[13] = (F) => u.value.incrementIncrement = F),
                                min: 0,
                                max: 23
                              }, null, 8, ["value"]),
                              Se(" " + $e(v.value.Hours.interval[1]) + " ", 1),
                              m(R, {
                                value: u.value.incrementStart,
                                "onUpdate:value": E[14] || (E[14] = (F) => u.value.incrementStart = F),
                                min: 0,
                                max: 23
                              }, null, 8, ["value"]),
                              Se(" " + $e(v.value.Hours.interval[2]), 1)
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      m(P, null, {
                        default: ce(() => [
                          m(k, {
                            class: "long",
                            value: "3"
                          }, {
                            default: ce(() => [
                              Se($e(v.value.Hours.specific) + " ", 1),
                              m(A, {
                                mode: "multiple",
                                value: u.value.specificSpecific,
                                "onUpdate:value": E[15] || (E[15] = (F) => u.value.specificSpecific = F)
                              }, {
                                default: ce(() => [
                                  (ke(), ct(We, null, qt(24, (F) => m(D, {
                                    key: F,
                                    value: F - 1
                                  }, {
                                    default: ce(() => [
                                      Se($e(F - 1), 1)
                                    ]),
                                    _: 2
                                  }, 1032, ["value"])), 64))
                                ]),
                                _: 1
                              }, 8, ["value"])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      m(P, null, {
                        default: ce(() => [
                          m(k, { value: "4" }, {
                            default: ce(() => [
                              Se($e(v.value.Hours.cycle[0]) + " ", 1),
                              m(R, {
                                value: u.value.rangeStart,
                                "onUpdate:value": E[16] || (E[16] = (F) => u.value.rangeStart = F),
                                min: 0,
                                max: 23
                              }, null, 8, ["value"]),
                              Se(" " + $e(v.value.Hours.cycle[1]) + " ", 1),
                              m(R, {
                                value: u.value.rangeEnd,
                                "onUpdate:value": E[17] || (E[17] = (F) => u.value.rangeEnd = F),
                                min: 0,
                                max: 23
                              }, null, 8, ["value"]),
                              Se(" " + $e(v.value.Hours.cycle[2]), 1)
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ])
                  ]),
                  _: 1
                }, 8, ["value"])
              ]),
              _: 1
            }),
            m(j, { key: "day" }, {
              tab: ce(() => [
                Ot("span", null, [
                  m(Ye(Bo)),
                  Se(" " + $e(v.value.Day.name), 1)
                ])
              ]),
              default: ce(() => [
                m(H, {
                  name: "day",
                  value: s.value.cronEvery,
                  "onUpdate:value": E[30] || (E[30] = (F) => s.value.cronEvery = F)
                }, {
                  default: ce(() => [
                    Ot("div", hz, [
                      m(P, null, {
                        default: ce(() => [
                          m(k, { value: "1" }, {
                            default: ce(() => [
                              Se($e(v.value.Day.every), 1)
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      m(P, null, {
                        default: ce(() => [
                          m(k, { value: "2" }, {
                            default: ce(() => [
                              Se($e(v.value.Day.intervalWeek[0]) + " ", 1),
                              m(R, {
                                value: c.value.incrementIncrement,
                                "onUpdate:value": E[19] || (E[19] = (F) => c.value.incrementIncrement = F),
                                min: 1,
                                max: 7
                              }, null, 8, ["value"]),
                              Se(" " + $e(v.value.Day.intervalWeek[1]) + " ", 1),
                              m(A, {
                                value: c.value.incrementStart,
                                "onUpdate:value": E[20] || (E[20] = (F) => c.value.incrementStart = F)
                              }, {
                                default: ce(() => [
                                  (ke(), ct(We, null, qt(7, (F) => m(D, {
                                    key: F,
                                    value: F
                                  }, {
                                    default: ce(() => [
                                      Se($e(v.value.Week[F - 1]), 1)
                                    ]),
                                    _: 2
                                  }, 1032, ["value"])), 64))
                                ]),
                                _: 1
                              }, 8, ["value"]),
                              Se(" " + $e(v.value.Day.intervalWeek[2]), 1)
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      m(P, null, {
                        default: ce(() => [
                          m(k, { value: "3" }, {
                            default: ce(() => [
                              Se($e(v.value.Day.intervalDay[0]) + " ", 1),
                              m(R, {
                                value: s.value.incrementIncrement,
                                "onUpdate:value": E[21] || (E[21] = (F) => s.value.incrementIncrement = F),
                                min: 1,
                                max: 31
                              }, null, 8, ["value"]),
                              Se(" " + $e(v.value.Day.intervalDay[1]) + " ", 1),
                              m(R, {
                                value: s.value.incrementStart,
                                "onUpdate:value": E[22] || (E[22] = (F) => s.value.incrementStart = F),
                                min: 1,
                                max: 31
                              }, null, 8, ["value"]),
                              Se(" " + $e(v.value.Day.intervalDay[2]), 1)
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      m(P, null, {
                        default: ce(() => [
                          m(k, {
                            class: "long",
                            value: "4"
                          }, {
                            default: ce(() => [
                              Se($e(v.value.Day.specificWeek) + " ", 1),
                              m(A, {
                                mode: "multiple",
                                value: c.value.specificSpecific,
                                "onUpdate:value": E[23] || (E[23] = (F) => c.value.specificSpecific = F)
                              }, {
                                default: ce(() => [
                                  (ke(), ct(We, null, qt(7, (F) => m(D, {
                                    key: F,
                                    value: [
                                      "SUN",
                                      "MON",
                                      "TUE",
                                      "WED",
                                      "THU",
                                      "FRI",
                                      "SAT"
                                    ][F - 1]
                                  }, {
                                    default: ce(() => [
                                      Se($e(v.value.Week[F - 1]), 1)
                                    ]),
                                    _: 2
                                  }, 1032, ["value"])), 64))
                                ]),
                                _: 1
                              }, 8, ["value"])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      m(P, null, {
                        default: ce(() => [
                          m(k, {
                            class: "long",
                            value: "5"
                          }, {
                            default: ce(() => [
                              Se($e(v.value.Day.specificDay) + " ", 1),
                              m(A, {
                                mode: "multiple",
                                value: s.value.specificSpecific,
                                "onUpdate:value": E[24] || (E[24] = (F) => s.value.specificSpecific = F)
                              }, {
                                default: ce(() => [
                                  (ke(), ct(We, null, qt(31, (F) => m(D, {
                                    key: F,
                                    value: F
                                  }, {
                                    default: ce(() => [
                                      Se($e(F), 1)
                                    ]),
                                    _: 2
                                  }, 1032, ["value"])), 64))
                                ]),
                                _: 1
                              }, 8, ["value"])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      m(P, null, {
                        default: ce(() => [
                          m(k, { value: "6" }, {
                            default: ce(() => [
                              Se($e(v.value.Day.lastDay), 1)
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      m(P, null, {
                        default: ce(() => [
                          m(k, { value: "7" }, {
                            default: ce(() => [
                              Se($e(v.value.Day.lastWeekday), 1)
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      m(P, null, {
                        default: ce(() => [
                          m(k, { value: "8" }, {
                            default: ce(() => [
                              Se($e(v.value.Day.lastWeek[0]) + " ", 1),
                              m(A, {
                                value: c.value.cronLastSpecificDomweek,
                                "onUpdate:value": E[25] || (E[25] = (F) => c.value.cronLastSpecificDomweek = F)
                              }, {
                                default: ce(() => [
                                  (ke(), ct(We, null, qt(7, (F) => m(D, {
                                    key: F,
                                    value: F
                                  }, {
                                    default: ce(() => [
                                      Se($e(v.value.Week[F - 1]), 1)
                                    ]),
                                    _: 2
                                  }, 1032, ["value"])), 64))
                                ]),
                                _: 1
                              }, 8, ["value"]),
                              Se(" " + $e(v.value.Day.lastWeek[1] || ""), 1)
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      m(P, null, {
                        default: ce(() => [
                          m(k, { value: "9" }, {
                            default: ce(() => [
                              m(R, {
                                value: s.value.cronDaysBeforeEomMinus,
                                "onUpdate:value": E[26] || (E[26] = (F) => s.value.cronDaysBeforeEomMinus = F),
                                min: 1,
                                max: 31
                              }, null, 8, ["value"]),
                              Se(" " + $e(v.value.Day.beforeEndMonth[0]), 1)
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      m(P, null, {
                        default: ce(() => [
                          m(k, { value: "10" }, {
                            default: ce(() => [
                              Se($e(v.value.Day.nearestWeekday[0]) + " ", 1),
                              m(R, {
                                value: s.value.cronDaysNearestweekday,
                                "onUpdate:value": E[27] || (E[27] = (F) => s.value.cronDaysNearestweekday = F),
                                min: 1,
                                max: 31
                              }, null, 8, ["value"]),
                              Se(" " + $e(v.value.Day.nearestWeekday[1]), 1)
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      m(P, null, {
                        default: ce(() => [
                          m(k, { value: "11" }, {
                            default: ce(() => [
                              Se($e(v.value.Day.someWeekday[0]) + " ", 1),
                              m(R, {
                                value: c.value.cronNthDayNth,
                                "onUpdate:value": E[28] || (E[28] = (F) => c.value.cronNthDayNth = F),
                                min: 1,
                                max: 5
                              }, null, 8, ["value"]),
                              m(A, {
                                value: c.value.cronNthDayDay,
                                "onUpdate:value": E[29] || (E[29] = (F) => c.value.cronNthDayDay = F)
                              }, {
                                default: ce(() => [
                                  (ke(), ct(We, null, qt(7, (F) => m(D, {
                                    key: F,
                                    value: F
                                  }, {
                                    default: ce(() => [
                                      Se($e(v.value.Week[F - 1]), 1)
                                    ]),
                                    _: 2
                                  }, 1032, ["value"])), 64))
                                ]),
                                _: 1
                              }, 8, ["value"]),
                              Se(" " + $e(v.value.Day.someWeekday[1]), 1)
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ])
                  ]),
                  _: 1
                }, 8, ["value"])
              ]),
              _: 1
            }),
            m(j, { key: "month" }, {
              tab: ce(() => [
                m(Ye(Bo)),
                Se(" " + $e(v.value.Month.name), 1)
              ]),
              default: ce(() => [
                m(H, {
                  name: "month",
                  value: d.value.cronEvery,
                  "onUpdate:value": E[36] || (E[36] = (F) => d.value.cronEvery = F)
                }, {
                  default: ce(() => [
                    Ot("div", bz, [
                      m(P, null, {
                        default: ce(() => [
                          m(k, { value: "1" }, {
                            default: ce(() => [
                              Se($e(v.value.Month.every), 1)
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      m(P, null, {
                        default: ce(() => [
                          m(k, { value: "2" }, {
                            default: ce(() => [
                              Se($e(v.value.Month.interval[0]) + " ", 1),
                              m(R, {
                                value: d.value.incrementIncrement,
                                "onUpdate:value": E[31] || (E[31] = (F) => d.value.incrementIncrement = F),
                                min: 0,
                                max: 12
                              }, null, 8, ["value"]),
                              Se(" " + $e(v.value.Month.interval[1]) + " ", 1),
                              m(R, {
                                value: d.value.incrementStart,
                                "onUpdate:value": E[32] || (E[32] = (F) => d.value.incrementStart = F),
                                min: 0,
                                max: 12
                              }, null, 8, ["value"])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      m(P, null, {
                        default: ce(() => [
                          m(k, {
                            class: "long",
                            value: "3"
                          }, {
                            default: ce(() => [
                              Se($e(v.value.Month.specific) + " ", 1),
                              m(A, {
                                mode: "multiple",
                                value: d.value.specificSpecific,
                                "onUpdate:value": E[33] || (E[33] = (F) => d.value.specificSpecific = F)
                              }, {
                                default: ce(() => [
                                  (ke(), ct(We, null, qt(12, (F) => m(D, {
                                    key: F,
                                    value: F
                                  }, {
                                    default: ce(() => [
                                      Se($e(F), 1)
                                    ]),
                                    _: 2
                                  }, 1032, ["value"])), 64))
                                ]),
                                _: 1
                              }, 8, ["value"])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      m(P, null, {
                        default: ce(() => [
                          m(k, { value: "4" }, {
                            default: ce(() => [
                              Se($e(v.value.Month.cycle[0]) + " ", 1),
                              m(R, {
                                value: d.value.rangeStart,
                                "onUpdate:value": E[34] || (E[34] = (F) => d.value.rangeStart = F),
                                min: 1,
                                max: 12
                              }, null, 8, ["value"]),
                              Se(" " + $e(v.value.Month.cycle[1]) + " ", 1),
                              m(R, {
                                value: d.value.rangeEnd,
                                "onUpdate:value": E[35] || (E[35] = (F) => d.value.rangeEnd = F),
                                min: 1,
                                max: 12
                              }, null, 8, ["value"])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ])
                  ]),
                  _: 1
                }, 8, ["value"])
              ]),
              _: 1
            }),
            m(j, { key: "year" }, {
              tab: ce(() => [
                m(Ye(Bo)),
                Se(" " + $e(v.value.Year.name), 1)
              ]),
              default: ce(() => [
                m(H, {
                  name: "year",
                  value: f.value.cronEvery,
                  "onUpdate:value": E[42] || (E[42] = (F) => f.value.cronEvery = F)
                }, {
                  default: ce(() => [
                    Ot("div", yz, [
                      m(P, null, {
                        default: ce(() => [
                          m(k, { value: "1" }, {
                            default: ce(() => [
                              Se($e(v.value.Year.every), 1)
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      m(P, null, {
                        default: ce(() => [
                          m(k, { value: "2" }, {
                            default: ce(() => [
                              Se($e(v.value.Year.interval[0]) + " ", 1),
                              m(R, {
                                value: f.value.incrementIncrement,
                                "onUpdate:value": E[37] || (E[37] = (F) => f.value.incrementIncrement = F),
                                min: 1,
                                max: 99
                              }, null, 8, ["value"]),
                              Se(" " + $e(v.value.Year.interval[1]) + " ", 1),
                              m(R, {
                                value: f.value.incrementStart,
                                "onUpdate:value": E[38] || (E[38] = (F) => f.value.incrementStart = F),
                                min: 2018,
                                max: 2218
                              }, null, 8, ["value"])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      m(P, null, {
                        default: ce(() => [
                          m(k, {
                            class: "long",
                            value: "3"
                          }, {
                            default: ce(() => [
                              Se($e(v.value.Year.specific) + " ", 1),
                              m(A, {
                                mode: "multiple",
                                value: f.value.specificSpecific,
                                "onUpdate:value": E[39] || (E[39] = (F) => f.value.specificSpecific = F)
                              }, {
                                default: ce(() => [
                                  (ke(), ct(We, null, qt(200, (F) => m(D, {
                                    key: F,
                                    value: 2017 + F
                                  }, {
                                    default: ce(() => [
                                      Se($e(2017 + F), 1)
                                    ]),
                                    _: 2
                                  }, 1032, ["value"])), 64))
                                ]),
                                _: 1
                              }, 8, ["value"])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      }),
                      m(P, null, {
                        default: ce(() => [
                          m(k, { value: "4" }, {
                            default: ce(() => [
                              Se($e(v.value.Year.cycle[0]) + " ", 1),
                              m(R, {
                                value: f.value.rangeStart,
                                "onUpdate:value": E[40] || (E[40] = (F) => f.value.rangeStart = F),
                                min: 2018,
                                max: 2218
                              }, null, 8, ["value"]),
                              Se(" " + $e(v.value.Year.cycle[1]) + " ", 1),
                              m(R, {
                                value: f.value.rangeEnd,
                                "onUpdate:value": E[41] || (E[41] = (F) => f.value.rangeEnd = F),
                                min: 2018,
                                max: 2218
                              }, null, 8, ["value"])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })
                    ])
                  ]),
                  _: 1
                }, 8, ["value"])
              ]),
              _: 1
            })
          ]),
          _: 1
        }),
        Ot("div", Sz, [
          Ot("span", $z, $e(N.value), 1)
        ]),
        Ot("div", Cz, [
          m(B, { onClick: _ }, {
            default: ce(() => [
              Se($e(v.value.Close), 1)
            ]),
            _: 1
          }),
          m(B, {
            type: "primary",
            onClick: M
          }, {
            default: ce(() => [
              Se($e(v.value.Save), 1)
            ]),
            _: 1
          })
        ])
      ]);
    };
  }
}), xz = /* @__PURE__ */ J({
  __name: "CronInput",
  props: {
    value: {}
  },
  emits: ["update:value"],
  setup(e, { emit: t }) {
    const n = e, o = t, r = T({
      get: () => n.value || "",
      set: (s) => {
        o("update:value", s);
      }
    }), a = G(!1), i = () => {
      a.value = !0;
    }, l = (s) => {
      console.log("change", s), r.value = `${s.second} ${s.minute} ${s.hour} ${s.day} ${s.month} ${s.Week}`;
    }, u = () => {
      console.log("close"), a.value = !1;
    };
    return (s, c) => {
      const d = At, f = fn;
      return ke(), ct("div", null, [
        m(d, {
          value: r.value,
          "onUpdate:value": c[0] || (c[0] = (p) => r.value = p),
          style: { width: "350px" }
        }, {
          addonAfter: ce(() => [
            Ot("span", {
              type: "primary",
              onClick: i,
              style: { cursor: "pointer" }
            }, "显示cron")
          ]),
          _: 1
        }, 8, ["value"]),
        m(f, {
          title: "corn 表达式",
          open: a.value,
          "onUpdate:open": c[1] || (c[1] = (p) => a.value = p),
          footer: null,
          width: "800px",
          destroyOnClose: ""
        }, {
          default: ce(() => [
            m(wz, {
              i18n: "cn",
              expression: r.value,
              onChange: l,
              onClose: u
            }, null, 8, ["expression"])
          ]),
          _: 1
        }, 8, ["open"])
      ]);
    };
  }
}), Oz = /* @__PURE__ */ J({
  __name: "AsyncSelect",
  props: {
    modelValue: {},
    options: { type: [Array, Function] }
  },
  setup(e, { emit: t }) {
    const n = e, o = t, r = G([]), a = T({
      get() {
        return n.modelValue;
      },
      set(u) {
        o("update:modelValue", u);
      }
    }), i = G(!1), l = async () => {
      i.value = !0;
      try {
        if (n.options instanceof Function) {
          const u = await n.options();
          r.value = u;
        } else {
          if (n.options && !Array.isArray(n.options)) {
            console.error(
              "options must be an array or a function that returns an array"
            );
            return;
          }
          r.value = n.options || [];
        }
      } catch (u) {
        console.error(u);
      }
      i.value = !1;
    };
    return ze(() => {
      l();
    }), (u, s) => (ke(), Ut(Ye(Sn), cn({
      value: a.value,
      onChange: s[0] || (s[0] = (c) => a.value = c),
      loading: i.value,
      options: r.value
    }, u.$attrs), null, 16, ["value", "loading", "options"]));
  }
}), Pz = /* @__PURE__ */ J({
  __name: "AsyncTreeSelect",
  props: {
    modelValue: {},
    treeData: { type: [Array, Function] }
  },
  setup(e, { emit: t }) {
    const n = e, o = t, r = G([]), a = T({
      get() {
        return n.modelValue;
      },
      set(u) {
        o("update:modelValue", u);
      }
    }), i = G(!1), l = async () => {
      i.value = !0;
      try {
        if (!n.treeData) {
          console.error("options must not be empty");
          return;
        }
        if (n.treeData instanceof Function) {
          const u = await n.treeData();
          r.value = u || [];
        } else {
          if (n.treeData && !Array.isArray(n.treeData)) {
            console.error(
              "options must be an array or a function that returns an array"
            );
            return;
          }
          r.value = n.treeData || [];
        }
      } catch (u) {
        console.error(u);
      }
      i.value = !1;
    };
    return ze(() => {
      l();
    }), (u, s) => (ke(), Ut(Ye(ZH), cn({
      value: a.value,
      onChange: s[0] || (s[0] = (c) => a.value = c),
      loading: i.value,
      treeData: r.value
    }, u.$attrs), null, 16, ["value", "loading", "treeData"]));
  }
}), lb = Et({
  Text: {
    component: Dt(At)
  },
  Password: {
    component: Dt(At),
    defaultProps: {
      type: "password"
    }
  },
  Textarea: {
    component: Dt(vC)
  },
  Number: {
    component: Dt(hC)
  },
  Select: {
    component: Dt(Oz)
  },
  Radio: {
    component: Dt(Y5)
  },
  Checkbox: {
    component: Dt(X5)
  },
  DatePicker: {
    component: Dt(tk)
  },
  Rate: {
    component: Dt(EL)
  },
  Slider: {
    component: Dt(GL)
  },
  Switch: {
    component: Dt(U5)
  },
  Upload: {
    component: Dt(lz)
  },
  TreeSelect: {
    component: Dt(Pz)
  },
  TimePicker: {
    component: Dt(e5)
  },
  AutoComplete: {
    component: Dt(K5)
  },
  Tag: {
    component: Dt(G5)
  },
  Mentions: {
    component: Dt(D8)
  },
  Divider: {
    component: Dt(q5)
  },
  AvatarGroup: {
    component: Dt(Q5)
  },
  Corn: {
    component: Dt(xz)
  }
}), Iz = {
  class: "title",
  style: { display: "flex", "justify-content": "center", "margin-bottom": "15px", "align-items": "center" }
}, Tz = {
  key: 0,
  style: { display: "flex", "justify-content": "center" }
}, Ez = {
  name: "dynamic-form"
}, Mz = /* @__PURE__ */ J({
  ...Ez,
  props: {
    schema: {},
    modelValue: {},
    showBtns: { type: [Boolean, Object] },
    registeToParent: { type: Function },
    unRegisteFromParent: { type: Function },
    disabled: { type: Boolean },
    onBeforeSubmit: { type: Function },
    onSubmit: { type: Function },
    onAfterSubmit: { type: Function }
  },
  emits: ["update:modelValue"],
  setup(e, { expose: t, emit: n }) {
    const o = e, r = T(() => typeof o.showBtns == "boolean" ? o.showBtns ? {
      clearAll: 0,
      reset: 1,
      submit: 1
    } : null : o.showBtns ? o.showBtns : {
      clearAll: 0,
      reset: 1,
      submit: 1
    }), a = G(null), i = On(), l = G({}), u = G([]);
    ze(() => {
      o.registeToParent && i && o.registeToParent(i);
    }), Xo(() => {
      o.unRegisteFromParent && i && o.unRegisteFromParent(i);
    });
    const s = (_) => {
      u.value.push(_);
    }, c = (_) => {
      const N = u.value.findIndex((I) => I.uid == _.uid);
      N > -1 && u.value.splice(N, 1);
    }, d = n, f = T({
      get: () => o.modelValue,
      set: (_) => {
        d("update:modelValue", _);
      }
    }), p = () => {
      const _ = o.schema.items.reduce(
        (N, I) => N[I.field] ? {} : (N[I.field] = I.value, N),
        {}
      );
      f.value = { ...f.value, ..._ };
    };
    gd(() => {
    }), ze(() => {
      p(), y.value = o.schema.items.some((_) => _.next);
    });
    const v = () => new Promise((_, N) => {
      var I;
      (I = a.value) == null || I.validateFields().then((E) => {
        _(E);
      }).catch((E) => N(E));
    }), g = (_ = !0) => {
      const N = o.schema.items.reduce(
        (I, E) => I[E.field] ? {} : (I[E.field] = _ ? void 0 : E.value, I),
        {}
      );
      f.value = { ...f.value, ...N };
    }, b = mw(() => Promise.resolve().then(() => _z)), y = G(!1), S = T(
      () => (_, N) => w.value(_, N).items.length > 0
    ), w = T(
      () => (_, N) => {
        var I;
        return ((I = N.next) == null ? void 0 : I.call(N, _)) || { title: "", items: [] };
      }
    ), C = G(!1), $ = async () => {
      var _, N, I, E, B;
      C.value = !0, (_ = o.onBeforeSubmit) == null || _.call(o, f.value);
      try {
        const k = await M();
        await ((I = (N = o.schema).onSubmit) == null ? void 0 : I.call(N, k)), await ((E = o.onSubmit) == null ? void 0 : E.call(o, f.value));
      } catch (k) {
        console.error("在数据提交时发生错误：", k), bo.error("操作失败");
      } finally {
        C.value = !1, (B = o.onAfterSubmit) == null || B.call(o, f.value);
      }
    }, O = () => {
      g(!1);
    }, x = () => {
      g();
    }, M = async () => {
      var N;
      const _ = await v();
      for (let I of u.value)
        await ((N = I.exposed) == null ? void 0 : N.validateThenGetModel());
      return _.next = l.value, _;
    };
    return le(
      () => l.value,
      (_) => {
        f.value.next = _;
      },
      {
        deep: !0,
        immediate: !0
      }
    ), le(
      () => f.value.next,
      (_) => {
        _ && (l.value = _);
      }
    ), t({
      validateFields: v,
      resetFields: g,
      validateThenGetModel: M
    }), (_, N) => {
      const I = E$, E = Zt, B = Lo;
      return ke(), ct("div", null, [
        Ot("div", Iz, $e(o.schema.title), 1),
        m(B, cn({
          ref_key: "formRef",
          ref: a,
          model: f.value
        }, { ..._.$attrs, ...o.schema.formProps }, {
          disabled: C.value || o.disabled,
          class: o.schema.className || "dynamic-form"
        }, Ol({ ...o.schema.formEvent, onNull: () => {
        } })), {
          default: ce(() => {
            var k, P, R;
            return [
              (ke(!0), ct(We, null, qt(o.schema.items, (D) => {
                var A;
                return An((ke(), ct("div", {
                  class: "items",
                  key: D.field
                }, [
                  m(I, cn({
                    name: D.field,
                    label: D.label,
                    ref_for: !0
                  }, D.formItemProps, {
                    class: ((A = D.formItemProps) == null ? void 0 : A.className) || "dynamic-form-item"
                  }), {
                    default: ce(() => {
                      var H, j, z, F;
                      return [
                        (ke(), Ut(gw(
                          typeof D.component == "string" ? (H = Ye(lb)[D.component]) == null ? void 0 : H.component : D.component
                        ), cn({ ref_for: !0 }, {
                          ...D.componentProps,
                          ...typeof D.component == "string" ? (j = Ye(lb)[D.component]) == null ? void 0 : j.defaultProps : (z = D.componentProps) == null ? void 0 : z.customProps
                        }, {
                          value: f.value[D.field],
                          "onUpdate:value": (U) => f.value[D.field] = U,
                          class: ((F = D.componentProps) == null ? void 0 : F.className) || "dynamic-form-component"
                        }, Ol({ ...D.componentEvent, onNull: () => {
                        } }), {
                          disabled: o.disabled || C.value
                        }), null, 16, ["value", "onUpdate:value", "class", "disabled"]))
                      ];
                    }),
                    _: 2
                  }, 1040, ["name", "label", "class"]),
                  y.value ? (ke(), ct("div", {
                    key: 0,
                    class: "subForms",
                    style: qr(D.nextFormStyle || {})
                  }, [
                    S.value(f.value[D.field], D) ? (ke(), Ut(Ye(b), {
                      key: 0,
                      schema: w.value(f.value[D.field], D),
                      modelValue: l.value,
                      "onUpdate:modelValue": N[0] || (N[0] = (H) => l.value = H),
                      "registe-to-parent": s,
                      "un-registe-from-parent": c,
                      disabled: o.disabled || C.value,
                      "show-btns": {
                        clearAll: 0,
                        reset: 0,
                        submit: 0
                      }
                    }, null, 8, ["schema", "modelValue", "disabled"])) : Vn("", !0)
                  ], 4)) : Vn("", !0)
                ])), [
                  [wo, D.onShow ? D.onShow(f.value) : !0]
                ]);
              }), 128)),
              r.value ? (ke(), ct("div", Tz, [
                (k = r.value) != null && k.clearAll ? (ke(), Ut(E, {
                  key: 0,
                  onClick: x
                }, {
                  default: ce(() => [
                    Se("清空")
                  ]),
                  _: 1
                })) : Vn("", !0),
                (P = r.value) != null && P.reset ? (ke(), Ut(E, {
                  key: 1,
                  style: { "margin-left": "50px" },
                  onClick: O
                }, {
                  default: ce(() => [
                    Se("重置")
                  ]),
                  _: 1
                })) : Vn("", !0),
                (R = r.value) != null && R.submit ? (ke(), Ut(E, {
                  key: 2,
                  type: "primary",
                  style: { "margin-left": "50px" },
                  onClick: $,
                  loading: o.disabled || C.value
                }, {
                  default: ce(() => [
                    Se("提交")
                  ]),
                  _: 1
                }, 8, ["loading"])) : Vn("", !0)
              ])) : Vn("", !0),
              o.schema.customBtns && o.schema.customBtns.length > 0 ? (ke(), ct("div", {
                key: 1,
                class: "custombtns",
                style: qr({
                  display: "flex",
                  justifyContent: "center",
                  marginTop: "20px",
                  gap: "20px",
                  ...o.schema.customBtnsStyle
                })
              }, [
                (ke(!0), ct(We, null, qt(o.schema.customBtns, (D) => (ke(), ct("div", {
                  key: D.text,
                  style: qr({
                    display: "inline",
                    justifyContent: "center",
                    ...D.outterStyle
                  })
                }, [
                  m(E, cn({
                    onClick: () => {
                      var A;
                      (A = D.onClick) == null || A.call(D, f.value);
                    },
                    ref_for: !0
                  }, D.props, {
                    style: {
                      ...D.style
                    }
                  }), {
                    default: ce(() => [
                      Se($e(D.text), 1)
                    ]),
                    _: 2
                  }, 1040, ["onClick", "style"])
                ], 4))), 128))
              ], 4)) : Vn("", !0)
            ];
          }),
          _: 1
        }, 16, ["model", "disabled", "class"])
      ]);
    };
  }
}), oi = /* @__PURE__ */ Np(Mz, [["__scopeId", "data-v-a8712d50"]]), _z = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: oi
}, Symbol.toStringTag, { value: "Module" })), Dz = { class: "fullscreen" }, Az = {
  key: 0,
  class: "btns"
}, Nz = /* @__PURE__ */ J({
  __name: "FullScreenDyForm",
  props: {
    schema: {},
    showBtns: { type: [Object, Boolean] },
    init: {},
    onCancel: { type: Function },
    allowDirectClose: { type: Boolean },
    onSubmit: { type: Function },
    style: {},
    draggable: { type: Boolean },
    title: {},
    fadeInOut: { type: Boolean },
    fadeTime: {},
    mousePosition: {},
    goClose: {},
    customBtns: {},
    showCloseBtn: { type: Boolean }
  },
  setup(e) {
    const t = e, n = G({}), o = G(!1), r = G(t.schema);
    ze(() => {
      Object.keys(t.init).length > 0 && (n.value = { ...t.init }), t.title && (r.value.title = t.title);
    });
    const a = () => {
      t.allowDirectClose ? t.onCancel() : fn.confirm({
        title: "确认关闭",
        content: "关闭后将不会保存当前数据，是否继续？",
        onOk: () => {
          t.onCancel();
        },
        okText: "确认关闭",
        okType: "primary",
        okButtonProps: { danger: !0 },
        cancelText: "返回",
        zIndex: 1e4,
        centered: !0
      });
    }, i = () => {
      o.value = !0;
    }, l = () => {
      o.value = !1;
    }, u = {
      mounted(p) {
        if (!t.draggable)
          return;
        let v = p;
        const g = (b) => {
          const y = {
            x: v.getBoundingClientRect().x,
            y: v.getBoundingClientRect().y
          }, S = {
            x: b.clientX,
            y: b.clientY
          }, w = {
            width: v.getBoundingClientRect().width,
            height: v.getBoundingClientRect().height
          }, C = ($) => {
            v.style.cursor = "move";
            const O = {
              x: $.clientX - S.x,
              y: $.clientY - S.y
            }, x = {
              x: y.x + O.x,
              y: y.y + O.y
            };
            x.x < 15 || x.y < 15 || x.x + w.width > window.innerWidth - 30 || x.y + w.height > window.innerHeight - 15 || (v.style.left = x.x + "px", v.style.top = x.y + "px");
          };
          document.addEventListener("mousemove", C), document.addEventListener("mouseup", () => {
            v.style.cursor = "default", document.removeEventListener("mousemove", C);
          });
        };
        v.style.position = "absolute", v.addEventListener("mousedown", g);
      },
      // 取消挂载时注销事件
      unmounted(p) {
        if (!t.draggable)
          return;
        p.removeEventListener("mousedown", () => {
        });
      }
    };
    let s = null;
    const c = {
      mounted(p, v) {
        s = p;
        const g = v.value;
        g.enable && (p.style.opacity = "0", setTimeout(() => {
          p.style.transition = "opacity " + g.fadeTime + "ms ease", p.style.opacity = "1";
        }, 10));
      }
    };
    let d = null;
    const f = {
      mounted(p, v) {
        d = p;
        const g = v.value;
        if (!g.enable)
          return;
        if (p.style.scale = "0.2", !t.mousePosition) {
          p.style.transformOrigin = "center";
          return;
        }
        const b = p.getBoundingClientRect(), y = t.mousePosition.x - b.left, S = t.mousePosition.y - b.top;
        p.style.transformOrigin = `${y}px ${S}px`, setTimeout(() => {
          p.style.transition = "scale " + g.fadeTime + "ms ease", p.style.scale = "1";
        }, 10);
      }
    };
    return le(
      () => t.goClose.value,
      (p) => {
        p && (s && (s.style.opacity = "0"), d && (d.style.scale = "0.2"));
      }
    ), (p, v) => An((ke(), ct("div", Dz, [
      An((ke(), ct("div", {
        class: "full-form",
        style: qr({
          ...t.style
        })
      }, [
        m(oi, {
          schema: r.value,
          modelValue: n.value,
          "onUpdate:modelValue": v[0] || (v[0] = (g) => n.value = g),
          "show-btns": t.showBtns,
          class: "form",
          "on-before-submit": i,
          "on-submit": t.onSubmit,
          "on-after-submit": l
        }, null, 8, ["schema", "modelValue", "show-btns", "on-submit"]),
        t.showCloseBtn ? (ke(), ct("div", Az, [
          m(Ye(Zt), {
            shape: "circle",
            type: "primary",
            danger: "",
            onClick: a,
            disabled: o.value
          }, {
            default: ce(() => [
              m(Ye(Qn))
            ]),
            _: 1
          }, 8, ["disabled"])
        ])) : Vn("", !0),
        t.customBtns && t.customBtns.length > 0 ? (ke(), ct("div", {
          key: 1,
          class: "custombtns",
          style: qr({
            display: "flex",
            justifyContent: "center",
            marginTop: "20px",
            gap: "20px",
            ...r.value.customBtnsStyle
          })
        }, [
          (ke(!0), ct(We, null, qt(t.customBtns, (g) => (ke(), ct("div", {
            key: g.text,
            style: qr({
              display: "inline",
              justifyContent: "center",
              ...g.outterStyle
            })
          }, [
            m(Ye(Zt), cn({
              onClick: () => {
                var b;
                (b = g.onClick) == null || b.call(g, n.value, t.onCancel);
              },
              ref_for: !0
            }, g.props, {
              style: {
                ...g.style
              }
            }), {
              default: ce(() => [
                Se($e(g.text), 1)
              ]),
              _: 2
            }, 1040, ["onClick", "style"])
          ], 4))), 128))
        ], 4)) : Vn("", !0)
      ], 4)), [
        [u],
        [f, {
          fadeTime: t.fadeTime || 150,
          enable: t.fadeInOut || !0
        }]
      ])
    ])), [
      [c, {
        fadeTime: t.fadeTime || 150,
        enable: t.fadeInOut || !0
      }]
    ]);
  }
});
let md = null;
const Rz = (e) => {
  md = {
    x: e.pageX,
    y: e.pageY
  }, setTimeout(() => md = null, 100);
};
typeof window < "u" && window.document && window.document.documentElement && document.documentElement.addEventListener("click", Rz, !0);
function zz(e) {
  let t = G(!1);
  const n = () => {
    t.value = !0, setTimeout(() => {
      a.unmount(), document.body.removeChild(o);
    }, e.fadeTime || 300);
  }, o = document.createElement("div");
  document.body.appendChild(o);
  const r = {
    ...e.schema,
    items: e.schema.items.map((i) => {
      var l;
      return {
        ...i,
        value: ((l = e.defaultValues) == null ? void 0 : l[i.field]) || i.value
      };
    })
  }, a = hw(Nz, {
    schema: r,
    showBtns: e.showBtns,
    init: e.init || {},
    onCancel: n,
    allowDirectClose: e.allowDirectClose || !1,
    onSubmit: async (i) => {
      var l;
      try {
        await ((l = e.submit) == null ? void 0 : l.call(e, i, n));
      } catch (u) {
        console.error(u);
      }
    },
    style: e.style || {},
    draggable: e.draggable || !1,
    title: e.title,
    fadeInOut: e.fadeInOut,
    fadeTime: e.fadeTime,
    mousePosition: md,
    goClose: t,
    customBtns: e.customBtns,
    showCloseBtn: e.showCloseBtn === void 0 ? !0 : e.showCloseBtn
  });
  a.mount(o);
}
oi.install = function(e) {
  e.component(oi.name || "", oi);
};
const Fz = {
  name: "EasyTable"
};
function Bz(e, t, n, o, r, a) {
  return ke(), ct("div");
}
const oc = /* @__PURE__ */ Np(Fz, [["render", Bz]]);
oc.install = function(e) {
  e.component(oc.name || "", oc);
};
class YC {
  /**
   *  构造函数
   * @param defaultConfig 默认请求配置
   */
  constructor(t) {
    /**
     * 默认请求配置
     */
    _i(this, "defaultConfig");
    /**
     * 请求拦截器
     */
    _i(this, "requestInterceptor", []);
    /**
     * 响应拦截器
     */
    _i(this, "responseInterceptor", []);
    this.defaultConfig = t;
  }
  /**
   *  创建一个请求工具
   * @param defaultConfig  默认请求配置
   * @returns  返回请求工具
   */
  static createService(t) {
    return new YC(t);
  }
  async request(t) {
    var l;
    t = { ...this.defaultConfig, ...t };
    for (const u of this.requestInterceptor)
      t = await u(t);
    const n = (l = t.baseURL) != null && l.endsWith("/") ? t.baseURL : t.baseURL + "/";
    let o = n ? n + t.url : t.url, r = "";
    if (t.params) {
      const u = t.params;
      t.paramsSerializer ? r = t.paramsSerializer(u) : r = Object.keys(u).map((s) => `${s}=${u[s]}`).join("&"), o += "?" + r;
    }
    if (t.transformRequest) {
      const { data: u, headers: s } = t.transformRequest(
        t.data,
        t.headers
      );
      t.headers = s, t.data = u;
    }
    const a = new Request(o, {
      method: t.method,
      headers: t.headers,
      body: t.data,
      mode: "cors",
      cache: "no-cache",
      credentials: "same-origin",
      redirect: "follow",
      referrerPolicy: "no-referrer-when-downgrade"
    }), i = await fetch(a);
    if (t.transformResponse)
      return t.transformResponse(i);
    switch (t.responseType) {
      case "json":
        return this.responseInterceptor.reduce(
          async (u, s) => s(await u),
          i.json()
        );
      case "text":
        return i.text();
      case "blob":
        return i.blob();
      case "arraybuffer":
        return i.arrayBuffer();
      case "stream":
        return i.body;
      case "document":
        return i.text();
      default:
        return i;
    }
  }
  addRequestInterceptor(t, n) {
    n ? this.requestInterceptor.splice(n, 0, t) : this.requestInterceptor.push(t);
  }
  addResponseInterceptor(t, n) {
    n ? this.responseInterceptor.splice(n, 0, t) : this.responseInterceptor.push(t);
  }
  get(t, n) {
    return this.request({
      ...n,
      url: t,
      method: "get"
    });
  }
  post(t, n, o) {
    return this.request({
      ...o,
      url: t,
      method: "post",
      data: n
    });
  }
  put(t, n, o) {
    return this.request({
      ...o,
      url: t,
      method: "put",
      data: n
    });
  }
  delete(t, n) {
    return this.request({
      ...n,
      url: t,
      method: "delete"
    });
  }
  patch(t, n, o) {
    return this.request({
      ...o,
      url: t,
      method: "patch",
      data: n
    });
  }
  head(t, n) {
    return this.request({
      ...n,
      url: t,
      method: "head"
    });
  }
  options(t, n) {
    return this.request({
      ...n,
      url: t,
      method: "options"
    });
  }
  connect(t, n) {
    return this.request({
      ...n,
      url: t,
      method: "connect"
    });
  }
  trace(t, n) {
    return this.request({
      ...n,
      url: t,
      method: "trace"
    });
  }
  req(t) {
    return this.request(t);
  }
}
export {
  oi as DynamicForm,
  oc as EasyTable,
  YC as Fetch,
  zz as useFullScreenDyForm
};
